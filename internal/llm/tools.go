package llm

import (
	"encoding/json"
	"errors"
	"strings"
)

// Tool represents a function tool.
type Tool struct {
	// Type is the type of the tool.
	// Any of "function", "image_generation", or "google" (for Google-specific tools).
	Type            string           `json:"type"`
	Function        Function         `json:"function,omitempty"`
	ImageGeneration *ImageGeneration `json:"image_generation,omitempty"`

	// Google contains Google/Gemini-specific grounding tools.
	// This namespace isolates Google's tools from other providers.
	Google *GoogleTools `json:"google,omitempty"`

	// CacheControl is used for provider-specific cache control (e.g., Anthropic).
	// This field is not serialized in JSON.
	CacheControl *CacheControl `json:"cache_control,omitempty"`
}

type toolJSONMarshaller Tool

func (t Tool) MarshalJSON() ([]byte, error) {
	// TODO: find a better way to save the image generation tool to the request body.
	m := toolJSONMarshaller(t)
	// ImageGeneration is not a valid field for chat completion, so we should remove it from the request.
	m.ImageGeneration = nil
	// Google tools are provider-specific and handled by transformers.
	m.Google = nil

	return json.Marshal(m)
}

// Function represents a function definition.
type Function struct {
	Name        string          `json:"name"`
	Description string          `json:"description,omitempty"`
	Parameters  json.RawMessage `json:"parameters"`
	Strict      *bool           `json:"strict,omitempty"`
}

// FunctionCall represents a function call (deprecated).
type FunctionCall struct {
	// The name of the function to call.
	Name string `json:"name"`

	// The arguments to call the function with, as generated by the model in JSON
	// format. Note that the model does not always generate valid JSON, and may
	// hallucinate parameters not defined by your function schema. Validate the
	// arguments in your code before calling your function.
	Arguments string `json:"arguments"`
}

// ToolCall represents a tool call in the response.
type ToolCall struct {
	ID string `json:"id,omitempty"`

	// The type of the tool. Currently, only `function` is supported.
	Type string `json:"type,omitempty"`

	Function FunctionCall `json:"function"`

	// Index is the index of the tool call in the list of tool calls.
	// Cannot use omitempty, as an index of 0 would be omitted, which can break consumers.
	Index int `json:"index"`

	// CacheControl is used for provider-specific cache control (e.g., Anthropic).
	CacheControl *CacheControl `json:"cache_control,omitempty"`

	// TransformerMetadata is used for provider-specific metadata (e.g., Gemini).
	TransformerMetadata map[string]any `json:"transformer_metadata,omitempty"`
}

type ToolFunction struct {
	Name string `json:"name"`
}

// ToolChoice represents the tool choice parameter for function calling.
//
// Tool choice can be a string or a struct.
type ToolChoice struct {
	ToolChoice      *string          `json:"tool_choice,omitempty"`
	NamedToolChoice *NamedToolChoice `json:"named_tool_choice,omitempty"`
}

type NamedToolChoice struct {
	Type     string       `json:"type"`
	Function ToolFunction `json:"function"`
}

func (t ToolChoice) MarshalJSON() ([]byte, error) {
	if t.ToolChoice != nil {
		return json.Marshal(t.ToolChoice)
	}

	return json.Marshal(t.NamedToolChoice)
}

func (t *ToolChoice) UnmarshalJSON(data []byte) error {
	var str string

	err := json.Unmarshal(data, &str)
	if err == nil {
		t.ToolChoice = &str
		return nil
	}

	var named NamedToolChoice

	err = json.Unmarshal(data, &named)
	if err == nil {
		t.NamedToolChoice = &named
		return nil
	}

	return errors.New("invalid tool choice type")
}

// ImageGeneration is a permissive structure to carry image generation tool
// parameters. It mirrors the OpenRouter/OpenAI Responses API fields we care
// about, but is intentionally loose to allow forward-compatibility.
type ImageGeneration struct {
	Model string `json:"model,omitempty"`
	// One of opaque, transparent.
	Background     string         `json:"background,omitempty"`
	InputFidelity  string         `json:"input_fidelity,omitempty"`
	InputImageMask map[string]any `json:"input_image_mask,omitempty"`
	// One of low, auto.
	Moderation string `json:"moderation,omitempty"`
	// The compression level (0-100%) for the generated images. Default: 100.
	OutputCompression *int64 `json:"output_compression,omitempty"`
	// One of png, webp, or jpeg. Default: png.
	OutputFormat string `json:"output_format,omitempty"`
	// The number of images to generate. Default: 1.
	PartialImages *int64 `json:"partial_images,omitempty"`
	// The quality of the image that will be generated.
	// auto (default value) will automatically select the best quality for the given model.
	// high, medium and low are supported for gpt-image-1.
	// hd and standard are supported for dall-e-3.
	// standard is the only option for dall-e-2.
	Quality string `json:"quality,omitempty"`
	// One of 256x256, 512x512, or 1024x1024. Default: 1024x1024.
	Size string `json:"size,omitempty"`

	// Whether to add a watermark to the generated image. Default: false.
	// It only works for the models support watermark, it will be ignored otherwise.
	Watermark bool `json:"watermark,omitempty"`
}

// GoogleTools contains Google/Gemini-specific grounding tools.
// This namespace isolates Google's tools from other providers,
// allowing for provider-specific implementations without naming conflicts.
type GoogleTools struct {
	// Search enables Google Search grounding for real-time web searches.
	Search *GoogleSearch `json:"search,omitempty"`
	// CodeExecution enables code execution as part of generation.
	CodeExecution *GoogleCodeExecution `json:"code_execution,omitempty"`
	// UrlContext enables URL context grounding for Gemini 2.0+.
	UrlContext *GoogleUrlContext `json:"url_context,omitempty"`
}

// GoogleSearch represents Google Search grounding tool for Gemini.
// This enables the model to perform real-time web searches.
type GoogleSearch struct{}

// GoogleCodeExecution represents code execution tool for Gemini.
// This enables the model to execute code as part of generation.
type GoogleCodeExecution struct{}

// GoogleUrlContext represents URL context grounding tool for Gemini 2.0+.
// This allows the model to fetch and process content from specified URLs.
type GoogleUrlContext struct{}

// ContainsGoogleNativeTools checks if the tools slice contains any Google native tools.
// Google native tools include GoogleSearch, GoogleCodeExecution, and GoogleUrlContext.
// These tools are only supported by native Gemini API format (gemini/gemini_vertex),
// not by OpenAI-compatible endpoints (gemini_openai).
func ContainsGoogleNativeTools(tools []Tool) bool {
	for _, tool := range tools {
		if IsGoogleNativeTool(tool) {
			return true
		}
	}

	return false
}

// IsGoogleNativeTool checks if a single tool is a Google native tool.
// Google native tools follow the naming convention "google_*".
func IsGoogleNativeTool(tool Tool) bool {
	return strings.HasPrefix(tool.Type, "google_")
}

// FilterGoogleNativeTools removes Google native tools from the tools slice.
// This is useful as a fallback when routing to channels that don't support native tools.
func FilterGoogleNativeTools(tools []Tool) []Tool {
	if len(tools) == 0 {
		return tools
	}

	filtered := make([]Tool, 0, len(tools))

	for _, tool := range tools {
		if !IsGoogleNativeTool(tool) {
			filtered = append(filtered, tool)
		}
	}

	return filtered
}

// ContainsAnthropicNativeTools checks if the tools slice contains any Anthropic native tools.
// Currently, this checks for the web_search function which maps to Anthropic's native
// web_search_20250305 tool type.
func ContainsAnthropicNativeTools(tools []Tool) bool {
	for _, tool := range tools {
		if IsAnthropicNativeTool(tool) {
			return true
		}
	}

	return false
}

// IsAnthropicNativeTool checks if a single tool is an Anthropic native tool.
// A tool is considered Anthropic native if:
// 1. It's a function tool with name "web_search" (OpenAI format input), OR
// 2. It's already transformed to type "web_search_20250305" (Anthropic native format).
func IsAnthropicNativeTool(tool Tool) bool {
	// Match function tool with web_search name (OpenAI format input)
	if tool.Type == ToolTypeFunction && tool.Function.Name == AnthropicWebSearchFunctionName {
		return true
	}
	// Match already-transformed Anthropic native tool type
	if tool.Type == ToolTypeAnthropicWebSearch {
		return true
	}

	return false
}

// FilterAnthropicNativeTools removes Anthropic native tools from the tools slice.
// This is useful as a fallback when routing to channels that don't support native tools.
func FilterAnthropicNativeTools(tools []Tool) []Tool {
	if len(tools) == 0 {
		return tools
	}

	filtered := make([]Tool, 0, len(tools))

	for _, tool := range tools {
		if !IsAnthropicNativeTool(tool) {
			filtered = append(filtered, tool)
		}
	}

	return filtered
}
