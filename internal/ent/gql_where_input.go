// Code generated by ent, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"
	"time"

	"github.com/looplj/axonhub/internal/ent/apikey"
	"github.com/looplj/axonhub/internal/ent/channel"
	"github.com/looplj/axonhub/internal/ent/channelmodelprice"
	"github.com/looplj/axonhub/internal/ent/channelmodelpriceversion"
	"github.com/looplj/axonhub/internal/ent/channeloverridetemplate"
	"github.com/looplj/axonhub/internal/ent/channelperformance"
	"github.com/looplj/axonhub/internal/ent/channelprobe"
	"github.com/looplj/axonhub/internal/ent/datastorage"
	"github.com/looplj/axonhub/internal/ent/model"
	"github.com/looplj/axonhub/internal/ent/predicate"
	"github.com/looplj/axonhub/internal/ent/project"
	"github.com/looplj/axonhub/internal/ent/prompt"
	"github.com/looplj/axonhub/internal/ent/request"
	"github.com/looplj/axonhub/internal/ent/requestexecution"
	"github.com/looplj/axonhub/internal/ent/role"
	"github.com/looplj/axonhub/internal/ent/system"
	"github.com/looplj/axonhub/internal/ent/thread"
	"github.com/looplj/axonhub/internal/ent/trace"
	"github.com/looplj/axonhub/internal/ent/usagelog"
	"github.com/looplj/axonhub/internal/ent/user"
	"github.com/looplj/axonhub/internal/ent/userproject"
	"github.com/looplj/axonhub/internal/ent/userrole"
)

// APIKeyWhereInput represents a where input for filtering APIKey queries.
type APIKeyWhereInput struct {
	Predicates []predicate.APIKey  `json:"-"`
	Not        *APIKeyWhereInput   `json:"not,omitempty"`
	Or         []*APIKeyWhereInput `json:"or,omitempty"`
	And        []*APIKeyWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt      *int  `json:"deletedAt,omitempty"`
	DeletedAtNEQ   *int  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn    []int `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn []int `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT    *int  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE   *int  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT    *int  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE   *int  `json:"deletedAtLTE,omitempty"`

	// "user_id" field predicates.
	UserID      *int  `json:"userID,omitempty"`
	UserIDNEQ   *int  `json:"userIDNEQ,omitempty"`
	UserIDIn    []int `json:"userIDIn,omitempty"`
	UserIDNotIn []int `json:"userIDNotIn,omitempty"`

	// "project_id" field predicates.
	ProjectID      *int  `json:"projectID,omitempty"`
	ProjectIDNEQ   *int  `json:"projectIDNEQ,omitempty"`
	ProjectIDIn    []int `json:"projectIDIn,omitempty"`
	ProjectIDNotIn []int `json:"projectIDNotIn,omitempty"`

	// "key" field predicates.
	Key             *string  `json:"key,omitempty"`
	KeyNEQ          *string  `json:"keyNEQ,omitempty"`
	KeyIn           []string `json:"keyIn,omitempty"`
	KeyNotIn        []string `json:"keyNotIn,omitempty"`
	KeyGT           *string  `json:"keyGT,omitempty"`
	KeyGTE          *string  `json:"keyGTE,omitempty"`
	KeyLT           *string  `json:"keyLT,omitempty"`
	KeyLTE          *string  `json:"keyLTE,omitempty"`
	KeyContains     *string  `json:"keyContains,omitempty"`
	KeyHasPrefix    *string  `json:"keyHasPrefix,omitempty"`
	KeyHasSuffix    *string  `json:"keyHasSuffix,omitempty"`
	KeyEqualFold    *string  `json:"keyEqualFold,omitempty"`
	KeyContainsFold *string  `json:"keyContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "type" field predicates.
	Type      *apikey.Type  `json:"type,omitempty"`
	TypeNEQ   *apikey.Type  `json:"typeNEQ,omitempty"`
	TypeIn    []apikey.Type `json:"typeIn,omitempty"`
	TypeNotIn []apikey.Type `json:"typeNotIn,omitempty"`

	// "status" field predicates.
	Status      *apikey.Status  `json:"status,omitempty"`
	StatusNEQ   *apikey.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []apikey.Status `json:"statusIn,omitempty"`
	StatusNotIn []apikey.Status `json:"statusNotIn,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`

	// "project" edge predicates.
	HasProject     *bool                `json:"hasProject,omitempty"`
	HasProjectWith []*ProjectWhereInput `json:"hasProjectWith,omitempty"`

	// "requests" edge predicates.
	HasRequests     *bool                `json:"hasRequests,omitempty"`
	HasRequestsWith []*RequestWhereInput `json:"hasRequestsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *APIKeyWhereInput) AddPredicates(predicates ...predicate.APIKey) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the APIKeyWhereInput filter on the APIKeyQuery builder.
func (i *APIKeyWhereInput) Filter(q *APIKeyQuery) (*APIKeyQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyAPIKeyWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyAPIKeyWhereInput is returned in case the APIKeyWhereInput is empty.
var ErrEmptyAPIKeyWhereInput = errors.New("ent: empty predicate APIKeyWhereInput")

// P returns a predicate for filtering apikeys.
// An error is returned if the input is empty or invalid.
func (i *APIKeyWhereInput) P() (predicate.APIKey, error) {
	var predicates []predicate.APIKey
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, apikey.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.APIKey, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, apikey.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.APIKey, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, apikey.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, apikey.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, apikey.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, apikey.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, apikey.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, apikey.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, apikey.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, apikey.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, apikey.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, apikey.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, apikey.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, apikey.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, apikey.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, apikey.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, apikey.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, apikey.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, apikey.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, apikey.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, apikey.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, apikey.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, apikey.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, apikey.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, apikey.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, apikey.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, apikey.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, apikey.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, apikey.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, apikey.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, apikey.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, apikey.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, apikey.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, apikey.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, apikey.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.UserID != nil {
		predicates = append(predicates, apikey.UserIDEQ(*i.UserID))
	}
	if i.UserIDNEQ != nil {
		predicates = append(predicates, apikey.UserIDNEQ(*i.UserIDNEQ))
	}
	if len(i.UserIDIn) > 0 {
		predicates = append(predicates, apikey.UserIDIn(i.UserIDIn...))
	}
	if len(i.UserIDNotIn) > 0 {
		predicates = append(predicates, apikey.UserIDNotIn(i.UserIDNotIn...))
	}
	if i.ProjectID != nil {
		predicates = append(predicates, apikey.ProjectIDEQ(*i.ProjectID))
	}
	if i.ProjectIDNEQ != nil {
		predicates = append(predicates, apikey.ProjectIDNEQ(*i.ProjectIDNEQ))
	}
	if len(i.ProjectIDIn) > 0 {
		predicates = append(predicates, apikey.ProjectIDIn(i.ProjectIDIn...))
	}
	if len(i.ProjectIDNotIn) > 0 {
		predicates = append(predicates, apikey.ProjectIDNotIn(i.ProjectIDNotIn...))
	}
	if i.Key != nil {
		predicates = append(predicates, apikey.KeyEQ(*i.Key))
	}
	if i.KeyNEQ != nil {
		predicates = append(predicates, apikey.KeyNEQ(*i.KeyNEQ))
	}
	if len(i.KeyIn) > 0 {
		predicates = append(predicates, apikey.KeyIn(i.KeyIn...))
	}
	if len(i.KeyNotIn) > 0 {
		predicates = append(predicates, apikey.KeyNotIn(i.KeyNotIn...))
	}
	if i.KeyGT != nil {
		predicates = append(predicates, apikey.KeyGT(*i.KeyGT))
	}
	if i.KeyGTE != nil {
		predicates = append(predicates, apikey.KeyGTE(*i.KeyGTE))
	}
	if i.KeyLT != nil {
		predicates = append(predicates, apikey.KeyLT(*i.KeyLT))
	}
	if i.KeyLTE != nil {
		predicates = append(predicates, apikey.KeyLTE(*i.KeyLTE))
	}
	if i.KeyContains != nil {
		predicates = append(predicates, apikey.KeyContains(*i.KeyContains))
	}
	if i.KeyHasPrefix != nil {
		predicates = append(predicates, apikey.KeyHasPrefix(*i.KeyHasPrefix))
	}
	if i.KeyHasSuffix != nil {
		predicates = append(predicates, apikey.KeyHasSuffix(*i.KeyHasSuffix))
	}
	if i.KeyEqualFold != nil {
		predicates = append(predicates, apikey.KeyEqualFold(*i.KeyEqualFold))
	}
	if i.KeyContainsFold != nil {
		predicates = append(predicates, apikey.KeyContainsFold(*i.KeyContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, apikey.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, apikey.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, apikey.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, apikey.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, apikey.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, apikey.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, apikey.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, apikey.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, apikey.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, apikey.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, apikey.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, apikey.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, apikey.NameContainsFold(*i.NameContainsFold))
	}
	if i.Type != nil {
		predicates = append(predicates, apikey.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, apikey.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, apikey.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, apikey.TypeNotIn(i.TypeNotIn...))
	}
	if i.Status != nil {
		predicates = append(predicates, apikey.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, apikey.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, apikey.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, apikey.StatusNotIn(i.StatusNotIn...))
	}

	if i.HasUser != nil {
		p := apikey.HasUser()
		if !*i.HasUser {
			p = apikey.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, apikey.HasUserWith(with...))
	}
	if i.HasProject != nil {
		p := apikey.HasProject()
		if !*i.HasProject {
			p = apikey.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProjectWith) > 0 {
		with := make([]predicate.Project, 0, len(i.HasProjectWith))
		for _, w := range i.HasProjectWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProjectWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, apikey.HasProjectWith(with...))
	}
	if i.HasRequests != nil {
		p := apikey.HasRequests()
		if !*i.HasRequests {
			p = apikey.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRequestsWith) > 0 {
		with := make([]predicate.Request, 0, len(i.HasRequestsWith))
		for _, w := range i.HasRequestsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRequestsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, apikey.HasRequestsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyAPIKeyWhereInput
	case 1:
		return predicates[0], nil
	default:
		return apikey.And(predicates...), nil
	}
}

// ChannelWhereInput represents a where input for filtering Channel queries.
type ChannelWhereInput struct {
	Predicates []predicate.Channel  `json:"-"`
	Not        *ChannelWhereInput   `json:"not,omitempty"`
	Or         []*ChannelWhereInput `json:"or,omitempty"`
	And        []*ChannelWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt      *int  `json:"deletedAt,omitempty"`
	DeletedAtNEQ   *int  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn    []int `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn []int `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT    *int  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE   *int  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT    *int  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE   *int  `json:"deletedAtLTE,omitempty"`

	// "type" field predicates.
	Type      *channel.Type  `json:"type,omitempty"`
	TypeNEQ   *channel.Type  `json:"typeNEQ,omitempty"`
	TypeIn    []channel.Type `json:"typeIn,omitempty"`
	TypeNotIn []channel.Type `json:"typeNotIn,omitempty"`

	// "base_url" field predicates.
	BaseURL             *string  `json:"baseURL,omitempty"`
	BaseURLNEQ          *string  `json:"baseURLNEQ,omitempty"`
	BaseURLIn           []string `json:"baseURLIn,omitempty"`
	BaseURLNotIn        []string `json:"baseURLNotIn,omitempty"`
	BaseURLGT           *string  `json:"baseURLGT,omitempty"`
	BaseURLGTE          *string  `json:"baseURLGTE,omitempty"`
	BaseURLLT           *string  `json:"baseURLLT,omitempty"`
	BaseURLLTE          *string  `json:"baseURLLTE,omitempty"`
	BaseURLContains     *string  `json:"baseURLContains,omitempty"`
	BaseURLHasPrefix    *string  `json:"baseURLHasPrefix,omitempty"`
	BaseURLHasSuffix    *string  `json:"baseURLHasSuffix,omitempty"`
	BaseURLIsNil        bool     `json:"baseURLIsNil,omitempty"`
	BaseURLNotNil       bool     `json:"baseURLNotNil,omitempty"`
	BaseURLEqualFold    *string  `json:"baseURLEqualFold,omitempty"`
	BaseURLContainsFold *string  `json:"baseURLContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "status" field predicates.
	Status      *channel.Status  `json:"status,omitempty"`
	StatusNEQ   *channel.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []channel.Status `json:"statusIn,omitempty"`
	StatusNotIn []channel.Status `json:"statusNotIn,omitempty"`

	// "auto_sync_supported_models" field predicates.
	AutoSyncSupportedModels    *bool `json:"autoSyncSupportedModels,omitempty"`
	AutoSyncSupportedModelsNEQ *bool `json:"autoSyncSupportedModelsNEQ,omitempty"`

	// "default_test_model" field predicates.
	DefaultTestModel             *string  `json:"defaultTestModel,omitempty"`
	DefaultTestModelNEQ          *string  `json:"defaultTestModelNEQ,omitempty"`
	DefaultTestModelIn           []string `json:"defaultTestModelIn,omitempty"`
	DefaultTestModelNotIn        []string `json:"defaultTestModelNotIn,omitempty"`
	DefaultTestModelGT           *string  `json:"defaultTestModelGT,omitempty"`
	DefaultTestModelGTE          *string  `json:"defaultTestModelGTE,omitempty"`
	DefaultTestModelLT           *string  `json:"defaultTestModelLT,omitempty"`
	DefaultTestModelLTE          *string  `json:"defaultTestModelLTE,omitempty"`
	DefaultTestModelContains     *string  `json:"defaultTestModelContains,omitempty"`
	DefaultTestModelHasPrefix    *string  `json:"defaultTestModelHasPrefix,omitempty"`
	DefaultTestModelHasSuffix    *string  `json:"defaultTestModelHasSuffix,omitempty"`
	DefaultTestModelEqualFold    *string  `json:"defaultTestModelEqualFold,omitempty"`
	DefaultTestModelContainsFold *string  `json:"defaultTestModelContainsFold,omitempty"`

	// "ordering_weight" field predicates.
	OrderingWeight      *int  `json:"orderingWeight,omitempty"`
	OrderingWeightNEQ   *int  `json:"orderingWeightNEQ,omitempty"`
	OrderingWeightIn    []int `json:"orderingWeightIn,omitempty"`
	OrderingWeightNotIn []int `json:"orderingWeightNotIn,omitempty"`
	OrderingWeightGT    *int  `json:"orderingWeightGT,omitempty"`
	OrderingWeightGTE   *int  `json:"orderingWeightGTE,omitempty"`
	OrderingWeightLT    *int  `json:"orderingWeightLT,omitempty"`
	OrderingWeightLTE   *int  `json:"orderingWeightLTE,omitempty"`

	// "error_message" field predicates.
	ErrorMessage             *string  `json:"errorMessage,omitempty"`
	ErrorMessageNEQ          *string  `json:"errorMessageNEQ,omitempty"`
	ErrorMessageIn           []string `json:"errorMessageIn,omitempty"`
	ErrorMessageNotIn        []string `json:"errorMessageNotIn,omitempty"`
	ErrorMessageGT           *string  `json:"errorMessageGT,omitempty"`
	ErrorMessageGTE          *string  `json:"errorMessageGTE,omitempty"`
	ErrorMessageLT           *string  `json:"errorMessageLT,omitempty"`
	ErrorMessageLTE          *string  `json:"errorMessageLTE,omitempty"`
	ErrorMessageContains     *string  `json:"errorMessageContains,omitempty"`
	ErrorMessageHasPrefix    *string  `json:"errorMessageHasPrefix,omitempty"`
	ErrorMessageHasSuffix    *string  `json:"errorMessageHasSuffix,omitempty"`
	ErrorMessageIsNil        bool     `json:"errorMessageIsNil,omitempty"`
	ErrorMessageNotNil       bool     `json:"errorMessageNotNil,omitempty"`
	ErrorMessageEqualFold    *string  `json:"errorMessageEqualFold,omitempty"`
	ErrorMessageContainsFold *string  `json:"errorMessageContainsFold,omitempty"`

	// "remark" field predicates.
	Remark             *string  `json:"remark,omitempty"`
	RemarkNEQ          *string  `json:"remarkNEQ,omitempty"`
	RemarkIn           []string `json:"remarkIn,omitempty"`
	RemarkNotIn        []string `json:"remarkNotIn,omitempty"`
	RemarkGT           *string  `json:"remarkGT,omitempty"`
	RemarkGTE          *string  `json:"remarkGTE,omitempty"`
	RemarkLT           *string  `json:"remarkLT,omitempty"`
	RemarkLTE          *string  `json:"remarkLTE,omitempty"`
	RemarkContains     *string  `json:"remarkContains,omitempty"`
	RemarkHasPrefix    *string  `json:"remarkHasPrefix,omitempty"`
	RemarkHasSuffix    *string  `json:"remarkHasSuffix,omitempty"`
	RemarkIsNil        bool     `json:"remarkIsNil,omitempty"`
	RemarkNotNil       bool     `json:"remarkNotNil,omitempty"`
	RemarkEqualFold    *string  `json:"remarkEqualFold,omitempty"`
	RemarkContainsFold *string  `json:"remarkContainsFold,omitempty"`

	// "requests" edge predicates.
	HasRequests     *bool                `json:"hasRequests,omitempty"`
	HasRequestsWith []*RequestWhereInput `json:"hasRequestsWith,omitempty"`

	// "executions" edge predicates.
	HasExecutions     *bool                         `json:"hasExecutions,omitempty"`
	HasExecutionsWith []*RequestExecutionWhereInput `json:"hasExecutionsWith,omitempty"`

	// "usage_logs" edge predicates.
	HasUsageLogs     *bool                 `json:"hasUsageLogs,omitempty"`
	HasUsageLogsWith []*UsageLogWhereInput `json:"hasUsageLogsWith,omitempty"`

	// "channel_performance" edge predicates.
	HasChannelPerformance     *bool                           `json:"hasChannelPerformance,omitempty"`
	HasChannelPerformanceWith []*ChannelPerformanceWhereInput `json:"hasChannelPerformanceWith,omitempty"`

	// "channel_probes" edge predicates.
	HasChannelProbes     *bool                     `json:"hasChannelProbes,omitempty"`
	HasChannelProbesWith []*ChannelProbeWhereInput `json:"hasChannelProbesWith,omitempty"`

	// "channel_model_prices" edge predicates.
	HasChannelModelPrices     *bool                          `json:"hasChannelModelPrices,omitempty"`
	HasChannelModelPricesWith []*ChannelModelPriceWhereInput `json:"hasChannelModelPricesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ChannelWhereInput) AddPredicates(predicates ...predicate.Channel) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ChannelWhereInput filter on the ChannelQuery builder.
func (i *ChannelWhereInput) Filter(q *ChannelQuery) (*ChannelQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyChannelWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyChannelWhereInput is returned in case the ChannelWhereInput is empty.
var ErrEmptyChannelWhereInput = errors.New("ent: empty predicate ChannelWhereInput")

// P returns a predicate for filtering channels.
// An error is returned if the input is empty or invalid.
func (i *ChannelWhereInput) P() (predicate.Channel, error) {
	var predicates []predicate.Channel
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, channel.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Channel, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, channel.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Channel, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, channel.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, channel.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, channel.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, channel.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, channel.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, channel.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, channel.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, channel.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, channel.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, channel.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, channel.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, channel.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, channel.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, channel.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, channel.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, channel.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, channel.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, channel.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, channel.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, channel.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, channel.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, channel.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, channel.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, channel.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, channel.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, channel.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, channel.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, channel.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, channel.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, channel.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, channel.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, channel.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, channel.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.Type != nil {
		predicates = append(predicates, channel.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, channel.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, channel.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, channel.TypeNotIn(i.TypeNotIn...))
	}
	if i.BaseURL != nil {
		predicates = append(predicates, channel.BaseURLEQ(*i.BaseURL))
	}
	if i.BaseURLNEQ != nil {
		predicates = append(predicates, channel.BaseURLNEQ(*i.BaseURLNEQ))
	}
	if len(i.BaseURLIn) > 0 {
		predicates = append(predicates, channel.BaseURLIn(i.BaseURLIn...))
	}
	if len(i.BaseURLNotIn) > 0 {
		predicates = append(predicates, channel.BaseURLNotIn(i.BaseURLNotIn...))
	}
	if i.BaseURLGT != nil {
		predicates = append(predicates, channel.BaseURLGT(*i.BaseURLGT))
	}
	if i.BaseURLGTE != nil {
		predicates = append(predicates, channel.BaseURLGTE(*i.BaseURLGTE))
	}
	if i.BaseURLLT != nil {
		predicates = append(predicates, channel.BaseURLLT(*i.BaseURLLT))
	}
	if i.BaseURLLTE != nil {
		predicates = append(predicates, channel.BaseURLLTE(*i.BaseURLLTE))
	}
	if i.BaseURLContains != nil {
		predicates = append(predicates, channel.BaseURLContains(*i.BaseURLContains))
	}
	if i.BaseURLHasPrefix != nil {
		predicates = append(predicates, channel.BaseURLHasPrefix(*i.BaseURLHasPrefix))
	}
	if i.BaseURLHasSuffix != nil {
		predicates = append(predicates, channel.BaseURLHasSuffix(*i.BaseURLHasSuffix))
	}
	if i.BaseURLIsNil {
		predicates = append(predicates, channel.BaseURLIsNil())
	}
	if i.BaseURLNotNil {
		predicates = append(predicates, channel.BaseURLNotNil())
	}
	if i.BaseURLEqualFold != nil {
		predicates = append(predicates, channel.BaseURLEqualFold(*i.BaseURLEqualFold))
	}
	if i.BaseURLContainsFold != nil {
		predicates = append(predicates, channel.BaseURLContainsFold(*i.BaseURLContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, channel.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, channel.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, channel.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, channel.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, channel.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, channel.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, channel.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, channel.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, channel.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, channel.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, channel.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, channel.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, channel.NameContainsFold(*i.NameContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, channel.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, channel.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, channel.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, channel.StatusNotIn(i.StatusNotIn...))
	}
	if i.AutoSyncSupportedModels != nil {
		predicates = append(predicates, channel.AutoSyncSupportedModelsEQ(*i.AutoSyncSupportedModels))
	}
	if i.AutoSyncSupportedModelsNEQ != nil {
		predicates = append(predicates, channel.AutoSyncSupportedModelsNEQ(*i.AutoSyncSupportedModelsNEQ))
	}
	if i.DefaultTestModel != nil {
		predicates = append(predicates, channel.DefaultTestModelEQ(*i.DefaultTestModel))
	}
	if i.DefaultTestModelNEQ != nil {
		predicates = append(predicates, channel.DefaultTestModelNEQ(*i.DefaultTestModelNEQ))
	}
	if len(i.DefaultTestModelIn) > 0 {
		predicates = append(predicates, channel.DefaultTestModelIn(i.DefaultTestModelIn...))
	}
	if len(i.DefaultTestModelNotIn) > 0 {
		predicates = append(predicates, channel.DefaultTestModelNotIn(i.DefaultTestModelNotIn...))
	}
	if i.DefaultTestModelGT != nil {
		predicates = append(predicates, channel.DefaultTestModelGT(*i.DefaultTestModelGT))
	}
	if i.DefaultTestModelGTE != nil {
		predicates = append(predicates, channel.DefaultTestModelGTE(*i.DefaultTestModelGTE))
	}
	if i.DefaultTestModelLT != nil {
		predicates = append(predicates, channel.DefaultTestModelLT(*i.DefaultTestModelLT))
	}
	if i.DefaultTestModelLTE != nil {
		predicates = append(predicates, channel.DefaultTestModelLTE(*i.DefaultTestModelLTE))
	}
	if i.DefaultTestModelContains != nil {
		predicates = append(predicates, channel.DefaultTestModelContains(*i.DefaultTestModelContains))
	}
	if i.DefaultTestModelHasPrefix != nil {
		predicates = append(predicates, channel.DefaultTestModelHasPrefix(*i.DefaultTestModelHasPrefix))
	}
	if i.DefaultTestModelHasSuffix != nil {
		predicates = append(predicates, channel.DefaultTestModelHasSuffix(*i.DefaultTestModelHasSuffix))
	}
	if i.DefaultTestModelEqualFold != nil {
		predicates = append(predicates, channel.DefaultTestModelEqualFold(*i.DefaultTestModelEqualFold))
	}
	if i.DefaultTestModelContainsFold != nil {
		predicates = append(predicates, channel.DefaultTestModelContainsFold(*i.DefaultTestModelContainsFold))
	}
	if i.OrderingWeight != nil {
		predicates = append(predicates, channel.OrderingWeightEQ(*i.OrderingWeight))
	}
	if i.OrderingWeightNEQ != nil {
		predicates = append(predicates, channel.OrderingWeightNEQ(*i.OrderingWeightNEQ))
	}
	if len(i.OrderingWeightIn) > 0 {
		predicates = append(predicates, channel.OrderingWeightIn(i.OrderingWeightIn...))
	}
	if len(i.OrderingWeightNotIn) > 0 {
		predicates = append(predicates, channel.OrderingWeightNotIn(i.OrderingWeightNotIn...))
	}
	if i.OrderingWeightGT != nil {
		predicates = append(predicates, channel.OrderingWeightGT(*i.OrderingWeightGT))
	}
	if i.OrderingWeightGTE != nil {
		predicates = append(predicates, channel.OrderingWeightGTE(*i.OrderingWeightGTE))
	}
	if i.OrderingWeightLT != nil {
		predicates = append(predicates, channel.OrderingWeightLT(*i.OrderingWeightLT))
	}
	if i.OrderingWeightLTE != nil {
		predicates = append(predicates, channel.OrderingWeightLTE(*i.OrderingWeightLTE))
	}
	if i.ErrorMessage != nil {
		predicates = append(predicates, channel.ErrorMessageEQ(*i.ErrorMessage))
	}
	if i.ErrorMessageNEQ != nil {
		predicates = append(predicates, channel.ErrorMessageNEQ(*i.ErrorMessageNEQ))
	}
	if len(i.ErrorMessageIn) > 0 {
		predicates = append(predicates, channel.ErrorMessageIn(i.ErrorMessageIn...))
	}
	if len(i.ErrorMessageNotIn) > 0 {
		predicates = append(predicates, channel.ErrorMessageNotIn(i.ErrorMessageNotIn...))
	}
	if i.ErrorMessageGT != nil {
		predicates = append(predicates, channel.ErrorMessageGT(*i.ErrorMessageGT))
	}
	if i.ErrorMessageGTE != nil {
		predicates = append(predicates, channel.ErrorMessageGTE(*i.ErrorMessageGTE))
	}
	if i.ErrorMessageLT != nil {
		predicates = append(predicates, channel.ErrorMessageLT(*i.ErrorMessageLT))
	}
	if i.ErrorMessageLTE != nil {
		predicates = append(predicates, channel.ErrorMessageLTE(*i.ErrorMessageLTE))
	}
	if i.ErrorMessageContains != nil {
		predicates = append(predicates, channel.ErrorMessageContains(*i.ErrorMessageContains))
	}
	if i.ErrorMessageHasPrefix != nil {
		predicates = append(predicates, channel.ErrorMessageHasPrefix(*i.ErrorMessageHasPrefix))
	}
	if i.ErrorMessageHasSuffix != nil {
		predicates = append(predicates, channel.ErrorMessageHasSuffix(*i.ErrorMessageHasSuffix))
	}
	if i.ErrorMessageIsNil {
		predicates = append(predicates, channel.ErrorMessageIsNil())
	}
	if i.ErrorMessageNotNil {
		predicates = append(predicates, channel.ErrorMessageNotNil())
	}
	if i.ErrorMessageEqualFold != nil {
		predicates = append(predicates, channel.ErrorMessageEqualFold(*i.ErrorMessageEqualFold))
	}
	if i.ErrorMessageContainsFold != nil {
		predicates = append(predicates, channel.ErrorMessageContainsFold(*i.ErrorMessageContainsFold))
	}
	if i.Remark != nil {
		predicates = append(predicates, channel.RemarkEQ(*i.Remark))
	}
	if i.RemarkNEQ != nil {
		predicates = append(predicates, channel.RemarkNEQ(*i.RemarkNEQ))
	}
	if len(i.RemarkIn) > 0 {
		predicates = append(predicates, channel.RemarkIn(i.RemarkIn...))
	}
	if len(i.RemarkNotIn) > 0 {
		predicates = append(predicates, channel.RemarkNotIn(i.RemarkNotIn...))
	}
	if i.RemarkGT != nil {
		predicates = append(predicates, channel.RemarkGT(*i.RemarkGT))
	}
	if i.RemarkGTE != nil {
		predicates = append(predicates, channel.RemarkGTE(*i.RemarkGTE))
	}
	if i.RemarkLT != nil {
		predicates = append(predicates, channel.RemarkLT(*i.RemarkLT))
	}
	if i.RemarkLTE != nil {
		predicates = append(predicates, channel.RemarkLTE(*i.RemarkLTE))
	}
	if i.RemarkContains != nil {
		predicates = append(predicates, channel.RemarkContains(*i.RemarkContains))
	}
	if i.RemarkHasPrefix != nil {
		predicates = append(predicates, channel.RemarkHasPrefix(*i.RemarkHasPrefix))
	}
	if i.RemarkHasSuffix != nil {
		predicates = append(predicates, channel.RemarkHasSuffix(*i.RemarkHasSuffix))
	}
	if i.RemarkIsNil {
		predicates = append(predicates, channel.RemarkIsNil())
	}
	if i.RemarkNotNil {
		predicates = append(predicates, channel.RemarkNotNil())
	}
	if i.RemarkEqualFold != nil {
		predicates = append(predicates, channel.RemarkEqualFold(*i.RemarkEqualFold))
	}
	if i.RemarkContainsFold != nil {
		predicates = append(predicates, channel.RemarkContainsFold(*i.RemarkContainsFold))
	}

	if i.HasRequests != nil {
		p := channel.HasRequests()
		if !*i.HasRequests {
			p = channel.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRequestsWith) > 0 {
		with := make([]predicate.Request, 0, len(i.HasRequestsWith))
		for _, w := range i.HasRequestsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRequestsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, channel.HasRequestsWith(with...))
	}
	if i.HasExecutions != nil {
		p := channel.HasExecutions()
		if !*i.HasExecutions {
			p = channel.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasExecutionsWith) > 0 {
		with := make([]predicate.RequestExecution, 0, len(i.HasExecutionsWith))
		for _, w := range i.HasExecutionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasExecutionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, channel.HasExecutionsWith(with...))
	}
	if i.HasUsageLogs != nil {
		p := channel.HasUsageLogs()
		if !*i.HasUsageLogs {
			p = channel.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUsageLogsWith) > 0 {
		with := make([]predicate.UsageLog, 0, len(i.HasUsageLogsWith))
		for _, w := range i.HasUsageLogsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUsageLogsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, channel.HasUsageLogsWith(with...))
	}
	if i.HasChannelPerformance != nil {
		p := channel.HasChannelPerformance()
		if !*i.HasChannelPerformance {
			p = channel.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasChannelPerformanceWith) > 0 {
		with := make([]predicate.ChannelPerformance, 0, len(i.HasChannelPerformanceWith))
		for _, w := range i.HasChannelPerformanceWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasChannelPerformanceWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, channel.HasChannelPerformanceWith(with...))
	}
	if i.HasChannelProbes != nil {
		p := channel.HasChannelProbes()
		if !*i.HasChannelProbes {
			p = channel.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasChannelProbesWith) > 0 {
		with := make([]predicate.ChannelProbe, 0, len(i.HasChannelProbesWith))
		for _, w := range i.HasChannelProbesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasChannelProbesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, channel.HasChannelProbesWith(with...))
	}
	if i.HasChannelModelPrices != nil {
		p := channel.HasChannelModelPrices()
		if !*i.HasChannelModelPrices {
			p = channel.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasChannelModelPricesWith) > 0 {
		with := make([]predicate.ChannelModelPrice, 0, len(i.HasChannelModelPricesWith))
		for _, w := range i.HasChannelModelPricesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasChannelModelPricesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, channel.HasChannelModelPricesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyChannelWhereInput
	case 1:
		return predicates[0], nil
	default:
		return channel.And(predicates...), nil
	}
}

// ChannelModelPriceWhereInput represents a where input for filtering ChannelModelPrice queries.
type ChannelModelPriceWhereInput struct {
	Predicates []predicate.ChannelModelPrice  `json:"-"`
	Not        *ChannelModelPriceWhereInput   `json:"not,omitempty"`
	Or         []*ChannelModelPriceWhereInput `json:"or,omitempty"`
	And        []*ChannelModelPriceWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt      *int  `json:"deletedAt,omitempty"`
	DeletedAtNEQ   *int  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn    []int `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn []int `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT    *int  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE   *int  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT    *int  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE   *int  `json:"deletedAtLTE,omitempty"`

	// "channel_id" field predicates.
	ChannelID      *int  `json:"channelID,omitempty"`
	ChannelIDNEQ   *int  `json:"channelIDNEQ,omitempty"`
	ChannelIDIn    []int `json:"channelIDIn,omitempty"`
	ChannelIDNotIn []int `json:"channelIDNotIn,omitempty"`

	// "model_id" field predicates.
	ModelID             *string  `json:"modelID,omitempty"`
	ModelIDNEQ          *string  `json:"modelIDNEQ,omitempty"`
	ModelIDIn           []string `json:"modelIDIn,omitempty"`
	ModelIDNotIn        []string `json:"modelIDNotIn,omitempty"`
	ModelIDGT           *string  `json:"modelIDGT,omitempty"`
	ModelIDGTE          *string  `json:"modelIDGTE,omitempty"`
	ModelIDLT           *string  `json:"modelIDLT,omitempty"`
	ModelIDLTE          *string  `json:"modelIDLTE,omitempty"`
	ModelIDContains     *string  `json:"modelIDContains,omitempty"`
	ModelIDHasPrefix    *string  `json:"modelIDHasPrefix,omitempty"`
	ModelIDHasSuffix    *string  `json:"modelIDHasSuffix,omitempty"`
	ModelIDEqualFold    *string  `json:"modelIDEqualFold,omitempty"`
	ModelIDContainsFold *string  `json:"modelIDContainsFold,omitempty"`

	// "refreance_id" field predicates.
	RefreanceID             *string  `json:"refreanceID,omitempty"`
	RefreanceIDNEQ          *string  `json:"refreanceIDNEQ,omitempty"`
	RefreanceIDIn           []string `json:"refreanceIDIn,omitempty"`
	RefreanceIDNotIn        []string `json:"refreanceIDNotIn,omitempty"`
	RefreanceIDGT           *string  `json:"refreanceIDGT,omitempty"`
	RefreanceIDGTE          *string  `json:"refreanceIDGTE,omitempty"`
	RefreanceIDLT           *string  `json:"refreanceIDLT,omitempty"`
	RefreanceIDLTE          *string  `json:"refreanceIDLTE,omitempty"`
	RefreanceIDContains     *string  `json:"refreanceIDContains,omitempty"`
	RefreanceIDHasPrefix    *string  `json:"refreanceIDHasPrefix,omitempty"`
	RefreanceIDHasSuffix    *string  `json:"refreanceIDHasSuffix,omitempty"`
	RefreanceIDEqualFold    *string  `json:"refreanceIDEqualFold,omitempty"`
	RefreanceIDContainsFold *string  `json:"refreanceIDContainsFold,omitempty"`

	// "channel" edge predicates.
	HasChannel     *bool                `json:"hasChannel,omitempty"`
	HasChannelWith []*ChannelWhereInput `json:"hasChannelWith,omitempty"`

	// "versions" edge predicates.
	HasVersions     *bool                                 `json:"hasVersions,omitempty"`
	HasVersionsWith []*ChannelModelPriceVersionWhereInput `json:"hasVersionsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ChannelModelPriceWhereInput) AddPredicates(predicates ...predicate.ChannelModelPrice) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ChannelModelPriceWhereInput filter on the ChannelModelPriceQuery builder.
func (i *ChannelModelPriceWhereInput) Filter(q *ChannelModelPriceQuery) (*ChannelModelPriceQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyChannelModelPriceWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyChannelModelPriceWhereInput is returned in case the ChannelModelPriceWhereInput is empty.
var ErrEmptyChannelModelPriceWhereInput = errors.New("ent: empty predicate ChannelModelPriceWhereInput")

// P returns a predicate for filtering channelmodelprices.
// An error is returned if the input is empty or invalid.
func (i *ChannelModelPriceWhereInput) P() (predicate.ChannelModelPrice, error) {
	var predicates []predicate.ChannelModelPrice
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, channelmodelprice.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ChannelModelPrice, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, channelmodelprice.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ChannelModelPrice, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, channelmodelprice.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, channelmodelprice.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, channelmodelprice.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, channelmodelprice.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, channelmodelprice.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, channelmodelprice.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, channelmodelprice.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, channelmodelprice.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, channelmodelprice.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, channelmodelprice.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, channelmodelprice.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, channelmodelprice.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, channelmodelprice.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, channelmodelprice.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, channelmodelprice.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, channelmodelprice.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, channelmodelprice.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, channelmodelprice.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, channelmodelprice.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, channelmodelprice.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, channelmodelprice.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, channelmodelprice.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, channelmodelprice.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, channelmodelprice.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, channelmodelprice.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, channelmodelprice.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, channelmodelprice.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, channelmodelprice.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, channelmodelprice.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, channelmodelprice.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, channelmodelprice.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, channelmodelprice.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, channelmodelprice.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.ChannelID != nil {
		predicates = append(predicates, channelmodelprice.ChannelIDEQ(*i.ChannelID))
	}
	if i.ChannelIDNEQ != nil {
		predicates = append(predicates, channelmodelprice.ChannelIDNEQ(*i.ChannelIDNEQ))
	}
	if len(i.ChannelIDIn) > 0 {
		predicates = append(predicates, channelmodelprice.ChannelIDIn(i.ChannelIDIn...))
	}
	if len(i.ChannelIDNotIn) > 0 {
		predicates = append(predicates, channelmodelprice.ChannelIDNotIn(i.ChannelIDNotIn...))
	}
	if i.ModelID != nil {
		predicates = append(predicates, channelmodelprice.ModelIDEQ(*i.ModelID))
	}
	if i.ModelIDNEQ != nil {
		predicates = append(predicates, channelmodelprice.ModelIDNEQ(*i.ModelIDNEQ))
	}
	if len(i.ModelIDIn) > 0 {
		predicates = append(predicates, channelmodelprice.ModelIDIn(i.ModelIDIn...))
	}
	if len(i.ModelIDNotIn) > 0 {
		predicates = append(predicates, channelmodelprice.ModelIDNotIn(i.ModelIDNotIn...))
	}
	if i.ModelIDGT != nil {
		predicates = append(predicates, channelmodelprice.ModelIDGT(*i.ModelIDGT))
	}
	if i.ModelIDGTE != nil {
		predicates = append(predicates, channelmodelprice.ModelIDGTE(*i.ModelIDGTE))
	}
	if i.ModelIDLT != nil {
		predicates = append(predicates, channelmodelprice.ModelIDLT(*i.ModelIDLT))
	}
	if i.ModelIDLTE != nil {
		predicates = append(predicates, channelmodelprice.ModelIDLTE(*i.ModelIDLTE))
	}
	if i.ModelIDContains != nil {
		predicates = append(predicates, channelmodelprice.ModelIDContains(*i.ModelIDContains))
	}
	if i.ModelIDHasPrefix != nil {
		predicates = append(predicates, channelmodelprice.ModelIDHasPrefix(*i.ModelIDHasPrefix))
	}
	if i.ModelIDHasSuffix != nil {
		predicates = append(predicates, channelmodelprice.ModelIDHasSuffix(*i.ModelIDHasSuffix))
	}
	if i.ModelIDEqualFold != nil {
		predicates = append(predicates, channelmodelprice.ModelIDEqualFold(*i.ModelIDEqualFold))
	}
	if i.ModelIDContainsFold != nil {
		predicates = append(predicates, channelmodelprice.ModelIDContainsFold(*i.ModelIDContainsFold))
	}
	if i.RefreanceID != nil {
		predicates = append(predicates, channelmodelprice.RefreanceIDEQ(*i.RefreanceID))
	}
	if i.RefreanceIDNEQ != nil {
		predicates = append(predicates, channelmodelprice.RefreanceIDNEQ(*i.RefreanceIDNEQ))
	}
	if len(i.RefreanceIDIn) > 0 {
		predicates = append(predicates, channelmodelprice.RefreanceIDIn(i.RefreanceIDIn...))
	}
	if len(i.RefreanceIDNotIn) > 0 {
		predicates = append(predicates, channelmodelprice.RefreanceIDNotIn(i.RefreanceIDNotIn...))
	}
	if i.RefreanceIDGT != nil {
		predicates = append(predicates, channelmodelprice.RefreanceIDGT(*i.RefreanceIDGT))
	}
	if i.RefreanceIDGTE != nil {
		predicates = append(predicates, channelmodelprice.RefreanceIDGTE(*i.RefreanceIDGTE))
	}
	if i.RefreanceIDLT != nil {
		predicates = append(predicates, channelmodelprice.RefreanceIDLT(*i.RefreanceIDLT))
	}
	if i.RefreanceIDLTE != nil {
		predicates = append(predicates, channelmodelprice.RefreanceIDLTE(*i.RefreanceIDLTE))
	}
	if i.RefreanceIDContains != nil {
		predicates = append(predicates, channelmodelprice.RefreanceIDContains(*i.RefreanceIDContains))
	}
	if i.RefreanceIDHasPrefix != nil {
		predicates = append(predicates, channelmodelprice.RefreanceIDHasPrefix(*i.RefreanceIDHasPrefix))
	}
	if i.RefreanceIDHasSuffix != nil {
		predicates = append(predicates, channelmodelprice.RefreanceIDHasSuffix(*i.RefreanceIDHasSuffix))
	}
	if i.RefreanceIDEqualFold != nil {
		predicates = append(predicates, channelmodelprice.RefreanceIDEqualFold(*i.RefreanceIDEqualFold))
	}
	if i.RefreanceIDContainsFold != nil {
		predicates = append(predicates, channelmodelprice.RefreanceIDContainsFold(*i.RefreanceIDContainsFold))
	}

	if i.HasChannel != nil {
		p := channelmodelprice.HasChannel()
		if !*i.HasChannel {
			p = channelmodelprice.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasChannelWith) > 0 {
		with := make([]predicate.Channel, 0, len(i.HasChannelWith))
		for _, w := range i.HasChannelWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasChannelWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, channelmodelprice.HasChannelWith(with...))
	}
	if i.HasVersions != nil {
		p := channelmodelprice.HasVersions()
		if !*i.HasVersions {
			p = channelmodelprice.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasVersionsWith) > 0 {
		with := make([]predicate.ChannelModelPriceVersion, 0, len(i.HasVersionsWith))
		for _, w := range i.HasVersionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasVersionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, channelmodelprice.HasVersionsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyChannelModelPriceWhereInput
	case 1:
		return predicates[0], nil
	default:
		return channelmodelprice.And(predicates...), nil
	}
}

// ChannelModelPriceVersionWhereInput represents a where input for filtering ChannelModelPriceVersion queries.
type ChannelModelPriceVersionWhereInput struct {
	Predicates []predicate.ChannelModelPriceVersion  `json:"-"`
	Not        *ChannelModelPriceVersionWhereInput   `json:"not,omitempty"`
	Or         []*ChannelModelPriceVersionWhereInput `json:"or,omitempty"`
	And        []*ChannelModelPriceVersionWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt      *int  `json:"deletedAt,omitempty"`
	DeletedAtNEQ   *int  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn    []int `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn []int `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT    *int  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE   *int  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT    *int  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE   *int  `json:"deletedAtLTE,omitempty"`

	// "channel_id" field predicates.
	ChannelID      *int  `json:"channelID,omitempty"`
	ChannelIDNEQ   *int  `json:"channelIDNEQ,omitempty"`
	ChannelIDIn    []int `json:"channelIDIn,omitempty"`
	ChannelIDNotIn []int `json:"channelIDNotIn,omitempty"`
	ChannelIDGT    *int  `json:"channelIDGT,omitempty"`
	ChannelIDGTE   *int  `json:"channelIDGTE,omitempty"`
	ChannelIDLT    *int  `json:"channelIDLT,omitempty"`
	ChannelIDLTE   *int  `json:"channelIDLTE,omitempty"`

	// "model_id" field predicates.
	ModelID             *string  `json:"modelID,omitempty"`
	ModelIDNEQ          *string  `json:"modelIDNEQ,omitempty"`
	ModelIDIn           []string `json:"modelIDIn,omitempty"`
	ModelIDNotIn        []string `json:"modelIDNotIn,omitempty"`
	ModelIDGT           *string  `json:"modelIDGT,omitempty"`
	ModelIDGTE          *string  `json:"modelIDGTE,omitempty"`
	ModelIDLT           *string  `json:"modelIDLT,omitempty"`
	ModelIDLTE          *string  `json:"modelIDLTE,omitempty"`
	ModelIDContains     *string  `json:"modelIDContains,omitempty"`
	ModelIDHasPrefix    *string  `json:"modelIDHasPrefix,omitempty"`
	ModelIDHasSuffix    *string  `json:"modelIDHasSuffix,omitempty"`
	ModelIDEqualFold    *string  `json:"modelIDEqualFold,omitempty"`
	ModelIDContainsFold *string  `json:"modelIDContainsFold,omitempty"`

	// "channel_model_price_id" field predicates.
	ChannelModelPriceID      *int  `json:"channelModelPriceID,omitempty"`
	ChannelModelPriceIDNEQ   *int  `json:"channelModelPriceIDNEQ,omitempty"`
	ChannelModelPriceIDIn    []int `json:"channelModelPriceIDIn,omitempty"`
	ChannelModelPriceIDNotIn []int `json:"channelModelPriceIDNotIn,omitempty"`

	// "status" field predicates.
	Status      *channelmodelpriceversion.Status  `json:"status,omitempty"`
	StatusNEQ   *channelmodelpriceversion.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []channelmodelpriceversion.Status `json:"statusIn,omitempty"`
	StatusNotIn []channelmodelpriceversion.Status `json:"statusNotIn,omitempty"`

	// "effective_start_at" field predicates.
	EffectiveStartAt      *time.Time  `json:"effectiveStartAt,omitempty"`
	EffectiveStartAtNEQ   *time.Time  `json:"effectiveStartAtNEQ,omitempty"`
	EffectiveStartAtIn    []time.Time `json:"effectiveStartAtIn,omitempty"`
	EffectiveStartAtNotIn []time.Time `json:"effectiveStartAtNotIn,omitempty"`
	EffectiveStartAtGT    *time.Time  `json:"effectiveStartAtGT,omitempty"`
	EffectiveStartAtGTE   *time.Time  `json:"effectiveStartAtGTE,omitempty"`
	EffectiveStartAtLT    *time.Time  `json:"effectiveStartAtLT,omitempty"`
	EffectiveStartAtLTE   *time.Time  `json:"effectiveStartAtLTE,omitempty"`

	// "effective_end_at" field predicates.
	EffectiveEndAt       *time.Time  `json:"effectiveEndAt,omitempty"`
	EffectiveEndAtNEQ    *time.Time  `json:"effectiveEndAtNEQ,omitempty"`
	EffectiveEndAtIn     []time.Time `json:"effectiveEndAtIn,omitempty"`
	EffectiveEndAtNotIn  []time.Time `json:"effectiveEndAtNotIn,omitempty"`
	EffectiveEndAtGT     *time.Time  `json:"effectiveEndAtGT,omitempty"`
	EffectiveEndAtGTE    *time.Time  `json:"effectiveEndAtGTE,omitempty"`
	EffectiveEndAtLT     *time.Time  `json:"effectiveEndAtLT,omitempty"`
	EffectiveEndAtLTE    *time.Time  `json:"effectiveEndAtLTE,omitempty"`
	EffectiveEndAtIsNil  bool        `json:"effectiveEndAtIsNil,omitempty"`
	EffectiveEndAtNotNil bool        `json:"effectiveEndAtNotNil,omitempty"`

	// "refreance_id" field predicates.
	RefreanceID             *string  `json:"refreanceID,omitempty"`
	RefreanceIDNEQ          *string  `json:"refreanceIDNEQ,omitempty"`
	RefreanceIDIn           []string `json:"refreanceIDIn,omitempty"`
	RefreanceIDNotIn        []string `json:"refreanceIDNotIn,omitempty"`
	RefreanceIDGT           *string  `json:"refreanceIDGT,omitempty"`
	RefreanceIDGTE          *string  `json:"refreanceIDGTE,omitempty"`
	RefreanceIDLT           *string  `json:"refreanceIDLT,omitempty"`
	RefreanceIDLTE          *string  `json:"refreanceIDLTE,omitempty"`
	RefreanceIDContains     *string  `json:"refreanceIDContains,omitempty"`
	RefreanceIDHasPrefix    *string  `json:"refreanceIDHasPrefix,omitempty"`
	RefreanceIDHasSuffix    *string  `json:"refreanceIDHasSuffix,omitempty"`
	RefreanceIDEqualFold    *string  `json:"refreanceIDEqualFold,omitempty"`
	RefreanceIDContainsFold *string  `json:"refreanceIDContainsFold,omitempty"`

	// "channel_model_price" edge predicates.
	HasChannelModelPrice     *bool                          `json:"hasChannelModelPrice,omitempty"`
	HasChannelModelPriceWith []*ChannelModelPriceWhereInput `json:"hasChannelModelPriceWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ChannelModelPriceVersionWhereInput) AddPredicates(predicates ...predicate.ChannelModelPriceVersion) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ChannelModelPriceVersionWhereInput filter on the ChannelModelPriceVersionQuery builder.
func (i *ChannelModelPriceVersionWhereInput) Filter(q *ChannelModelPriceVersionQuery) (*ChannelModelPriceVersionQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyChannelModelPriceVersionWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyChannelModelPriceVersionWhereInput is returned in case the ChannelModelPriceVersionWhereInput is empty.
var ErrEmptyChannelModelPriceVersionWhereInput = errors.New("ent: empty predicate ChannelModelPriceVersionWhereInput")

// P returns a predicate for filtering channelmodelpriceversions.
// An error is returned if the input is empty or invalid.
func (i *ChannelModelPriceVersionWhereInput) P() (predicate.ChannelModelPriceVersion, error) {
	var predicates []predicate.ChannelModelPriceVersion
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, channelmodelpriceversion.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ChannelModelPriceVersion, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, channelmodelpriceversion.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ChannelModelPriceVersion, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, channelmodelpriceversion.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, channelmodelpriceversion.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, channelmodelpriceversion.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, channelmodelpriceversion.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, channelmodelpriceversion.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, channelmodelpriceversion.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, channelmodelpriceversion.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, channelmodelpriceversion.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, channelmodelpriceversion.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, channelmodelpriceversion.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, channelmodelpriceversion.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, channelmodelpriceversion.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, channelmodelpriceversion.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, channelmodelpriceversion.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, channelmodelpriceversion.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, channelmodelpriceversion.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, channelmodelpriceversion.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, channelmodelpriceversion.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, channelmodelpriceversion.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, channelmodelpriceversion.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, channelmodelpriceversion.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, channelmodelpriceversion.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, channelmodelpriceversion.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, channelmodelpriceversion.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, channelmodelpriceversion.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, channelmodelpriceversion.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, channelmodelpriceversion.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, channelmodelpriceversion.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, channelmodelpriceversion.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, channelmodelpriceversion.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, channelmodelpriceversion.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, channelmodelpriceversion.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, channelmodelpriceversion.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.ChannelID != nil {
		predicates = append(predicates, channelmodelpriceversion.ChannelIDEQ(*i.ChannelID))
	}
	if i.ChannelIDNEQ != nil {
		predicates = append(predicates, channelmodelpriceversion.ChannelIDNEQ(*i.ChannelIDNEQ))
	}
	if len(i.ChannelIDIn) > 0 {
		predicates = append(predicates, channelmodelpriceversion.ChannelIDIn(i.ChannelIDIn...))
	}
	if len(i.ChannelIDNotIn) > 0 {
		predicates = append(predicates, channelmodelpriceversion.ChannelIDNotIn(i.ChannelIDNotIn...))
	}
	if i.ChannelIDGT != nil {
		predicates = append(predicates, channelmodelpriceversion.ChannelIDGT(*i.ChannelIDGT))
	}
	if i.ChannelIDGTE != nil {
		predicates = append(predicates, channelmodelpriceversion.ChannelIDGTE(*i.ChannelIDGTE))
	}
	if i.ChannelIDLT != nil {
		predicates = append(predicates, channelmodelpriceversion.ChannelIDLT(*i.ChannelIDLT))
	}
	if i.ChannelIDLTE != nil {
		predicates = append(predicates, channelmodelpriceversion.ChannelIDLTE(*i.ChannelIDLTE))
	}
	if i.ModelID != nil {
		predicates = append(predicates, channelmodelpriceversion.ModelIDEQ(*i.ModelID))
	}
	if i.ModelIDNEQ != nil {
		predicates = append(predicates, channelmodelpriceversion.ModelIDNEQ(*i.ModelIDNEQ))
	}
	if len(i.ModelIDIn) > 0 {
		predicates = append(predicates, channelmodelpriceversion.ModelIDIn(i.ModelIDIn...))
	}
	if len(i.ModelIDNotIn) > 0 {
		predicates = append(predicates, channelmodelpriceversion.ModelIDNotIn(i.ModelIDNotIn...))
	}
	if i.ModelIDGT != nil {
		predicates = append(predicates, channelmodelpriceversion.ModelIDGT(*i.ModelIDGT))
	}
	if i.ModelIDGTE != nil {
		predicates = append(predicates, channelmodelpriceversion.ModelIDGTE(*i.ModelIDGTE))
	}
	if i.ModelIDLT != nil {
		predicates = append(predicates, channelmodelpriceversion.ModelIDLT(*i.ModelIDLT))
	}
	if i.ModelIDLTE != nil {
		predicates = append(predicates, channelmodelpriceversion.ModelIDLTE(*i.ModelIDLTE))
	}
	if i.ModelIDContains != nil {
		predicates = append(predicates, channelmodelpriceversion.ModelIDContains(*i.ModelIDContains))
	}
	if i.ModelIDHasPrefix != nil {
		predicates = append(predicates, channelmodelpriceversion.ModelIDHasPrefix(*i.ModelIDHasPrefix))
	}
	if i.ModelIDHasSuffix != nil {
		predicates = append(predicates, channelmodelpriceversion.ModelIDHasSuffix(*i.ModelIDHasSuffix))
	}
	if i.ModelIDEqualFold != nil {
		predicates = append(predicates, channelmodelpriceversion.ModelIDEqualFold(*i.ModelIDEqualFold))
	}
	if i.ModelIDContainsFold != nil {
		predicates = append(predicates, channelmodelpriceversion.ModelIDContainsFold(*i.ModelIDContainsFold))
	}
	if i.ChannelModelPriceID != nil {
		predicates = append(predicates, channelmodelpriceversion.ChannelModelPriceIDEQ(*i.ChannelModelPriceID))
	}
	if i.ChannelModelPriceIDNEQ != nil {
		predicates = append(predicates, channelmodelpriceversion.ChannelModelPriceIDNEQ(*i.ChannelModelPriceIDNEQ))
	}
	if len(i.ChannelModelPriceIDIn) > 0 {
		predicates = append(predicates, channelmodelpriceversion.ChannelModelPriceIDIn(i.ChannelModelPriceIDIn...))
	}
	if len(i.ChannelModelPriceIDNotIn) > 0 {
		predicates = append(predicates, channelmodelpriceversion.ChannelModelPriceIDNotIn(i.ChannelModelPriceIDNotIn...))
	}
	if i.Status != nil {
		predicates = append(predicates, channelmodelpriceversion.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, channelmodelpriceversion.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, channelmodelpriceversion.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, channelmodelpriceversion.StatusNotIn(i.StatusNotIn...))
	}
	if i.EffectiveStartAt != nil {
		predicates = append(predicates, channelmodelpriceversion.EffectiveStartAtEQ(*i.EffectiveStartAt))
	}
	if i.EffectiveStartAtNEQ != nil {
		predicates = append(predicates, channelmodelpriceversion.EffectiveStartAtNEQ(*i.EffectiveStartAtNEQ))
	}
	if len(i.EffectiveStartAtIn) > 0 {
		predicates = append(predicates, channelmodelpriceversion.EffectiveStartAtIn(i.EffectiveStartAtIn...))
	}
	if len(i.EffectiveStartAtNotIn) > 0 {
		predicates = append(predicates, channelmodelpriceversion.EffectiveStartAtNotIn(i.EffectiveStartAtNotIn...))
	}
	if i.EffectiveStartAtGT != nil {
		predicates = append(predicates, channelmodelpriceversion.EffectiveStartAtGT(*i.EffectiveStartAtGT))
	}
	if i.EffectiveStartAtGTE != nil {
		predicates = append(predicates, channelmodelpriceversion.EffectiveStartAtGTE(*i.EffectiveStartAtGTE))
	}
	if i.EffectiveStartAtLT != nil {
		predicates = append(predicates, channelmodelpriceversion.EffectiveStartAtLT(*i.EffectiveStartAtLT))
	}
	if i.EffectiveStartAtLTE != nil {
		predicates = append(predicates, channelmodelpriceversion.EffectiveStartAtLTE(*i.EffectiveStartAtLTE))
	}
	if i.EffectiveEndAt != nil {
		predicates = append(predicates, channelmodelpriceversion.EffectiveEndAtEQ(*i.EffectiveEndAt))
	}
	if i.EffectiveEndAtNEQ != nil {
		predicates = append(predicates, channelmodelpriceversion.EffectiveEndAtNEQ(*i.EffectiveEndAtNEQ))
	}
	if len(i.EffectiveEndAtIn) > 0 {
		predicates = append(predicates, channelmodelpriceversion.EffectiveEndAtIn(i.EffectiveEndAtIn...))
	}
	if len(i.EffectiveEndAtNotIn) > 0 {
		predicates = append(predicates, channelmodelpriceversion.EffectiveEndAtNotIn(i.EffectiveEndAtNotIn...))
	}
	if i.EffectiveEndAtGT != nil {
		predicates = append(predicates, channelmodelpriceversion.EffectiveEndAtGT(*i.EffectiveEndAtGT))
	}
	if i.EffectiveEndAtGTE != nil {
		predicates = append(predicates, channelmodelpriceversion.EffectiveEndAtGTE(*i.EffectiveEndAtGTE))
	}
	if i.EffectiveEndAtLT != nil {
		predicates = append(predicates, channelmodelpriceversion.EffectiveEndAtLT(*i.EffectiveEndAtLT))
	}
	if i.EffectiveEndAtLTE != nil {
		predicates = append(predicates, channelmodelpriceversion.EffectiveEndAtLTE(*i.EffectiveEndAtLTE))
	}
	if i.EffectiveEndAtIsNil {
		predicates = append(predicates, channelmodelpriceversion.EffectiveEndAtIsNil())
	}
	if i.EffectiveEndAtNotNil {
		predicates = append(predicates, channelmodelpriceversion.EffectiveEndAtNotNil())
	}
	if i.RefreanceID != nil {
		predicates = append(predicates, channelmodelpriceversion.RefreanceIDEQ(*i.RefreanceID))
	}
	if i.RefreanceIDNEQ != nil {
		predicates = append(predicates, channelmodelpriceversion.RefreanceIDNEQ(*i.RefreanceIDNEQ))
	}
	if len(i.RefreanceIDIn) > 0 {
		predicates = append(predicates, channelmodelpriceversion.RefreanceIDIn(i.RefreanceIDIn...))
	}
	if len(i.RefreanceIDNotIn) > 0 {
		predicates = append(predicates, channelmodelpriceversion.RefreanceIDNotIn(i.RefreanceIDNotIn...))
	}
	if i.RefreanceIDGT != nil {
		predicates = append(predicates, channelmodelpriceversion.RefreanceIDGT(*i.RefreanceIDGT))
	}
	if i.RefreanceIDGTE != nil {
		predicates = append(predicates, channelmodelpriceversion.RefreanceIDGTE(*i.RefreanceIDGTE))
	}
	if i.RefreanceIDLT != nil {
		predicates = append(predicates, channelmodelpriceversion.RefreanceIDLT(*i.RefreanceIDLT))
	}
	if i.RefreanceIDLTE != nil {
		predicates = append(predicates, channelmodelpriceversion.RefreanceIDLTE(*i.RefreanceIDLTE))
	}
	if i.RefreanceIDContains != nil {
		predicates = append(predicates, channelmodelpriceversion.RefreanceIDContains(*i.RefreanceIDContains))
	}
	if i.RefreanceIDHasPrefix != nil {
		predicates = append(predicates, channelmodelpriceversion.RefreanceIDHasPrefix(*i.RefreanceIDHasPrefix))
	}
	if i.RefreanceIDHasSuffix != nil {
		predicates = append(predicates, channelmodelpriceversion.RefreanceIDHasSuffix(*i.RefreanceIDHasSuffix))
	}
	if i.RefreanceIDEqualFold != nil {
		predicates = append(predicates, channelmodelpriceversion.RefreanceIDEqualFold(*i.RefreanceIDEqualFold))
	}
	if i.RefreanceIDContainsFold != nil {
		predicates = append(predicates, channelmodelpriceversion.RefreanceIDContainsFold(*i.RefreanceIDContainsFold))
	}

	if i.HasChannelModelPrice != nil {
		p := channelmodelpriceversion.HasChannelModelPrice()
		if !*i.HasChannelModelPrice {
			p = channelmodelpriceversion.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasChannelModelPriceWith) > 0 {
		with := make([]predicate.ChannelModelPrice, 0, len(i.HasChannelModelPriceWith))
		for _, w := range i.HasChannelModelPriceWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasChannelModelPriceWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, channelmodelpriceversion.HasChannelModelPriceWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyChannelModelPriceVersionWhereInput
	case 1:
		return predicates[0], nil
	default:
		return channelmodelpriceversion.And(predicates...), nil
	}
}

// ChannelOverrideTemplateWhereInput represents a where input for filtering ChannelOverrideTemplate queries.
type ChannelOverrideTemplateWhereInput struct {
	Predicates []predicate.ChannelOverrideTemplate  `json:"-"`
	Not        *ChannelOverrideTemplateWhereInput   `json:"not,omitempty"`
	Or         []*ChannelOverrideTemplateWhereInput `json:"or,omitempty"`
	And        []*ChannelOverrideTemplateWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt      *int  `json:"deletedAt,omitempty"`
	DeletedAtNEQ   *int  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn    []int `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn []int `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT    *int  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE   *int  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT    *int  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE   *int  `json:"deletedAtLTE,omitempty"`

	// "user_id" field predicates.
	UserID      *int  `json:"userID,omitempty"`
	UserIDNEQ   *int  `json:"userIDNEQ,omitempty"`
	UserIDIn    []int `json:"userIDIn,omitempty"`
	UserIDNotIn []int `json:"userIDNotIn,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "channel_type" field predicates.
	ChannelType             *string  `json:"channelType,omitempty"`
	ChannelTypeNEQ          *string  `json:"channelTypeNEQ,omitempty"`
	ChannelTypeIn           []string `json:"channelTypeIn,omitempty"`
	ChannelTypeNotIn        []string `json:"channelTypeNotIn,omitempty"`
	ChannelTypeGT           *string  `json:"channelTypeGT,omitempty"`
	ChannelTypeGTE          *string  `json:"channelTypeGTE,omitempty"`
	ChannelTypeLT           *string  `json:"channelTypeLT,omitempty"`
	ChannelTypeLTE          *string  `json:"channelTypeLTE,omitempty"`
	ChannelTypeContains     *string  `json:"channelTypeContains,omitempty"`
	ChannelTypeHasPrefix    *string  `json:"channelTypeHasPrefix,omitempty"`
	ChannelTypeHasSuffix    *string  `json:"channelTypeHasSuffix,omitempty"`
	ChannelTypeEqualFold    *string  `json:"channelTypeEqualFold,omitempty"`
	ChannelTypeContainsFold *string  `json:"channelTypeContainsFold,omitempty"`

	// "override_parameters" field predicates.
	OverrideParameters             *string  `json:"overrideParameters,omitempty"`
	OverrideParametersNEQ          *string  `json:"overrideParametersNEQ,omitempty"`
	OverrideParametersIn           []string `json:"overrideParametersIn,omitempty"`
	OverrideParametersNotIn        []string `json:"overrideParametersNotIn,omitempty"`
	OverrideParametersGT           *string  `json:"overrideParametersGT,omitempty"`
	OverrideParametersGTE          *string  `json:"overrideParametersGTE,omitempty"`
	OverrideParametersLT           *string  `json:"overrideParametersLT,omitempty"`
	OverrideParametersLTE          *string  `json:"overrideParametersLTE,omitempty"`
	OverrideParametersContains     *string  `json:"overrideParametersContains,omitempty"`
	OverrideParametersHasPrefix    *string  `json:"overrideParametersHasPrefix,omitempty"`
	OverrideParametersHasSuffix    *string  `json:"overrideParametersHasSuffix,omitempty"`
	OverrideParametersEqualFold    *string  `json:"overrideParametersEqualFold,omitempty"`
	OverrideParametersContainsFold *string  `json:"overrideParametersContainsFold,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ChannelOverrideTemplateWhereInput) AddPredicates(predicates ...predicate.ChannelOverrideTemplate) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ChannelOverrideTemplateWhereInput filter on the ChannelOverrideTemplateQuery builder.
func (i *ChannelOverrideTemplateWhereInput) Filter(q *ChannelOverrideTemplateQuery) (*ChannelOverrideTemplateQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyChannelOverrideTemplateWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyChannelOverrideTemplateWhereInput is returned in case the ChannelOverrideTemplateWhereInput is empty.
var ErrEmptyChannelOverrideTemplateWhereInput = errors.New("ent: empty predicate ChannelOverrideTemplateWhereInput")

// P returns a predicate for filtering channeloverridetemplates.
// An error is returned if the input is empty or invalid.
func (i *ChannelOverrideTemplateWhereInput) P() (predicate.ChannelOverrideTemplate, error) {
	var predicates []predicate.ChannelOverrideTemplate
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, channeloverridetemplate.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ChannelOverrideTemplate, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, channeloverridetemplate.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ChannelOverrideTemplate, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, channeloverridetemplate.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, channeloverridetemplate.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, channeloverridetemplate.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, channeloverridetemplate.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, channeloverridetemplate.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, channeloverridetemplate.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, channeloverridetemplate.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, channeloverridetemplate.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, channeloverridetemplate.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, channeloverridetemplate.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, channeloverridetemplate.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, channeloverridetemplate.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, channeloverridetemplate.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, channeloverridetemplate.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, channeloverridetemplate.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, channeloverridetemplate.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, channeloverridetemplate.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, channeloverridetemplate.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, channeloverridetemplate.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, channeloverridetemplate.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, channeloverridetemplate.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, channeloverridetemplate.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, channeloverridetemplate.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, channeloverridetemplate.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, channeloverridetemplate.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, channeloverridetemplate.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, channeloverridetemplate.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, channeloverridetemplate.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, channeloverridetemplate.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, channeloverridetemplate.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, channeloverridetemplate.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, channeloverridetemplate.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, channeloverridetemplate.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.UserID != nil {
		predicates = append(predicates, channeloverridetemplate.UserIDEQ(*i.UserID))
	}
	if i.UserIDNEQ != nil {
		predicates = append(predicates, channeloverridetemplate.UserIDNEQ(*i.UserIDNEQ))
	}
	if len(i.UserIDIn) > 0 {
		predicates = append(predicates, channeloverridetemplate.UserIDIn(i.UserIDIn...))
	}
	if len(i.UserIDNotIn) > 0 {
		predicates = append(predicates, channeloverridetemplate.UserIDNotIn(i.UserIDNotIn...))
	}
	if i.Name != nil {
		predicates = append(predicates, channeloverridetemplate.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, channeloverridetemplate.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, channeloverridetemplate.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, channeloverridetemplate.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, channeloverridetemplate.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, channeloverridetemplate.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, channeloverridetemplate.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, channeloverridetemplate.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, channeloverridetemplate.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, channeloverridetemplate.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, channeloverridetemplate.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, channeloverridetemplate.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, channeloverridetemplate.NameContainsFold(*i.NameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, channeloverridetemplate.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, channeloverridetemplate.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, channeloverridetemplate.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, channeloverridetemplate.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, channeloverridetemplate.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, channeloverridetemplate.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, channeloverridetemplate.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, channeloverridetemplate.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, channeloverridetemplate.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, channeloverridetemplate.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, channeloverridetemplate.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, channeloverridetemplate.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, channeloverridetemplate.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, channeloverridetemplate.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, channeloverridetemplate.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.ChannelType != nil {
		predicates = append(predicates, channeloverridetemplate.ChannelTypeEQ(*i.ChannelType))
	}
	if i.ChannelTypeNEQ != nil {
		predicates = append(predicates, channeloverridetemplate.ChannelTypeNEQ(*i.ChannelTypeNEQ))
	}
	if len(i.ChannelTypeIn) > 0 {
		predicates = append(predicates, channeloverridetemplate.ChannelTypeIn(i.ChannelTypeIn...))
	}
	if len(i.ChannelTypeNotIn) > 0 {
		predicates = append(predicates, channeloverridetemplate.ChannelTypeNotIn(i.ChannelTypeNotIn...))
	}
	if i.ChannelTypeGT != nil {
		predicates = append(predicates, channeloverridetemplate.ChannelTypeGT(*i.ChannelTypeGT))
	}
	if i.ChannelTypeGTE != nil {
		predicates = append(predicates, channeloverridetemplate.ChannelTypeGTE(*i.ChannelTypeGTE))
	}
	if i.ChannelTypeLT != nil {
		predicates = append(predicates, channeloverridetemplate.ChannelTypeLT(*i.ChannelTypeLT))
	}
	if i.ChannelTypeLTE != nil {
		predicates = append(predicates, channeloverridetemplate.ChannelTypeLTE(*i.ChannelTypeLTE))
	}
	if i.ChannelTypeContains != nil {
		predicates = append(predicates, channeloverridetemplate.ChannelTypeContains(*i.ChannelTypeContains))
	}
	if i.ChannelTypeHasPrefix != nil {
		predicates = append(predicates, channeloverridetemplate.ChannelTypeHasPrefix(*i.ChannelTypeHasPrefix))
	}
	if i.ChannelTypeHasSuffix != nil {
		predicates = append(predicates, channeloverridetemplate.ChannelTypeHasSuffix(*i.ChannelTypeHasSuffix))
	}
	if i.ChannelTypeEqualFold != nil {
		predicates = append(predicates, channeloverridetemplate.ChannelTypeEqualFold(*i.ChannelTypeEqualFold))
	}
	if i.ChannelTypeContainsFold != nil {
		predicates = append(predicates, channeloverridetemplate.ChannelTypeContainsFold(*i.ChannelTypeContainsFold))
	}
	if i.OverrideParameters != nil {
		predicates = append(predicates, channeloverridetemplate.OverrideParametersEQ(*i.OverrideParameters))
	}
	if i.OverrideParametersNEQ != nil {
		predicates = append(predicates, channeloverridetemplate.OverrideParametersNEQ(*i.OverrideParametersNEQ))
	}
	if len(i.OverrideParametersIn) > 0 {
		predicates = append(predicates, channeloverridetemplate.OverrideParametersIn(i.OverrideParametersIn...))
	}
	if len(i.OverrideParametersNotIn) > 0 {
		predicates = append(predicates, channeloverridetemplate.OverrideParametersNotIn(i.OverrideParametersNotIn...))
	}
	if i.OverrideParametersGT != nil {
		predicates = append(predicates, channeloverridetemplate.OverrideParametersGT(*i.OverrideParametersGT))
	}
	if i.OverrideParametersGTE != nil {
		predicates = append(predicates, channeloverridetemplate.OverrideParametersGTE(*i.OverrideParametersGTE))
	}
	if i.OverrideParametersLT != nil {
		predicates = append(predicates, channeloverridetemplate.OverrideParametersLT(*i.OverrideParametersLT))
	}
	if i.OverrideParametersLTE != nil {
		predicates = append(predicates, channeloverridetemplate.OverrideParametersLTE(*i.OverrideParametersLTE))
	}
	if i.OverrideParametersContains != nil {
		predicates = append(predicates, channeloverridetemplate.OverrideParametersContains(*i.OverrideParametersContains))
	}
	if i.OverrideParametersHasPrefix != nil {
		predicates = append(predicates, channeloverridetemplate.OverrideParametersHasPrefix(*i.OverrideParametersHasPrefix))
	}
	if i.OverrideParametersHasSuffix != nil {
		predicates = append(predicates, channeloverridetemplate.OverrideParametersHasSuffix(*i.OverrideParametersHasSuffix))
	}
	if i.OverrideParametersEqualFold != nil {
		predicates = append(predicates, channeloverridetemplate.OverrideParametersEqualFold(*i.OverrideParametersEqualFold))
	}
	if i.OverrideParametersContainsFold != nil {
		predicates = append(predicates, channeloverridetemplate.OverrideParametersContainsFold(*i.OverrideParametersContainsFold))
	}

	if i.HasUser != nil {
		p := channeloverridetemplate.HasUser()
		if !*i.HasUser {
			p = channeloverridetemplate.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, channeloverridetemplate.HasUserWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyChannelOverrideTemplateWhereInput
	case 1:
		return predicates[0], nil
	default:
		return channeloverridetemplate.And(predicates...), nil
	}
}

// ChannelPerformanceWhereInput represents a where input for filtering ChannelPerformance queries.
type ChannelPerformanceWhereInput struct {
	Predicates []predicate.ChannelPerformance  `json:"-"`
	Not        *ChannelPerformanceWhereInput   `json:"not,omitempty"`
	Or         []*ChannelPerformanceWhereInput `json:"or,omitempty"`
	And        []*ChannelPerformanceWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt      *int  `json:"deletedAt,omitempty"`
	DeletedAtNEQ   *int  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn    []int `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn []int `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT    *int  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE   *int  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT    *int  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE   *int  `json:"deletedAtLTE,omitempty"`

	// "channel_id" field predicates.
	ChannelID      *int  `json:"channelID,omitempty"`
	ChannelIDNEQ   *int  `json:"channelIDNEQ,omitempty"`
	ChannelIDIn    []int `json:"channelIDIn,omitempty"`
	ChannelIDNotIn []int `json:"channelIDNotIn,omitempty"`

	// "success_rate" field predicates.
	SuccessRate      *int  `json:"successRate,omitempty"`
	SuccessRateNEQ   *int  `json:"successRateNEQ,omitempty"`
	SuccessRateIn    []int `json:"successRateIn,omitempty"`
	SuccessRateNotIn []int `json:"successRateNotIn,omitempty"`
	SuccessRateGT    *int  `json:"successRateGT,omitempty"`
	SuccessRateGTE   *int  `json:"successRateGTE,omitempty"`
	SuccessRateLT    *int  `json:"successRateLT,omitempty"`
	SuccessRateLTE   *int  `json:"successRateLTE,omitempty"`

	// "avg_latency_ms" field predicates.
	AvgLatencyMs      *int  `json:"avgLatencyMs,omitempty"`
	AvgLatencyMsNEQ   *int  `json:"avgLatencyMsNEQ,omitempty"`
	AvgLatencyMsIn    []int `json:"avgLatencyMsIn,omitempty"`
	AvgLatencyMsNotIn []int `json:"avgLatencyMsNotIn,omitempty"`
	AvgLatencyMsGT    *int  `json:"avgLatencyMsGT,omitempty"`
	AvgLatencyMsGTE   *int  `json:"avgLatencyMsGTE,omitempty"`
	AvgLatencyMsLT    *int  `json:"avgLatencyMsLT,omitempty"`
	AvgLatencyMsLTE   *int  `json:"avgLatencyMsLTE,omitempty"`

	// "avg_token_per_second" field predicates.
	AvgTokenPerSecond      *int  `json:"avgTokenPerSecond,omitempty"`
	AvgTokenPerSecondNEQ   *int  `json:"avgTokenPerSecondNEQ,omitempty"`
	AvgTokenPerSecondIn    []int `json:"avgTokenPerSecondIn,omitempty"`
	AvgTokenPerSecondNotIn []int `json:"avgTokenPerSecondNotIn,omitempty"`
	AvgTokenPerSecondGT    *int  `json:"avgTokenPerSecondGT,omitempty"`
	AvgTokenPerSecondGTE   *int  `json:"avgTokenPerSecondGTE,omitempty"`
	AvgTokenPerSecondLT    *int  `json:"avgTokenPerSecondLT,omitempty"`
	AvgTokenPerSecondLTE   *int  `json:"avgTokenPerSecondLTE,omitempty"`

	// "avg_stream_first_token_latency_ms" field predicates.
	AvgStreamFirstTokenLatencyMs      *int  `json:"avgStreamFirstTokenLatencyMs,omitempty"`
	AvgStreamFirstTokenLatencyMsNEQ   *int  `json:"avgStreamFirstTokenLatencyMsNEQ,omitempty"`
	AvgStreamFirstTokenLatencyMsIn    []int `json:"avgStreamFirstTokenLatencyMsIn,omitempty"`
	AvgStreamFirstTokenLatencyMsNotIn []int `json:"avgStreamFirstTokenLatencyMsNotIn,omitempty"`
	AvgStreamFirstTokenLatencyMsGT    *int  `json:"avgStreamFirstTokenLatencyMsGT,omitempty"`
	AvgStreamFirstTokenLatencyMsGTE   *int  `json:"avgStreamFirstTokenLatencyMsGTE,omitempty"`
	AvgStreamFirstTokenLatencyMsLT    *int  `json:"avgStreamFirstTokenLatencyMsLT,omitempty"`
	AvgStreamFirstTokenLatencyMsLTE   *int  `json:"avgStreamFirstTokenLatencyMsLTE,omitempty"`

	// "avg_stream_token_per_second" field predicates.
	AvgStreamTokenPerSecond      *float64  `json:"avgStreamTokenPerSecond,omitempty"`
	AvgStreamTokenPerSecondNEQ   *float64  `json:"avgStreamTokenPerSecondNEQ,omitempty"`
	AvgStreamTokenPerSecondIn    []float64 `json:"avgStreamTokenPerSecondIn,omitempty"`
	AvgStreamTokenPerSecondNotIn []float64 `json:"avgStreamTokenPerSecondNotIn,omitempty"`
	AvgStreamTokenPerSecondGT    *float64  `json:"avgStreamTokenPerSecondGT,omitempty"`
	AvgStreamTokenPerSecondGTE   *float64  `json:"avgStreamTokenPerSecondGTE,omitempty"`
	AvgStreamTokenPerSecondLT    *float64  `json:"avgStreamTokenPerSecondLT,omitempty"`
	AvgStreamTokenPerSecondLTE   *float64  `json:"avgStreamTokenPerSecondLTE,omitempty"`

	// "last_success_at" field predicates.
	LastSuccessAt       *time.Time  `json:"lastSuccessAt,omitempty"`
	LastSuccessAtNEQ    *time.Time  `json:"lastSuccessAtNEQ,omitempty"`
	LastSuccessAtIn     []time.Time `json:"lastSuccessAtIn,omitempty"`
	LastSuccessAtNotIn  []time.Time `json:"lastSuccessAtNotIn,omitempty"`
	LastSuccessAtGT     *time.Time  `json:"lastSuccessAtGT,omitempty"`
	LastSuccessAtGTE    *time.Time  `json:"lastSuccessAtGTE,omitempty"`
	LastSuccessAtLT     *time.Time  `json:"lastSuccessAtLT,omitempty"`
	LastSuccessAtLTE    *time.Time  `json:"lastSuccessAtLTE,omitempty"`
	LastSuccessAtIsNil  bool        `json:"lastSuccessAtIsNil,omitempty"`
	LastSuccessAtNotNil bool        `json:"lastSuccessAtNotNil,omitempty"`

	// "last_failure_at" field predicates.
	LastFailureAt       *time.Time  `json:"lastFailureAt,omitempty"`
	LastFailureAtNEQ    *time.Time  `json:"lastFailureAtNEQ,omitempty"`
	LastFailureAtIn     []time.Time `json:"lastFailureAtIn,omitempty"`
	LastFailureAtNotIn  []time.Time `json:"lastFailureAtNotIn,omitempty"`
	LastFailureAtGT     *time.Time  `json:"lastFailureAtGT,omitempty"`
	LastFailureAtGTE    *time.Time  `json:"lastFailureAtGTE,omitempty"`
	LastFailureAtLT     *time.Time  `json:"lastFailureAtLT,omitempty"`
	LastFailureAtLTE    *time.Time  `json:"lastFailureAtLTE,omitempty"`
	LastFailureAtIsNil  bool        `json:"lastFailureAtIsNil,omitempty"`
	LastFailureAtNotNil bool        `json:"lastFailureAtNotNil,omitempty"`

	// "request_count" field predicates.
	RequestCount      *int64  `json:"requestCount,omitempty"`
	RequestCountNEQ   *int64  `json:"requestCountNEQ,omitempty"`
	RequestCountIn    []int64 `json:"requestCountIn,omitempty"`
	RequestCountNotIn []int64 `json:"requestCountNotIn,omitempty"`
	RequestCountGT    *int64  `json:"requestCountGT,omitempty"`
	RequestCountGTE   *int64  `json:"requestCountGTE,omitempty"`
	RequestCountLT    *int64  `json:"requestCountLT,omitempty"`
	RequestCountLTE   *int64  `json:"requestCountLTE,omitempty"`

	// "success_count" field predicates.
	SuccessCount      *int64  `json:"successCount,omitempty"`
	SuccessCountNEQ   *int64  `json:"successCountNEQ,omitempty"`
	SuccessCountIn    []int64 `json:"successCountIn,omitempty"`
	SuccessCountNotIn []int64 `json:"successCountNotIn,omitempty"`
	SuccessCountGT    *int64  `json:"successCountGT,omitempty"`
	SuccessCountGTE   *int64  `json:"successCountGTE,omitempty"`
	SuccessCountLT    *int64  `json:"successCountLT,omitempty"`
	SuccessCountLTE   *int64  `json:"successCountLTE,omitempty"`

	// "failure_count" field predicates.
	FailureCount      *int64  `json:"failureCount,omitempty"`
	FailureCountNEQ   *int64  `json:"failureCountNEQ,omitempty"`
	FailureCountIn    []int64 `json:"failureCountIn,omitempty"`
	FailureCountNotIn []int64 `json:"failureCountNotIn,omitempty"`
	FailureCountGT    *int64  `json:"failureCountGT,omitempty"`
	FailureCountGTE   *int64  `json:"failureCountGTE,omitempty"`
	FailureCountLT    *int64  `json:"failureCountLT,omitempty"`
	FailureCountLTE   *int64  `json:"failureCountLTE,omitempty"`

	// "total_token_count" field predicates.
	TotalTokenCount      *int64  `json:"totalTokenCount,omitempty"`
	TotalTokenCountNEQ   *int64  `json:"totalTokenCountNEQ,omitempty"`
	TotalTokenCountIn    []int64 `json:"totalTokenCountIn,omitempty"`
	TotalTokenCountNotIn []int64 `json:"totalTokenCountNotIn,omitempty"`
	TotalTokenCountGT    *int64  `json:"totalTokenCountGT,omitempty"`
	TotalTokenCountGTE   *int64  `json:"totalTokenCountGTE,omitempty"`
	TotalTokenCountLT    *int64  `json:"totalTokenCountLT,omitempty"`
	TotalTokenCountLTE   *int64  `json:"totalTokenCountLTE,omitempty"`

	// "total_request_latency_ms" field predicates.
	TotalRequestLatencyMs      *int64  `json:"totalRequestLatencyMs,omitempty"`
	TotalRequestLatencyMsNEQ   *int64  `json:"totalRequestLatencyMsNEQ,omitempty"`
	TotalRequestLatencyMsIn    []int64 `json:"totalRequestLatencyMsIn,omitempty"`
	TotalRequestLatencyMsNotIn []int64 `json:"totalRequestLatencyMsNotIn,omitempty"`
	TotalRequestLatencyMsGT    *int64  `json:"totalRequestLatencyMsGT,omitempty"`
	TotalRequestLatencyMsGTE   *int64  `json:"totalRequestLatencyMsGTE,omitempty"`
	TotalRequestLatencyMsLT    *int64  `json:"totalRequestLatencyMsLT,omitempty"`
	TotalRequestLatencyMsLTE   *int64  `json:"totalRequestLatencyMsLTE,omitempty"`

	// "stream_success_count" field predicates.
	StreamSuccessCount      *int64  `json:"streamSuccessCount,omitempty"`
	StreamSuccessCountNEQ   *int64  `json:"streamSuccessCountNEQ,omitempty"`
	StreamSuccessCountIn    []int64 `json:"streamSuccessCountIn,omitempty"`
	StreamSuccessCountNotIn []int64 `json:"streamSuccessCountNotIn,omitempty"`
	StreamSuccessCountGT    *int64  `json:"streamSuccessCountGT,omitempty"`
	StreamSuccessCountGTE   *int64  `json:"streamSuccessCountGTE,omitempty"`
	StreamSuccessCountLT    *int64  `json:"streamSuccessCountLT,omitempty"`
	StreamSuccessCountLTE   *int64  `json:"streamSuccessCountLTE,omitempty"`

	// "stream_total_request_count" field predicates.
	StreamTotalRequestCount      *int64  `json:"streamTotalRequestCount,omitempty"`
	StreamTotalRequestCountNEQ   *int64  `json:"streamTotalRequestCountNEQ,omitempty"`
	StreamTotalRequestCountIn    []int64 `json:"streamTotalRequestCountIn,omitempty"`
	StreamTotalRequestCountNotIn []int64 `json:"streamTotalRequestCountNotIn,omitempty"`
	StreamTotalRequestCountGT    *int64  `json:"streamTotalRequestCountGT,omitempty"`
	StreamTotalRequestCountGTE   *int64  `json:"streamTotalRequestCountGTE,omitempty"`
	StreamTotalRequestCountLT    *int64  `json:"streamTotalRequestCountLT,omitempty"`
	StreamTotalRequestCountLTE   *int64  `json:"streamTotalRequestCountLTE,omitempty"`

	// "stream_total_token_count" field predicates.
	StreamTotalTokenCount      *int64  `json:"streamTotalTokenCount,omitempty"`
	StreamTotalTokenCountNEQ   *int64  `json:"streamTotalTokenCountNEQ,omitempty"`
	StreamTotalTokenCountIn    []int64 `json:"streamTotalTokenCountIn,omitempty"`
	StreamTotalTokenCountNotIn []int64 `json:"streamTotalTokenCountNotIn,omitempty"`
	StreamTotalTokenCountGT    *int64  `json:"streamTotalTokenCountGT,omitempty"`
	StreamTotalTokenCountGTE   *int64  `json:"streamTotalTokenCountGTE,omitempty"`
	StreamTotalTokenCountLT    *int64  `json:"streamTotalTokenCountLT,omitempty"`
	StreamTotalTokenCountLTE   *int64  `json:"streamTotalTokenCountLTE,omitempty"`

	// "stream_total_request_latency_ms" field predicates.
	StreamTotalRequestLatencyMs      *int64  `json:"streamTotalRequestLatencyMs,omitempty"`
	StreamTotalRequestLatencyMsNEQ   *int64  `json:"streamTotalRequestLatencyMsNEQ,omitempty"`
	StreamTotalRequestLatencyMsIn    []int64 `json:"streamTotalRequestLatencyMsIn,omitempty"`
	StreamTotalRequestLatencyMsNotIn []int64 `json:"streamTotalRequestLatencyMsNotIn,omitempty"`
	StreamTotalRequestLatencyMsGT    *int64  `json:"streamTotalRequestLatencyMsGT,omitempty"`
	StreamTotalRequestLatencyMsGTE   *int64  `json:"streamTotalRequestLatencyMsGTE,omitempty"`
	StreamTotalRequestLatencyMsLT    *int64  `json:"streamTotalRequestLatencyMsLT,omitempty"`
	StreamTotalRequestLatencyMsLTE   *int64  `json:"streamTotalRequestLatencyMsLTE,omitempty"`

	// "stream_total_first_token_latency_ms" field predicates.
	StreamTotalFirstTokenLatencyMs      *int64  `json:"streamTotalFirstTokenLatencyMs,omitempty"`
	StreamTotalFirstTokenLatencyMsNEQ   *int64  `json:"streamTotalFirstTokenLatencyMsNEQ,omitempty"`
	StreamTotalFirstTokenLatencyMsIn    []int64 `json:"streamTotalFirstTokenLatencyMsIn,omitempty"`
	StreamTotalFirstTokenLatencyMsNotIn []int64 `json:"streamTotalFirstTokenLatencyMsNotIn,omitempty"`
	StreamTotalFirstTokenLatencyMsGT    *int64  `json:"streamTotalFirstTokenLatencyMsGT,omitempty"`
	StreamTotalFirstTokenLatencyMsGTE   *int64  `json:"streamTotalFirstTokenLatencyMsGTE,omitempty"`
	StreamTotalFirstTokenLatencyMsLT    *int64  `json:"streamTotalFirstTokenLatencyMsLT,omitempty"`
	StreamTotalFirstTokenLatencyMsLTE   *int64  `json:"streamTotalFirstTokenLatencyMsLTE,omitempty"`

	// "consecutive_failures" field predicates.
	ConsecutiveFailures      *int64  `json:"consecutiveFailures,omitempty"`
	ConsecutiveFailuresNEQ   *int64  `json:"consecutiveFailuresNEQ,omitempty"`
	ConsecutiveFailuresIn    []int64 `json:"consecutiveFailuresIn,omitempty"`
	ConsecutiveFailuresNotIn []int64 `json:"consecutiveFailuresNotIn,omitempty"`
	ConsecutiveFailuresGT    *int64  `json:"consecutiveFailuresGT,omitempty"`
	ConsecutiveFailuresGTE   *int64  `json:"consecutiveFailuresGTE,omitempty"`
	ConsecutiveFailuresLT    *int64  `json:"consecutiveFailuresLT,omitempty"`
	ConsecutiveFailuresLTE   *int64  `json:"consecutiveFailuresLTE,omitempty"`

	// "channel" edge predicates.
	HasChannel     *bool                `json:"hasChannel,omitempty"`
	HasChannelWith []*ChannelWhereInput `json:"hasChannelWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ChannelPerformanceWhereInput) AddPredicates(predicates ...predicate.ChannelPerformance) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ChannelPerformanceWhereInput filter on the ChannelPerformanceQuery builder.
func (i *ChannelPerformanceWhereInput) Filter(q *ChannelPerformanceQuery) (*ChannelPerformanceQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyChannelPerformanceWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyChannelPerformanceWhereInput is returned in case the ChannelPerformanceWhereInput is empty.
var ErrEmptyChannelPerformanceWhereInput = errors.New("ent: empty predicate ChannelPerformanceWhereInput")

// P returns a predicate for filtering channelperformances.
// An error is returned if the input is empty or invalid.
func (i *ChannelPerformanceWhereInput) P() (predicate.ChannelPerformance, error) {
	var predicates []predicate.ChannelPerformance
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, channelperformance.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ChannelPerformance, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, channelperformance.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ChannelPerformance, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, channelperformance.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, channelperformance.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, channelperformance.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, channelperformance.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, channelperformance.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, channelperformance.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, channelperformance.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, channelperformance.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, channelperformance.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, channelperformance.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, channelperformance.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, channelperformance.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, channelperformance.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, channelperformance.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, channelperformance.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, channelperformance.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, channelperformance.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, channelperformance.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, channelperformance.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, channelperformance.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, channelperformance.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, channelperformance.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, channelperformance.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, channelperformance.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, channelperformance.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, channelperformance.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, channelperformance.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, channelperformance.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, channelperformance.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, channelperformance.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, channelperformance.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, channelperformance.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, channelperformance.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.ChannelID != nil {
		predicates = append(predicates, channelperformance.ChannelIDEQ(*i.ChannelID))
	}
	if i.ChannelIDNEQ != nil {
		predicates = append(predicates, channelperformance.ChannelIDNEQ(*i.ChannelIDNEQ))
	}
	if len(i.ChannelIDIn) > 0 {
		predicates = append(predicates, channelperformance.ChannelIDIn(i.ChannelIDIn...))
	}
	if len(i.ChannelIDNotIn) > 0 {
		predicates = append(predicates, channelperformance.ChannelIDNotIn(i.ChannelIDNotIn...))
	}
	if i.SuccessRate != nil {
		predicates = append(predicates, channelperformance.SuccessRateEQ(*i.SuccessRate))
	}
	if i.SuccessRateNEQ != nil {
		predicates = append(predicates, channelperformance.SuccessRateNEQ(*i.SuccessRateNEQ))
	}
	if len(i.SuccessRateIn) > 0 {
		predicates = append(predicates, channelperformance.SuccessRateIn(i.SuccessRateIn...))
	}
	if len(i.SuccessRateNotIn) > 0 {
		predicates = append(predicates, channelperformance.SuccessRateNotIn(i.SuccessRateNotIn...))
	}
	if i.SuccessRateGT != nil {
		predicates = append(predicates, channelperformance.SuccessRateGT(*i.SuccessRateGT))
	}
	if i.SuccessRateGTE != nil {
		predicates = append(predicates, channelperformance.SuccessRateGTE(*i.SuccessRateGTE))
	}
	if i.SuccessRateLT != nil {
		predicates = append(predicates, channelperformance.SuccessRateLT(*i.SuccessRateLT))
	}
	if i.SuccessRateLTE != nil {
		predicates = append(predicates, channelperformance.SuccessRateLTE(*i.SuccessRateLTE))
	}
	if i.AvgLatencyMs != nil {
		predicates = append(predicates, channelperformance.AvgLatencyMsEQ(*i.AvgLatencyMs))
	}
	if i.AvgLatencyMsNEQ != nil {
		predicates = append(predicates, channelperformance.AvgLatencyMsNEQ(*i.AvgLatencyMsNEQ))
	}
	if len(i.AvgLatencyMsIn) > 0 {
		predicates = append(predicates, channelperformance.AvgLatencyMsIn(i.AvgLatencyMsIn...))
	}
	if len(i.AvgLatencyMsNotIn) > 0 {
		predicates = append(predicates, channelperformance.AvgLatencyMsNotIn(i.AvgLatencyMsNotIn...))
	}
	if i.AvgLatencyMsGT != nil {
		predicates = append(predicates, channelperformance.AvgLatencyMsGT(*i.AvgLatencyMsGT))
	}
	if i.AvgLatencyMsGTE != nil {
		predicates = append(predicates, channelperformance.AvgLatencyMsGTE(*i.AvgLatencyMsGTE))
	}
	if i.AvgLatencyMsLT != nil {
		predicates = append(predicates, channelperformance.AvgLatencyMsLT(*i.AvgLatencyMsLT))
	}
	if i.AvgLatencyMsLTE != nil {
		predicates = append(predicates, channelperformance.AvgLatencyMsLTE(*i.AvgLatencyMsLTE))
	}
	if i.AvgTokenPerSecond != nil {
		predicates = append(predicates, channelperformance.AvgTokenPerSecondEQ(*i.AvgTokenPerSecond))
	}
	if i.AvgTokenPerSecondNEQ != nil {
		predicates = append(predicates, channelperformance.AvgTokenPerSecondNEQ(*i.AvgTokenPerSecondNEQ))
	}
	if len(i.AvgTokenPerSecondIn) > 0 {
		predicates = append(predicates, channelperformance.AvgTokenPerSecondIn(i.AvgTokenPerSecondIn...))
	}
	if len(i.AvgTokenPerSecondNotIn) > 0 {
		predicates = append(predicates, channelperformance.AvgTokenPerSecondNotIn(i.AvgTokenPerSecondNotIn...))
	}
	if i.AvgTokenPerSecondGT != nil {
		predicates = append(predicates, channelperformance.AvgTokenPerSecondGT(*i.AvgTokenPerSecondGT))
	}
	if i.AvgTokenPerSecondGTE != nil {
		predicates = append(predicates, channelperformance.AvgTokenPerSecondGTE(*i.AvgTokenPerSecondGTE))
	}
	if i.AvgTokenPerSecondLT != nil {
		predicates = append(predicates, channelperformance.AvgTokenPerSecondLT(*i.AvgTokenPerSecondLT))
	}
	if i.AvgTokenPerSecondLTE != nil {
		predicates = append(predicates, channelperformance.AvgTokenPerSecondLTE(*i.AvgTokenPerSecondLTE))
	}
	if i.AvgStreamFirstTokenLatencyMs != nil {
		predicates = append(predicates, channelperformance.AvgStreamFirstTokenLatencyMsEQ(*i.AvgStreamFirstTokenLatencyMs))
	}
	if i.AvgStreamFirstTokenLatencyMsNEQ != nil {
		predicates = append(predicates, channelperformance.AvgStreamFirstTokenLatencyMsNEQ(*i.AvgStreamFirstTokenLatencyMsNEQ))
	}
	if len(i.AvgStreamFirstTokenLatencyMsIn) > 0 {
		predicates = append(predicates, channelperformance.AvgStreamFirstTokenLatencyMsIn(i.AvgStreamFirstTokenLatencyMsIn...))
	}
	if len(i.AvgStreamFirstTokenLatencyMsNotIn) > 0 {
		predicates = append(predicates, channelperformance.AvgStreamFirstTokenLatencyMsNotIn(i.AvgStreamFirstTokenLatencyMsNotIn...))
	}
	if i.AvgStreamFirstTokenLatencyMsGT != nil {
		predicates = append(predicates, channelperformance.AvgStreamFirstTokenLatencyMsGT(*i.AvgStreamFirstTokenLatencyMsGT))
	}
	if i.AvgStreamFirstTokenLatencyMsGTE != nil {
		predicates = append(predicates, channelperformance.AvgStreamFirstTokenLatencyMsGTE(*i.AvgStreamFirstTokenLatencyMsGTE))
	}
	if i.AvgStreamFirstTokenLatencyMsLT != nil {
		predicates = append(predicates, channelperformance.AvgStreamFirstTokenLatencyMsLT(*i.AvgStreamFirstTokenLatencyMsLT))
	}
	if i.AvgStreamFirstTokenLatencyMsLTE != nil {
		predicates = append(predicates, channelperformance.AvgStreamFirstTokenLatencyMsLTE(*i.AvgStreamFirstTokenLatencyMsLTE))
	}
	if i.AvgStreamTokenPerSecond != nil {
		predicates = append(predicates, channelperformance.AvgStreamTokenPerSecondEQ(*i.AvgStreamTokenPerSecond))
	}
	if i.AvgStreamTokenPerSecondNEQ != nil {
		predicates = append(predicates, channelperformance.AvgStreamTokenPerSecondNEQ(*i.AvgStreamTokenPerSecondNEQ))
	}
	if len(i.AvgStreamTokenPerSecondIn) > 0 {
		predicates = append(predicates, channelperformance.AvgStreamTokenPerSecondIn(i.AvgStreamTokenPerSecondIn...))
	}
	if len(i.AvgStreamTokenPerSecondNotIn) > 0 {
		predicates = append(predicates, channelperformance.AvgStreamTokenPerSecondNotIn(i.AvgStreamTokenPerSecondNotIn...))
	}
	if i.AvgStreamTokenPerSecondGT != nil {
		predicates = append(predicates, channelperformance.AvgStreamTokenPerSecondGT(*i.AvgStreamTokenPerSecondGT))
	}
	if i.AvgStreamTokenPerSecondGTE != nil {
		predicates = append(predicates, channelperformance.AvgStreamTokenPerSecondGTE(*i.AvgStreamTokenPerSecondGTE))
	}
	if i.AvgStreamTokenPerSecondLT != nil {
		predicates = append(predicates, channelperformance.AvgStreamTokenPerSecondLT(*i.AvgStreamTokenPerSecondLT))
	}
	if i.AvgStreamTokenPerSecondLTE != nil {
		predicates = append(predicates, channelperformance.AvgStreamTokenPerSecondLTE(*i.AvgStreamTokenPerSecondLTE))
	}
	if i.LastSuccessAt != nil {
		predicates = append(predicates, channelperformance.LastSuccessAtEQ(*i.LastSuccessAt))
	}
	if i.LastSuccessAtNEQ != nil {
		predicates = append(predicates, channelperformance.LastSuccessAtNEQ(*i.LastSuccessAtNEQ))
	}
	if len(i.LastSuccessAtIn) > 0 {
		predicates = append(predicates, channelperformance.LastSuccessAtIn(i.LastSuccessAtIn...))
	}
	if len(i.LastSuccessAtNotIn) > 0 {
		predicates = append(predicates, channelperformance.LastSuccessAtNotIn(i.LastSuccessAtNotIn...))
	}
	if i.LastSuccessAtGT != nil {
		predicates = append(predicates, channelperformance.LastSuccessAtGT(*i.LastSuccessAtGT))
	}
	if i.LastSuccessAtGTE != nil {
		predicates = append(predicates, channelperformance.LastSuccessAtGTE(*i.LastSuccessAtGTE))
	}
	if i.LastSuccessAtLT != nil {
		predicates = append(predicates, channelperformance.LastSuccessAtLT(*i.LastSuccessAtLT))
	}
	if i.LastSuccessAtLTE != nil {
		predicates = append(predicates, channelperformance.LastSuccessAtLTE(*i.LastSuccessAtLTE))
	}
	if i.LastSuccessAtIsNil {
		predicates = append(predicates, channelperformance.LastSuccessAtIsNil())
	}
	if i.LastSuccessAtNotNil {
		predicates = append(predicates, channelperformance.LastSuccessAtNotNil())
	}
	if i.LastFailureAt != nil {
		predicates = append(predicates, channelperformance.LastFailureAtEQ(*i.LastFailureAt))
	}
	if i.LastFailureAtNEQ != nil {
		predicates = append(predicates, channelperformance.LastFailureAtNEQ(*i.LastFailureAtNEQ))
	}
	if len(i.LastFailureAtIn) > 0 {
		predicates = append(predicates, channelperformance.LastFailureAtIn(i.LastFailureAtIn...))
	}
	if len(i.LastFailureAtNotIn) > 0 {
		predicates = append(predicates, channelperformance.LastFailureAtNotIn(i.LastFailureAtNotIn...))
	}
	if i.LastFailureAtGT != nil {
		predicates = append(predicates, channelperformance.LastFailureAtGT(*i.LastFailureAtGT))
	}
	if i.LastFailureAtGTE != nil {
		predicates = append(predicates, channelperformance.LastFailureAtGTE(*i.LastFailureAtGTE))
	}
	if i.LastFailureAtLT != nil {
		predicates = append(predicates, channelperformance.LastFailureAtLT(*i.LastFailureAtLT))
	}
	if i.LastFailureAtLTE != nil {
		predicates = append(predicates, channelperformance.LastFailureAtLTE(*i.LastFailureAtLTE))
	}
	if i.LastFailureAtIsNil {
		predicates = append(predicates, channelperformance.LastFailureAtIsNil())
	}
	if i.LastFailureAtNotNil {
		predicates = append(predicates, channelperformance.LastFailureAtNotNil())
	}
	if i.RequestCount != nil {
		predicates = append(predicates, channelperformance.RequestCountEQ(*i.RequestCount))
	}
	if i.RequestCountNEQ != nil {
		predicates = append(predicates, channelperformance.RequestCountNEQ(*i.RequestCountNEQ))
	}
	if len(i.RequestCountIn) > 0 {
		predicates = append(predicates, channelperformance.RequestCountIn(i.RequestCountIn...))
	}
	if len(i.RequestCountNotIn) > 0 {
		predicates = append(predicates, channelperformance.RequestCountNotIn(i.RequestCountNotIn...))
	}
	if i.RequestCountGT != nil {
		predicates = append(predicates, channelperformance.RequestCountGT(*i.RequestCountGT))
	}
	if i.RequestCountGTE != nil {
		predicates = append(predicates, channelperformance.RequestCountGTE(*i.RequestCountGTE))
	}
	if i.RequestCountLT != nil {
		predicates = append(predicates, channelperformance.RequestCountLT(*i.RequestCountLT))
	}
	if i.RequestCountLTE != nil {
		predicates = append(predicates, channelperformance.RequestCountLTE(*i.RequestCountLTE))
	}
	if i.SuccessCount != nil {
		predicates = append(predicates, channelperformance.SuccessCountEQ(*i.SuccessCount))
	}
	if i.SuccessCountNEQ != nil {
		predicates = append(predicates, channelperformance.SuccessCountNEQ(*i.SuccessCountNEQ))
	}
	if len(i.SuccessCountIn) > 0 {
		predicates = append(predicates, channelperformance.SuccessCountIn(i.SuccessCountIn...))
	}
	if len(i.SuccessCountNotIn) > 0 {
		predicates = append(predicates, channelperformance.SuccessCountNotIn(i.SuccessCountNotIn...))
	}
	if i.SuccessCountGT != nil {
		predicates = append(predicates, channelperformance.SuccessCountGT(*i.SuccessCountGT))
	}
	if i.SuccessCountGTE != nil {
		predicates = append(predicates, channelperformance.SuccessCountGTE(*i.SuccessCountGTE))
	}
	if i.SuccessCountLT != nil {
		predicates = append(predicates, channelperformance.SuccessCountLT(*i.SuccessCountLT))
	}
	if i.SuccessCountLTE != nil {
		predicates = append(predicates, channelperformance.SuccessCountLTE(*i.SuccessCountLTE))
	}
	if i.FailureCount != nil {
		predicates = append(predicates, channelperformance.FailureCountEQ(*i.FailureCount))
	}
	if i.FailureCountNEQ != nil {
		predicates = append(predicates, channelperformance.FailureCountNEQ(*i.FailureCountNEQ))
	}
	if len(i.FailureCountIn) > 0 {
		predicates = append(predicates, channelperformance.FailureCountIn(i.FailureCountIn...))
	}
	if len(i.FailureCountNotIn) > 0 {
		predicates = append(predicates, channelperformance.FailureCountNotIn(i.FailureCountNotIn...))
	}
	if i.FailureCountGT != nil {
		predicates = append(predicates, channelperformance.FailureCountGT(*i.FailureCountGT))
	}
	if i.FailureCountGTE != nil {
		predicates = append(predicates, channelperformance.FailureCountGTE(*i.FailureCountGTE))
	}
	if i.FailureCountLT != nil {
		predicates = append(predicates, channelperformance.FailureCountLT(*i.FailureCountLT))
	}
	if i.FailureCountLTE != nil {
		predicates = append(predicates, channelperformance.FailureCountLTE(*i.FailureCountLTE))
	}
	if i.TotalTokenCount != nil {
		predicates = append(predicates, channelperformance.TotalTokenCountEQ(*i.TotalTokenCount))
	}
	if i.TotalTokenCountNEQ != nil {
		predicates = append(predicates, channelperformance.TotalTokenCountNEQ(*i.TotalTokenCountNEQ))
	}
	if len(i.TotalTokenCountIn) > 0 {
		predicates = append(predicates, channelperformance.TotalTokenCountIn(i.TotalTokenCountIn...))
	}
	if len(i.TotalTokenCountNotIn) > 0 {
		predicates = append(predicates, channelperformance.TotalTokenCountNotIn(i.TotalTokenCountNotIn...))
	}
	if i.TotalTokenCountGT != nil {
		predicates = append(predicates, channelperformance.TotalTokenCountGT(*i.TotalTokenCountGT))
	}
	if i.TotalTokenCountGTE != nil {
		predicates = append(predicates, channelperformance.TotalTokenCountGTE(*i.TotalTokenCountGTE))
	}
	if i.TotalTokenCountLT != nil {
		predicates = append(predicates, channelperformance.TotalTokenCountLT(*i.TotalTokenCountLT))
	}
	if i.TotalTokenCountLTE != nil {
		predicates = append(predicates, channelperformance.TotalTokenCountLTE(*i.TotalTokenCountLTE))
	}
	if i.TotalRequestLatencyMs != nil {
		predicates = append(predicates, channelperformance.TotalRequestLatencyMsEQ(*i.TotalRequestLatencyMs))
	}
	if i.TotalRequestLatencyMsNEQ != nil {
		predicates = append(predicates, channelperformance.TotalRequestLatencyMsNEQ(*i.TotalRequestLatencyMsNEQ))
	}
	if len(i.TotalRequestLatencyMsIn) > 0 {
		predicates = append(predicates, channelperformance.TotalRequestLatencyMsIn(i.TotalRequestLatencyMsIn...))
	}
	if len(i.TotalRequestLatencyMsNotIn) > 0 {
		predicates = append(predicates, channelperformance.TotalRequestLatencyMsNotIn(i.TotalRequestLatencyMsNotIn...))
	}
	if i.TotalRequestLatencyMsGT != nil {
		predicates = append(predicates, channelperformance.TotalRequestLatencyMsGT(*i.TotalRequestLatencyMsGT))
	}
	if i.TotalRequestLatencyMsGTE != nil {
		predicates = append(predicates, channelperformance.TotalRequestLatencyMsGTE(*i.TotalRequestLatencyMsGTE))
	}
	if i.TotalRequestLatencyMsLT != nil {
		predicates = append(predicates, channelperformance.TotalRequestLatencyMsLT(*i.TotalRequestLatencyMsLT))
	}
	if i.TotalRequestLatencyMsLTE != nil {
		predicates = append(predicates, channelperformance.TotalRequestLatencyMsLTE(*i.TotalRequestLatencyMsLTE))
	}
	if i.StreamSuccessCount != nil {
		predicates = append(predicates, channelperformance.StreamSuccessCountEQ(*i.StreamSuccessCount))
	}
	if i.StreamSuccessCountNEQ != nil {
		predicates = append(predicates, channelperformance.StreamSuccessCountNEQ(*i.StreamSuccessCountNEQ))
	}
	if len(i.StreamSuccessCountIn) > 0 {
		predicates = append(predicates, channelperformance.StreamSuccessCountIn(i.StreamSuccessCountIn...))
	}
	if len(i.StreamSuccessCountNotIn) > 0 {
		predicates = append(predicates, channelperformance.StreamSuccessCountNotIn(i.StreamSuccessCountNotIn...))
	}
	if i.StreamSuccessCountGT != nil {
		predicates = append(predicates, channelperformance.StreamSuccessCountGT(*i.StreamSuccessCountGT))
	}
	if i.StreamSuccessCountGTE != nil {
		predicates = append(predicates, channelperformance.StreamSuccessCountGTE(*i.StreamSuccessCountGTE))
	}
	if i.StreamSuccessCountLT != nil {
		predicates = append(predicates, channelperformance.StreamSuccessCountLT(*i.StreamSuccessCountLT))
	}
	if i.StreamSuccessCountLTE != nil {
		predicates = append(predicates, channelperformance.StreamSuccessCountLTE(*i.StreamSuccessCountLTE))
	}
	if i.StreamTotalRequestCount != nil {
		predicates = append(predicates, channelperformance.StreamTotalRequestCountEQ(*i.StreamTotalRequestCount))
	}
	if i.StreamTotalRequestCountNEQ != nil {
		predicates = append(predicates, channelperformance.StreamTotalRequestCountNEQ(*i.StreamTotalRequestCountNEQ))
	}
	if len(i.StreamTotalRequestCountIn) > 0 {
		predicates = append(predicates, channelperformance.StreamTotalRequestCountIn(i.StreamTotalRequestCountIn...))
	}
	if len(i.StreamTotalRequestCountNotIn) > 0 {
		predicates = append(predicates, channelperformance.StreamTotalRequestCountNotIn(i.StreamTotalRequestCountNotIn...))
	}
	if i.StreamTotalRequestCountGT != nil {
		predicates = append(predicates, channelperformance.StreamTotalRequestCountGT(*i.StreamTotalRequestCountGT))
	}
	if i.StreamTotalRequestCountGTE != nil {
		predicates = append(predicates, channelperformance.StreamTotalRequestCountGTE(*i.StreamTotalRequestCountGTE))
	}
	if i.StreamTotalRequestCountLT != nil {
		predicates = append(predicates, channelperformance.StreamTotalRequestCountLT(*i.StreamTotalRequestCountLT))
	}
	if i.StreamTotalRequestCountLTE != nil {
		predicates = append(predicates, channelperformance.StreamTotalRequestCountLTE(*i.StreamTotalRequestCountLTE))
	}
	if i.StreamTotalTokenCount != nil {
		predicates = append(predicates, channelperformance.StreamTotalTokenCountEQ(*i.StreamTotalTokenCount))
	}
	if i.StreamTotalTokenCountNEQ != nil {
		predicates = append(predicates, channelperformance.StreamTotalTokenCountNEQ(*i.StreamTotalTokenCountNEQ))
	}
	if len(i.StreamTotalTokenCountIn) > 0 {
		predicates = append(predicates, channelperformance.StreamTotalTokenCountIn(i.StreamTotalTokenCountIn...))
	}
	if len(i.StreamTotalTokenCountNotIn) > 0 {
		predicates = append(predicates, channelperformance.StreamTotalTokenCountNotIn(i.StreamTotalTokenCountNotIn...))
	}
	if i.StreamTotalTokenCountGT != nil {
		predicates = append(predicates, channelperformance.StreamTotalTokenCountGT(*i.StreamTotalTokenCountGT))
	}
	if i.StreamTotalTokenCountGTE != nil {
		predicates = append(predicates, channelperformance.StreamTotalTokenCountGTE(*i.StreamTotalTokenCountGTE))
	}
	if i.StreamTotalTokenCountLT != nil {
		predicates = append(predicates, channelperformance.StreamTotalTokenCountLT(*i.StreamTotalTokenCountLT))
	}
	if i.StreamTotalTokenCountLTE != nil {
		predicates = append(predicates, channelperformance.StreamTotalTokenCountLTE(*i.StreamTotalTokenCountLTE))
	}
	if i.StreamTotalRequestLatencyMs != nil {
		predicates = append(predicates, channelperformance.StreamTotalRequestLatencyMsEQ(*i.StreamTotalRequestLatencyMs))
	}
	if i.StreamTotalRequestLatencyMsNEQ != nil {
		predicates = append(predicates, channelperformance.StreamTotalRequestLatencyMsNEQ(*i.StreamTotalRequestLatencyMsNEQ))
	}
	if len(i.StreamTotalRequestLatencyMsIn) > 0 {
		predicates = append(predicates, channelperformance.StreamTotalRequestLatencyMsIn(i.StreamTotalRequestLatencyMsIn...))
	}
	if len(i.StreamTotalRequestLatencyMsNotIn) > 0 {
		predicates = append(predicates, channelperformance.StreamTotalRequestLatencyMsNotIn(i.StreamTotalRequestLatencyMsNotIn...))
	}
	if i.StreamTotalRequestLatencyMsGT != nil {
		predicates = append(predicates, channelperformance.StreamTotalRequestLatencyMsGT(*i.StreamTotalRequestLatencyMsGT))
	}
	if i.StreamTotalRequestLatencyMsGTE != nil {
		predicates = append(predicates, channelperformance.StreamTotalRequestLatencyMsGTE(*i.StreamTotalRequestLatencyMsGTE))
	}
	if i.StreamTotalRequestLatencyMsLT != nil {
		predicates = append(predicates, channelperformance.StreamTotalRequestLatencyMsLT(*i.StreamTotalRequestLatencyMsLT))
	}
	if i.StreamTotalRequestLatencyMsLTE != nil {
		predicates = append(predicates, channelperformance.StreamTotalRequestLatencyMsLTE(*i.StreamTotalRequestLatencyMsLTE))
	}
	if i.StreamTotalFirstTokenLatencyMs != nil {
		predicates = append(predicates, channelperformance.StreamTotalFirstTokenLatencyMsEQ(*i.StreamTotalFirstTokenLatencyMs))
	}
	if i.StreamTotalFirstTokenLatencyMsNEQ != nil {
		predicates = append(predicates, channelperformance.StreamTotalFirstTokenLatencyMsNEQ(*i.StreamTotalFirstTokenLatencyMsNEQ))
	}
	if len(i.StreamTotalFirstTokenLatencyMsIn) > 0 {
		predicates = append(predicates, channelperformance.StreamTotalFirstTokenLatencyMsIn(i.StreamTotalFirstTokenLatencyMsIn...))
	}
	if len(i.StreamTotalFirstTokenLatencyMsNotIn) > 0 {
		predicates = append(predicates, channelperformance.StreamTotalFirstTokenLatencyMsNotIn(i.StreamTotalFirstTokenLatencyMsNotIn...))
	}
	if i.StreamTotalFirstTokenLatencyMsGT != nil {
		predicates = append(predicates, channelperformance.StreamTotalFirstTokenLatencyMsGT(*i.StreamTotalFirstTokenLatencyMsGT))
	}
	if i.StreamTotalFirstTokenLatencyMsGTE != nil {
		predicates = append(predicates, channelperformance.StreamTotalFirstTokenLatencyMsGTE(*i.StreamTotalFirstTokenLatencyMsGTE))
	}
	if i.StreamTotalFirstTokenLatencyMsLT != nil {
		predicates = append(predicates, channelperformance.StreamTotalFirstTokenLatencyMsLT(*i.StreamTotalFirstTokenLatencyMsLT))
	}
	if i.StreamTotalFirstTokenLatencyMsLTE != nil {
		predicates = append(predicates, channelperformance.StreamTotalFirstTokenLatencyMsLTE(*i.StreamTotalFirstTokenLatencyMsLTE))
	}
	if i.ConsecutiveFailures != nil {
		predicates = append(predicates, channelperformance.ConsecutiveFailuresEQ(*i.ConsecutiveFailures))
	}
	if i.ConsecutiveFailuresNEQ != nil {
		predicates = append(predicates, channelperformance.ConsecutiveFailuresNEQ(*i.ConsecutiveFailuresNEQ))
	}
	if len(i.ConsecutiveFailuresIn) > 0 {
		predicates = append(predicates, channelperformance.ConsecutiveFailuresIn(i.ConsecutiveFailuresIn...))
	}
	if len(i.ConsecutiveFailuresNotIn) > 0 {
		predicates = append(predicates, channelperformance.ConsecutiveFailuresNotIn(i.ConsecutiveFailuresNotIn...))
	}
	if i.ConsecutiveFailuresGT != nil {
		predicates = append(predicates, channelperformance.ConsecutiveFailuresGT(*i.ConsecutiveFailuresGT))
	}
	if i.ConsecutiveFailuresGTE != nil {
		predicates = append(predicates, channelperformance.ConsecutiveFailuresGTE(*i.ConsecutiveFailuresGTE))
	}
	if i.ConsecutiveFailuresLT != nil {
		predicates = append(predicates, channelperformance.ConsecutiveFailuresLT(*i.ConsecutiveFailuresLT))
	}
	if i.ConsecutiveFailuresLTE != nil {
		predicates = append(predicates, channelperformance.ConsecutiveFailuresLTE(*i.ConsecutiveFailuresLTE))
	}

	if i.HasChannel != nil {
		p := channelperformance.HasChannel()
		if !*i.HasChannel {
			p = channelperformance.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasChannelWith) > 0 {
		with := make([]predicate.Channel, 0, len(i.HasChannelWith))
		for _, w := range i.HasChannelWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasChannelWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, channelperformance.HasChannelWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyChannelPerformanceWhereInput
	case 1:
		return predicates[0], nil
	default:
		return channelperformance.And(predicates...), nil
	}
}

// ChannelProbeWhereInput represents a where input for filtering ChannelProbe queries.
type ChannelProbeWhereInput struct {
	Predicates []predicate.ChannelProbe  `json:"-"`
	Not        *ChannelProbeWhereInput   `json:"not,omitempty"`
	Or         []*ChannelProbeWhereInput `json:"or,omitempty"`
	And        []*ChannelProbeWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "channel_id" field predicates.
	ChannelID      *int  `json:"channelID,omitempty"`
	ChannelIDNEQ   *int  `json:"channelIDNEQ,omitempty"`
	ChannelIDIn    []int `json:"channelIDIn,omitempty"`
	ChannelIDNotIn []int `json:"channelIDNotIn,omitempty"`

	// "total_request_count" field predicates.
	TotalRequestCount      *int  `json:"totalRequestCount,omitempty"`
	TotalRequestCountNEQ   *int  `json:"totalRequestCountNEQ,omitempty"`
	TotalRequestCountIn    []int `json:"totalRequestCountIn,omitempty"`
	TotalRequestCountNotIn []int `json:"totalRequestCountNotIn,omitempty"`
	TotalRequestCountGT    *int  `json:"totalRequestCountGT,omitempty"`
	TotalRequestCountGTE   *int  `json:"totalRequestCountGTE,omitempty"`
	TotalRequestCountLT    *int  `json:"totalRequestCountLT,omitempty"`
	TotalRequestCountLTE   *int  `json:"totalRequestCountLTE,omitempty"`

	// "success_request_count" field predicates.
	SuccessRequestCount      *int  `json:"successRequestCount,omitempty"`
	SuccessRequestCountNEQ   *int  `json:"successRequestCountNEQ,omitempty"`
	SuccessRequestCountIn    []int `json:"successRequestCountIn,omitempty"`
	SuccessRequestCountNotIn []int `json:"successRequestCountNotIn,omitempty"`
	SuccessRequestCountGT    *int  `json:"successRequestCountGT,omitempty"`
	SuccessRequestCountGTE   *int  `json:"successRequestCountGTE,omitempty"`
	SuccessRequestCountLT    *int  `json:"successRequestCountLT,omitempty"`
	SuccessRequestCountLTE   *int  `json:"successRequestCountLTE,omitempty"`

	// "timestamp" field predicates.
	Timestamp      *int64  `json:"timestamp,omitempty"`
	TimestampNEQ   *int64  `json:"timestampNEQ,omitempty"`
	TimestampIn    []int64 `json:"timestampIn,omitempty"`
	TimestampNotIn []int64 `json:"timestampNotIn,omitempty"`
	TimestampGT    *int64  `json:"timestampGT,omitempty"`
	TimestampGTE   *int64  `json:"timestampGTE,omitempty"`
	TimestampLT    *int64  `json:"timestampLT,omitempty"`
	TimestampLTE   *int64  `json:"timestampLTE,omitempty"`

	// "channel" edge predicates.
	HasChannel     *bool                `json:"hasChannel,omitempty"`
	HasChannelWith []*ChannelWhereInput `json:"hasChannelWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ChannelProbeWhereInput) AddPredicates(predicates ...predicate.ChannelProbe) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ChannelProbeWhereInput filter on the ChannelProbeQuery builder.
func (i *ChannelProbeWhereInput) Filter(q *ChannelProbeQuery) (*ChannelProbeQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyChannelProbeWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyChannelProbeWhereInput is returned in case the ChannelProbeWhereInput is empty.
var ErrEmptyChannelProbeWhereInput = errors.New("ent: empty predicate ChannelProbeWhereInput")

// P returns a predicate for filtering channelprobes.
// An error is returned if the input is empty or invalid.
func (i *ChannelProbeWhereInput) P() (predicate.ChannelProbe, error) {
	var predicates []predicate.ChannelProbe
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, channelprobe.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ChannelProbe, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, channelprobe.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ChannelProbe, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, channelprobe.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, channelprobe.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, channelprobe.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, channelprobe.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, channelprobe.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, channelprobe.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, channelprobe.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, channelprobe.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, channelprobe.IDLTE(*i.IDLTE))
	}
	if i.ChannelID != nil {
		predicates = append(predicates, channelprobe.ChannelIDEQ(*i.ChannelID))
	}
	if i.ChannelIDNEQ != nil {
		predicates = append(predicates, channelprobe.ChannelIDNEQ(*i.ChannelIDNEQ))
	}
	if len(i.ChannelIDIn) > 0 {
		predicates = append(predicates, channelprobe.ChannelIDIn(i.ChannelIDIn...))
	}
	if len(i.ChannelIDNotIn) > 0 {
		predicates = append(predicates, channelprobe.ChannelIDNotIn(i.ChannelIDNotIn...))
	}
	if i.TotalRequestCount != nil {
		predicates = append(predicates, channelprobe.TotalRequestCountEQ(*i.TotalRequestCount))
	}
	if i.TotalRequestCountNEQ != nil {
		predicates = append(predicates, channelprobe.TotalRequestCountNEQ(*i.TotalRequestCountNEQ))
	}
	if len(i.TotalRequestCountIn) > 0 {
		predicates = append(predicates, channelprobe.TotalRequestCountIn(i.TotalRequestCountIn...))
	}
	if len(i.TotalRequestCountNotIn) > 0 {
		predicates = append(predicates, channelprobe.TotalRequestCountNotIn(i.TotalRequestCountNotIn...))
	}
	if i.TotalRequestCountGT != nil {
		predicates = append(predicates, channelprobe.TotalRequestCountGT(*i.TotalRequestCountGT))
	}
	if i.TotalRequestCountGTE != nil {
		predicates = append(predicates, channelprobe.TotalRequestCountGTE(*i.TotalRequestCountGTE))
	}
	if i.TotalRequestCountLT != nil {
		predicates = append(predicates, channelprobe.TotalRequestCountLT(*i.TotalRequestCountLT))
	}
	if i.TotalRequestCountLTE != nil {
		predicates = append(predicates, channelprobe.TotalRequestCountLTE(*i.TotalRequestCountLTE))
	}
	if i.SuccessRequestCount != nil {
		predicates = append(predicates, channelprobe.SuccessRequestCountEQ(*i.SuccessRequestCount))
	}
	if i.SuccessRequestCountNEQ != nil {
		predicates = append(predicates, channelprobe.SuccessRequestCountNEQ(*i.SuccessRequestCountNEQ))
	}
	if len(i.SuccessRequestCountIn) > 0 {
		predicates = append(predicates, channelprobe.SuccessRequestCountIn(i.SuccessRequestCountIn...))
	}
	if len(i.SuccessRequestCountNotIn) > 0 {
		predicates = append(predicates, channelprobe.SuccessRequestCountNotIn(i.SuccessRequestCountNotIn...))
	}
	if i.SuccessRequestCountGT != nil {
		predicates = append(predicates, channelprobe.SuccessRequestCountGT(*i.SuccessRequestCountGT))
	}
	if i.SuccessRequestCountGTE != nil {
		predicates = append(predicates, channelprobe.SuccessRequestCountGTE(*i.SuccessRequestCountGTE))
	}
	if i.SuccessRequestCountLT != nil {
		predicates = append(predicates, channelprobe.SuccessRequestCountLT(*i.SuccessRequestCountLT))
	}
	if i.SuccessRequestCountLTE != nil {
		predicates = append(predicates, channelprobe.SuccessRequestCountLTE(*i.SuccessRequestCountLTE))
	}
	if i.Timestamp != nil {
		predicates = append(predicates, channelprobe.TimestampEQ(*i.Timestamp))
	}
	if i.TimestampNEQ != nil {
		predicates = append(predicates, channelprobe.TimestampNEQ(*i.TimestampNEQ))
	}
	if len(i.TimestampIn) > 0 {
		predicates = append(predicates, channelprobe.TimestampIn(i.TimestampIn...))
	}
	if len(i.TimestampNotIn) > 0 {
		predicates = append(predicates, channelprobe.TimestampNotIn(i.TimestampNotIn...))
	}
	if i.TimestampGT != nil {
		predicates = append(predicates, channelprobe.TimestampGT(*i.TimestampGT))
	}
	if i.TimestampGTE != nil {
		predicates = append(predicates, channelprobe.TimestampGTE(*i.TimestampGTE))
	}
	if i.TimestampLT != nil {
		predicates = append(predicates, channelprobe.TimestampLT(*i.TimestampLT))
	}
	if i.TimestampLTE != nil {
		predicates = append(predicates, channelprobe.TimestampLTE(*i.TimestampLTE))
	}

	if i.HasChannel != nil {
		p := channelprobe.HasChannel()
		if !*i.HasChannel {
			p = channelprobe.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasChannelWith) > 0 {
		with := make([]predicate.Channel, 0, len(i.HasChannelWith))
		for _, w := range i.HasChannelWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasChannelWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, channelprobe.HasChannelWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyChannelProbeWhereInput
	case 1:
		return predicates[0], nil
	default:
		return channelprobe.And(predicates...), nil
	}
}

// DataStorageWhereInput represents a where input for filtering DataStorage queries.
type DataStorageWhereInput struct {
	Predicates []predicate.DataStorage  `json:"-"`
	Not        *DataStorageWhereInput   `json:"not,omitempty"`
	Or         []*DataStorageWhereInput `json:"or,omitempty"`
	And        []*DataStorageWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt      *int  `json:"deletedAt,omitempty"`
	DeletedAtNEQ   *int  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn    []int `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn []int `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT    *int  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE   *int  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT    *int  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE   *int  `json:"deletedAtLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "primary" field predicates.
	Primary    *bool `json:"primary,omitempty"`
	PrimaryNEQ *bool `json:"primaryNEQ,omitempty"`

	// "type" field predicates.
	Type      *datastorage.Type  `json:"type,omitempty"`
	TypeNEQ   *datastorage.Type  `json:"typeNEQ,omitempty"`
	TypeIn    []datastorage.Type `json:"typeIn,omitempty"`
	TypeNotIn []datastorage.Type `json:"typeNotIn,omitempty"`

	// "status" field predicates.
	Status      *datastorage.Status  `json:"status,omitempty"`
	StatusNEQ   *datastorage.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []datastorage.Status `json:"statusIn,omitempty"`
	StatusNotIn []datastorage.Status `json:"statusNotIn,omitempty"`

	// "requests" edge predicates.
	HasRequests     *bool                `json:"hasRequests,omitempty"`
	HasRequestsWith []*RequestWhereInput `json:"hasRequestsWith,omitempty"`

	// "executions" edge predicates.
	HasExecutions     *bool                         `json:"hasExecutions,omitempty"`
	HasExecutionsWith []*RequestExecutionWhereInput `json:"hasExecutionsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *DataStorageWhereInput) AddPredicates(predicates ...predicate.DataStorage) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the DataStorageWhereInput filter on the DataStorageQuery builder.
func (i *DataStorageWhereInput) Filter(q *DataStorageQuery) (*DataStorageQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyDataStorageWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyDataStorageWhereInput is returned in case the DataStorageWhereInput is empty.
var ErrEmptyDataStorageWhereInput = errors.New("ent: empty predicate DataStorageWhereInput")

// P returns a predicate for filtering datastorages.
// An error is returned if the input is empty or invalid.
func (i *DataStorageWhereInput) P() (predicate.DataStorage, error) {
	var predicates []predicate.DataStorage
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, datastorage.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.DataStorage, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, datastorage.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.DataStorage, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, datastorage.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, datastorage.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, datastorage.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, datastorage.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, datastorage.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, datastorage.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, datastorage.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, datastorage.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, datastorage.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, datastorage.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, datastorage.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, datastorage.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, datastorage.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, datastorage.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, datastorage.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, datastorage.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, datastorage.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, datastorage.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, datastorage.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, datastorage.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, datastorage.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, datastorage.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, datastorage.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, datastorage.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, datastorage.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, datastorage.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, datastorage.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, datastorage.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, datastorage.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, datastorage.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, datastorage.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, datastorage.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, datastorage.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, datastorage.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, datastorage.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, datastorage.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, datastorage.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, datastorage.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, datastorage.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, datastorage.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, datastorage.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, datastorage.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, datastorage.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, datastorage.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, datastorage.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, datastorage.NameContainsFold(*i.NameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, datastorage.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, datastorage.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, datastorage.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, datastorage.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, datastorage.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, datastorage.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, datastorage.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, datastorage.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, datastorage.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, datastorage.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, datastorage.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, datastorage.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, datastorage.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.Primary != nil {
		predicates = append(predicates, datastorage.PrimaryEQ(*i.Primary))
	}
	if i.PrimaryNEQ != nil {
		predicates = append(predicates, datastorage.PrimaryNEQ(*i.PrimaryNEQ))
	}
	if i.Type != nil {
		predicates = append(predicates, datastorage.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, datastorage.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, datastorage.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, datastorage.TypeNotIn(i.TypeNotIn...))
	}
	if i.Status != nil {
		predicates = append(predicates, datastorage.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, datastorage.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, datastorage.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, datastorage.StatusNotIn(i.StatusNotIn...))
	}

	if i.HasRequests != nil {
		p := datastorage.HasRequests()
		if !*i.HasRequests {
			p = datastorage.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRequestsWith) > 0 {
		with := make([]predicate.Request, 0, len(i.HasRequestsWith))
		for _, w := range i.HasRequestsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRequestsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, datastorage.HasRequestsWith(with...))
	}
	if i.HasExecutions != nil {
		p := datastorage.HasExecutions()
		if !*i.HasExecutions {
			p = datastorage.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasExecutionsWith) > 0 {
		with := make([]predicate.RequestExecution, 0, len(i.HasExecutionsWith))
		for _, w := range i.HasExecutionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasExecutionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, datastorage.HasExecutionsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyDataStorageWhereInput
	case 1:
		return predicates[0], nil
	default:
		return datastorage.And(predicates...), nil
	}
}

// ModelWhereInput represents a where input for filtering Model queries.
type ModelWhereInput struct {
	Predicates []predicate.Model  `json:"-"`
	Not        *ModelWhereInput   `json:"not,omitempty"`
	Or         []*ModelWhereInput `json:"or,omitempty"`
	And        []*ModelWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt      *int  `json:"deletedAt,omitempty"`
	DeletedAtNEQ   *int  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn    []int `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn []int `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT    *int  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE   *int  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT    *int  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE   *int  `json:"deletedAtLTE,omitempty"`

	// "developer" field predicates.
	Developer             *string  `json:"developer,omitempty"`
	DeveloperNEQ          *string  `json:"developerNEQ,omitempty"`
	DeveloperIn           []string `json:"developerIn,omitempty"`
	DeveloperNotIn        []string `json:"developerNotIn,omitempty"`
	DeveloperGT           *string  `json:"developerGT,omitempty"`
	DeveloperGTE          *string  `json:"developerGTE,omitempty"`
	DeveloperLT           *string  `json:"developerLT,omitempty"`
	DeveloperLTE          *string  `json:"developerLTE,omitempty"`
	DeveloperContains     *string  `json:"developerContains,omitempty"`
	DeveloperHasPrefix    *string  `json:"developerHasPrefix,omitempty"`
	DeveloperHasSuffix    *string  `json:"developerHasSuffix,omitempty"`
	DeveloperEqualFold    *string  `json:"developerEqualFold,omitempty"`
	DeveloperContainsFold *string  `json:"developerContainsFold,omitempty"`

	// "model_id" field predicates.
	ModelID             *string  `json:"modelID,omitempty"`
	ModelIDNEQ          *string  `json:"modelIDNEQ,omitempty"`
	ModelIDIn           []string `json:"modelIDIn,omitempty"`
	ModelIDNotIn        []string `json:"modelIDNotIn,omitempty"`
	ModelIDGT           *string  `json:"modelIDGT,omitempty"`
	ModelIDGTE          *string  `json:"modelIDGTE,omitempty"`
	ModelIDLT           *string  `json:"modelIDLT,omitempty"`
	ModelIDLTE          *string  `json:"modelIDLTE,omitempty"`
	ModelIDContains     *string  `json:"modelIDContains,omitempty"`
	ModelIDHasPrefix    *string  `json:"modelIDHasPrefix,omitempty"`
	ModelIDHasSuffix    *string  `json:"modelIDHasSuffix,omitempty"`
	ModelIDEqualFold    *string  `json:"modelIDEqualFold,omitempty"`
	ModelIDContainsFold *string  `json:"modelIDContainsFold,omitempty"`

	// "type" field predicates.
	Type      *model.Type  `json:"type,omitempty"`
	TypeNEQ   *model.Type  `json:"typeNEQ,omitempty"`
	TypeIn    []model.Type `json:"typeIn,omitempty"`
	TypeNotIn []model.Type `json:"typeNotIn,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "icon" field predicates.
	Icon             *string  `json:"icon,omitempty"`
	IconNEQ          *string  `json:"iconNEQ,omitempty"`
	IconIn           []string `json:"iconIn,omitempty"`
	IconNotIn        []string `json:"iconNotIn,omitempty"`
	IconGT           *string  `json:"iconGT,omitempty"`
	IconGTE          *string  `json:"iconGTE,omitempty"`
	IconLT           *string  `json:"iconLT,omitempty"`
	IconLTE          *string  `json:"iconLTE,omitempty"`
	IconContains     *string  `json:"iconContains,omitempty"`
	IconHasPrefix    *string  `json:"iconHasPrefix,omitempty"`
	IconHasSuffix    *string  `json:"iconHasSuffix,omitempty"`
	IconEqualFold    *string  `json:"iconEqualFold,omitempty"`
	IconContainsFold *string  `json:"iconContainsFold,omitempty"`

	// "group" field predicates.
	Group             *string  `json:"group,omitempty"`
	GroupNEQ          *string  `json:"groupNEQ,omitempty"`
	GroupIn           []string `json:"groupIn,omitempty"`
	GroupNotIn        []string `json:"groupNotIn,omitempty"`
	GroupGT           *string  `json:"groupGT,omitempty"`
	GroupGTE          *string  `json:"groupGTE,omitempty"`
	GroupLT           *string  `json:"groupLT,omitempty"`
	GroupLTE          *string  `json:"groupLTE,omitempty"`
	GroupContains     *string  `json:"groupContains,omitempty"`
	GroupHasPrefix    *string  `json:"groupHasPrefix,omitempty"`
	GroupHasSuffix    *string  `json:"groupHasSuffix,omitempty"`
	GroupEqualFold    *string  `json:"groupEqualFold,omitempty"`
	GroupContainsFold *string  `json:"groupContainsFold,omitempty"`

	// "status" field predicates.
	Status      *model.Status  `json:"status,omitempty"`
	StatusNEQ   *model.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []model.Status `json:"statusIn,omitempty"`
	StatusNotIn []model.Status `json:"statusNotIn,omitempty"`

	// "remark" field predicates.
	Remark             *string  `json:"remark,omitempty"`
	RemarkNEQ          *string  `json:"remarkNEQ,omitempty"`
	RemarkIn           []string `json:"remarkIn,omitempty"`
	RemarkNotIn        []string `json:"remarkNotIn,omitempty"`
	RemarkGT           *string  `json:"remarkGT,omitempty"`
	RemarkGTE          *string  `json:"remarkGTE,omitempty"`
	RemarkLT           *string  `json:"remarkLT,omitempty"`
	RemarkLTE          *string  `json:"remarkLTE,omitempty"`
	RemarkContains     *string  `json:"remarkContains,omitempty"`
	RemarkHasPrefix    *string  `json:"remarkHasPrefix,omitempty"`
	RemarkHasSuffix    *string  `json:"remarkHasSuffix,omitempty"`
	RemarkIsNil        bool     `json:"remarkIsNil,omitempty"`
	RemarkNotNil       bool     `json:"remarkNotNil,omitempty"`
	RemarkEqualFold    *string  `json:"remarkEqualFold,omitempty"`
	RemarkContainsFold *string  `json:"remarkContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ModelWhereInput) AddPredicates(predicates ...predicate.Model) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ModelWhereInput filter on the ModelQuery builder.
func (i *ModelWhereInput) Filter(q *ModelQuery) (*ModelQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyModelWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyModelWhereInput is returned in case the ModelWhereInput is empty.
var ErrEmptyModelWhereInput = errors.New("ent: empty predicate ModelWhereInput")

// P returns a predicate for filtering models.
// An error is returned if the input is empty or invalid.
func (i *ModelWhereInput) P() (predicate.Model, error) {
	var predicates []predicate.Model
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, model.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Model, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, model.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Model, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, model.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, model.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, model.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, model.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, model.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, model.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, model.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, model.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, model.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, model.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, model.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, model.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, model.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, model.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, model.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, model.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, model.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, model.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, model.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, model.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, model.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, model.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, model.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, model.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, model.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, model.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, model.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, model.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, model.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, model.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, model.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, model.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, model.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.Developer != nil {
		predicates = append(predicates, model.DeveloperEQ(*i.Developer))
	}
	if i.DeveloperNEQ != nil {
		predicates = append(predicates, model.DeveloperNEQ(*i.DeveloperNEQ))
	}
	if len(i.DeveloperIn) > 0 {
		predicates = append(predicates, model.DeveloperIn(i.DeveloperIn...))
	}
	if len(i.DeveloperNotIn) > 0 {
		predicates = append(predicates, model.DeveloperNotIn(i.DeveloperNotIn...))
	}
	if i.DeveloperGT != nil {
		predicates = append(predicates, model.DeveloperGT(*i.DeveloperGT))
	}
	if i.DeveloperGTE != nil {
		predicates = append(predicates, model.DeveloperGTE(*i.DeveloperGTE))
	}
	if i.DeveloperLT != nil {
		predicates = append(predicates, model.DeveloperLT(*i.DeveloperLT))
	}
	if i.DeveloperLTE != nil {
		predicates = append(predicates, model.DeveloperLTE(*i.DeveloperLTE))
	}
	if i.DeveloperContains != nil {
		predicates = append(predicates, model.DeveloperContains(*i.DeveloperContains))
	}
	if i.DeveloperHasPrefix != nil {
		predicates = append(predicates, model.DeveloperHasPrefix(*i.DeveloperHasPrefix))
	}
	if i.DeveloperHasSuffix != nil {
		predicates = append(predicates, model.DeveloperHasSuffix(*i.DeveloperHasSuffix))
	}
	if i.DeveloperEqualFold != nil {
		predicates = append(predicates, model.DeveloperEqualFold(*i.DeveloperEqualFold))
	}
	if i.DeveloperContainsFold != nil {
		predicates = append(predicates, model.DeveloperContainsFold(*i.DeveloperContainsFold))
	}
	if i.ModelID != nil {
		predicates = append(predicates, model.ModelIDEQ(*i.ModelID))
	}
	if i.ModelIDNEQ != nil {
		predicates = append(predicates, model.ModelIDNEQ(*i.ModelIDNEQ))
	}
	if len(i.ModelIDIn) > 0 {
		predicates = append(predicates, model.ModelIDIn(i.ModelIDIn...))
	}
	if len(i.ModelIDNotIn) > 0 {
		predicates = append(predicates, model.ModelIDNotIn(i.ModelIDNotIn...))
	}
	if i.ModelIDGT != nil {
		predicates = append(predicates, model.ModelIDGT(*i.ModelIDGT))
	}
	if i.ModelIDGTE != nil {
		predicates = append(predicates, model.ModelIDGTE(*i.ModelIDGTE))
	}
	if i.ModelIDLT != nil {
		predicates = append(predicates, model.ModelIDLT(*i.ModelIDLT))
	}
	if i.ModelIDLTE != nil {
		predicates = append(predicates, model.ModelIDLTE(*i.ModelIDLTE))
	}
	if i.ModelIDContains != nil {
		predicates = append(predicates, model.ModelIDContains(*i.ModelIDContains))
	}
	if i.ModelIDHasPrefix != nil {
		predicates = append(predicates, model.ModelIDHasPrefix(*i.ModelIDHasPrefix))
	}
	if i.ModelIDHasSuffix != nil {
		predicates = append(predicates, model.ModelIDHasSuffix(*i.ModelIDHasSuffix))
	}
	if i.ModelIDEqualFold != nil {
		predicates = append(predicates, model.ModelIDEqualFold(*i.ModelIDEqualFold))
	}
	if i.ModelIDContainsFold != nil {
		predicates = append(predicates, model.ModelIDContainsFold(*i.ModelIDContainsFold))
	}
	if i.Type != nil {
		predicates = append(predicates, model.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, model.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, model.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, model.TypeNotIn(i.TypeNotIn...))
	}
	if i.Name != nil {
		predicates = append(predicates, model.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, model.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, model.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, model.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, model.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, model.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, model.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, model.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, model.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, model.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, model.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, model.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, model.NameContainsFold(*i.NameContainsFold))
	}
	if i.Icon != nil {
		predicates = append(predicates, model.IconEQ(*i.Icon))
	}
	if i.IconNEQ != nil {
		predicates = append(predicates, model.IconNEQ(*i.IconNEQ))
	}
	if len(i.IconIn) > 0 {
		predicates = append(predicates, model.IconIn(i.IconIn...))
	}
	if len(i.IconNotIn) > 0 {
		predicates = append(predicates, model.IconNotIn(i.IconNotIn...))
	}
	if i.IconGT != nil {
		predicates = append(predicates, model.IconGT(*i.IconGT))
	}
	if i.IconGTE != nil {
		predicates = append(predicates, model.IconGTE(*i.IconGTE))
	}
	if i.IconLT != nil {
		predicates = append(predicates, model.IconLT(*i.IconLT))
	}
	if i.IconLTE != nil {
		predicates = append(predicates, model.IconLTE(*i.IconLTE))
	}
	if i.IconContains != nil {
		predicates = append(predicates, model.IconContains(*i.IconContains))
	}
	if i.IconHasPrefix != nil {
		predicates = append(predicates, model.IconHasPrefix(*i.IconHasPrefix))
	}
	if i.IconHasSuffix != nil {
		predicates = append(predicates, model.IconHasSuffix(*i.IconHasSuffix))
	}
	if i.IconEqualFold != nil {
		predicates = append(predicates, model.IconEqualFold(*i.IconEqualFold))
	}
	if i.IconContainsFold != nil {
		predicates = append(predicates, model.IconContainsFold(*i.IconContainsFold))
	}
	if i.Group != nil {
		predicates = append(predicates, model.GroupEQ(*i.Group))
	}
	if i.GroupNEQ != nil {
		predicates = append(predicates, model.GroupNEQ(*i.GroupNEQ))
	}
	if len(i.GroupIn) > 0 {
		predicates = append(predicates, model.GroupIn(i.GroupIn...))
	}
	if len(i.GroupNotIn) > 0 {
		predicates = append(predicates, model.GroupNotIn(i.GroupNotIn...))
	}
	if i.GroupGT != nil {
		predicates = append(predicates, model.GroupGT(*i.GroupGT))
	}
	if i.GroupGTE != nil {
		predicates = append(predicates, model.GroupGTE(*i.GroupGTE))
	}
	if i.GroupLT != nil {
		predicates = append(predicates, model.GroupLT(*i.GroupLT))
	}
	if i.GroupLTE != nil {
		predicates = append(predicates, model.GroupLTE(*i.GroupLTE))
	}
	if i.GroupContains != nil {
		predicates = append(predicates, model.GroupContains(*i.GroupContains))
	}
	if i.GroupHasPrefix != nil {
		predicates = append(predicates, model.GroupHasPrefix(*i.GroupHasPrefix))
	}
	if i.GroupHasSuffix != nil {
		predicates = append(predicates, model.GroupHasSuffix(*i.GroupHasSuffix))
	}
	if i.GroupEqualFold != nil {
		predicates = append(predicates, model.GroupEqualFold(*i.GroupEqualFold))
	}
	if i.GroupContainsFold != nil {
		predicates = append(predicates, model.GroupContainsFold(*i.GroupContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, model.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, model.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, model.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, model.StatusNotIn(i.StatusNotIn...))
	}
	if i.Remark != nil {
		predicates = append(predicates, model.RemarkEQ(*i.Remark))
	}
	if i.RemarkNEQ != nil {
		predicates = append(predicates, model.RemarkNEQ(*i.RemarkNEQ))
	}
	if len(i.RemarkIn) > 0 {
		predicates = append(predicates, model.RemarkIn(i.RemarkIn...))
	}
	if len(i.RemarkNotIn) > 0 {
		predicates = append(predicates, model.RemarkNotIn(i.RemarkNotIn...))
	}
	if i.RemarkGT != nil {
		predicates = append(predicates, model.RemarkGT(*i.RemarkGT))
	}
	if i.RemarkGTE != nil {
		predicates = append(predicates, model.RemarkGTE(*i.RemarkGTE))
	}
	if i.RemarkLT != nil {
		predicates = append(predicates, model.RemarkLT(*i.RemarkLT))
	}
	if i.RemarkLTE != nil {
		predicates = append(predicates, model.RemarkLTE(*i.RemarkLTE))
	}
	if i.RemarkContains != nil {
		predicates = append(predicates, model.RemarkContains(*i.RemarkContains))
	}
	if i.RemarkHasPrefix != nil {
		predicates = append(predicates, model.RemarkHasPrefix(*i.RemarkHasPrefix))
	}
	if i.RemarkHasSuffix != nil {
		predicates = append(predicates, model.RemarkHasSuffix(*i.RemarkHasSuffix))
	}
	if i.RemarkIsNil {
		predicates = append(predicates, model.RemarkIsNil())
	}
	if i.RemarkNotNil {
		predicates = append(predicates, model.RemarkNotNil())
	}
	if i.RemarkEqualFold != nil {
		predicates = append(predicates, model.RemarkEqualFold(*i.RemarkEqualFold))
	}
	if i.RemarkContainsFold != nil {
		predicates = append(predicates, model.RemarkContainsFold(*i.RemarkContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyModelWhereInput
	case 1:
		return predicates[0], nil
	default:
		return model.And(predicates...), nil
	}
}

// ProjectWhereInput represents a where input for filtering Project queries.
type ProjectWhereInput struct {
	Predicates []predicate.Project  `json:"-"`
	Not        *ProjectWhereInput   `json:"not,omitempty"`
	Or         []*ProjectWhereInput `json:"or,omitempty"`
	And        []*ProjectWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt      *int  `json:"deletedAt,omitempty"`
	DeletedAtNEQ   *int  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn    []int `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn []int `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT    *int  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE   *int  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT    *int  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE   *int  `json:"deletedAtLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "status" field predicates.
	Status      *project.Status  `json:"status,omitempty"`
	StatusNEQ   *project.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []project.Status `json:"statusIn,omitempty"`
	StatusNotIn []project.Status `json:"statusNotIn,omitempty"`

	// "users" edge predicates.
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`

	// "roles" edge predicates.
	HasRoles     *bool             `json:"hasRoles,omitempty"`
	HasRolesWith []*RoleWhereInput `json:"hasRolesWith,omitempty"`

	// "api_keys" edge predicates.
	HasAPIKeys     *bool               `json:"hasAPIKeys,omitempty"`
	HasAPIKeysWith []*APIKeyWhereInput `json:"hasAPIKeysWith,omitempty"`

	// "requests" edge predicates.
	HasRequests     *bool                `json:"hasRequests,omitempty"`
	HasRequestsWith []*RequestWhereInput `json:"hasRequestsWith,omitempty"`

	// "usage_logs" edge predicates.
	HasUsageLogs     *bool                 `json:"hasUsageLogs,omitempty"`
	HasUsageLogsWith []*UsageLogWhereInput `json:"hasUsageLogsWith,omitempty"`

	// "threads" edge predicates.
	HasThreads     *bool               `json:"hasThreads,omitempty"`
	HasThreadsWith []*ThreadWhereInput `json:"hasThreadsWith,omitempty"`

	// "traces" edge predicates.
	HasTraces     *bool              `json:"hasTraces,omitempty"`
	HasTracesWith []*TraceWhereInput `json:"hasTracesWith,omitempty"`

	// "prompts" edge predicates.
	HasPrompts     *bool               `json:"hasPrompts,omitempty"`
	HasPromptsWith []*PromptWhereInput `json:"hasPromptsWith,omitempty"`

	// "project_users" edge predicates.
	HasProjectUsers     *bool                    `json:"hasProjectUsers,omitempty"`
	HasProjectUsersWith []*UserProjectWhereInput `json:"hasProjectUsersWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ProjectWhereInput) AddPredicates(predicates ...predicate.Project) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ProjectWhereInput filter on the ProjectQuery builder.
func (i *ProjectWhereInput) Filter(q *ProjectQuery) (*ProjectQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyProjectWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyProjectWhereInput is returned in case the ProjectWhereInput is empty.
var ErrEmptyProjectWhereInput = errors.New("ent: empty predicate ProjectWhereInput")

// P returns a predicate for filtering projects.
// An error is returned if the input is empty or invalid.
func (i *ProjectWhereInput) P() (predicate.Project, error) {
	var predicates []predicate.Project
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, project.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Project, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, project.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Project, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, project.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, project.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, project.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, project.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, project.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, project.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, project.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, project.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, project.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, project.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, project.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, project.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, project.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, project.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, project.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, project.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, project.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, project.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, project.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, project.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, project.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, project.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, project.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, project.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, project.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, project.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, project.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, project.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, project.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, project.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, project.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, project.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, project.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, project.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, project.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, project.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, project.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, project.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, project.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, project.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, project.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, project.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, project.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, project.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, project.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, project.NameContainsFold(*i.NameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, project.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, project.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, project.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, project.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, project.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, project.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, project.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, project.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, project.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, project.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, project.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, project.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, project.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, project.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, project.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, project.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, project.StatusNotIn(i.StatusNotIn...))
	}

	if i.HasUsers != nil {
		p := project.HasUsers()
		if !*i.HasUsers {
			p = project.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUsersWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUsersWith))
		for _, w := range i.HasUsersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUsersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, project.HasUsersWith(with...))
	}
	if i.HasRoles != nil {
		p := project.HasRoles()
		if !*i.HasRoles {
			p = project.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRolesWith) > 0 {
		with := make([]predicate.Role, 0, len(i.HasRolesWith))
		for _, w := range i.HasRolesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRolesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, project.HasRolesWith(with...))
	}
	if i.HasAPIKeys != nil {
		p := project.HasAPIKeys()
		if !*i.HasAPIKeys {
			p = project.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAPIKeysWith) > 0 {
		with := make([]predicate.APIKey, 0, len(i.HasAPIKeysWith))
		for _, w := range i.HasAPIKeysWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAPIKeysWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, project.HasAPIKeysWith(with...))
	}
	if i.HasRequests != nil {
		p := project.HasRequests()
		if !*i.HasRequests {
			p = project.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRequestsWith) > 0 {
		with := make([]predicate.Request, 0, len(i.HasRequestsWith))
		for _, w := range i.HasRequestsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRequestsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, project.HasRequestsWith(with...))
	}
	if i.HasUsageLogs != nil {
		p := project.HasUsageLogs()
		if !*i.HasUsageLogs {
			p = project.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUsageLogsWith) > 0 {
		with := make([]predicate.UsageLog, 0, len(i.HasUsageLogsWith))
		for _, w := range i.HasUsageLogsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUsageLogsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, project.HasUsageLogsWith(with...))
	}
	if i.HasThreads != nil {
		p := project.HasThreads()
		if !*i.HasThreads {
			p = project.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasThreadsWith) > 0 {
		with := make([]predicate.Thread, 0, len(i.HasThreadsWith))
		for _, w := range i.HasThreadsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasThreadsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, project.HasThreadsWith(with...))
	}
	if i.HasTraces != nil {
		p := project.HasTraces()
		if !*i.HasTraces {
			p = project.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTracesWith) > 0 {
		with := make([]predicate.Trace, 0, len(i.HasTracesWith))
		for _, w := range i.HasTracesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTracesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, project.HasTracesWith(with...))
	}
	if i.HasPrompts != nil {
		p := project.HasPrompts()
		if !*i.HasPrompts {
			p = project.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPromptsWith) > 0 {
		with := make([]predicate.Prompt, 0, len(i.HasPromptsWith))
		for _, w := range i.HasPromptsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPromptsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, project.HasPromptsWith(with...))
	}
	if i.HasProjectUsers != nil {
		p := project.HasProjectUsers()
		if !*i.HasProjectUsers {
			p = project.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProjectUsersWith) > 0 {
		with := make([]predicate.UserProject, 0, len(i.HasProjectUsersWith))
		for _, w := range i.HasProjectUsersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProjectUsersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, project.HasProjectUsersWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyProjectWhereInput
	case 1:
		return predicates[0], nil
	default:
		return project.And(predicates...), nil
	}
}

// PromptWhereInput represents a where input for filtering Prompt queries.
type PromptWhereInput struct {
	Predicates []predicate.Prompt  `json:"-"`
	Not        *PromptWhereInput   `json:"not,omitempty"`
	Or         []*PromptWhereInput `json:"or,omitempty"`
	And        []*PromptWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt      *int  `json:"deletedAt,omitempty"`
	DeletedAtNEQ   *int  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn    []int `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn []int `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT    *int  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE   *int  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT    *int  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE   *int  `json:"deletedAtLTE,omitempty"`

	// "project_id" field predicates.
	ProjectID      *int  `json:"projectID,omitempty"`
	ProjectIDNEQ   *int  `json:"projectIDNEQ,omitempty"`
	ProjectIDIn    []int `json:"projectIDIn,omitempty"`
	ProjectIDNotIn []int `json:"projectIDNotIn,omitempty"`
	ProjectIDGT    *int  `json:"projectIDGT,omitempty"`
	ProjectIDGTE   *int  `json:"projectIDGTE,omitempty"`
	ProjectIDLT    *int  `json:"projectIDLT,omitempty"`
	ProjectIDLTE   *int  `json:"projectIDLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "role" field predicates.
	Role             *string  `json:"role,omitempty"`
	RoleNEQ          *string  `json:"roleNEQ,omitempty"`
	RoleIn           []string `json:"roleIn,omitempty"`
	RoleNotIn        []string `json:"roleNotIn,omitempty"`
	RoleGT           *string  `json:"roleGT,omitempty"`
	RoleGTE          *string  `json:"roleGTE,omitempty"`
	RoleLT           *string  `json:"roleLT,omitempty"`
	RoleLTE          *string  `json:"roleLTE,omitempty"`
	RoleContains     *string  `json:"roleContains,omitempty"`
	RoleHasPrefix    *string  `json:"roleHasPrefix,omitempty"`
	RoleHasSuffix    *string  `json:"roleHasSuffix,omitempty"`
	RoleEqualFold    *string  `json:"roleEqualFold,omitempty"`
	RoleContainsFold *string  `json:"roleContainsFold,omitempty"`

	// "content" field predicates.
	Content             *string  `json:"content,omitempty"`
	ContentNEQ          *string  `json:"contentNEQ,omitempty"`
	ContentIn           []string `json:"contentIn,omitempty"`
	ContentNotIn        []string `json:"contentNotIn,omitempty"`
	ContentGT           *string  `json:"contentGT,omitempty"`
	ContentGTE          *string  `json:"contentGTE,omitempty"`
	ContentLT           *string  `json:"contentLT,omitempty"`
	ContentLTE          *string  `json:"contentLTE,omitempty"`
	ContentContains     *string  `json:"contentContains,omitempty"`
	ContentHasPrefix    *string  `json:"contentHasPrefix,omitempty"`
	ContentHasSuffix    *string  `json:"contentHasSuffix,omitempty"`
	ContentEqualFold    *string  `json:"contentEqualFold,omitempty"`
	ContentContainsFold *string  `json:"contentContainsFold,omitempty"`

	// "status" field predicates.
	Status      *prompt.Status  `json:"status,omitempty"`
	StatusNEQ   *prompt.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []prompt.Status `json:"statusIn,omitempty"`
	StatusNotIn []prompt.Status `json:"statusNotIn,omitempty"`

	// "projects" edge predicates.
	HasProjects     *bool                `json:"hasProjects,omitempty"`
	HasProjectsWith []*ProjectWhereInput `json:"hasProjectsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PromptWhereInput) AddPredicates(predicates ...predicate.Prompt) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PromptWhereInput filter on the PromptQuery builder.
func (i *PromptWhereInput) Filter(q *PromptQuery) (*PromptQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPromptWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPromptWhereInput is returned in case the PromptWhereInput is empty.
var ErrEmptyPromptWhereInput = errors.New("ent: empty predicate PromptWhereInput")

// P returns a predicate for filtering prompts.
// An error is returned if the input is empty or invalid.
func (i *PromptWhereInput) P() (predicate.Prompt, error) {
	var predicates []predicate.Prompt
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, prompt.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Prompt, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, prompt.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Prompt, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, prompt.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, prompt.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, prompt.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, prompt.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, prompt.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, prompt.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, prompt.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, prompt.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, prompt.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, prompt.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, prompt.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, prompt.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, prompt.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, prompt.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, prompt.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, prompt.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, prompt.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, prompt.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, prompt.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, prompt.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, prompt.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, prompt.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, prompt.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, prompt.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, prompt.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, prompt.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, prompt.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, prompt.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, prompt.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, prompt.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, prompt.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, prompt.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, prompt.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.ProjectID != nil {
		predicates = append(predicates, prompt.ProjectIDEQ(*i.ProjectID))
	}
	if i.ProjectIDNEQ != nil {
		predicates = append(predicates, prompt.ProjectIDNEQ(*i.ProjectIDNEQ))
	}
	if len(i.ProjectIDIn) > 0 {
		predicates = append(predicates, prompt.ProjectIDIn(i.ProjectIDIn...))
	}
	if len(i.ProjectIDNotIn) > 0 {
		predicates = append(predicates, prompt.ProjectIDNotIn(i.ProjectIDNotIn...))
	}
	if i.ProjectIDGT != nil {
		predicates = append(predicates, prompt.ProjectIDGT(*i.ProjectIDGT))
	}
	if i.ProjectIDGTE != nil {
		predicates = append(predicates, prompt.ProjectIDGTE(*i.ProjectIDGTE))
	}
	if i.ProjectIDLT != nil {
		predicates = append(predicates, prompt.ProjectIDLT(*i.ProjectIDLT))
	}
	if i.ProjectIDLTE != nil {
		predicates = append(predicates, prompt.ProjectIDLTE(*i.ProjectIDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, prompt.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, prompt.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, prompt.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, prompt.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, prompt.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, prompt.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, prompt.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, prompt.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, prompt.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, prompt.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, prompt.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, prompt.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, prompt.NameContainsFold(*i.NameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, prompt.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, prompt.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, prompt.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, prompt.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, prompt.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, prompt.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, prompt.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, prompt.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, prompt.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, prompt.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, prompt.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, prompt.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, prompt.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.Role != nil {
		predicates = append(predicates, prompt.RoleEQ(*i.Role))
	}
	if i.RoleNEQ != nil {
		predicates = append(predicates, prompt.RoleNEQ(*i.RoleNEQ))
	}
	if len(i.RoleIn) > 0 {
		predicates = append(predicates, prompt.RoleIn(i.RoleIn...))
	}
	if len(i.RoleNotIn) > 0 {
		predicates = append(predicates, prompt.RoleNotIn(i.RoleNotIn...))
	}
	if i.RoleGT != nil {
		predicates = append(predicates, prompt.RoleGT(*i.RoleGT))
	}
	if i.RoleGTE != nil {
		predicates = append(predicates, prompt.RoleGTE(*i.RoleGTE))
	}
	if i.RoleLT != nil {
		predicates = append(predicates, prompt.RoleLT(*i.RoleLT))
	}
	if i.RoleLTE != nil {
		predicates = append(predicates, prompt.RoleLTE(*i.RoleLTE))
	}
	if i.RoleContains != nil {
		predicates = append(predicates, prompt.RoleContains(*i.RoleContains))
	}
	if i.RoleHasPrefix != nil {
		predicates = append(predicates, prompt.RoleHasPrefix(*i.RoleHasPrefix))
	}
	if i.RoleHasSuffix != nil {
		predicates = append(predicates, prompt.RoleHasSuffix(*i.RoleHasSuffix))
	}
	if i.RoleEqualFold != nil {
		predicates = append(predicates, prompt.RoleEqualFold(*i.RoleEqualFold))
	}
	if i.RoleContainsFold != nil {
		predicates = append(predicates, prompt.RoleContainsFold(*i.RoleContainsFold))
	}
	if i.Content != nil {
		predicates = append(predicates, prompt.ContentEQ(*i.Content))
	}
	if i.ContentNEQ != nil {
		predicates = append(predicates, prompt.ContentNEQ(*i.ContentNEQ))
	}
	if len(i.ContentIn) > 0 {
		predicates = append(predicates, prompt.ContentIn(i.ContentIn...))
	}
	if len(i.ContentNotIn) > 0 {
		predicates = append(predicates, prompt.ContentNotIn(i.ContentNotIn...))
	}
	if i.ContentGT != nil {
		predicates = append(predicates, prompt.ContentGT(*i.ContentGT))
	}
	if i.ContentGTE != nil {
		predicates = append(predicates, prompt.ContentGTE(*i.ContentGTE))
	}
	if i.ContentLT != nil {
		predicates = append(predicates, prompt.ContentLT(*i.ContentLT))
	}
	if i.ContentLTE != nil {
		predicates = append(predicates, prompt.ContentLTE(*i.ContentLTE))
	}
	if i.ContentContains != nil {
		predicates = append(predicates, prompt.ContentContains(*i.ContentContains))
	}
	if i.ContentHasPrefix != nil {
		predicates = append(predicates, prompt.ContentHasPrefix(*i.ContentHasPrefix))
	}
	if i.ContentHasSuffix != nil {
		predicates = append(predicates, prompt.ContentHasSuffix(*i.ContentHasSuffix))
	}
	if i.ContentEqualFold != nil {
		predicates = append(predicates, prompt.ContentEqualFold(*i.ContentEqualFold))
	}
	if i.ContentContainsFold != nil {
		predicates = append(predicates, prompt.ContentContainsFold(*i.ContentContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, prompt.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, prompt.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, prompt.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, prompt.StatusNotIn(i.StatusNotIn...))
	}

	if i.HasProjects != nil {
		p := prompt.HasProjects()
		if !*i.HasProjects {
			p = prompt.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProjectsWith) > 0 {
		with := make([]predicate.Project, 0, len(i.HasProjectsWith))
		for _, w := range i.HasProjectsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProjectsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, prompt.HasProjectsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPromptWhereInput
	case 1:
		return predicates[0], nil
	default:
		return prompt.And(predicates...), nil
	}
}

// RequestWhereInput represents a where input for filtering Request queries.
type RequestWhereInput struct {
	Predicates []predicate.Request  `json:"-"`
	Not        *RequestWhereInput   `json:"not,omitempty"`
	Or         []*RequestWhereInput `json:"or,omitempty"`
	And        []*RequestWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "api_key_id" field predicates.
	APIKeyID       *int  `json:"apiKeyID,omitempty"`
	APIKeyIDNEQ    *int  `json:"apiKeyIDNEQ,omitempty"`
	APIKeyIDIn     []int `json:"apiKeyIDIn,omitempty"`
	APIKeyIDNotIn  []int `json:"apiKeyIDNotIn,omitempty"`
	APIKeyIDIsNil  bool  `json:"apiKeyIDIsNil,omitempty"`
	APIKeyIDNotNil bool  `json:"apiKeyIDNotNil,omitempty"`

	// "project_id" field predicates.
	ProjectID      *int  `json:"projectID,omitempty"`
	ProjectIDNEQ   *int  `json:"projectIDNEQ,omitempty"`
	ProjectIDIn    []int `json:"projectIDIn,omitempty"`
	ProjectIDNotIn []int `json:"projectIDNotIn,omitempty"`

	// "trace_id" field predicates.
	TraceID       *int  `json:"traceID,omitempty"`
	TraceIDNEQ    *int  `json:"traceIDNEQ,omitempty"`
	TraceIDIn     []int `json:"traceIDIn,omitempty"`
	TraceIDNotIn  []int `json:"traceIDNotIn,omitempty"`
	TraceIDIsNil  bool  `json:"traceIDIsNil,omitempty"`
	TraceIDNotNil bool  `json:"traceIDNotNil,omitempty"`

	// "data_storage_id" field predicates.
	DataStorageID       *int  `json:"dataStorageID,omitempty"`
	DataStorageIDNEQ    *int  `json:"dataStorageIDNEQ,omitempty"`
	DataStorageIDIn     []int `json:"dataStorageIDIn,omitempty"`
	DataStorageIDNotIn  []int `json:"dataStorageIDNotIn,omitempty"`
	DataStorageIDIsNil  bool  `json:"dataStorageIDIsNil,omitempty"`
	DataStorageIDNotNil bool  `json:"dataStorageIDNotNil,omitempty"`

	// "source" field predicates.
	Source      *request.Source  `json:"source,omitempty"`
	SourceNEQ   *request.Source  `json:"sourceNEQ,omitempty"`
	SourceIn    []request.Source `json:"sourceIn,omitempty"`
	SourceNotIn []request.Source `json:"sourceNotIn,omitempty"`

	// "model_id" field predicates.
	ModelID             *string  `json:"modelID,omitempty"`
	ModelIDNEQ          *string  `json:"modelIDNEQ,omitempty"`
	ModelIDIn           []string `json:"modelIDIn,omitempty"`
	ModelIDNotIn        []string `json:"modelIDNotIn,omitempty"`
	ModelIDGT           *string  `json:"modelIDGT,omitempty"`
	ModelIDGTE          *string  `json:"modelIDGTE,omitempty"`
	ModelIDLT           *string  `json:"modelIDLT,omitempty"`
	ModelIDLTE          *string  `json:"modelIDLTE,omitempty"`
	ModelIDContains     *string  `json:"modelIDContains,omitempty"`
	ModelIDHasPrefix    *string  `json:"modelIDHasPrefix,omitempty"`
	ModelIDHasSuffix    *string  `json:"modelIDHasSuffix,omitempty"`
	ModelIDEqualFold    *string  `json:"modelIDEqualFold,omitempty"`
	ModelIDContainsFold *string  `json:"modelIDContainsFold,omitempty"`

	// "format" field predicates.
	Format             *string  `json:"format,omitempty"`
	FormatNEQ          *string  `json:"formatNEQ,omitempty"`
	FormatIn           []string `json:"formatIn,omitempty"`
	FormatNotIn        []string `json:"formatNotIn,omitempty"`
	FormatGT           *string  `json:"formatGT,omitempty"`
	FormatGTE          *string  `json:"formatGTE,omitempty"`
	FormatLT           *string  `json:"formatLT,omitempty"`
	FormatLTE          *string  `json:"formatLTE,omitempty"`
	FormatContains     *string  `json:"formatContains,omitempty"`
	FormatHasPrefix    *string  `json:"formatHasPrefix,omitempty"`
	FormatHasSuffix    *string  `json:"formatHasSuffix,omitempty"`
	FormatEqualFold    *string  `json:"formatEqualFold,omitempty"`
	FormatContainsFold *string  `json:"formatContainsFold,omitempty"`

	// "channel_id" field predicates.
	ChannelID       *int  `json:"channelID,omitempty"`
	ChannelIDNEQ    *int  `json:"channelIDNEQ,omitempty"`
	ChannelIDIn     []int `json:"channelIDIn,omitempty"`
	ChannelIDNotIn  []int `json:"channelIDNotIn,omitempty"`
	ChannelIDIsNil  bool  `json:"channelIDIsNil,omitempty"`
	ChannelIDNotNil bool  `json:"channelIDNotNil,omitempty"`

	// "external_id" field predicates.
	ExternalID             *string  `json:"externalID,omitempty"`
	ExternalIDNEQ          *string  `json:"externalIDNEQ,omitempty"`
	ExternalIDIn           []string `json:"externalIDIn,omitempty"`
	ExternalIDNotIn        []string `json:"externalIDNotIn,omitempty"`
	ExternalIDGT           *string  `json:"externalIDGT,omitempty"`
	ExternalIDGTE          *string  `json:"externalIDGTE,omitempty"`
	ExternalIDLT           *string  `json:"externalIDLT,omitempty"`
	ExternalIDLTE          *string  `json:"externalIDLTE,omitempty"`
	ExternalIDContains     *string  `json:"externalIDContains,omitempty"`
	ExternalIDHasPrefix    *string  `json:"externalIDHasPrefix,omitempty"`
	ExternalIDHasSuffix    *string  `json:"externalIDHasSuffix,omitempty"`
	ExternalIDIsNil        bool     `json:"externalIDIsNil,omitempty"`
	ExternalIDNotNil       bool     `json:"externalIDNotNil,omitempty"`
	ExternalIDEqualFold    *string  `json:"externalIDEqualFold,omitempty"`
	ExternalIDContainsFold *string  `json:"externalIDContainsFold,omitempty"`

	// "status" field predicates.
	Status      *request.Status  `json:"status,omitempty"`
	StatusNEQ   *request.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []request.Status `json:"statusIn,omitempty"`
	StatusNotIn []request.Status `json:"statusNotIn,omitempty"`

	// "stream" field predicates.
	Stream    *bool `json:"stream,omitempty"`
	StreamNEQ *bool `json:"streamNEQ,omitempty"`

	// "client_ip" field predicates.
	ClientIP             *string  `json:"clientIP,omitempty"`
	ClientIPNEQ          *string  `json:"clientIPNEQ,omitempty"`
	ClientIPIn           []string `json:"clientIPIn,omitempty"`
	ClientIPNotIn        []string `json:"clientIPNotIn,omitempty"`
	ClientIPGT           *string  `json:"clientIPGT,omitempty"`
	ClientIPGTE          *string  `json:"clientIPGTE,omitempty"`
	ClientIPLT           *string  `json:"clientIPLT,omitempty"`
	ClientIPLTE          *string  `json:"clientIPLTE,omitempty"`
	ClientIPContains     *string  `json:"clientIPContains,omitempty"`
	ClientIPHasPrefix    *string  `json:"clientIPHasPrefix,omitempty"`
	ClientIPHasSuffix    *string  `json:"clientIPHasSuffix,omitempty"`
	ClientIPEqualFold    *string  `json:"clientIPEqualFold,omitempty"`
	ClientIPContainsFold *string  `json:"clientIPContainsFold,omitempty"`

	// "metrics_latency_ms" field predicates.
	MetricsLatencyMs       *int64  `json:"metricsLatencyMs,omitempty"`
	MetricsLatencyMsNEQ    *int64  `json:"metricsLatencyMsNEQ,omitempty"`
	MetricsLatencyMsIn     []int64 `json:"metricsLatencyMsIn,omitempty"`
	MetricsLatencyMsNotIn  []int64 `json:"metricsLatencyMsNotIn,omitempty"`
	MetricsLatencyMsGT     *int64  `json:"metricsLatencyMsGT,omitempty"`
	MetricsLatencyMsGTE    *int64  `json:"metricsLatencyMsGTE,omitempty"`
	MetricsLatencyMsLT     *int64  `json:"metricsLatencyMsLT,omitempty"`
	MetricsLatencyMsLTE    *int64  `json:"metricsLatencyMsLTE,omitempty"`
	MetricsLatencyMsIsNil  bool    `json:"metricsLatencyMsIsNil,omitempty"`
	MetricsLatencyMsNotNil bool    `json:"metricsLatencyMsNotNil,omitempty"`

	// "metrics_first_token_latency_ms" field predicates.
	MetricsFirstTokenLatencyMs       *int64  `json:"metricsFirstTokenLatencyMs,omitempty"`
	MetricsFirstTokenLatencyMsNEQ    *int64  `json:"metricsFirstTokenLatencyMsNEQ,omitempty"`
	MetricsFirstTokenLatencyMsIn     []int64 `json:"metricsFirstTokenLatencyMsIn,omitempty"`
	MetricsFirstTokenLatencyMsNotIn  []int64 `json:"metricsFirstTokenLatencyMsNotIn,omitempty"`
	MetricsFirstTokenLatencyMsGT     *int64  `json:"metricsFirstTokenLatencyMsGT,omitempty"`
	MetricsFirstTokenLatencyMsGTE    *int64  `json:"metricsFirstTokenLatencyMsGTE,omitempty"`
	MetricsFirstTokenLatencyMsLT     *int64  `json:"metricsFirstTokenLatencyMsLT,omitempty"`
	MetricsFirstTokenLatencyMsLTE    *int64  `json:"metricsFirstTokenLatencyMsLTE,omitempty"`
	MetricsFirstTokenLatencyMsIsNil  bool    `json:"metricsFirstTokenLatencyMsIsNil,omitempty"`
	MetricsFirstTokenLatencyMsNotNil bool    `json:"metricsFirstTokenLatencyMsNotNil,omitempty"`

	// "api_key" edge predicates.
	HasAPIKey     *bool               `json:"hasAPIKey,omitempty"`
	HasAPIKeyWith []*APIKeyWhereInput `json:"hasAPIKeyWith,omitempty"`

	// "project" edge predicates.
	HasProject     *bool                `json:"hasProject,omitempty"`
	HasProjectWith []*ProjectWhereInput `json:"hasProjectWith,omitempty"`

	// "trace" edge predicates.
	HasTrace     *bool              `json:"hasTrace,omitempty"`
	HasTraceWith []*TraceWhereInput `json:"hasTraceWith,omitempty"`

	// "data_storage" edge predicates.
	HasDataStorage     *bool                    `json:"hasDataStorage,omitempty"`
	HasDataStorageWith []*DataStorageWhereInput `json:"hasDataStorageWith,omitempty"`

	// "executions" edge predicates.
	HasExecutions     *bool                         `json:"hasExecutions,omitempty"`
	HasExecutionsWith []*RequestExecutionWhereInput `json:"hasExecutionsWith,omitempty"`

	// "channel" edge predicates.
	HasChannel     *bool                `json:"hasChannel,omitempty"`
	HasChannelWith []*ChannelWhereInput `json:"hasChannelWith,omitempty"`

	// "usage_logs" edge predicates.
	HasUsageLogs     *bool                 `json:"hasUsageLogs,omitempty"`
	HasUsageLogsWith []*UsageLogWhereInput `json:"hasUsageLogsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *RequestWhereInput) AddPredicates(predicates ...predicate.Request) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the RequestWhereInput filter on the RequestQuery builder.
func (i *RequestWhereInput) Filter(q *RequestQuery) (*RequestQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyRequestWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyRequestWhereInput is returned in case the RequestWhereInput is empty.
var ErrEmptyRequestWhereInput = errors.New("ent: empty predicate RequestWhereInput")

// P returns a predicate for filtering requests.
// An error is returned if the input is empty or invalid.
func (i *RequestWhereInput) P() (predicate.Request, error) {
	var predicates []predicate.Request
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, request.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Request, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, request.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Request, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, request.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, request.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, request.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, request.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, request.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, request.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, request.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, request.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, request.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, request.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, request.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, request.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, request.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, request.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, request.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, request.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, request.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, request.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, request.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, request.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, request.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, request.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, request.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, request.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, request.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.APIKeyID != nil {
		predicates = append(predicates, request.APIKeyIDEQ(*i.APIKeyID))
	}
	if i.APIKeyIDNEQ != nil {
		predicates = append(predicates, request.APIKeyIDNEQ(*i.APIKeyIDNEQ))
	}
	if len(i.APIKeyIDIn) > 0 {
		predicates = append(predicates, request.APIKeyIDIn(i.APIKeyIDIn...))
	}
	if len(i.APIKeyIDNotIn) > 0 {
		predicates = append(predicates, request.APIKeyIDNotIn(i.APIKeyIDNotIn...))
	}
	if i.APIKeyIDIsNil {
		predicates = append(predicates, request.APIKeyIDIsNil())
	}
	if i.APIKeyIDNotNil {
		predicates = append(predicates, request.APIKeyIDNotNil())
	}
	if i.ProjectID != nil {
		predicates = append(predicates, request.ProjectIDEQ(*i.ProjectID))
	}
	if i.ProjectIDNEQ != nil {
		predicates = append(predicates, request.ProjectIDNEQ(*i.ProjectIDNEQ))
	}
	if len(i.ProjectIDIn) > 0 {
		predicates = append(predicates, request.ProjectIDIn(i.ProjectIDIn...))
	}
	if len(i.ProjectIDNotIn) > 0 {
		predicates = append(predicates, request.ProjectIDNotIn(i.ProjectIDNotIn...))
	}
	if i.TraceID != nil {
		predicates = append(predicates, request.TraceIDEQ(*i.TraceID))
	}
	if i.TraceIDNEQ != nil {
		predicates = append(predicates, request.TraceIDNEQ(*i.TraceIDNEQ))
	}
	if len(i.TraceIDIn) > 0 {
		predicates = append(predicates, request.TraceIDIn(i.TraceIDIn...))
	}
	if len(i.TraceIDNotIn) > 0 {
		predicates = append(predicates, request.TraceIDNotIn(i.TraceIDNotIn...))
	}
	if i.TraceIDIsNil {
		predicates = append(predicates, request.TraceIDIsNil())
	}
	if i.TraceIDNotNil {
		predicates = append(predicates, request.TraceIDNotNil())
	}
	if i.DataStorageID != nil {
		predicates = append(predicates, request.DataStorageIDEQ(*i.DataStorageID))
	}
	if i.DataStorageIDNEQ != nil {
		predicates = append(predicates, request.DataStorageIDNEQ(*i.DataStorageIDNEQ))
	}
	if len(i.DataStorageIDIn) > 0 {
		predicates = append(predicates, request.DataStorageIDIn(i.DataStorageIDIn...))
	}
	if len(i.DataStorageIDNotIn) > 0 {
		predicates = append(predicates, request.DataStorageIDNotIn(i.DataStorageIDNotIn...))
	}
	if i.DataStorageIDIsNil {
		predicates = append(predicates, request.DataStorageIDIsNil())
	}
	if i.DataStorageIDNotNil {
		predicates = append(predicates, request.DataStorageIDNotNil())
	}
	if i.Source != nil {
		predicates = append(predicates, request.SourceEQ(*i.Source))
	}
	if i.SourceNEQ != nil {
		predicates = append(predicates, request.SourceNEQ(*i.SourceNEQ))
	}
	if len(i.SourceIn) > 0 {
		predicates = append(predicates, request.SourceIn(i.SourceIn...))
	}
	if len(i.SourceNotIn) > 0 {
		predicates = append(predicates, request.SourceNotIn(i.SourceNotIn...))
	}
	if i.ModelID != nil {
		predicates = append(predicates, request.ModelIDEQ(*i.ModelID))
	}
	if i.ModelIDNEQ != nil {
		predicates = append(predicates, request.ModelIDNEQ(*i.ModelIDNEQ))
	}
	if len(i.ModelIDIn) > 0 {
		predicates = append(predicates, request.ModelIDIn(i.ModelIDIn...))
	}
	if len(i.ModelIDNotIn) > 0 {
		predicates = append(predicates, request.ModelIDNotIn(i.ModelIDNotIn...))
	}
	if i.ModelIDGT != nil {
		predicates = append(predicates, request.ModelIDGT(*i.ModelIDGT))
	}
	if i.ModelIDGTE != nil {
		predicates = append(predicates, request.ModelIDGTE(*i.ModelIDGTE))
	}
	if i.ModelIDLT != nil {
		predicates = append(predicates, request.ModelIDLT(*i.ModelIDLT))
	}
	if i.ModelIDLTE != nil {
		predicates = append(predicates, request.ModelIDLTE(*i.ModelIDLTE))
	}
	if i.ModelIDContains != nil {
		predicates = append(predicates, request.ModelIDContains(*i.ModelIDContains))
	}
	if i.ModelIDHasPrefix != nil {
		predicates = append(predicates, request.ModelIDHasPrefix(*i.ModelIDHasPrefix))
	}
	if i.ModelIDHasSuffix != nil {
		predicates = append(predicates, request.ModelIDHasSuffix(*i.ModelIDHasSuffix))
	}
	if i.ModelIDEqualFold != nil {
		predicates = append(predicates, request.ModelIDEqualFold(*i.ModelIDEqualFold))
	}
	if i.ModelIDContainsFold != nil {
		predicates = append(predicates, request.ModelIDContainsFold(*i.ModelIDContainsFold))
	}
	if i.Format != nil {
		predicates = append(predicates, request.FormatEQ(*i.Format))
	}
	if i.FormatNEQ != nil {
		predicates = append(predicates, request.FormatNEQ(*i.FormatNEQ))
	}
	if len(i.FormatIn) > 0 {
		predicates = append(predicates, request.FormatIn(i.FormatIn...))
	}
	if len(i.FormatNotIn) > 0 {
		predicates = append(predicates, request.FormatNotIn(i.FormatNotIn...))
	}
	if i.FormatGT != nil {
		predicates = append(predicates, request.FormatGT(*i.FormatGT))
	}
	if i.FormatGTE != nil {
		predicates = append(predicates, request.FormatGTE(*i.FormatGTE))
	}
	if i.FormatLT != nil {
		predicates = append(predicates, request.FormatLT(*i.FormatLT))
	}
	if i.FormatLTE != nil {
		predicates = append(predicates, request.FormatLTE(*i.FormatLTE))
	}
	if i.FormatContains != nil {
		predicates = append(predicates, request.FormatContains(*i.FormatContains))
	}
	if i.FormatHasPrefix != nil {
		predicates = append(predicates, request.FormatHasPrefix(*i.FormatHasPrefix))
	}
	if i.FormatHasSuffix != nil {
		predicates = append(predicates, request.FormatHasSuffix(*i.FormatHasSuffix))
	}
	if i.FormatEqualFold != nil {
		predicates = append(predicates, request.FormatEqualFold(*i.FormatEqualFold))
	}
	if i.FormatContainsFold != nil {
		predicates = append(predicates, request.FormatContainsFold(*i.FormatContainsFold))
	}
	if i.ChannelID != nil {
		predicates = append(predicates, request.ChannelIDEQ(*i.ChannelID))
	}
	if i.ChannelIDNEQ != nil {
		predicates = append(predicates, request.ChannelIDNEQ(*i.ChannelIDNEQ))
	}
	if len(i.ChannelIDIn) > 0 {
		predicates = append(predicates, request.ChannelIDIn(i.ChannelIDIn...))
	}
	if len(i.ChannelIDNotIn) > 0 {
		predicates = append(predicates, request.ChannelIDNotIn(i.ChannelIDNotIn...))
	}
	if i.ChannelIDIsNil {
		predicates = append(predicates, request.ChannelIDIsNil())
	}
	if i.ChannelIDNotNil {
		predicates = append(predicates, request.ChannelIDNotNil())
	}
	if i.ExternalID != nil {
		predicates = append(predicates, request.ExternalIDEQ(*i.ExternalID))
	}
	if i.ExternalIDNEQ != nil {
		predicates = append(predicates, request.ExternalIDNEQ(*i.ExternalIDNEQ))
	}
	if len(i.ExternalIDIn) > 0 {
		predicates = append(predicates, request.ExternalIDIn(i.ExternalIDIn...))
	}
	if len(i.ExternalIDNotIn) > 0 {
		predicates = append(predicates, request.ExternalIDNotIn(i.ExternalIDNotIn...))
	}
	if i.ExternalIDGT != nil {
		predicates = append(predicates, request.ExternalIDGT(*i.ExternalIDGT))
	}
	if i.ExternalIDGTE != nil {
		predicates = append(predicates, request.ExternalIDGTE(*i.ExternalIDGTE))
	}
	if i.ExternalIDLT != nil {
		predicates = append(predicates, request.ExternalIDLT(*i.ExternalIDLT))
	}
	if i.ExternalIDLTE != nil {
		predicates = append(predicates, request.ExternalIDLTE(*i.ExternalIDLTE))
	}
	if i.ExternalIDContains != nil {
		predicates = append(predicates, request.ExternalIDContains(*i.ExternalIDContains))
	}
	if i.ExternalIDHasPrefix != nil {
		predicates = append(predicates, request.ExternalIDHasPrefix(*i.ExternalIDHasPrefix))
	}
	if i.ExternalIDHasSuffix != nil {
		predicates = append(predicates, request.ExternalIDHasSuffix(*i.ExternalIDHasSuffix))
	}
	if i.ExternalIDIsNil {
		predicates = append(predicates, request.ExternalIDIsNil())
	}
	if i.ExternalIDNotNil {
		predicates = append(predicates, request.ExternalIDNotNil())
	}
	if i.ExternalIDEqualFold != nil {
		predicates = append(predicates, request.ExternalIDEqualFold(*i.ExternalIDEqualFold))
	}
	if i.ExternalIDContainsFold != nil {
		predicates = append(predicates, request.ExternalIDContainsFold(*i.ExternalIDContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, request.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, request.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, request.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, request.StatusNotIn(i.StatusNotIn...))
	}
	if i.Stream != nil {
		predicates = append(predicates, request.StreamEQ(*i.Stream))
	}
	if i.StreamNEQ != nil {
		predicates = append(predicates, request.StreamNEQ(*i.StreamNEQ))
	}
	if i.ClientIP != nil {
		predicates = append(predicates, request.ClientIPEQ(*i.ClientIP))
	}
	if i.ClientIPNEQ != nil {
		predicates = append(predicates, request.ClientIPNEQ(*i.ClientIPNEQ))
	}
	if len(i.ClientIPIn) > 0 {
		predicates = append(predicates, request.ClientIPIn(i.ClientIPIn...))
	}
	if len(i.ClientIPNotIn) > 0 {
		predicates = append(predicates, request.ClientIPNotIn(i.ClientIPNotIn...))
	}
	if i.ClientIPGT != nil {
		predicates = append(predicates, request.ClientIPGT(*i.ClientIPGT))
	}
	if i.ClientIPGTE != nil {
		predicates = append(predicates, request.ClientIPGTE(*i.ClientIPGTE))
	}
	if i.ClientIPLT != nil {
		predicates = append(predicates, request.ClientIPLT(*i.ClientIPLT))
	}
	if i.ClientIPLTE != nil {
		predicates = append(predicates, request.ClientIPLTE(*i.ClientIPLTE))
	}
	if i.ClientIPContains != nil {
		predicates = append(predicates, request.ClientIPContains(*i.ClientIPContains))
	}
	if i.ClientIPHasPrefix != nil {
		predicates = append(predicates, request.ClientIPHasPrefix(*i.ClientIPHasPrefix))
	}
	if i.ClientIPHasSuffix != nil {
		predicates = append(predicates, request.ClientIPHasSuffix(*i.ClientIPHasSuffix))
	}
	if i.ClientIPEqualFold != nil {
		predicates = append(predicates, request.ClientIPEqualFold(*i.ClientIPEqualFold))
	}
	if i.ClientIPContainsFold != nil {
		predicates = append(predicates, request.ClientIPContainsFold(*i.ClientIPContainsFold))
	}
	if i.MetricsLatencyMs != nil {
		predicates = append(predicates, request.MetricsLatencyMsEQ(*i.MetricsLatencyMs))
	}
	if i.MetricsLatencyMsNEQ != nil {
		predicates = append(predicates, request.MetricsLatencyMsNEQ(*i.MetricsLatencyMsNEQ))
	}
	if len(i.MetricsLatencyMsIn) > 0 {
		predicates = append(predicates, request.MetricsLatencyMsIn(i.MetricsLatencyMsIn...))
	}
	if len(i.MetricsLatencyMsNotIn) > 0 {
		predicates = append(predicates, request.MetricsLatencyMsNotIn(i.MetricsLatencyMsNotIn...))
	}
	if i.MetricsLatencyMsGT != nil {
		predicates = append(predicates, request.MetricsLatencyMsGT(*i.MetricsLatencyMsGT))
	}
	if i.MetricsLatencyMsGTE != nil {
		predicates = append(predicates, request.MetricsLatencyMsGTE(*i.MetricsLatencyMsGTE))
	}
	if i.MetricsLatencyMsLT != nil {
		predicates = append(predicates, request.MetricsLatencyMsLT(*i.MetricsLatencyMsLT))
	}
	if i.MetricsLatencyMsLTE != nil {
		predicates = append(predicates, request.MetricsLatencyMsLTE(*i.MetricsLatencyMsLTE))
	}
	if i.MetricsLatencyMsIsNil {
		predicates = append(predicates, request.MetricsLatencyMsIsNil())
	}
	if i.MetricsLatencyMsNotNil {
		predicates = append(predicates, request.MetricsLatencyMsNotNil())
	}
	if i.MetricsFirstTokenLatencyMs != nil {
		predicates = append(predicates, request.MetricsFirstTokenLatencyMsEQ(*i.MetricsFirstTokenLatencyMs))
	}
	if i.MetricsFirstTokenLatencyMsNEQ != nil {
		predicates = append(predicates, request.MetricsFirstTokenLatencyMsNEQ(*i.MetricsFirstTokenLatencyMsNEQ))
	}
	if len(i.MetricsFirstTokenLatencyMsIn) > 0 {
		predicates = append(predicates, request.MetricsFirstTokenLatencyMsIn(i.MetricsFirstTokenLatencyMsIn...))
	}
	if len(i.MetricsFirstTokenLatencyMsNotIn) > 0 {
		predicates = append(predicates, request.MetricsFirstTokenLatencyMsNotIn(i.MetricsFirstTokenLatencyMsNotIn...))
	}
	if i.MetricsFirstTokenLatencyMsGT != nil {
		predicates = append(predicates, request.MetricsFirstTokenLatencyMsGT(*i.MetricsFirstTokenLatencyMsGT))
	}
	if i.MetricsFirstTokenLatencyMsGTE != nil {
		predicates = append(predicates, request.MetricsFirstTokenLatencyMsGTE(*i.MetricsFirstTokenLatencyMsGTE))
	}
	if i.MetricsFirstTokenLatencyMsLT != nil {
		predicates = append(predicates, request.MetricsFirstTokenLatencyMsLT(*i.MetricsFirstTokenLatencyMsLT))
	}
	if i.MetricsFirstTokenLatencyMsLTE != nil {
		predicates = append(predicates, request.MetricsFirstTokenLatencyMsLTE(*i.MetricsFirstTokenLatencyMsLTE))
	}
	if i.MetricsFirstTokenLatencyMsIsNil {
		predicates = append(predicates, request.MetricsFirstTokenLatencyMsIsNil())
	}
	if i.MetricsFirstTokenLatencyMsNotNil {
		predicates = append(predicates, request.MetricsFirstTokenLatencyMsNotNil())
	}

	if i.HasAPIKey != nil {
		p := request.HasAPIKey()
		if !*i.HasAPIKey {
			p = request.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAPIKeyWith) > 0 {
		with := make([]predicate.APIKey, 0, len(i.HasAPIKeyWith))
		for _, w := range i.HasAPIKeyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAPIKeyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, request.HasAPIKeyWith(with...))
	}
	if i.HasProject != nil {
		p := request.HasProject()
		if !*i.HasProject {
			p = request.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProjectWith) > 0 {
		with := make([]predicate.Project, 0, len(i.HasProjectWith))
		for _, w := range i.HasProjectWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProjectWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, request.HasProjectWith(with...))
	}
	if i.HasTrace != nil {
		p := request.HasTrace()
		if !*i.HasTrace {
			p = request.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTraceWith) > 0 {
		with := make([]predicate.Trace, 0, len(i.HasTraceWith))
		for _, w := range i.HasTraceWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTraceWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, request.HasTraceWith(with...))
	}
	if i.HasDataStorage != nil {
		p := request.HasDataStorage()
		if !*i.HasDataStorage {
			p = request.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDataStorageWith) > 0 {
		with := make([]predicate.DataStorage, 0, len(i.HasDataStorageWith))
		for _, w := range i.HasDataStorageWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDataStorageWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, request.HasDataStorageWith(with...))
	}
	if i.HasExecutions != nil {
		p := request.HasExecutions()
		if !*i.HasExecutions {
			p = request.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasExecutionsWith) > 0 {
		with := make([]predicate.RequestExecution, 0, len(i.HasExecutionsWith))
		for _, w := range i.HasExecutionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasExecutionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, request.HasExecutionsWith(with...))
	}
	if i.HasChannel != nil {
		p := request.HasChannel()
		if !*i.HasChannel {
			p = request.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasChannelWith) > 0 {
		with := make([]predicate.Channel, 0, len(i.HasChannelWith))
		for _, w := range i.HasChannelWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasChannelWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, request.HasChannelWith(with...))
	}
	if i.HasUsageLogs != nil {
		p := request.HasUsageLogs()
		if !*i.HasUsageLogs {
			p = request.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUsageLogsWith) > 0 {
		with := make([]predicate.UsageLog, 0, len(i.HasUsageLogsWith))
		for _, w := range i.HasUsageLogsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUsageLogsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, request.HasUsageLogsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyRequestWhereInput
	case 1:
		return predicates[0], nil
	default:
		return request.And(predicates...), nil
	}
}

// RequestExecutionWhereInput represents a where input for filtering RequestExecution queries.
type RequestExecutionWhereInput struct {
	Predicates []predicate.RequestExecution  `json:"-"`
	Not        *RequestExecutionWhereInput   `json:"not,omitempty"`
	Or         []*RequestExecutionWhereInput `json:"or,omitempty"`
	And        []*RequestExecutionWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "project_id" field predicates.
	ProjectID      *int  `json:"projectID,omitempty"`
	ProjectIDNEQ   *int  `json:"projectIDNEQ,omitempty"`
	ProjectIDIn    []int `json:"projectIDIn,omitempty"`
	ProjectIDNotIn []int `json:"projectIDNotIn,omitempty"`
	ProjectIDGT    *int  `json:"projectIDGT,omitempty"`
	ProjectIDGTE   *int  `json:"projectIDGTE,omitempty"`
	ProjectIDLT    *int  `json:"projectIDLT,omitempty"`
	ProjectIDLTE   *int  `json:"projectIDLTE,omitempty"`

	// "request_id" field predicates.
	RequestID      *int  `json:"requestID,omitempty"`
	RequestIDNEQ   *int  `json:"requestIDNEQ,omitempty"`
	RequestIDIn    []int `json:"requestIDIn,omitempty"`
	RequestIDNotIn []int `json:"requestIDNotIn,omitempty"`

	// "channel_id" field predicates.
	ChannelID       *int  `json:"channelID,omitempty"`
	ChannelIDNEQ    *int  `json:"channelIDNEQ,omitempty"`
	ChannelIDIn     []int `json:"channelIDIn,omitempty"`
	ChannelIDNotIn  []int `json:"channelIDNotIn,omitempty"`
	ChannelIDIsNil  bool  `json:"channelIDIsNil,omitempty"`
	ChannelIDNotNil bool  `json:"channelIDNotNil,omitempty"`

	// "data_storage_id" field predicates.
	DataStorageID       *int  `json:"dataStorageID,omitempty"`
	DataStorageIDNEQ    *int  `json:"dataStorageIDNEQ,omitempty"`
	DataStorageIDIn     []int `json:"dataStorageIDIn,omitempty"`
	DataStorageIDNotIn  []int `json:"dataStorageIDNotIn,omitempty"`
	DataStorageIDIsNil  bool  `json:"dataStorageIDIsNil,omitempty"`
	DataStorageIDNotNil bool  `json:"dataStorageIDNotNil,omitempty"`

	// "external_id" field predicates.
	ExternalID             *string  `json:"externalID,omitempty"`
	ExternalIDNEQ          *string  `json:"externalIDNEQ,omitempty"`
	ExternalIDIn           []string `json:"externalIDIn,omitempty"`
	ExternalIDNotIn        []string `json:"externalIDNotIn,omitempty"`
	ExternalIDGT           *string  `json:"externalIDGT,omitempty"`
	ExternalIDGTE          *string  `json:"externalIDGTE,omitempty"`
	ExternalIDLT           *string  `json:"externalIDLT,omitempty"`
	ExternalIDLTE          *string  `json:"externalIDLTE,omitempty"`
	ExternalIDContains     *string  `json:"externalIDContains,omitempty"`
	ExternalIDHasPrefix    *string  `json:"externalIDHasPrefix,omitempty"`
	ExternalIDHasSuffix    *string  `json:"externalIDHasSuffix,omitempty"`
	ExternalIDIsNil        bool     `json:"externalIDIsNil,omitempty"`
	ExternalIDNotNil       bool     `json:"externalIDNotNil,omitempty"`
	ExternalIDEqualFold    *string  `json:"externalIDEqualFold,omitempty"`
	ExternalIDContainsFold *string  `json:"externalIDContainsFold,omitempty"`

	// "model_id" field predicates.
	ModelID             *string  `json:"modelID,omitempty"`
	ModelIDNEQ          *string  `json:"modelIDNEQ,omitempty"`
	ModelIDIn           []string `json:"modelIDIn,omitempty"`
	ModelIDNotIn        []string `json:"modelIDNotIn,omitempty"`
	ModelIDGT           *string  `json:"modelIDGT,omitempty"`
	ModelIDGTE          *string  `json:"modelIDGTE,omitempty"`
	ModelIDLT           *string  `json:"modelIDLT,omitempty"`
	ModelIDLTE          *string  `json:"modelIDLTE,omitempty"`
	ModelIDContains     *string  `json:"modelIDContains,omitempty"`
	ModelIDHasPrefix    *string  `json:"modelIDHasPrefix,omitempty"`
	ModelIDHasSuffix    *string  `json:"modelIDHasSuffix,omitempty"`
	ModelIDEqualFold    *string  `json:"modelIDEqualFold,omitempty"`
	ModelIDContainsFold *string  `json:"modelIDContainsFold,omitempty"`

	// "format" field predicates.
	Format             *string  `json:"format,omitempty"`
	FormatNEQ          *string  `json:"formatNEQ,omitempty"`
	FormatIn           []string `json:"formatIn,omitempty"`
	FormatNotIn        []string `json:"formatNotIn,omitempty"`
	FormatGT           *string  `json:"formatGT,omitempty"`
	FormatGTE          *string  `json:"formatGTE,omitempty"`
	FormatLT           *string  `json:"formatLT,omitempty"`
	FormatLTE          *string  `json:"formatLTE,omitempty"`
	FormatContains     *string  `json:"formatContains,omitempty"`
	FormatHasPrefix    *string  `json:"formatHasPrefix,omitempty"`
	FormatHasSuffix    *string  `json:"formatHasSuffix,omitempty"`
	FormatEqualFold    *string  `json:"formatEqualFold,omitempty"`
	FormatContainsFold *string  `json:"formatContainsFold,omitempty"`

	// "error_message" field predicates.
	ErrorMessage             *string  `json:"errorMessage,omitempty"`
	ErrorMessageNEQ          *string  `json:"errorMessageNEQ,omitempty"`
	ErrorMessageIn           []string `json:"errorMessageIn,omitempty"`
	ErrorMessageNotIn        []string `json:"errorMessageNotIn,omitempty"`
	ErrorMessageGT           *string  `json:"errorMessageGT,omitempty"`
	ErrorMessageGTE          *string  `json:"errorMessageGTE,omitempty"`
	ErrorMessageLT           *string  `json:"errorMessageLT,omitempty"`
	ErrorMessageLTE          *string  `json:"errorMessageLTE,omitempty"`
	ErrorMessageContains     *string  `json:"errorMessageContains,omitempty"`
	ErrorMessageHasPrefix    *string  `json:"errorMessageHasPrefix,omitempty"`
	ErrorMessageHasSuffix    *string  `json:"errorMessageHasSuffix,omitempty"`
	ErrorMessageIsNil        bool     `json:"errorMessageIsNil,omitempty"`
	ErrorMessageNotNil       bool     `json:"errorMessageNotNil,omitempty"`
	ErrorMessageEqualFold    *string  `json:"errorMessageEqualFold,omitempty"`
	ErrorMessageContainsFold *string  `json:"errorMessageContainsFold,omitempty"`

	// "status" field predicates.
	Status      *requestexecution.Status  `json:"status,omitempty"`
	StatusNEQ   *requestexecution.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []requestexecution.Status `json:"statusIn,omitempty"`
	StatusNotIn []requestexecution.Status `json:"statusNotIn,omitempty"`

	// "stream" field predicates.
	Stream    *bool `json:"stream,omitempty"`
	StreamNEQ *bool `json:"streamNEQ,omitempty"`

	// "metrics_latency_ms" field predicates.
	MetricsLatencyMs       *int64  `json:"metricsLatencyMs,omitempty"`
	MetricsLatencyMsNEQ    *int64  `json:"metricsLatencyMsNEQ,omitempty"`
	MetricsLatencyMsIn     []int64 `json:"metricsLatencyMsIn,omitempty"`
	MetricsLatencyMsNotIn  []int64 `json:"metricsLatencyMsNotIn,omitempty"`
	MetricsLatencyMsGT     *int64  `json:"metricsLatencyMsGT,omitempty"`
	MetricsLatencyMsGTE    *int64  `json:"metricsLatencyMsGTE,omitempty"`
	MetricsLatencyMsLT     *int64  `json:"metricsLatencyMsLT,omitempty"`
	MetricsLatencyMsLTE    *int64  `json:"metricsLatencyMsLTE,omitempty"`
	MetricsLatencyMsIsNil  bool    `json:"metricsLatencyMsIsNil,omitempty"`
	MetricsLatencyMsNotNil bool    `json:"metricsLatencyMsNotNil,omitempty"`

	// "metrics_first_token_latency_ms" field predicates.
	MetricsFirstTokenLatencyMs       *int64  `json:"metricsFirstTokenLatencyMs,omitempty"`
	MetricsFirstTokenLatencyMsNEQ    *int64  `json:"metricsFirstTokenLatencyMsNEQ,omitempty"`
	MetricsFirstTokenLatencyMsIn     []int64 `json:"metricsFirstTokenLatencyMsIn,omitempty"`
	MetricsFirstTokenLatencyMsNotIn  []int64 `json:"metricsFirstTokenLatencyMsNotIn,omitempty"`
	MetricsFirstTokenLatencyMsGT     *int64  `json:"metricsFirstTokenLatencyMsGT,omitempty"`
	MetricsFirstTokenLatencyMsGTE    *int64  `json:"metricsFirstTokenLatencyMsGTE,omitempty"`
	MetricsFirstTokenLatencyMsLT     *int64  `json:"metricsFirstTokenLatencyMsLT,omitempty"`
	MetricsFirstTokenLatencyMsLTE    *int64  `json:"metricsFirstTokenLatencyMsLTE,omitempty"`
	MetricsFirstTokenLatencyMsIsNil  bool    `json:"metricsFirstTokenLatencyMsIsNil,omitempty"`
	MetricsFirstTokenLatencyMsNotNil bool    `json:"metricsFirstTokenLatencyMsNotNil,omitempty"`

	// "request" edge predicates.
	HasRequest     *bool                `json:"hasRequest,omitempty"`
	HasRequestWith []*RequestWhereInput `json:"hasRequestWith,omitempty"`

	// "channel" edge predicates.
	HasChannel     *bool                `json:"hasChannel,omitempty"`
	HasChannelWith []*ChannelWhereInput `json:"hasChannelWith,omitempty"`

	// "data_storage" edge predicates.
	HasDataStorage     *bool                    `json:"hasDataStorage,omitempty"`
	HasDataStorageWith []*DataStorageWhereInput `json:"hasDataStorageWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *RequestExecutionWhereInput) AddPredicates(predicates ...predicate.RequestExecution) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the RequestExecutionWhereInput filter on the RequestExecutionQuery builder.
func (i *RequestExecutionWhereInput) Filter(q *RequestExecutionQuery) (*RequestExecutionQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyRequestExecutionWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyRequestExecutionWhereInput is returned in case the RequestExecutionWhereInput is empty.
var ErrEmptyRequestExecutionWhereInput = errors.New("ent: empty predicate RequestExecutionWhereInput")

// P returns a predicate for filtering requestexecutions.
// An error is returned if the input is empty or invalid.
func (i *RequestExecutionWhereInput) P() (predicate.RequestExecution, error) {
	var predicates []predicate.RequestExecution
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, requestexecution.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.RequestExecution, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, requestexecution.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.RequestExecution, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, requestexecution.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, requestexecution.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, requestexecution.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, requestexecution.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, requestexecution.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, requestexecution.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, requestexecution.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, requestexecution.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, requestexecution.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, requestexecution.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, requestexecution.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, requestexecution.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, requestexecution.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, requestexecution.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, requestexecution.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, requestexecution.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, requestexecution.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, requestexecution.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, requestexecution.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, requestexecution.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, requestexecution.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, requestexecution.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, requestexecution.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, requestexecution.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, requestexecution.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.ProjectID != nil {
		predicates = append(predicates, requestexecution.ProjectIDEQ(*i.ProjectID))
	}
	if i.ProjectIDNEQ != nil {
		predicates = append(predicates, requestexecution.ProjectIDNEQ(*i.ProjectIDNEQ))
	}
	if len(i.ProjectIDIn) > 0 {
		predicates = append(predicates, requestexecution.ProjectIDIn(i.ProjectIDIn...))
	}
	if len(i.ProjectIDNotIn) > 0 {
		predicates = append(predicates, requestexecution.ProjectIDNotIn(i.ProjectIDNotIn...))
	}
	if i.ProjectIDGT != nil {
		predicates = append(predicates, requestexecution.ProjectIDGT(*i.ProjectIDGT))
	}
	if i.ProjectIDGTE != nil {
		predicates = append(predicates, requestexecution.ProjectIDGTE(*i.ProjectIDGTE))
	}
	if i.ProjectIDLT != nil {
		predicates = append(predicates, requestexecution.ProjectIDLT(*i.ProjectIDLT))
	}
	if i.ProjectIDLTE != nil {
		predicates = append(predicates, requestexecution.ProjectIDLTE(*i.ProjectIDLTE))
	}
	if i.RequestID != nil {
		predicates = append(predicates, requestexecution.RequestIDEQ(*i.RequestID))
	}
	if i.RequestIDNEQ != nil {
		predicates = append(predicates, requestexecution.RequestIDNEQ(*i.RequestIDNEQ))
	}
	if len(i.RequestIDIn) > 0 {
		predicates = append(predicates, requestexecution.RequestIDIn(i.RequestIDIn...))
	}
	if len(i.RequestIDNotIn) > 0 {
		predicates = append(predicates, requestexecution.RequestIDNotIn(i.RequestIDNotIn...))
	}
	if i.ChannelID != nil {
		predicates = append(predicates, requestexecution.ChannelIDEQ(*i.ChannelID))
	}
	if i.ChannelIDNEQ != nil {
		predicates = append(predicates, requestexecution.ChannelIDNEQ(*i.ChannelIDNEQ))
	}
	if len(i.ChannelIDIn) > 0 {
		predicates = append(predicates, requestexecution.ChannelIDIn(i.ChannelIDIn...))
	}
	if len(i.ChannelIDNotIn) > 0 {
		predicates = append(predicates, requestexecution.ChannelIDNotIn(i.ChannelIDNotIn...))
	}
	if i.ChannelIDIsNil {
		predicates = append(predicates, requestexecution.ChannelIDIsNil())
	}
	if i.ChannelIDNotNil {
		predicates = append(predicates, requestexecution.ChannelIDNotNil())
	}
	if i.DataStorageID != nil {
		predicates = append(predicates, requestexecution.DataStorageIDEQ(*i.DataStorageID))
	}
	if i.DataStorageIDNEQ != nil {
		predicates = append(predicates, requestexecution.DataStorageIDNEQ(*i.DataStorageIDNEQ))
	}
	if len(i.DataStorageIDIn) > 0 {
		predicates = append(predicates, requestexecution.DataStorageIDIn(i.DataStorageIDIn...))
	}
	if len(i.DataStorageIDNotIn) > 0 {
		predicates = append(predicates, requestexecution.DataStorageIDNotIn(i.DataStorageIDNotIn...))
	}
	if i.DataStorageIDIsNil {
		predicates = append(predicates, requestexecution.DataStorageIDIsNil())
	}
	if i.DataStorageIDNotNil {
		predicates = append(predicates, requestexecution.DataStorageIDNotNil())
	}
	if i.ExternalID != nil {
		predicates = append(predicates, requestexecution.ExternalIDEQ(*i.ExternalID))
	}
	if i.ExternalIDNEQ != nil {
		predicates = append(predicates, requestexecution.ExternalIDNEQ(*i.ExternalIDNEQ))
	}
	if len(i.ExternalIDIn) > 0 {
		predicates = append(predicates, requestexecution.ExternalIDIn(i.ExternalIDIn...))
	}
	if len(i.ExternalIDNotIn) > 0 {
		predicates = append(predicates, requestexecution.ExternalIDNotIn(i.ExternalIDNotIn...))
	}
	if i.ExternalIDGT != nil {
		predicates = append(predicates, requestexecution.ExternalIDGT(*i.ExternalIDGT))
	}
	if i.ExternalIDGTE != nil {
		predicates = append(predicates, requestexecution.ExternalIDGTE(*i.ExternalIDGTE))
	}
	if i.ExternalIDLT != nil {
		predicates = append(predicates, requestexecution.ExternalIDLT(*i.ExternalIDLT))
	}
	if i.ExternalIDLTE != nil {
		predicates = append(predicates, requestexecution.ExternalIDLTE(*i.ExternalIDLTE))
	}
	if i.ExternalIDContains != nil {
		predicates = append(predicates, requestexecution.ExternalIDContains(*i.ExternalIDContains))
	}
	if i.ExternalIDHasPrefix != nil {
		predicates = append(predicates, requestexecution.ExternalIDHasPrefix(*i.ExternalIDHasPrefix))
	}
	if i.ExternalIDHasSuffix != nil {
		predicates = append(predicates, requestexecution.ExternalIDHasSuffix(*i.ExternalIDHasSuffix))
	}
	if i.ExternalIDIsNil {
		predicates = append(predicates, requestexecution.ExternalIDIsNil())
	}
	if i.ExternalIDNotNil {
		predicates = append(predicates, requestexecution.ExternalIDNotNil())
	}
	if i.ExternalIDEqualFold != nil {
		predicates = append(predicates, requestexecution.ExternalIDEqualFold(*i.ExternalIDEqualFold))
	}
	if i.ExternalIDContainsFold != nil {
		predicates = append(predicates, requestexecution.ExternalIDContainsFold(*i.ExternalIDContainsFold))
	}
	if i.ModelID != nil {
		predicates = append(predicates, requestexecution.ModelIDEQ(*i.ModelID))
	}
	if i.ModelIDNEQ != nil {
		predicates = append(predicates, requestexecution.ModelIDNEQ(*i.ModelIDNEQ))
	}
	if len(i.ModelIDIn) > 0 {
		predicates = append(predicates, requestexecution.ModelIDIn(i.ModelIDIn...))
	}
	if len(i.ModelIDNotIn) > 0 {
		predicates = append(predicates, requestexecution.ModelIDNotIn(i.ModelIDNotIn...))
	}
	if i.ModelIDGT != nil {
		predicates = append(predicates, requestexecution.ModelIDGT(*i.ModelIDGT))
	}
	if i.ModelIDGTE != nil {
		predicates = append(predicates, requestexecution.ModelIDGTE(*i.ModelIDGTE))
	}
	if i.ModelIDLT != nil {
		predicates = append(predicates, requestexecution.ModelIDLT(*i.ModelIDLT))
	}
	if i.ModelIDLTE != nil {
		predicates = append(predicates, requestexecution.ModelIDLTE(*i.ModelIDLTE))
	}
	if i.ModelIDContains != nil {
		predicates = append(predicates, requestexecution.ModelIDContains(*i.ModelIDContains))
	}
	if i.ModelIDHasPrefix != nil {
		predicates = append(predicates, requestexecution.ModelIDHasPrefix(*i.ModelIDHasPrefix))
	}
	if i.ModelIDHasSuffix != nil {
		predicates = append(predicates, requestexecution.ModelIDHasSuffix(*i.ModelIDHasSuffix))
	}
	if i.ModelIDEqualFold != nil {
		predicates = append(predicates, requestexecution.ModelIDEqualFold(*i.ModelIDEqualFold))
	}
	if i.ModelIDContainsFold != nil {
		predicates = append(predicates, requestexecution.ModelIDContainsFold(*i.ModelIDContainsFold))
	}
	if i.Format != nil {
		predicates = append(predicates, requestexecution.FormatEQ(*i.Format))
	}
	if i.FormatNEQ != nil {
		predicates = append(predicates, requestexecution.FormatNEQ(*i.FormatNEQ))
	}
	if len(i.FormatIn) > 0 {
		predicates = append(predicates, requestexecution.FormatIn(i.FormatIn...))
	}
	if len(i.FormatNotIn) > 0 {
		predicates = append(predicates, requestexecution.FormatNotIn(i.FormatNotIn...))
	}
	if i.FormatGT != nil {
		predicates = append(predicates, requestexecution.FormatGT(*i.FormatGT))
	}
	if i.FormatGTE != nil {
		predicates = append(predicates, requestexecution.FormatGTE(*i.FormatGTE))
	}
	if i.FormatLT != nil {
		predicates = append(predicates, requestexecution.FormatLT(*i.FormatLT))
	}
	if i.FormatLTE != nil {
		predicates = append(predicates, requestexecution.FormatLTE(*i.FormatLTE))
	}
	if i.FormatContains != nil {
		predicates = append(predicates, requestexecution.FormatContains(*i.FormatContains))
	}
	if i.FormatHasPrefix != nil {
		predicates = append(predicates, requestexecution.FormatHasPrefix(*i.FormatHasPrefix))
	}
	if i.FormatHasSuffix != nil {
		predicates = append(predicates, requestexecution.FormatHasSuffix(*i.FormatHasSuffix))
	}
	if i.FormatEqualFold != nil {
		predicates = append(predicates, requestexecution.FormatEqualFold(*i.FormatEqualFold))
	}
	if i.FormatContainsFold != nil {
		predicates = append(predicates, requestexecution.FormatContainsFold(*i.FormatContainsFold))
	}
	if i.ErrorMessage != nil {
		predicates = append(predicates, requestexecution.ErrorMessageEQ(*i.ErrorMessage))
	}
	if i.ErrorMessageNEQ != nil {
		predicates = append(predicates, requestexecution.ErrorMessageNEQ(*i.ErrorMessageNEQ))
	}
	if len(i.ErrorMessageIn) > 0 {
		predicates = append(predicates, requestexecution.ErrorMessageIn(i.ErrorMessageIn...))
	}
	if len(i.ErrorMessageNotIn) > 0 {
		predicates = append(predicates, requestexecution.ErrorMessageNotIn(i.ErrorMessageNotIn...))
	}
	if i.ErrorMessageGT != nil {
		predicates = append(predicates, requestexecution.ErrorMessageGT(*i.ErrorMessageGT))
	}
	if i.ErrorMessageGTE != nil {
		predicates = append(predicates, requestexecution.ErrorMessageGTE(*i.ErrorMessageGTE))
	}
	if i.ErrorMessageLT != nil {
		predicates = append(predicates, requestexecution.ErrorMessageLT(*i.ErrorMessageLT))
	}
	if i.ErrorMessageLTE != nil {
		predicates = append(predicates, requestexecution.ErrorMessageLTE(*i.ErrorMessageLTE))
	}
	if i.ErrorMessageContains != nil {
		predicates = append(predicates, requestexecution.ErrorMessageContains(*i.ErrorMessageContains))
	}
	if i.ErrorMessageHasPrefix != nil {
		predicates = append(predicates, requestexecution.ErrorMessageHasPrefix(*i.ErrorMessageHasPrefix))
	}
	if i.ErrorMessageHasSuffix != nil {
		predicates = append(predicates, requestexecution.ErrorMessageHasSuffix(*i.ErrorMessageHasSuffix))
	}
	if i.ErrorMessageIsNil {
		predicates = append(predicates, requestexecution.ErrorMessageIsNil())
	}
	if i.ErrorMessageNotNil {
		predicates = append(predicates, requestexecution.ErrorMessageNotNil())
	}
	if i.ErrorMessageEqualFold != nil {
		predicates = append(predicates, requestexecution.ErrorMessageEqualFold(*i.ErrorMessageEqualFold))
	}
	if i.ErrorMessageContainsFold != nil {
		predicates = append(predicates, requestexecution.ErrorMessageContainsFold(*i.ErrorMessageContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, requestexecution.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, requestexecution.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, requestexecution.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, requestexecution.StatusNotIn(i.StatusNotIn...))
	}
	if i.Stream != nil {
		predicates = append(predicates, requestexecution.StreamEQ(*i.Stream))
	}
	if i.StreamNEQ != nil {
		predicates = append(predicates, requestexecution.StreamNEQ(*i.StreamNEQ))
	}
	if i.MetricsLatencyMs != nil {
		predicates = append(predicates, requestexecution.MetricsLatencyMsEQ(*i.MetricsLatencyMs))
	}
	if i.MetricsLatencyMsNEQ != nil {
		predicates = append(predicates, requestexecution.MetricsLatencyMsNEQ(*i.MetricsLatencyMsNEQ))
	}
	if len(i.MetricsLatencyMsIn) > 0 {
		predicates = append(predicates, requestexecution.MetricsLatencyMsIn(i.MetricsLatencyMsIn...))
	}
	if len(i.MetricsLatencyMsNotIn) > 0 {
		predicates = append(predicates, requestexecution.MetricsLatencyMsNotIn(i.MetricsLatencyMsNotIn...))
	}
	if i.MetricsLatencyMsGT != nil {
		predicates = append(predicates, requestexecution.MetricsLatencyMsGT(*i.MetricsLatencyMsGT))
	}
	if i.MetricsLatencyMsGTE != nil {
		predicates = append(predicates, requestexecution.MetricsLatencyMsGTE(*i.MetricsLatencyMsGTE))
	}
	if i.MetricsLatencyMsLT != nil {
		predicates = append(predicates, requestexecution.MetricsLatencyMsLT(*i.MetricsLatencyMsLT))
	}
	if i.MetricsLatencyMsLTE != nil {
		predicates = append(predicates, requestexecution.MetricsLatencyMsLTE(*i.MetricsLatencyMsLTE))
	}
	if i.MetricsLatencyMsIsNil {
		predicates = append(predicates, requestexecution.MetricsLatencyMsIsNil())
	}
	if i.MetricsLatencyMsNotNil {
		predicates = append(predicates, requestexecution.MetricsLatencyMsNotNil())
	}
	if i.MetricsFirstTokenLatencyMs != nil {
		predicates = append(predicates, requestexecution.MetricsFirstTokenLatencyMsEQ(*i.MetricsFirstTokenLatencyMs))
	}
	if i.MetricsFirstTokenLatencyMsNEQ != nil {
		predicates = append(predicates, requestexecution.MetricsFirstTokenLatencyMsNEQ(*i.MetricsFirstTokenLatencyMsNEQ))
	}
	if len(i.MetricsFirstTokenLatencyMsIn) > 0 {
		predicates = append(predicates, requestexecution.MetricsFirstTokenLatencyMsIn(i.MetricsFirstTokenLatencyMsIn...))
	}
	if len(i.MetricsFirstTokenLatencyMsNotIn) > 0 {
		predicates = append(predicates, requestexecution.MetricsFirstTokenLatencyMsNotIn(i.MetricsFirstTokenLatencyMsNotIn...))
	}
	if i.MetricsFirstTokenLatencyMsGT != nil {
		predicates = append(predicates, requestexecution.MetricsFirstTokenLatencyMsGT(*i.MetricsFirstTokenLatencyMsGT))
	}
	if i.MetricsFirstTokenLatencyMsGTE != nil {
		predicates = append(predicates, requestexecution.MetricsFirstTokenLatencyMsGTE(*i.MetricsFirstTokenLatencyMsGTE))
	}
	if i.MetricsFirstTokenLatencyMsLT != nil {
		predicates = append(predicates, requestexecution.MetricsFirstTokenLatencyMsLT(*i.MetricsFirstTokenLatencyMsLT))
	}
	if i.MetricsFirstTokenLatencyMsLTE != nil {
		predicates = append(predicates, requestexecution.MetricsFirstTokenLatencyMsLTE(*i.MetricsFirstTokenLatencyMsLTE))
	}
	if i.MetricsFirstTokenLatencyMsIsNil {
		predicates = append(predicates, requestexecution.MetricsFirstTokenLatencyMsIsNil())
	}
	if i.MetricsFirstTokenLatencyMsNotNil {
		predicates = append(predicates, requestexecution.MetricsFirstTokenLatencyMsNotNil())
	}

	if i.HasRequest != nil {
		p := requestexecution.HasRequest()
		if !*i.HasRequest {
			p = requestexecution.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRequestWith) > 0 {
		with := make([]predicate.Request, 0, len(i.HasRequestWith))
		for _, w := range i.HasRequestWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRequestWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, requestexecution.HasRequestWith(with...))
	}
	if i.HasChannel != nil {
		p := requestexecution.HasChannel()
		if !*i.HasChannel {
			p = requestexecution.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasChannelWith) > 0 {
		with := make([]predicate.Channel, 0, len(i.HasChannelWith))
		for _, w := range i.HasChannelWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasChannelWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, requestexecution.HasChannelWith(with...))
	}
	if i.HasDataStorage != nil {
		p := requestexecution.HasDataStorage()
		if !*i.HasDataStorage {
			p = requestexecution.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDataStorageWith) > 0 {
		with := make([]predicate.DataStorage, 0, len(i.HasDataStorageWith))
		for _, w := range i.HasDataStorageWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDataStorageWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, requestexecution.HasDataStorageWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyRequestExecutionWhereInput
	case 1:
		return predicates[0], nil
	default:
		return requestexecution.And(predicates...), nil
	}
}

// RoleWhereInput represents a where input for filtering Role queries.
type RoleWhereInput struct {
	Predicates []predicate.Role  `json:"-"`
	Not        *RoleWhereInput   `json:"not,omitempty"`
	Or         []*RoleWhereInput `json:"or,omitempty"`
	And        []*RoleWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt      *int  `json:"deletedAt,omitempty"`
	DeletedAtNEQ   *int  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn    []int `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn []int `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT    *int  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE   *int  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT    *int  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE   *int  `json:"deletedAtLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "level" field predicates.
	Level      *role.Level  `json:"level,omitempty"`
	LevelNEQ   *role.Level  `json:"levelNEQ,omitempty"`
	LevelIn    []role.Level `json:"levelIn,omitempty"`
	LevelNotIn []role.Level `json:"levelNotIn,omitempty"`

	// "project_id" field predicates.
	ProjectID       *int  `json:"projectID,omitempty"`
	ProjectIDNEQ    *int  `json:"projectIDNEQ,omitempty"`
	ProjectIDIn     []int `json:"projectIDIn,omitempty"`
	ProjectIDNotIn  []int `json:"projectIDNotIn,omitempty"`
	ProjectIDIsNil  bool  `json:"projectIDIsNil,omitempty"`
	ProjectIDNotNil bool  `json:"projectIDNotNil,omitempty"`

	// "users" edge predicates.
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`

	// "project" edge predicates.
	HasProject     *bool                `json:"hasProject,omitempty"`
	HasProjectWith []*ProjectWhereInput `json:"hasProjectWith,omitempty"`

	// "user_roles" edge predicates.
	HasUserRoles     *bool                 `json:"hasUserRoles,omitempty"`
	HasUserRolesWith []*UserRoleWhereInput `json:"hasUserRolesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *RoleWhereInput) AddPredicates(predicates ...predicate.Role) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the RoleWhereInput filter on the RoleQuery builder.
func (i *RoleWhereInput) Filter(q *RoleQuery) (*RoleQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyRoleWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyRoleWhereInput is returned in case the RoleWhereInput is empty.
var ErrEmptyRoleWhereInput = errors.New("ent: empty predicate RoleWhereInput")

// P returns a predicate for filtering roles.
// An error is returned if the input is empty or invalid.
func (i *RoleWhereInput) P() (predicate.Role, error) {
	var predicates []predicate.Role
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, role.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Role, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, role.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Role, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, role.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, role.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, role.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, role.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, role.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, role.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, role.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, role.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, role.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, role.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, role.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, role.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, role.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, role.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, role.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, role.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, role.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, role.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, role.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, role.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, role.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, role.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, role.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, role.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, role.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, role.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, role.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, role.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, role.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, role.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, role.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, role.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, role.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, role.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, role.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, role.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, role.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, role.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, role.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, role.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, role.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, role.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, role.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, role.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, role.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, role.NameContainsFold(*i.NameContainsFold))
	}
	if i.Level != nil {
		predicates = append(predicates, role.LevelEQ(*i.Level))
	}
	if i.LevelNEQ != nil {
		predicates = append(predicates, role.LevelNEQ(*i.LevelNEQ))
	}
	if len(i.LevelIn) > 0 {
		predicates = append(predicates, role.LevelIn(i.LevelIn...))
	}
	if len(i.LevelNotIn) > 0 {
		predicates = append(predicates, role.LevelNotIn(i.LevelNotIn...))
	}
	if i.ProjectID != nil {
		predicates = append(predicates, role.ProjectIDEQ(*i.ProjectID))
	}
	if i.ProjectIDNEQ != nil {
		predicates = append(predicates, role.ProjectIDNEQ(*i.ProjectIDNEQ))
	}
	if len(i.ProjectIDIn) > 0 {
		predicates = append(predicates, role.ProjectIDIn(i.ProjectIDIn...))
	}
	if len(i.ProjectIDNotIn) > 0 {
		predicates = append(predicates, role.ProjectIDNotIn(i.ProjectIDNotIn...))
	}
	if i.ProjectIDIsNil {
		predicates = append(predicates, role.ProjectIDIsNil())
	}
	if i.ProjectIDNotNil {
		predicates = append(predicates, role.ProjectIDNotNil())
	}

	if i.HasUsers != nil {
		p := role.HasUsers()
		if !*i.HasUsers {
			p = role.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUsersWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUsersWith))
		for _, w := range i.HasUsersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUsersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, role.HasUsersWith(with...))
	}
	if i.HasProject != nil {
		p := role.HasProject()
		if !*i.HasProject {
			p = role.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProjectWith) > 0 {
		with := make([]predicate.Project, 0, len(i.HasProjectWith))
		for _, w := range i.HasProjectWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProjectWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, role.HasProjectWith(with...))
	}
	if i.HasUserRoles != nil {
		p := role.HasUserRoles()
		if !*i.HasUserRoles {
			p = role.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserRolesWith) > 0 {
		with := make([]predicate.UserRole, 0, len(i.HasUserRolesWith))
		for _, w := range i.HasUserRolesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserRolesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, role.HasUserRolesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyRoleWhereInput
	case 1:
		return predicates[0], nil
	default:
		return role.And(predicates...), nil
	}
}

// SystemWhereInput represents a where input for filtering System queries.
type SystemWhereInput struct {
	Predicates []predicate.System  `json:"-"`
	Not        *SystemWhereInput   `json:"not,omitempty"`
	Or         []*SystemWhereInput `json:"or,omitempty"`
	And        []*SystemWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt      *int  `json:"deletedAt,omitempty"`
	DeletedAtNEQ   *int  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn    []int `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn []int `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT    *int  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE   *int  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT    *int  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE   *int  `json:"deletedAtLTE,omitempty"`

	// "key" field predicates.
	Key             *string  `json:"key,omitempty"`
	KeyNEQ          *string  `json:"keyNEQ,omitempty"`
	KeyIn           []string `json:"keyIn,omitempty"`
	KeyNotIn        []string `json:"keyNotIn,omitempty"`
	KeyGT           *string  `json:"keyGT,omitempty"`
	KeyGTE          *string  `json:"keyGTE,omitempty"`
	KeyLT           *string  `json:"keyLT,omitempty"`
	KeyLTE          *string  `json:"keyLTE,omitempty"`
	KeyContains     *string  `json:"keyContains,omitempty"`
	KeyHasPrefix    *string  `json:"keyHasPrefix,omitempty"`
	KeyHasSuffix    *string  `json:"keyHasSuffix,omitempty"`
	KeyEqualFold    *string  `json:"keyEqualFold,omitempty"`
	KeyContainsFold *string  `json:"keyContainsFold,omitempty"`

	// "value" field predicates.
	Value             *string  `json:"value,omitempty"`
	ValueNEQ          *string  `json:"valueNEQ,omitempty"`
	ValueIn           []string `json:"valueIn,omitempty"`
	ValueNotIn        []string `json:"valueNotIn,omitempty"`
	ValueGT           *string  `json:"valueGT,omitempty"`
	ValueGTE          *string  `json:"valueGTE,omitempty"`
	ValueLT           *string  `json:"valueLT,omitempty"`
	ValueLTE          *string  `json:"valueLTE,omitempty"`
	ValueContains     *string  `json:"valueContains,omitempty"`
	ValueHasPrefix    *string  `json:"valueHasPrefix,omitempty"`
	ValueHasSuffix    *string  `json:"valueHasSuffix,omitempty"`
	ValueEqualFold    *string  `json:"valueEqualFold,omitempty"`
	ValueContainsFold *string  `json:"valueContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *SystemWhereInput) AddPredicates(predicates ...predicate.System) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the SystemWhereInput filter on the SystemQuery builder.
func (i *SystemWhereInput) Filter(q *SystemQuery) (*SystemQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptySystemWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptySystemWhereInput is returned in case the SystemWhereInput is empty.
var ErrEmptySystemWhereInput = errors.New("ent: empty predicate SystemWhereInput")

// P returns a predicate for filtering systems.
// An error is returned if the input is empty or invalid.
func (i *SystemWhereInput) P() (predicate.System, error) {
	var predicates []predicate.System
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, system.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.System, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, system.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.System, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, system.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, system.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, system.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, system.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, system.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, system.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, system.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, system.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, system.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, system.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, system.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, system.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, system.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, system.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, system.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, system.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, system.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, system.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, system.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, system.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, system.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, system.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, system.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, system.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, system.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, system.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, system.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, system.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, system.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, system.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, system.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, system.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, system.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.Key != nil {
		predicates = append(predicates, system.KeyEQ(*i.Key))
	}
	if i.KeyNEQ != nil {
		predicates = append(predicates, system.KeyNEQ(*i.KeyNEQ))
	}
	if len(i.KeyIn) > 0 {
		predicates = append(predicates, system.KeyIn(i.KeyIn...))
	}
	if len(i.KeyNotIn) > 0 {
		predicates = append(predicates, system.KeyNotIn(i.KeyNotIn...))
	}
	if i.KeyGT != nil {
		predicates = append(predicates, system.KeyGT(*i.KeyGT))
	}
	if i.KeyGTE != nil {
		predicates = append(predicates, system.KeyGTE(*i.KeyGTE))
	}
	if i.KeyLT != nil {
		predicates = append(predicates, system.KeyLT(*i.KeyLT))
	}
	if i.KeyLTE != nil {
		predicates = append(predicates, system.KeyLTE(*i.KeyLTE))
	}
	if i.KeyContains != nil {
		predicates = append(predicates, system.KeyContains(*i.KeyContains))
	}
	if i.KeyHasPrefix != nil {
		predicates = append(predicates, system.KeyHasPrefix(*i.KeyHasPrefix))
	}
	if i.KeyHasSuffix != nil {
		predicates = append(predicates, system.KeyHasSuffix(*i.KeyHasSuffix))
	}
	if i.KeyEqualFold != nil {
		predicates = append(predicates, system.KeyEqualFold(*i.KeyEqualFold))
	}
	if i.KeyContainsFold != nil {
		predicates = append(predicates, system.KeyContainsFold(*i.KeyContainsFold))
	}
	if i.Value != nil {
		predicates = append(predicates, system.ValueEQ(*i.Value))
	}
	if i.ValueNEQ != nil {
		predicates = append(predicates, system.ValueNEQ(*i.ValueNEQ))
	}
	if len(i.ValueIn) > 0 {
		predicates = append(predicates, system.ValueIn(i.ValueIn...))
	}
	if len(i.ValueNotIn) > 0 {
		predicates = append(predicates, system.ValueNotIn(i.ValueNotIn...))
	}
	if i.ValueGT != nil {
		predicates = append(predicates, system.ValueGT(*i.ValueGT))
	}
	if i.ValueGTE != nil {
		predicates = append(predicates, system.ValueGTE(*i.ValueGTE))
	}
	if i.ValueLT != nil {
		predicates = append(predicates, system.ValueLT(*i.ValueLT))
	}
	if i.ValueLTE != nil {
		predicates = append(predicates, system.ValueLTE(*i.ValueLTE))
	}
	if i.ValueContains != nil {
		predicates = append(predicates, system.ValueContains(*i.ValueContains))
	}
	if i.ValueHasPrefix != nil {
		predicates = append(predicates, system.ValueHasPrefix(*i.ValueHasPrefix))
	}
	if i.ValueHasSuffix != nil {
		predicates = append(predicates, system.ValueHasSuffix(*i.ValueHasSuffix))
	}
	if i.ValueEqualFold != nil {
		predicates = append(predicates, system.ValueEqualFold(*i.ValueEqualFold))
	}
	if i.ValueContainsFold != nil {
		predicates = append(predicates, system.ValueContainsFold(*i.ValueContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptySystemWhereInput
	case 1:
		return predicates[0], nil
	default:
		return system.And(predicates...), nil
	}
}

// ThreadWhereInput represents a where input for filtering Thread queries.
type ThreadWhereInput struct {
	Predicates []predicate.Thread  `json:"-"`
	Not        *ThreadWhereInput   `json:"not,omitempty"`
	Or         []*ThreadWhereInput `json:"or,omitempty"`
	And        []*ThreadWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "project_id" field predicates.
	ProjectID      *int  `json:"projectID,omitempty"`
	ProjectIDNEQ   *int  `json:"projectIDNEQ,omitempty"`
	ProjectIDIn    []int `json:"projectIDIn,omitempty"`
	ProjectIDNotIn []int `json:"projectIDNotIn,omitempty"`

	// "thread_id" field predicates.
	ThreadID             *string  `json:"threadID,omitempty"`
	ThreadIDNEQ          *string  `json:"threadIDNEQ,omitempty"`
	ThreadIDIn           []string `json:"threadIDIn,omitempty"`
	ThreadIDNotIn        []string `json:"threadIDNotIn,omitempty"`
	ThreadIDGT           *string  `json:"threadIDGT,omitempty"`
	ThreadIDGTE          *string  `json:"threadIDGTE,omitempty"`
	ThreadIDLT           *string  `json:"threadIDLT,omitempty"`
	ThreadIDLTE          *string  `json:"threadIDLTE,omitempty"`
	ThreadIDContains     *string  `json:"threadIDContains,omitempty"`
	ThreadIDHasPrefix    *string  `json:"threadIDHasPrefix,omitempty"`
	ThreadIDHasSuffix    *string  `json:"threadIDHasSuffix,omitempty"`
	ThreadIDEqualFold    *string  `json:"threadIDEqualFold,omitempty"`
	ThreadIDContainsFold *string  `json:"threadIDContainsFold,omitempty"`

	// "project" edge predicates.
	HasProject     *bool                `json:"hasProject,omitempty"`
	HasProjectWith []*ProjectWhereInput `json:"hasProjectWith,omitempty"`

	// "traces" edge predicates.
	HasTraces     *bool              `json:"hasTraces,omitempty"`
	HasTracesWith []*TraceWhereInput `json:"hasTracesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ThreadWhereInput) AddPredicates(predicates ...predicate.Thread) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ThreadWhereInput filter on the ThreadQuery builder.
func (i *ThreadWhereInput) Filter(q *ThreadQuery) (*ThreadQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyThreadWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyThreadWhereInput is returned in case the ThreadWhereInput is empty.
var ErrEmptyThreadWhereInput = errors.New("ent: empty predicate ThreadWhereInput")

// P returns a predicate for filtering threads.
// An error is returned if the input is empty or invalid.
func (i *ThreadWhereInput) P() (predicate.Thread, error) {
	var predicates []predicate.Thread
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, thread.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Thread, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, thread.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Thread, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, thread.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, thread.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, thread.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, thread.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, thread.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, thread.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, thread.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, thread.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, thread.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, thread.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, thread.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, thread.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, thread.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, thread.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, thread.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, thread.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, thread.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, thread.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, thread.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, thread.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, thread.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, thread.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, thread.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, thread.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, thread.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.ProjectID != nil {
		predicates = append(predicates, thread.ProjectIDEQ(*i.ProjectID))
	}
	if i.ProjectIDNEQ != nil {
		predicates = append(predicates, thread.ProjectIDNEQ(*i.ProjectIDNEQ))
	}
	if len(i.ProjectIDIn) > 0 {
		predicates = append(predicates, thread.ProjectIDIn(i.ProjectIDIn...))
	}
	if len(i.ProjectIDNotIn) > 0 {
		predicates = append(predicates, thread.ProjectIDNotIn(i.ProjectIDNotIn...))
	}
	if i.ThreadID != nil {
		predicates = append(predicates, thread.ThreadIDEQ(*i.ThreadID))
	}
	if i.ThreadIDNEQ != nil {
		predicates = append(predicates, thread.ThreadIDNEQ(*i.ThreadIDNEQ))
	}
	if len(i.ThreadIDIn) > 0 {
		predicates = append(predicates, thread.ThreadIDIn(i.ThreadIDIn...))
	}
	if len(i.ThreadIDNotIn) > 0 {
		predicates = append(predicates, thread.ThreadIDNotIn(i.ThreadIDNotIn...))
	}
	if i.ThreadIDGT != nil {
		predicates = append(predicates, thread.ThreadIDGT(*i.ThreadIDGT))
	}
	if i.ThreadIDGTE != nil {
		predicates = append(predicates, thread.ThreadIDGTE(*i.ThreadIDGTE))
	}
	if i.ThreadIDLT != nil {
		predicates = append(predicates, thread.ThreadIDLT(*i.ThreadIDLT))
	}
	if i.ThreadIDLTE != nil {
		predicates = append(predicates, thread.ThreadIDLTE(*i.ThreadIDLTE))
	}
	if i.ThreadIDContains != nil {
		predicates = append(predicates, thread.ThreadIDContains(*i.ThreadIDContains))
	}
	if i.ThreadIDHasPrefix != nil {
		predicates = append(predicates, thread.ThreadIDHasPrefix(*i.ThreadIDHasPrefix))
	}
	if i.ThreadIDHasSuffix != nil {
		predicates = append(predicates, thread.ThreadIDHasSuffix(*i.ThreadIDHasSuffix))
	}
	if i.ThreadIDEqualFold != nil {
		predicates = append(predicates, thread.ThreadIDEqualFold(*i.ThreadIDEqualFold))
	}
	if i.ThreadIDContainsFold != nil {
		predicates = append(predicates, thread.ThreadIDContainsFold(*i.ThreadIDContainsFold))
	}

	if i.HasProject != nil {
		p := thread.HasProject()
		if !*i.HasProject {
			p = thread.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProjectWith) > 0 {
		with := make([]predicate.Project, 0, len(i.HasProjectWith))
		for _, w := range i.HasProjectWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProjectWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, thread.HasProjectWith(with...))
	}
	if i.HasTraces != nil {
		p := thread.HasTraces()
		if !*i.HasTraces {
			p = thread.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTracesWith) > 0 {
		with := make([]predicate.Trace, 0, len(i.HasTracesWith))
		for _, w := range i.HasTracesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTracesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, thread.HasTracesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyThreadWhereInput
	case 1:
		return predicates[0], nil
	default:
		return thread.And(predicates...), nil
	}
}

// TraceWhereInput represents a where input for filtering Trace queries.
type TraceWhereInput struct {
	Predicates []predicate.Trace  `json:"-"`
	Not        *TraceWhereInput   `json:"not,omitempty"`
	Or         []*TraceWhereInput `json:"or,omitempty"`
	And        []*TraceWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "project_id" field predicates.
	ProjectID      *int  `json:"projectID,omitempty"`
	ProjectIDNEQ   *int  `json:"projectIDNEQ,omitempty"`
	ProjectIDIn    []int `json:"projectIDIn,omitempty"`
	ProjectIDNotIn []int `json:"projectIDNotIn,omitempty"`

	// "trace_id" field predicates.
	TraceID             *string  `json:"traceID,omitempty"`
	TraceIDNEQ          *string  `json:"traceIDNEQ,omitempty"`
	TraceIDIn           []string `json:"traceIDIn,omitempty"`
	TraceIDNotIn        []string `json:"traceIDNotIn,omitempty"`
	TraceIDGT           *string  `json:"traceIDGT,omitempty"`
	TraceIDGTE          *string  `json:"traceIDGTE,omitempty"`
	TraceIDLT           *string  `json:"traceIDLT,omitempty"`
	TraceIDLTE          *string  `json:"traceIDLTE,omitempty"`
	TraceIDContains     *string  `json:"traceIDContains,omitempty"`
	TraceIDHasPrefix    *string  `json:"traceIDHasPrefix,omitempty"`
	TraceIDHasSuffix    *string  `json:"traceIDHasSuffix,omitempty"`
	TraceIDEqualFold    *string  `json:"traceIDEqualFold,omitempty"`
	TraceIDContainsFold *string  `json:"traceIDContainsFold,omitempty"`

	// "thread_id" field predicates.
	ThreadID       *int  `json:"threadID,omitempty"`
	ThreadIDNEQ    *int  `json:"threadIDNEQ,omitempty"`
	ThreadIDIn     []int `json:"threadIDIn,omitempty"`
	ThreadIDNotIn  []int `json:"threadIDNotIn,omitempty"`
	ThreadIDIsNil  bool  `json:"threadIDIsNil,omitempty"`
	ThreadIDNotNil bool  `json:"threadIDNotNil,omitempty"`

	// "project" edge predicates.
	HasProject     *bool                `json:"hasProject,omitempty"`
	HasProjectWith []*ProjectWhereInput `json:"hasProjectWith,omitempty"`

	// "thread" edge predicates.
	HasThread     *bool               `json:"hasThread,omitempty"`
	HasThreadWith []*ThreadWhereInput `json:"hasThreadWith,omitempty"`

	// "requests" edge predicates.
	HasRequests     *bool                `json:"hasRequests,omitempty"`
	HasRequestsWith []*RequestWhereInput `json:"hasRequestsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *TraceWhereInput) AddPredicates(predicates ...predicate.Trace) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the TraceWhereInput filter on the TraceQuery builder.
func (i *TraceWhereInput) Filter(q *TraceQuery) (*TraceQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyTraceWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyTraceWhereInput is returned in case the TraceWhereInput is empty.
var ErrEmptyTraceWhereInput = errors.New("ent: empty predicate TraceWhereInput")

// P returns a predicate for filtering traces.
// An error is returned if the input is empty or invalid.
func (i *TraceWhereInput) P() (predicate.Trace, error) {
	var predicates []predicate.Trace
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, trace.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Trace, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, trace.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Trace, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, trace.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, trace.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, trace.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, trace.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, trace.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, trace.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, trace.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, trace.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, trace.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, trace.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, trace.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, trace.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, trace.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, trace.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, trace.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, trace.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, trace.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, trace.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, trace.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, trace.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, trace.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, trace.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, trace.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, trace.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, trace.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.ProjectID != nil {
		predicates = append(predicates, trace.ProjectIDEQ(*i.ProjectID))
	}
	if i.ProjectIDNEQ != nil {
		predicates = append(predicates, trace.ProjectIDNEQ(*i.ProjectIDNEQ))
	}
	if len(i.ProjectIDIn) > 0 {
		predicates = append(predicates, trace.ProjectIDIn(i.ProjectIDIn...))
	}
	if len(i.ProjectIDNotIn) > 0 {
		predicates = append(predicates, trace.ProjectIDNotIn(i.ProjectIDNotIn...))
	}
	if i.TraceID != nil {
		predicates = append(predicates, trace.TraceIDEQ(*i.TraceID))
	}
	if i.TraceIDNEQ != nil {
		predicates = append(predicates, trace.TraceIDNEQ(*i.TraceIDNEQ))
	}
	if len(i.TraceIDIn) > 0 {
		predicates = append(predicates, trace.TraceIDIn(i.TraceIDIn...))
	}
	if len(i.TraceIDNotIn) > 0 {
		predicates = append(predicates, trace.TraceIDNotIn(i.TraceIDNotIn...))
	}
	if i.TraceIDGT != nil {
		predicates = append(predicates, trace.TraceIDGT(*i.TraceIDGT))
	}
	if i.TraceIDGTE != nil {
		predicates = append(predicates, trace.TraceIDGTE(*i.TraceIDGTE))
	}
	if i.TraceIDLT != nil {
		predicates = append(predicates, trace.TraceIDLT(*i.TraceIDLT))
	}
	if i.TraceIDLTE != nil {
		predicates = append(predicates, trace.TraceIDLTE(*i.TraceIDLTE))
	}
	if i.TraceIDContains != nil {
		predicates = append(predicates, trace.TraceIDContains(*i.TraceIDContains))
	}
	if i.TraceIDHasPrefix != nil {
		predicates = append(predicates, trace.TraceIDHasPrefix(*i.TraceIDHasPrefix))
	}
	if i.TraceIDHasSuffix != nil {
		predicates = append(predicates, trace.TraceIDHasSuffix(*i.TraceIDHasSuffix))
	}
	if i.TraceIDEqualFold != nil {
		predicates = append(predicates, trace.TraceIDEqualFold(*i.TraceIDEqualFold))
	}
	if i.TraceIDContainsFold != nil {
		predicates = append(predicates, trace.TraceIDContainsFold(*i.TraceIDContainsFold))
	}
	if i.ThreadID != nil {
		predicates = append(predicates, trace.ThreadIDEQ(*i.ThreadID))
	}
	if i.ThreadIDNEQ != nil {
		predicates = append(predicates, trace.ThreadIDNEQ(*i.ThreadIDNEQ))
	}
	if len(i.ThreadIDIn) > 0 {
		predicates = append(predicates, trace.ThreadIDIn(i.ThreadIDIn...))
	}
	if len(i.ThreadIDNotIn) > 0 {
		predicates = append(predicates, trace.ThreadIDNotIn(i.ThreadIDNotIn...))
	}
	if i.ThreadIDIsNil {
		predicates = append(predicates, trace.ThreadIDIsNil())
	}
	if i.ThreadIDNotNil {
		predicates = append(predicates, trace.ThreadIDNotNil())
	}

	if i.HasProject != nil {
		p := trace.HasProject()
		if !*i.HasProject {
			p = trace.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProjectWith) > 0 {
		with := make([]predicate.Project, 0, len(i.HasProjectWith))
		for _, w := range i.HasProjectWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProjectWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, trace.HasProjectWith(with...))
	}
	if i.HasThread != nil {
		p := trace.HasThread()
		if !*i.HasThread {
			p = trace.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasThreadWith) > 0 {
		with := make([]predicate.Thread, 0, len(i.HasThreadWith))
		for _, w := range i.HasThreadWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasThreadWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, trace.HasThreadWith(with...))
	}
	if i.HasRequests != nil {
		p := trace.HasRequests()
		if !*i.HasRequests {
			p = trace.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRequestsWith) > 0 {
		with := make([]predicate.Request, 0, len(i.HasRequestsWith))
		for _, w := range i.HasRequestsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRequestsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, trace.HasRequestsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyTraceWhereInput
	case 1:
		return predicates[0], nil
	default:
		return trace.And(predicates...), nil
	}
}

// UsageLogWhereInput represents a where input for filtering UsageLog queries.
type UsageLogWhereInput struct {
	Predicates []predicate.UsageLog  `json:"-"`
	Not        *UsageLogWhereInput   `json:"not,omitempty"`
	Or         []*UsageLogWhereInput `json:"or,omitempty"`
	And        []*UsageLogWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "request_id" field predicates.
	RequestID      *int  `json:"requestID,omitempty"`
	RequestIDNEQ   *int  `json:"requestIDNEQ,omitempty"`
	RequestIDIn    []int `json:"requestIDIn,omitempty"`
	RequestIDNotIn []int `json:"requestIDNotIn,omitempty"`

	// "api_key_id" field predicates.
	APIKeyID       *int  `json:"apiKeyID,omitempty"`
	APIKeyIDNEQ    *int  `json:"apiKeyIDNEQ,omitempty"`
	APIKeyIDIn     []int `json:"apiKeyIDIn,omitempty"`
	APIKeyIDNotIn  []int `json:"apiKeyIDNotIn,omitempty"`
	APIKeyIDGT     *int  `json:"apiKeyIDGT,omitempty"`
	APIKeyIDGTE    *int  `json:"apiKeyIDGTE,omitempty"`
	APIKeyIDLT     *int  `json:"apiKeyIDLT,omitempty"`
	APIKeyIDLTE    *int  `json:"apiKeyIDLTE,omitempty"`
	APIKeyIDIsNil  bool  `json:"apiKeyIDIsNil,omitempty"`
	APIKeyIDNotNil bool  `json:"apiKeyIDNotNil,omitempty"`

	// "project_id" field predicates.
	ProjectID      *int  `json:"projectID,omitempty"`
	ProjectIDNEQ   *int  `json:"projectIDNEQ,omitempty"`
	ProjectIDIn    []int `json:"projectIDIn,omitempty"`
	ProjectIDNotIn []int `json:"projectIDNotIn,omitempty"`

	// "channel_id" field predicates.
	ChannelID       *int  `json:"channelID,omitempty"`
	ChannelIDNEQ    *int  `json:"channelIDNEQ,omitempty"`
	ChannelIDIn     []int `json:"channelIDIn,omitempty"`
	ChannelIDNotIn  []int `json:"channelIDNotIn,omitempty"`
	ChannelIDIsNil  bool  `json:"channelIDIsNil,omitempty"`
	ChannelIDNotNil bool  `json:"channelIDNotNil,omitempty"`

	// "model_id" field predicates.
	ModelID             *string  `json:"modelID,omitempty"`
	ModelIDNEQ          *string  `json:"modelIDNEQ,omitempty"`
	ModelIDIn           []string `json:"modelIDIn,omitempty"`
	ModelIDNotIn        []string `json:"modelIDNotIn,omitempty"`
	ModelIDGT           *string  `json:"modelIDGT,omitempty"`
	ModelIDGTE          *string  `json:"modelIDGTE,omitempty"`
	ModelIDLT           *string  `json:"modelIDLT,omitempty"`
	ModelIDLTE          *string  `json:"modelIDLTE,omitempty"`
	ModelIDContains     *string  `json:"modelIDContains,omitempty"`
	ModelIDHasPrefix    *string  `json:"modelIDHasPrefix,omitempty"`
	ModelIDHasSuffix    *string  `json:"modelIDHasSuffix,omitempty"`
	ModelIDEqualFold    *string  `json:"modelIDEqualFold,omitempty"`
	ModelIDContainsFold *string  `json:"modelIDContainsFold,omitempty"`

	// "prompt_tokens" field predicates.
	PromptTokens      *int64  `json:"promptTokens,omitempty"`
	PromptTokensNEQ   *int64  `json:"promptTokensNEQ,omitempty"`
	PromptTokensIn    []int64 `json:"promptTokensIn,omitempty"`
	PromptTokensNotIn []int64 `json:"promptTokensNotIn,omitempty"`
	PromptTokensGT    *int64  `json:"promptTokensGT,omitempty"`
	PromptTokensGTE   *int64  `json:"promptTokensGTE,omitempty"`
	PromptTokensLT    *int64  `json:"promptTokensLT,omitempty"`
	PromptTokensLTE   *int64  `json:"promptTokensLTE,omitempty"`

	// "completion_tokens" field predicates.
	CompletionTokens      *int64  `json:"completionTokens,omitempty"`
	CompletionTokensNEQ   *int64  `json:"completionTokensNEQ,omitempty"`
	CompletionTokensIn    []int64 `json:"completionTokensIn,omitempty"`
	CompletionTokensNotIn []int64 `json:"completionTokensNotIn,omitempty"`
	CompletionTokensGT    *int64  `json:"completionTokensGT,omitempty"`
	CompletionTokensGTE   *int64  `json:"completionTokensGTE,omitempty"`
	CompletionTokensLT    *int64  `json:"completionTokensLT,omitempty"`
	CompletionTokensLTE   *int64  `json:"completionTokensLTE,omitempty"`

	// "total_tokens" field predicates.
	TotalTokens      *int64  `json:"totalTokens,omitempty"`
	TotalTokensNEQ   *int64  `json:"totalTokensNEQ,omitempty"`
	TotalTokensIn    []int64 `json:"totalTokensIn,omitempty"`
	TotalTokensNotIn []int64 `json:"totalTokensNotIn,omitempty"`
	TotalTokensGT    *int64  `json:"totalTokensGT,omitempty"`
	TotalTokensGTE   *int64  `json:"totalTokensGTE,omitempty"`
	TotalTokensLT    *int64  `json:"totalTokensLT,omitempty"`
	TotalTokensLTE   *int64  `json:"totalTokensLTE,omitempty"`

	// "prompt_audio_tokens" field predicates.
	PromptAudioTokens      *int64  `json:"promptAudioTokens,omitempty"`
	PromptAudioTokensNEQ   *int64  `json:"promptAudioTokensNEQ,omitempty"`
	PromptAudioTokensIn    []int64 `json:"promptAudioTokensIn,omitempty"`
	PromptAudioTokensNotIn []int64 `json:"promptAudioTokensNotIn,omitempty"`
	PromptAudioTokensGT    *int64  `json:"promptAudioTokensGT,omitempty"`
	PromptAudioTokensGTE   *int64  `json:"promptAudioTokensGTE,omitempty"`
	PromptAudioTokensLT    *int64  `json:"promptAudioTokensLT,omitempty"`
	PromptAudioTokensLTE   *int64  `json:"promptAudioTokensLTE,omitempty"`

	// "prompt_cached_tokens" field predicates.
	PromptCachedTokens      *int64  `json:"promptCachedTokens,omitempty"`
	PromptCachedTokensNEQ   *int64  `json:"promptCachedTokensNEQ,omitempty"`
	PromptCachedTokensIn    []int64 `json:"promptCachedTokensIn,omitempty"`
	PromptCachedTokensNotIn []int64 `json:"promptCachedTokensNotIn,omitempty"`
	PromptCachedTokensGT    *int64  `json:"promptCachedTokensGT,omitempty"`
	PromptCachedTokensGTE   *int64  `json:"promptCachedTokensGTE,omitempty"`
	PromptCachedTokensLT    *int64  `json:"promptCachedTokensLT,omitempty"`
	PromptCachedTokensLTE   *int64  `json:"promptCachedTokensLTE,omitempty"`

	// "prompt_write_cached_tokens" field predicates.
	PromptWriteCachedTokens       *int64  `json:"promptWriteCachedTokens,omitempty"`
	PromptWriteCachedTokensNEQ    *int64  `json:"promptWriteCachedTokensNEQ,omitempty"`
	PromptWriteCachedTokensIn     []int64 `json:"promptWriteCachedTokensIn,omitempty"`
	PromptWriteCachedTokensNotIn  []int64 `json:"promptWriteCachedTokensNotIn,omitempty"`
	PromptWriteCachedTokensGT     *int64  `json:"promptWriteCachedTokensGT,omitempty"`
	PromptWriteCachedTokensGTE    *int64  `json:"promptWriteCachedTokensGTE,omitempty"`
	PromptWriteCachedTokensLT     *int64  `json:"promptWriteCachedTokensLT,omitempty"`
	PromptWriteCachedTokensLTE    *int64  `json:"promptWriteCachedTokensLTE,omitempty"`
	PromptWriteCachedTokensIsNil  bool    `json:"promptWriteCachedTokensIsNil,omitempty"`
	PromptWriteCachedTokensNotNil bool    `json:"promptWriteCachedTokensNotNil,omitempty"`

	// "prompt_write_cached_tokens_5m" field predicates.
	PromptWriteCachedTokens5m       *int64  `json:"promptWriteCachedTokens5m,omitempty"`
	PromptWriteCachedTokens5mNEQ    *int64  `json:"promptWriteCachedTokens5mNEQ,omitempty"`
	PromptWriteCachedTokens5mIn     []int64 `json:"promptWriteCachedTokens5mIn,omitempty"`
	PromptWriteCachedTokens5mNotIn  []int64 `json:"promptWriteCachedTokens5mNotIn,omitempty"`
	PromptWriteCachedTokens5mGT     *int64  `json:"promptWriteCachedTokens5mGT,omitempty"`
	PromptWriteCachedTokens5mGTE    *int64  `json:"promptWriteCachedTokens5mGTE,omitempty"`
	PromptWriteCachedTokens5mLT     *int64  `json:"promptWriteCachedTokens5mLT,omitempty"`
	PromptWriteCachedTokens5mLTE    *int64  `json:"promptWriteCachedTokens5mLTE,omitempty"`
	PromptWriteCachedTokens5mIsNil  bool    `json:"promptWriteCachedTokens5mIsNil,omitempty"`
	PromptWriteCachedTokens5mNotNil bool    `json:"promptWriteCachedTokens5mNotNil,omitempty"`

	// "prompt_write_cached_tokens_1h" field predicates.
	PromptWriteCachedTokens1h       *int64  `json:"promptWriteCachedTokens1h,omitempty"`
	PromptWriteCachedTokens1hNEQ    *int64  `json:"promptWriteCachedTokens1hNEQ,omitempty"`
	PromptWriteCachedTokens1hIn     []int64 `json:"promptWriteCachedTokens1hIn,omitempty"`
	PromptWriteCachedTokens1hNotIn  []int64 `json:"promptWriteCachedTokens1hNotIn,omitempty"`
	PromptWriteCachedTokens1hGT     *int64  `json:"promptWriteCachedTokens1hGT,omitempty"`
	PromptWriteCachedTokens1hGTE    *int64  `json:"promptWriteCachedTokens1hGTE,omitempty"`
	PromptWriteCachedTokens1hLT     *int64  `json:"promptWriteCachedTokens1hLT,omitempty"`
	PromptWriteCachedTokens1hLTE    *int64  `json:"promptWriteCachedTokens1hLTE,omitempty"`
	PromptWriteCachedTokens1hIsNil  bool    `json:"promptWriteCachedTokens1hIsNil,omitempty"`
	PromptWriteCachedTokens1hNotNil bool    `json:"promptWriteCachedTokens1hNotNil,omitempty"`

	// "completion_audio_tokens" field predicates.
	CompletionAudioTokens       *int64  `json:"completionAudioTokens,omitempty"`
	CompletionAudioTokensNEQ    *int64  `json:"completionAudioTokensNEQ,omitempty"`
	CompletionAudioTokensIn     []int64 `json:"completionAudioTokensIn,omitempty"`
	CompletionAudioTokensNotIn  []int64 `json:"completionAudioTokensNotIn,omitempty"`
	CompletionAudioTokensGT     *int64  `json:"completionAudioTokensGT,omitempty"`
	CompletionAudioTokensGTE    *int64  `json:"completionAudioTokensGTE,omitempty"`
	CompletionAudioTokensLT     *int64  `json:"completionAudioTokensLT,omitempty"`
	CompletionAudioTokensLTE    *int64  `json:"completionAudioTokensLTE,omitempty"`
	CompletionAudioTokensIsNil  bool    `json:"completionAudioTokensIsNil,omitempty"`
	CompletionAudioTokensNotNil bool    `json:"completionAudioTokensNotNil,omitempty"`

	// "completion_reasoning_tokens" field predicates.
	CompletionReasoningTokens       *int64  `json:"completionReasoningTokens,omitempty"`
	CompletionReasoningTokensNEQ    *int64  `json:"completionReasoningTokensNEQ,omitempty"`
	CompletionReasoningTokensIn     []int64 `json:"completionReasoningTokensIn,omitempty"`
	CompletionReasoningTokensNotIn  []int64 `json:"completionReasoningTokensNotIn,omitempty"`
	CompletionReasoningTokensGT     *int64  `json:"completionReasoningTokensGT,omitempty"`
	CompletionReasoningTokensGTE    *int64  `json:"completionReasoningTokensGTE,omitempty"`
	CompletionReasoningTokensLT     *int64  `json:"completionReasoningTokensLT,omitempty"`
	CompletionReasoningTokensLTE    *int64  `json:"completionReasoningTokensLTE,omitempty"`
	CompletionReasoningTokensIsNil  bool    `json:"completionReasoningTokensIsNil,omitempty"`
	CompletionReasoningTokensNotNil bool    `json:"completionReasoningTokensNotNil,omitempty"`

	// "completion_accepted_prediction_tokens" field predicates.
	CompletionAcceptedPredictionTokens       *int64  `json:"completionAcceptedPredictionTokens,omitempty"`
	CompletionAcceptedPredictionTokensNEQ    *int64  `json:"completionAcceptedPredictionTokensNEQ,omitempty"`
	CompletionAcceptedPredictionTokensIn     []int64 `json:"completionAcceptedPredictionTokensIn,omitempty"`
	CompletionAcceptedPredictionTokensNotIn  []int64 `json:"completionAcceptedPredictionTokensNotIn,omitempty"`
	CompletionAcceptedPredictionTokensGT     *int64  `json:"completionAcceptedPredictionTokensGT,omitempty"`
	CompletionAcceptedPredictionTokensGTE    *int64  `json:"completionAcceptedPredictionTokensGTE,omitempty"`
	CompletionAcceptedPredictionTokensLT     *int64  `json:"completionAcceptedPredictionTokensLT,omitempty"`
	CompletionAcceptedPredictionTokensLTE    *int64  `json:"completionAcceptedPredictionTokensLTE,omitempty"`
	CompletionAcceptedPredictionTokensIsNil  bool    `json:"completionAcceptedPredictionTokensIsNil,omitempty"`
	CompletionAcceptedPredictionTokensNotNil bool    `json:"completionAcceptedPredictionTokensNotNil,omitempty"`

	// "completion_rejected_prediction_tokens" field predicates.
	CompletionRejectedPredictionTokens       *int64  `json:"completionRejectedPredictionTokens,omitempty"`
	CompletionRejectedPredictionTokensNEQ    *int64  `json:"completionRejectedPredictionTokensNEQ,omitempty"`
	CompletionRejectedPredictionTokensIn     []int64 `json:"completionRejectedPredictionTokensIn,omitempty"`
	CompletionRejectedPredictionTokensNotIn  []int64 `json:"completionRejectedPredictionTokensNotIn,omitempty"`
	CompletionRejectedPredictionTokensGT     *int64  `json:"completionRejectedPredictionTokensGT,omitempty"`
	CompletionRejectedPredictionTokensGTE    *int64  `json:"completionRejectedPredictionTokensGTE,omitempty"`
	CompletionRejectedPredictionTokensLT     *int64  `json:"completionRejectedPredictionTokensLT,omitempty"`
	CompletionRejectedPredictionTokensLTE    *int64  `json:"completionRejectedPredictionTokensLTE,omitempty"`
	CompletionRejectedPredictionTokensIsNil  bool    `json:"completionRejectedPredictionTokensIsNil,omitempty"`
	CompletionRejectedPredictionTokensNotNil bool    `json:"completionRejectedPredictionTokensNotNil,omitempty"`

	// "source" field predicates.
	Source      *usagelog.Source  `json:"source,omitempty"`
	SourceNEQ   *usagelog.Source  `json:"sourceNEQ,omitempty"`
	SourceIn    []usagelog.Source `json:"sourceIn,omitempty"`
	SourceNotIn []usagelog.Source `json:"sourceNotIn,omitempty"`

	// "format" field predicates.
	Format             *string  `json:"format,omitempty"`
	FormatNEQ          *string  `json:"formatNEQ,omitempty"`
	FormatIn           []string `json:"formatIn,omitempty"`
	FormatNotIn        []string `json:"formatNotIn,omitempty"`
	FormatGT           *string  `json:"formatGT,omitempty"`
	FormatGTE          *string  `json:"formatGTE,omitempty"`
	FormatLT           *string  `json:"formatLT,omitempty"`
	FormatLTE          *string  `json:"formatLTE,omitempty"`
	FormatContains     *string  `json:"formatContains,omitempty"`
	FormatHasPrefix    *string  `json:"formatHasPrefix,omitempty"`
	FormatHasSuffix    *string  `json:"formatHasSuffix,omitempty"`
	FormatEqualFold    *string  `json:"formatEqualFold,omitempty"`
	FormatContainsFold *string  `json:"formatContainsFold,omitempty"`

	// "total_cost" field predicates.
	TotalCost       *float64  `json:"totalCost,omitempty"`
	TotalCostNEQ    *float64  `json:"totalCostNEQ,omitempty"`
	TotalCostIn     []float64 `json:"totalCostIn,omitempty"`
	TotalCostNotIn  []float64 `json:"totalCostNotIn,omitempty"`
	TotalCostGT     *float64  `json:"totalCostGT,omitempty"`
	TotalCostGTE    *float64  `json:"totalCostGTE,omitempty"`
	TotalCostLT     *float64  `json:"totalCostLT,omitempty"`
	TotalCostLTE    *float64  `json:"totalCostLTE,omitempty"`
	TotalCostIsNil  bool      `json:"totalCostIsNil,omitempty"`
	TotalCostNotNil bool      `json:"totalCostNotNil,omitempty"`

	// "cost_price_reference_id" field predicates.
	CostPriceReferenceID             *string  `json:"costPriceReferenceID,omitempty"`
	CostPriceReferenceIDNEQ          *string  `json:"costPriceReferenceIDNEQ,omitempty"`
	CostPriceReferenceIDIn           []string `json:"costPriceReferenceIDIn,omitempty"`
	CostPriceReferenceIDNotIn        []string `json:"costPriceReferenceIDNotIn,omitempty"`
	CostPriceReferenceIDGT           *string  `json:"costPriceReferenceIDGT,omitempty"`
	CostPriceReferenceIDGTE          *string  `json:"costPriceReferenceIDGTE,omitempty"`
	CostPriceReferenceIDLT           *string  `json:"costPriceReferenceIDLT,omitempty"`
	CostPriceReferenceIDLTE          *string  `json:"costPriceReferenceIDLTE,omitempty"`
	CostPriceReferenceIDContains     *string  `json:"costPriceReferenceIDContains,omitempty"`
	CostPriceReferenceIDHasPrefix    *string  `json:"costPriceReferenceIDHasPrefix,omitempty"`
	CostPriceReferenceIDHasSuffix    *string  `json:"costPriceReferenceIDHasSuffix,omitempty"`
	CostPriceReferenceIDIsNil        bool     `json:"costPriceReferenceIDIsNil,omitempty"`
	CostPriceReferenceIDNotNil       bool     `json:"costPriceReferenceIDNotNil,omitempty"`
	CostPriceReferenceIDEqualFold    *string  `json:"costPriceReferenceIDEqualFold,omitempty"`
	CostPriceReferenceIDContainsFold *string  `json:"costPriceReferenceIDContainsFold,omitempty"`

	// "request" edge predicates.
	HasRequest     *bool                `json:"hasRequest,omitempty"`
	HasRequestWith []*RequestWhereInput `json:"hasRequestWith,omitempty"`

	// "project" edge predicates.
	HasProject     *bool                `json:"hasProject,omitempty"`
	HasProjectWith []*ProjectWhereInput `json:"hasProjectWith,omitempty"`

	// "channel" edge predicates.
	HasChannel     *bool                `json:"hasChannel,omitempty"`
	HasChannelWith []*ChannelWhereInput `json:"hasChannelWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UsageLogWhereInput) AddPredicates(predicates ...predicate.UsageLog) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UsageLogWhereInput filter on the UsageLogQuery builder.
func (i *UsageLogWhereInput) Filter(q *UsageLogQuery) (*UsageLogQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUsageLogWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUsageLogWhereInput is returned in case the UsageLogWhereInput is empty.
var ErrEmptyUsageLogWhereInput = errors.New("ent: empty predicate UsageLogWhereInput")

// P returns a predicate for filtering usagelogs.
// An error is returned if the input is empty or invalid.
func (i *UsageLogWhereInput) P() (predicate.UsageLog, error) {
	var predicates []predicate.UsageLog
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, usagelog.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.UsageLog, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, usagelog.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.UsageLog, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, usagelog.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, usagelog.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, usagelog.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, usagelog.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, usagelog.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, usagelog.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, usagelog.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, usagelog.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, usagelog.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, usagelog.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, usagelog.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, usagelog.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, usagelog.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, usagelog.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, usagelog.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, usagelog.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, usagelog.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, usagelog.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, usagelog.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, usagelog.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, usagelog.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, usagelog.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, usagelog.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, usagelog.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, usagelog.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.RequestID != nil {
		predicates = append(predicates, usagelog.RequestIDEQ(*i.RequestID))
	}
	if i.RequestIDNEQ != nil {
		predicates = append(predicates, usagelog.RequestIDNEQ(*i.RequestIDNEQ))
	}
	if len(i.RequestIDIn) > 0 {
		predicates = append(predicates, usagelog.RequestIDIn(i.RequestIDIn...))
	}
	if len(i.RequestIDNotIn) > 0 {
		predicates = append(predicates, usagelog.RequestIDNotIn(i.RequestIDNotIn...))
	}
	if i.APIKeyID != nil {
		predicates = append(predicates, usagelog.APIKeyIDEQ(*i.APIKeyID))
	}
	if i.APIKeyIDNEQ != nil {
		predicates = append(predicates, usagelog.APIKeyIDNEQ(*i.APIKeyIDNEQ))
	}
	if len(i.APIKeyIDIn) > 0 {
		predicates = append(predicates, usagelog.APIKeyIDIn(i.APIKeyIDIn...))
	}
	if len(i.APIKeyIDNotIn) > 0 {
		predicates = append(predicates, usagelog.APIKeyIDNotIn(i.APIKeyIDNotIn...))
	}
	if i.APIKeyIDGT != nil {
		predicates = append(predicates, usagelog.APIKeyIDGT(*i.APIKeyIDGT))
	}
	if i.APIKeyIDGTE != nil {
		predicates = append(predicates, usagelog.APIKeyIDGTE(*i.APIKeyIDGTE))
	}
	if i.APIKeyIDLT != nil {
		predicates = append(predicates, usagelog.APIKeyIDLT(*i.APIKeyIDLT))
	}
	if i.APIKeyIDLTE != nil {
		predicates = append(predicates, usagelog.APIKeyIDLTE(*i.APIKeyIDLTE))
	}
	if i.APIKeyIDIsNil {
		predicates = append(predicates, usagelog.APIKeyIDIsNil())
	}
	if i.APIKeyIDNotNil {
		predicates = append(predicates, usagelog.APIKeyIDNotNil())
	}
	if i.ProjectID != nil {
		predicates = append(predicates, usagelog.ProjectIDEQ(*i.ProjectID))
	}
	if i.ProjectIDNEQ != nil {
		predicates = append(predicates, usagelog.ProjectIDNEQ(*i.ProjectIDNEQ))
	}
	if len(i.ProjectIDIn) > 0 {
		predicates = append(predicates, usagelog.ProjectIDIn(i.ProjectIDIn...))
	}
	if len(i.ProjectIDNotIn) > 0 {
		predicates = append(predicates, usagelog.ProjectIDNotIn(i.ProjectIDNotIn...))
	}
	if i.ChannelID != nil {
		predicates = append(predicates, usagelog.ChannelIDEQ(*i.ChannelID))
	}
	if i.ChannelIDNEQ != nil {
		predicates = append(predicates, usagelog.ChannelIDNEQ(*i.ChannelIDNEQ))
	}
	if len(i.ChannelIDIn) > 0 {
		predicates = append(predicates, usagelog.ChannelIDIn(i.ChannelIDIn...))
	}
	if len(i.ChannelIDNotIn) > 0 {
		predicates = append(predicates, usagelog.ChannelIDNotIn(i.ChannelIDNotIn...))
	}
	if i.ChannelIDIsNil {
		predicates = append(predicates, usagelog.ChannelIDIsNil())
	}
	if i.ChannelIDNotNil {
		predicates = append(predicates, usagelog.ChannelIDNotNil())
	}
	if i.ModelID != nil {
		predicates = append(predicates, usagelog.ModelIDEQ(*i.ModelID))
	}
	if i.ModelIDNEQ != nil {
		predicates = append(predicates, usagelog.ModelIDNEQ(*i.ModelIDNEQ))
	}
	if len(i.ModelIDIn) > 0 {
		predicates = append(predicates, usagelog.ModelIDIn(i.ModelIDIn...))
	}
	if len(i.ModelIDNotIn) > 0 {
		predicates = append(predicates, usagelog.ModelIDNotIn(i.ModelIDNotIn...))
	}
	if i.ModelIDGT != nil {
		predicates = append(predicates, usagelog.ModelIDGT(*i.ModelIDGT))
	}
	if i.ModelIDGTE != nil {
		predicates = append(predicates, usagelog.ModelIDGTE(*i.ModelIDGTE))
	}
	if i.ModelIDLT != nil {
		predicates = append(predicates, usagelog.ModelIDLT(*i.ModelIDLT))
	}
	if i.ModelIDLTE != nil {
		predicates = append(predicates, usagelog.ModelIDLTE(*i.ModelIDLTE))
	}
	if i.ModelIDContains != nil {
		predicates = append(predicates, usagelog.ModelIDContains(*i.ModelIDContains))
	}
	if i.ModelIDHasPrefix != nil {
		predicates = append(predicates, usagelog.ModelIDHasPrefix(*i.ModelIDHasPrefix))
	}
	if i.ModelIDHasSuffix != nil {
		predicates = append(predicates, usagelog.ModelIDHasSuffix(*i.ModelIDHasSuffix))
	}
	if i.ModelIDEqualFold != nil {
		predicates = append(predicates, usagelog.ModelIDEqualFold(*i.ModelIDEqualFold))
	}
	if i.ModelIDContainsFold != nil {
		predicates = append(predicates, usagelog.ModelIDContainsFold(*i.ModelIDContainsFold))
	}
	if i.PromptTokens != nil {
		predicates = append(predicates, usagelog.PromptTokensEQ(*i.PromptTokens))
	}
	if i.PromptTokensNEQ != nil {
		predicates = append(predicates, usagelog.PromptTokensNEQ(*i.PromptTokensNEQ))
	}
	if len(i.PromptTokensIn) > 0 {
		predicates = append(predicates, usagelog.PromptTokensIn(i.PromptTokensIn...))
	}
	if len(i.PromptTokensNotIn) > 0 {
		predicates = append(predicates, usagelog.PromptTokensNotIn(i.PromptTokensNotIn...))
	}
	if i.PromptTokensGT != nil {
		predicates = append(predicates, usagelog.PromptTokensGT(*i.PromptTokensGT))
	}
	if i.PromptTokensGTE != nil {
		predicates = append(predicates, usagelog.PromptTokensGTE(*i.PromptTokensGTE))
	}
	if i.PromptTokensLT != nil {
		predicates = append(predicates, usagelog.PromptTokensLT(*i.PromptTokensLT))
	}
	if i.PromptTokensLTE != nil {
		predicates = append(predicates, usagelog.PromptTokensLTE(*i.PromptTokensLTE))
	}
	if i.CompletionTokens != nil {
		predicates = append(predicates, usagelog.CompletionTokensEQ(*i.CompletionTokens))
	}
	if i.CompletionTokensNEQ != nil {
		predicates = append(predicates, usagelog.CompletionTokensNEQ(*i.CompletionTokensNEQ))
	}
	if len(i.CompletionTokensIn) > 0 {
		predicates = append(predicates, usagelog.CompletionTokensIn(i.CompletionTokensIn...))
	}
	if len(i.CompletionTokensNotIn) > 0 {
		predicates = append(predicates, usagelog.CompletionTokensNotIn(i.CompletionTokensNotIn...))
	}
	if i.CompletionTokensGT != nil {
		predicates = append(predicates, usagelog.CompletionTokensGT(*i.CompletionTokensGT))
	}
	if i.CompletionTokensGTE != nil {
		predicates = append(predicates, usagelog.CompletionTokensGTE(*i.CompletionTokensGTE))
	}
	if i.CompletionTokensLT != nil {
		predicates = append(predicates, usagelog.CompletionTokensLT(*i.CompletionTokensLT))
	}
	if i.CompletionTokensLTE != nil {
		predicates = append(predicates, usagelog.CompletionTokensLTE(*i.CompletionTokensLTE))
	}
	if i.TotalTokens != nil {
		predicates = append(predicates, usagelog.TotalTokensEQ(*i.TotalTokens))
	}
	if i.TotalTokensNEQ != nil {
		predicates = append(predicates, usagelog.TotalTokensNEQ(*i.TotalTokensNEQ))
	}
	if len(i.TotalTokensIn) > 0 {
		predicates = append(predicates, usagelog.TotalTokensIn(i.TotalTokensIn...))
	}
	if len(i.TotalTokensNotIn) > 0 {
		predicates = append(predicates, usagelog.TotalTokensNotIn(i.TotalTokensNotIn...))
	}
	if i.TotalTokensGT != nil {
		predicates = append(predicates, usagelog.TotalTokensGT(*i.TotalTokensGT))
	}
	if i.TotalTokensGTE != nil {
		predicates = append(predicates, usagelog.TotalTokensGTE(*i.TotalTokensGTE))
	}
	if i.TotalTokensLT != nil {
		predicates = append(predicates, usagelog.TotalTokensLT(*i.TotalTokensLT))
	}
	if i.TotalTokensLTE != nil {
		predicates = append(predicates, usagelog.TotalTokensLTE(*i.TotalTokensLTE))
	}
	if i.PromptAudioTokens != nil {
		predicates = append(predicates, usagelog.PromptAudioTokensEQ(*i.PromptAudioTokens))
	}
	if i.PromptAudioTokensNEQ != nil {
		predicates = append(predicates, usagelog.PromptAudioTokensNEQ(*i.PromptAudioTokensNEQ))
	}
	if len(i.PromptAudioTokensIn) > 0 {
		predicates = append(predicates, usagelog.PromptAudioTokensIn(i.PromptAudioTokensIn...))
	}
	if len(i.PromptAudioTokensNotIn) > 0 {
		predicates = append(predicates, usagelog.PromptAudioTokensNotIn(i.PromptAudioTokensNotIn...))
	}
	if i.PromptAudioTokensGT != nil {
		predicates = append(predicates, usagelog.PromptAudioTokensGT(*i.PromptAudioTokensGT))
	}
	if i.PromptAudioTokensGTE != nil {
		predicates = append(predicates, usagelog.PromptAudioTokensGTE(*i.PromptAudioTokensGTE))
	}
	if i.PromptAudioTokensLT != nil {
		predicates = append(predicates, usagelog.PromptAudioTokensLT(*i.PromptAudioTokensLT))
	}
	if i.PromptAudioTokensLTE != nil {
		predicates = append(predicates, usagelog.PromptAudioTokensLTE(*i.PromptAudioTokensLTE))
	}
	if i.PromptCachedTokens != nil {
		predicates = append(predicates, usagelog.PromptCachedTokensEQ(*i.PromptCachedTokens))
	}
	if i.PromptCachedTokensNEQ != nil {
		predicates = append(predicates, usagelog.PromptCachedTokensNEQ(*i.PromptCachedTokensNEQ))
	}
	if len(i.PromptCachedTokensIn) > 0 {
		predicates = append(predicates, usagelog.PromptCachedTokensIn(i.PromptCachedTokensIn...))
	}
	if len(i.PromptCachedTokensNotIn) > 0 {
		predicates = append(predicates, usagelog.PromptCachedTokensNotIn(i.PromptCachedTokensNotIn...))
	}
	if i.PromptCachedTokensGT != nil {
		predicates = append(predicates, usagelog.PromptCachedTokensGT(*i.PromptCachedTokensGT))
	}
	if i.PromptCachedTokensGTE != nil {
		predicates = append(predicates, usagelog.PromptCachedTokensGTE(*i.PromptCachedTokensGTE))
	}
	if i.PromptCachedTokensLT != nil {
		predicates = append(predicates, usagelog.PromptCachedTokensLT(*i.PromptCachedTokensLT))
	}
	if i.PromptCachedTokensLTE != nil {
		predicates = append(predicates, usagelog.PromptCachedTokensLTE(*i.PromptCachedTokensLTE))
	}
	if i.PromptWriteCachedTokens != nil {
		predicates = append(predicates, usagelog.PromptWriteCachedTokensEQ(*i.PromptWriteCachedTokens))
	}
	if i.PromptWriteCachedTokensNEQ != nil {
		predicates = append(predicates, usagelog.PromptWriteCachedTokensNEQ(*i.PromptWriteCachedTokensNEQ))
	}
	if len(i.PromptWriteCachedTokensIn) > 0 {
		predicates = append(predicates, usagelog.PromptWriteCachedTokensIn(i.PromptWriteCachedTokensIn...))
	}
	if len(i.PromptWriteCachedTokensNotIn) > 0 {
		predicates = append(predicates, usagelog.PromptWriteCachedTokensNotIn(i.PromptWriteCachedTokensNotIn...))
	}
	if i.PromptWriteCachedTokensGT != nil {
		predicates = append(predicates, usagelog.PromptWriteCachedTokensGT(*i.PromptWriteCachedTokensGT))
	}
	if i.PromptWriteCachedTokensGTE != nil {
		predicates = append(predicates, usagelog.PromptWriteCachedTokensGTE(*i.PromptWriteCachedTokensGTE))
	}
	if i.PromptWriteCachedTokensLT != nil {
		predicates = append(predicates, usagelog.PromptWriteCachedTokensLT(*i.PromptWriteCachedTokensLT))
	}
	if i.PromptWriteCachedTokensLTE != nil {
		predicates = append(predicates, usagelog.PromptWriteCachedTokensLTE(*i.PromptWriteCachedTokensLTE))
	}
	if i.PromptWriteCachedTokensIsNil {
		predicates = append(predicates, usagelog.PromptWriteCachedTokensIsNil())
	}
	if i.PromptWriteCachedTokensNotNil {
		predicates = append(predicates, usagelog.PromptWriteCachedTokensNotNil())
	}
	if i.PromptWriteCachedTokens5m != nil {
		predicates = append(predicates, usagelog.PromptWriteCachedTokens5mEQ(*i.PromptWriteCachedTokens5m))
	}
	if i.PromptWriteCachedTokens5mNEQ != nil {
		predicates = append(predicates, usagelog.PromptWriteCachedTokens5mNEQ(*i.PromptWriteCachedTokens5mNEQ))
	}
	if len(i.PromptWriteCachedTokens5mIn) > 0 {
		predicates = append(predicates, usagelog.PromptWriteCachedTokens5mIn(i.PromptWriteCachedTokens5mIn...))
	}
	if len(i.PromptWriteCachedTokens5mNotIn) > 0 {
		predicates = append(predicates, usagelog.PromptWriteCachedTokens5mNotIn(i.PromptWriteCachedTokens5mNotIn...))
	}
	if i.PromptWriteCachedTokens5mGT != nil {
		predicates = append(predicates, usagelog.PromptWriteCachedTokens5mGT(*i.PromptWriteCachedTokens5mGT))
	}
	if i.PromptWriteCachedTokens5mGTE != nil {
		predicates = append(predicates, usagelog.PromptWriteCachedTokens5mGTE(*i.PromptWriteCachedTokens5mGTE))
	}
	if i.PromptWriteCachedTokens5mLT != nil {
		predicates = append(predicates, usagelog.PromptWriteCachedTokens5mLT(*i.PromptWriteCachedTokens5mLT))
	}
	if i.PromptWriteCachedTokens5mLTE != nil {
		predicates = append(predicates, usagelog.PromptWriteCachedTokens5mLTE(*i.PromptWriteCachedTokens5mLTE))
	}
	if i.PromptWriteCachedTokens5mIsNil {
		predicates = append(predicates, usagelog.PromptWriteCachedTokens5mIsNil())
	}
	if i.PromptWriteCachedTokens5mNotNil {
		predicates = append(predicates, usagelog.PromptWriteCachedTokens5mNotNil())
	}
	if i.PromptWriteCachedTokens1h != nil {
		predicates = append(predicates, usagelog.PromptWriteCachedTokens1hEQ(*i.PromptWriteCachedTokens1h))
	}
	if i.PromptWriteCachedTokens1hNEQ != nil {
		predicates = append(predicates, usagelog.PromptWriteCachedTokens1hNEQ(*i.PromptWriteCachedTokens1hNEQ))
	}
	if len(i.PromptWriteCachedTokens1hIn) > 0 {
		predicates = append(predicates, usagelog.PromptWriteCachedTokens1hIn(i.PromptWriteCachedTokens1hIn...))
	}
	if len(i.PromptWriteCachedTokens1hNotIn) > 0 {
		predicates = append(predicates, usagelog.PromptWriteCachedTokens1hNotIn(i.PromptWriteCachedTokens1hNotIn...))
	}
	if i.PromptWriteCachedTokens1hGT != nil {
		predicates = append(predicates, usagelog.PromptWriteCachedTokens1hGT(*i.PromptWriteCachedTokens1hGT))
	}
	if i.PromptWriteCachedTokens1hGTE != nil {
		predicates = append(predicates, usagelog.PromptWriteCachedTokens1hGTE(*i.PromptWriteCachedTokens1hGTE))
	}
	if i.PromptWriteCachedTokens1hLT != nil {
		predicates = append(predicates, usagelog.PromptWriteCachedTokens1hLT(*i.PromptWriteCachedTokens1hLT))
	}
	if i.PromptWriteCachedTokens1hLTE != nil {
		predicates = append(predicates, usagelog.PromptWriteCachedTokens1hLTE(*i.PromptWriteCachedTokens1hLTE))
	}
	if i.PromptWriteCachedTokens1hIsNil {
		predicates = append(predicates, usagelog.PromptWriteCachedTokens1hIsNil())
	}
	if i.PromptWriteCachedTokens1hNotNil {
		predicates = append(predicates, usagelog.PromptWriteCachedTokens1hNotNil())
	}
	if i.CompletionAudioTokens != nil {
		predicates = append(predicates, usagelog.CompletionAudioTokensEQ(*i.CompletionAudioTokens))
	}
	if i.CompletionAudioTokensNEQ != nil {
		predicates = append(predicates, usagelog.CompletionAudioTokensNEQ(*i.CompletionAudioTokensNEQ))
	}
	if len(i.CompletionAudioTokensIn) > 0 {
		predicates = append(predicates, usagelog.CompletionAudioTokensIn(i.CompletionAudioTokensIn...))
	}
	if len(i.CompletionAudioTokensNotIn) > 0 {
		predicates = append(predicates, usagelog.CompletionAudioTokensNotIn(i.CompletionAudioTokensNotIn...))
	}
	if i.CompletionAudioTokensGT != nil {
		predicates = append(predicates, usagelog.CompletionAudioTokensGT(*i.CompletionAudioTokensGT))
	}
	if i.CompletionAudioTokensGTE != nil {
		predicates = append(predicates, usagelog.CompletionAudioTokensGTE(*i.CompletionAudioTokensGTE))
	}
	if i.CompletionAudioTokensLT != nil {
		predicates = append(predicates, usagelog.CompletionAudioTokensLT(*i.CompletionAudioTokensLT))
	}
	if i.CompletionAudioTokensLTE != nil {
		predicates = append(predicates, usagelog.CompletionAudioTokensLTE(*i.CompletionAudioTokensLTE))
	}
	if i.CompletionAudioTokensIsNil {
		predicates = append(predicates, usagelog.CompletionAudioTokensIsNil())
	}
	if i.CompletionAudioTokensNotNil {
		predicates = append(predicates, usagelog.CompletionAudioTokensNotNil())
	}
	if i.CompletionReasoningTokens != nil {
		predicates = append(predicates, usagelog.CompletionReasoningTokensEQ(*i.CompletionReasoningTokens))
	}
	if i.CompletionReasoningTokensNEQ != nil {
		predicates = append(predicates, usagelog.CompletionReasoningTokensNEQ(*i.CompletionReasoningTokensNEQ))
	}
	if len(i.CompletionReasoningTokensIn) > 0 {
		predicates = append(predicates, usagelog.CompletionReasoningTokensIn(i.CompletionReasoningTokensIn...))
	}
	if len(i.CompletionReasoningTokensNotIn) > 0 {
		predicates = append(predicates, usagelog.CompletionReasoningTokensNotIn(i.CompletionReasoningTokensNotIn...))
	}
	if i.CompletionReasoningTokensGT != nil {
		predicates = append(predicates, usagelog.CompletionReasoningTokensGT(*i.CompletionReasoningTokensGT))
	}
	if i.CompletionReasoningTokensGTE != nil {
		predicates = append(predicates, usagelog.CompletionReasoningTokensGTE(*i.CompletionReasoningTokensGTE))
	}
	if i.CompletionReasoningTokensLT != nil {
		predicates = append(predicates, usagelog.CompletionReasoningTokensLT(*i.CompletionReasoningTokensLT))
	}
	if i.CompletionReasoningTokensLTE != nil {
		predicates = append(predicates, usagelog.CompletionReasoningTokensLTE(*i.CompletionReasoningTokensLTE))
	}
	if i.CompletionReasoningTokensIsNil {
		predicates = append(predicates, usagelog.CompletionReasoningTokensIsNil())
	}
	if i.CompletionReasoningTokensNotNil {
		predicates = append(predicates, usagelog.CompletionReasoningTokensNotNil())
	}
	if i.CompletionAcceptedPredictionTokens != nil {
		predicates = append(predicates, usagelog.CompletionAcceptedPredictionTokensEQ(*i.CompletionAcceptedPredictionTokens))
	}
	if i.CompletionAcceptedPredictionTokensNEQ != nil {
		predicates = append(predicates, usagelog.CompletionAcceptedPredictionTokensNEQ(*i.CompletionAcceptedPredictionTokensNEQ))
	}
	if len(i.CompletionAcceptedPredictionTokensIn) > 0 {
		predicates = append(predicates, usagelog.CompletionAcceptedPredictionTokensIn(i.CompletionAcceptedPredictionTokensIn...))
	}
	if len(i.CompletionAcceptedPredictionTokensNotIn) > 0 {
		predicates = append(predicates, usagelog.CompletionAcceptedPredictionTokensNotIn(i.CompletionAcceptedPredictionTokensNotIn...))
	}
	if i.CompletionAcceptedPredictionTokensGT != nil {
		predicates = append(predicates, usagelog.CompletionAcceptedPredictionTokensGT(*i.CompletionAcceptedPredictionTokensGT))
	}
	if i.CompletionAcceptedPredictionTokensGTE != nil {
		predicates = append(predicates, usagelog.CompletionAcceptedPredictionTokensGTE(*i.CompletionAcceptedPredictionTokensGTE))
	}
	if i.CompletionAcceptedPredictionTokensLT != nil {
		predicates = append(predicates, usagelog.CompletionAcceptedPredictionTokensLT(*i.CompletionAcceptedPredictionTokensLT))
	}
	if i.CompletionAcceptedPredictionTokensLTE != nil {
		predicates = append(predicates, usagelog.CompletionAcceptedPredictionTokensLTE(*i.CompletionAcceptedPredictionTokensLTE))
	}
	if i.CompletionAcceptedPredictionTokensIsNil {
		predicates = append(predicates, usagelog.CompletionAcceptedPredictionTokensIsNil())
	}
	if i.CompletionAcceptedPredictionTokensNotNil {
		predicates = append(predicates, usagelog.CompletionAcceptedPredictionTokensNotNil())
	}
	if i.CompletionRejectedPredictionTokens != nil {
		predicates = append(predicates, usagelog.CompletionRejectedPredictionTokensEQ(*i.CompletionRejectedPredictionTokens))
	}
	if i.CompletionRejectedPredictionTokensNEQ != nil {
		predicates = append(predicates, usagelog.CompletionRejectedPredictionTokensNEQ(*i.CompletionRejectedPredictionTokensNEQ))
	}
	if len(i.CompletionRejectedPredictionTokensIn) > 0 {
		predicates = append(predicates, usagelog.CompletionRejectedPredictionTokensIn(i.CompletionRejectedPredictionTokensIn...))
	}
	if len(i.CompletionRejectedPredictionTokensNotIn) > 0 {
		predicates = append(predicates, usagelog.CompletionRejectedPredictionTokensNotIn(i.CompletionRejectedPredictionTokensNotIn...))
	}
	if i.CompletionRejectedPredictionTokensGT != nil {
		predicates = append(predicates, usagelog.CompletionRejectedPredictionTokensGT(*i.CompletionRejectedPredictionTokensGT))
	}
	if i.CompletionRejectedPredictionTokensGTE != nil {
		predicates = append(predicates, usagelog.CompletionRejectedPredictionTokensGTE(*i.CompletionRejectedPredictionTokensGTE))
	}
	if i.CompletionRejectedPredictionTokensLT != nil {
		predicates = append(predicates, usagelog.CompletionRejectedPredictionTokensLT(*i.CompletionRejectedPredictionTokensLT))
	}
	if i.CompletionRejectedPredictionTokensLTE != nil {
		predicates = append(predicates, usagelog.CompletionRejectedPredictionTokensLTE(*i.CompletionRejectedPredictionTokensLTE))
	}
	if i.CompletionRejectedPredictionTokensIsNil {
		predicates = append(predicates, usagelog.CompletionRejectedPredictionTokensIsNil())
	}
	if i.CompletionRejectedPredictionTokensNotNil {
		predicates = append(predicates, usagelog.CompletionRejectedPredictionTokensNotNil())
	}
	if i.Source != nil {
		predicates = append(predicates, usagelog.SourceEQ(*i.Source))
	}
	if i.SourceNEQ != nil {
		predicates = append(predicates, usagelog.SourceNEQ(*i.SourceNEQ))
	}
	if len(i.SourceIn) > 0 {
		predicates = append(predicates, usagelog.SourceIn(i.SourceIn...))
	}
	if len(i.SourceNotIn) > 0 {
		predicates = append(predicates, usagelog.SourceNotIn(i.SourceNotIn...))
	}
	if i.Format != nil {
		predicates = append(predicates, usagelog.FormatEQ(*i.Format))
	}
	if i.FormatNEQ != nil {
		predicates = append(predicates, usagelog.FormatNEQ(*i.FormatNEQ))
	}
	if len(i.FormatIn) > 0 {
		predicates = append(predicates, usagelog.FormatIn(i.FormatIn...))
	}
	if len(i.FormatNotIn) > 0 {
		predicates = append(predicates, usagelog.FormatNotIn(i.FormatNotIn...))
	}
	if i.FormatGT != nil {
		predicates = append(predicates, usagelog.FormatGT(*i.FormatGT))
	}
	if i.FormatGTE != nil {
		predicates = append(predicates, usagelog.FormatGTE(*i.FormatGTE))
	}
	if i.FormatLT != nil {
		predicates = append(predicates, usagelog.FormatLT(*i.FormatLT))
	}
	if i.FormatLTE != nil {
		predicates = append(predicates, usagelog.FormatLTE(*i.FormatLTE))
	}
	if i.FormatContains != nil {
		predicates = append(predicates, usagelog.FormatContains(*i.FormatContains))
	}
	if i.FormatHasPrefix != nil {
		predicates = append(predicates, usagelog.FormatHasPrefix(*i.FormatHasPrefix))
	}
	if i.FormatHasSuffix != nil {
		predicates = append(predicates, usagelog.FormatHasSuffix(*i.FormatHasSuffix))
	}
	if i.FormatEqualFold != nil {
		predicates = append(predicates, usagelog.FormatEqualFold(*i.FormatEqualFold))
	}
	if i.FormatContainsFold != nil {
		predicates = append(predicates, usagelog.FormatContainsFold(*i.FormatContainsFold))
	}
	if i.TotalCost != nil {
		predicates = append(predicates, usagelog.TotalCostEQ(*i.TotalCost))
	}
	if i.TotalCostNEQ != nil {
		predicates = append(predicates, usagelog.TotalCostNEQ(*i.TotalCostNEQ))
	}
	if len(i.TotalCostIn) > 0 {
		predicates = append(predicates, usagelog.TotalCostIn(i.TotalCostIn...))
	}
	if len(i.TotalCostNotIn) > 0 {
		predicates = append(predicates, usagelog.TotalCostNotIn(i.TotalCostNotIn...))
	}
	if i.TotalCostGT != nil {
		predicates = append(predicates, usagelog.TotalCostGT(*i.TotalCostGT))
	}
	if i.TotalCostGTE != nil {
		predicates = append(predicates, usagelog.TotalCostGTE(*i.TotalCostGTE))
	}
	if i.TotalCostLT != nil {
		predicates = append(predicates, usagelog.TotalCostLT(*i.TotalCostLT))
	}
	if i.TotalCostLTE != nil {
		predicates = append(predicates, usagelog.TotalCostLTE(*i.TotalCostLTE))
	}
	if i.TotalCostIsNil {
		predicates = append(predicates, usagelog.TotalCostIsNil())
	}
	if i.TotalCostNotNil {
		predicates = append(predicates, usagelog.TotalCostNotNil())
	}
	if i.CostPriceReferenceID != nil {
		predicates = append(predicates, usagelog.CostPriceReferenceIDEQ(*i.CostPriceReferenceID))
	}
	if i.CostPriceReferenceIDNEQ != nil {
		predicates = append(predicates, usagelog.CostPriceReferenceIDNEQ(*i.CostPriceReferenceIDNEQ))
	}
	if len(i.CostPriceReferenceIDIn) > 0 {
		predicates = append(predicates, usagelog.CostPriceReferenceIDIn(i.CostPriceReferenceIDIn...))
	}
	if len(i.CostPriceReferenceIDNotIn) > 0 {
		predicates = append(predicates, usagelog.CostPriceReferenceIDNotIn(i.CostPriceReferenceIDNotIn...))
	}
	if i.CostPriceReferenceIDGT != nil {
		predicates = append(predicates, usagelog.CostPriceReferenceIDGT(*i.CostPriceReferenceIDGT))
	}
	if i.CostPriceReferenceIDGTE != nil {
		predicates = append(predicates, usagelog.CostPriceReferenceIDGTE(*i.CostPriceReferenceIDGTE))
	}
	if i.CostPriceReferenceIDLT != nil {
		predicates = append(predicates, usagelog.CostPriceReferenceIDLT(*i.CostPriceReferenceIDLT))
	}
	if i.CostPriceReferenceIDLTE != nil {
		predicates = append(predicates, usagelog.CostPriceReferenceIDLTE(*i.CostPriceReferenceIDLTE))
	}
	if i.CostPriceReferenceIDContains != nil {
		predicates = append(predicates, usagelog.CostPriceReferenceIDContains(*i.CostPriceReferenceIDContains))
	}
	if i.CostPriceReferenceIDHasPrefix != nil {
		predicates = append(predicates, usagelog.CostPriceReferenceIDHasPrefix(*i.CostPriceReferenceIDHasPrefix))
	}
	if i.CostPriceReferenceIDHasSuffix != nil {
		predicates = append(predicates, usagelog.CostPriceReferenceIDHasSuffix(*i.CostPriceReferenceIDHasSuffix))
	}
	if i.CostPriceReferenceIDIsNil {
		predicates = append(predicates, usagelog.CostPriceReferenceIDIsNil())
	}
	if i.CostPriceReferenceIDNotNil {
		predicates = append(predicates, usagelog.CostPriceReferenceIDNotNil())
	}
	if i.CostPriceReferenceIDEqualFold != nil {
		predicates = append(predicates, usagelog.CostPriceReferenceIDEqualFold(*i.CostPriceReferenceIDEqualFold))
	}
	if i.CostPriceReferenceIDContainsFold != nil {
		predicates = append(predicates, usagelog.CostPriceReferenceIDContainsFold(*i.CostPriceReferenceIDContainsFold))
	}

	if i.HasRequest != nil {
		p := usagelog.HasRequest()
		if !*i.HasRequest {
			p = usagelog.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRequestWith) > 0 {
		with := make([]predicate.Request, 0, len(i.HasRequestWith))
		for _, w := range i.HasRequestWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRequestWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, usagelog.HasRequestWith(with...))
	}
	if i.HasProject != nil {
		p := usagelog.HasProject()
		if !*i.HasProject {
			p = usagelog.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProjectWith) > 0 {
		with := make([]predicate.Project, 0, len(i.HasProjectWith))
		for _, w := range i.HasProjectWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProjectWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, usagelog.HasProjectWith(with...))
	}
	if i.HasChannel != nil {
		p := usagelog.HasChannel()
		if !*i.HasChannel {
			p = usagelog.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasChannelWith) > 0 {
		with := make([]predicate.Channel, 0, len(i.HasChannelWith))
		for _, w := range i.HasChannelWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasChannelWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, usagelog.HasChannelWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUsageLogWhereInput
	case 1:
		return predicates[0], nil
	default:
		return usagelog.And(predicates...), nil
	}
}

// UserWhereInput represents a where input for filtering User queries.
type UserWhereInput struct {
	Predicates []predicate.User  `json:"-"`
	Not        *UserWhereInput   `json:"not,omitempty"`
	Or         []*UserWhereInput `json:"or,omitempty"`
	And        []*UserWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt      *int  `json:"deletedAt,omitempty"`
	DeletedAtNEQ   *int  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn    []int `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn []int `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT    *int  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE   *int  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT    *int  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE   *int  `json:"deletedAtLTE,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "status" field predicates.
	Status      *user.Status  `json:"status,omitempty"`
	StatusNEQ   *user.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []user.Status `json:"statusIn,omitempty"`
	StatusNotIn []user.Status `json:"statusNotIn,omitempty"`

	// "prefer_language" field predicates.
	PreferLanguage             *string  `json:"preferLanguage,omitempty"`
	PreferLanguageNEQ          *string  `json:"preferLanguageNEQ,omitempty"`
	PreferLanguageIn           []string `json:"preferLanguageIn,omitempty"`
	PreferLanguageNotIn        []string `json:"preferLanguageNotIn,omitempty"`
	PreferLanguageGT           *string  `json:"preferLanguageGT,omitempty"`
	PreferLanguageGTE          *string  `json:"preferLanguageGTE,omitempty"`
	PreferLanguageLT           *string  `json:"preferLanguageLT,omitempty"`
	PreferLanguageLTE          *string  `json:"preferLanguageLTE,omitempty"`
	PreferLanguageContains     *string  `json:"preferLanguageContains,omitempty"`
	PreferLanguageHasPrefix    *string  `json:"preferLanguageHasPrefix,omitempty"`
	PreferLanguageHasSuffix    *string  `json:"preferLanguageHasSuffix,omitempty"`
	PreferLanguageEqualFold    *string  `json:"preferLanguageEqualFold,omitempty"`
	PreferLanguageContainsFold *string  `json:"preferLanguageContainsFold,omitempty"`

	// "password" field predicates.
	Password             *string  `json:"password,omitempty"`
	PasswordNEQ          *string  `json:"passwordNEQ,omitempty"`
	PasswordIn           []string `json:"passwordIn,omitempty"`
	PasswordNotIn        []string `json:"passwordNotIn,omitempty"`
	PasswordGT           *string  `json:"passwordGT,omitempty"`
	PasswordGTE          *string  `json:"passwordGTE,omitempty"`
	PasswordLT           *string  `json:"passwordLT,omitempty"`
	PasswordLTE          *string  `json:"passwordLTE,omitempty"`
	PasswordContains     *string  `json:"passwordContains,omitempty"`
	PasswordHasPrefix    *string  `json:"passwordHasPrefix,omitempty"`
	PasswordHasSuffix    *string  `json:"passwordHasSuffix,omitempty"`
	PasswordEqualFold    *string  `json:"passwordEqualFold,omitempty"`
	PasswordContainsFold *string  `json:"passwordContainsFold,omitempty"`

	// "first_name" field predicates.
	FirstName             *string  `json:"firstName,omitempty"`
	FirstNameNEQ          *string  `json:"firstNameNEQ,omitempty"`
	FirstNameIn           []string `json:"firstNameIn,omitempty"`
	FirstNameNotIn        []string `json:"firstNameNotIn,omitempty"`
	FirstNameGT           *string  `json:"firstNameGT,omitempty"`
	FirstNameGTE          *string  `json:"firstNameGTE,omitempty"`
	FirstNameLT           *string  `json:"firstNameLT,omitempty"`
	FirstNameLTE          *string  `json:"firstNameLTE,omitempty"`
	FirstNameContains     *string  `json:"firstNameContains,omitempty"`
	FirstNameHasPrefix    *string  `json:"firstNameHasPrefix,omitempty"`
	FirstNameHasSuffix    *string  `json:"firstNameHasSuffix,omitempty"`
	FirstNameEqualFold    *string  `json:"firstNameEqualFold,omitempty"`
	FirstNameContainsFold *string  `json:"firstNameContainsFold,omitempty"`

	// "last_name" field predicates.
	LastName             *string  `json:"lastName,omitempty"`
	LastNameNEQ          *string  `json:"lastNameNEQ,omitempty"`
	LastNameIn           []string `json:"lastNameIn,omitempty"`
	LastNameNotIn        []string `json:"lastNameNotIn,omitempty"`
	LastNameGT           *string  `json:"lastNameGT,omitempty"`
	LastNameGTE          *string  `json:"lastNameGTE,omitempty"`
	LastNameLT           *string  `json:"lastNameLT,omitempty"`
	LastNameLTE          *string  `json:"lastNameLTE,omitempty"`
	LastNameContains     *string  `json:"lastNameContains,omitempty"`
	LastNameHasPrefix    *string  `json:"lastNameHasPrefix,omitempty"`
	LastNameHasSuffix    *string  `json:"lastNameHasSuffix,omitempty"`
	LastNameEqualFold    *string  `json:"lastNameEqualFold,omitempty"`
	LastNameContainsFold *string  `json:"lastNameContainsFold,omitempty"`

	// "avatar" field predicates.
	Avatar             *string  `json:"avatar,omitempty"`
	AvatarNEQ          *string  `json:"avatarNEQ,omitempty"`
	AvatarIn           []string `json:"avatarIn,omitempty"`
	AvatarNotIn        []string `json:"avatarNotIn,omitempty"`
	AvatarGT           *string  `json:"avatarGT,omitempty"`
	AvatarGTE          *string  `json:"avatarGTE,omitempty"`
	AvatarLT           *string  `json:"avatarLT,omitempty"`
	AvatarLTE          *string  `json:"avatarLTE,omitempty"`
	AvatarContains     *string  `json:"avatarContains,omitempty"`
	AvatarHasPrefix    *string  `json:"avatarHasPrefix,omitempty"`
	AvatarHasSuffix    *string  `json:"avatarHasSuffix,omitempty"`
	AvatarIsNil        bool     `json:"avatarIsNil,omitempty"`
	AvatarNotNil       bool     `json:"avatarNotNil,omitempty"`
	AvatarEqualFold    *string  `json:"avatarEqualFold,omitempty"`
	AvatarContainsFold *string  `json:"avatarContainsFold,omitempty"`

	// "is_owner" field predicates.
	IsOwner    *bool `json:"isOwner,omitempty"`
	IsOwnerNEQ *bool `json:"isOwnerNEQ,omitempty"`

	// "projects" edge predicates.
	HasProjects     *bool                `json:"hasProjects,omitempty"`
	HasProjectsWith []*ProjectWhereInput `json:"hasProjectsWith,omitempty"`

	// "api_keys" edge predicates.
	HasAPIKeys     *bool               `json:"hasAPIKeys,omitempty"`
	HasAPIKeysWith []*APIKeyWhereInput `json:"hasAPIKeysWith,omitempty"`

	// "roles" edge predicates.
	HasRoles     *bool             `json:"hasRoles,omitempty"`
	HasRolesWith []*RoleWhereInput `json:"hasRolesWith,omitempty"`

	// "channel_override_templates" edge predicates.
	HasChannelOverrideTemplates     *bool                                `json:"hasChannelOverrideTemplates,omitempty"`
	HasChannelOverrideTemplatesWith []*ChannelOverrideTemplateWhereInput `json:"hasChannelOverrideTemplatesWith,omitempty"`

	// "project_users" edge predicates.
	HasProjectUsers     *bool                    `json:"hasProjectUsers,omitempty"`
	HasProjectUsersWith []*UserProjectWhereInput `json:"hasProjectUsersWith,omitempty"`

	// "user_roles" edge predicates.
	HasUserRoles     *bool                 `json:"hasUserRoles,omitempty"`
	HasUserRolesWith []*UserRoleWhereInput `json:"hasUserRolesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserWhereInput) AddPredicates(predicates ...predicate.User) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserWhereInput filter on the UserQuery builder.
func (i *UserWhereInput) Filter(q *UserQuery) (*UserQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserWhereInput is returned in case the UserWhereInput is empty.
var ErrEmptyUserWhereInput = errors.New("ent: empty predicate UserWhereInput")

// P returns a predicate for filtering users.
// An error is returned if the input is empty or invalid.
func (i *UserWhereInput) P() (predicate.User, error) {
	var predicates []predicate.User
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, user.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.User, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, user.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.User, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, user.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, user.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, user.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, user.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, user.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, user.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, user.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, user.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, user.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, user.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, user.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, user.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, user.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, user.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, user.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, user.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, user.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, user.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, user.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, user.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, user.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, user.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, user.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, user.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, user.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, user.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, user.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, user.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, user.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, user.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, user.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, user.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, user.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.Email != nil {
		predicates = append(predicates, user.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, user.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, user.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, user.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, user.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, user.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, user.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, user.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, user.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, user.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, user.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, user.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, user.EmailContainsFold(*i.EmailContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, user.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, user.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, user.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, user.StatusNotIn(i.StatusNotIn...))
	}
	if i.PreferLanguage != nil {
		predicates = append(predicates, user.PreferLanguageEQ(*i.PreferLanguage))
	}
	if i.PreferLanguageNEQ != nil {
		predicates = append(predicates, user.PreferLanguageNEQ(*i.PreferLanguageNEQ))
	}
	if len(i.PreferLanguageIn) > 0 {
		predicates = append(predicates, user.PreferLanguageIn(i.PreferLanguageIn...))
	}
	if len(i.PreferLanguageNotIn) > 0 {
		predicates = append(predicates, user.PreferLanguageNotIn(i.PreferLanguageNotIn...))
	}
	if i.PreferLanguageGT != nil {
		predicates = append(predicates, user.PreferLanguageGT(*i.PreferLanguageGT))
	}
	if i.PreferLanguageGTE != nil {
		predicates = append(predicates, user.PreferLanguageGTE(*i.PreferLanguageGTE))
	}
	if i.PreferLanguageLT != nil {
		predicates = append(predicates, user.PreferLanguageLT(*i.PreferLanguageLT))
	}
	if i.PreferLanguageLTE != nil {
		predicates = append(predicates, user.PreferLanguageLTE(*i.PreferLanguageLTE))
	}
	if i.PreferLanguageContains != nil {
		predicates = append(predicates, user.PreferLanguageContains(*i.PreferLanguageContains))
	}
	if i.PreferLanguageHasPrefix != nil {
		predicates = append(predicates, user.PreferLanguageHasPrefix(*i.PreferLanguageHasPrefix))
	}
	if i.PreferLanguageHasSuffix != nil {
		predicates = append(predicates, user.PreferLanguageHasSuffix(*i.PreferLanguageHasSuffix))
	}
	if i.PreferLanguageEqualFold != nil {
		predicates = append(predicates, user.PreferLanguageEqualFold(*i.PreferLanguageEqualFold))
	}
	if i.PreferLanguageContainsFold != nil {
		predicates = append(predicates, user.PreferLanguageContainsFold(*i.PreferLanguageContainsFold))
	}
	if i.Password != nil {
		predicates = append(predicates, user.PasswordEQ(*i.Password))
	}
	if i.PasswordNEQ != nil {
		predicates = append(predicates, user.PasswordNEQ(*i.PasswordNEQ))
	}
	if len(i.PasswordIn) > 0 {
		predicates = append(predicates, user.PasswordIn(i.PasswordIn...))
	}
	if len(i.PasswordNotIn) > 0 {
		predicates = append(predicates, user.PasswordNotIn(i.PasswordNotIn...))
	}
	if i.PasswordGT != nil {
		predicates = append(predicates, user.PasswordGT(*i.PasswordGT))
	}
	if i.PasswordGTE != nil {
		predicates = append(predicates, user.PasswordGTE(*i.PasswordGTE))
	}
	if i.PasswordLT != nil {
		predicates = append(predicates, user.PasswordLT(*i.PasswordLT))
	}
	if i.PasswordLTE != nil {
		predicates = append(predicates, user.PasswordLTE(*i.PasswordLTE))
	}
	if i.PasswordContains != nil {
		predicates = append(predicates, user.PasswordContains(*i.PasswordContains))
	}
	if i.PasswordHasPrefix != nil {
		predicates = append(predicates, user.PasswordHasPrefix(*i.PasswordHasPrefix))
	}
	if i.PasswordHasSuffix != nil {
		predicates = append(predicates, user.PasswordHasSuffix(*i.PasswordHasSuffix))
	}
	if i.PasswordEqualFold != nil {
		predicates = append(predicates, user.PasswordEqualFold(*i.PasswordEqualFold))
	}
	if i.PasswordContainsFold != nil {
		predicates = append(predicates, user.PasswordContainsFold(*i.PasswordContainsFold))
	}
	if i.FirstName != nil {
		predicates = append(predicates, user.FirstNameEQ(*i.FirstName))
	}
	if i.FirstNameNEQ != nil {
		predicates = append(predicates, user.FirstNameNEQ(*i.FirstNameNEQ))
	}
	if len(i.FirstNameIn) > 0 {
		predicates = append(predicates, user.FirstNameIn(i.FirstNameIn...))
	}
	if len(i.FirstNameNotIn) > 0 {
		predicates = append(predicates, user.FirstNameNotIn(i.FirstNameNotIn...))
	}
	if i.FirstNameGT != nil {
		predicates = append(predicates, user.FirstNameGT(*i.FirstNameGT))
	}
	if i.FirstNameGTE != nil {
		predicates = append(predicates, user.FirstNameGTE(*i.FirstNameGTE))
	}
	if i.FirstNameLT != nil {
		predicates = append(predicates, user.FirstNameLT(*i.FirstNameLT))
	}
	if i.FirstNameLTE != nil {
		predicates = append(predicates, user.FirstNameLTE(*i.FirstNameLTE))
	}
	if i.FirstNameContains != nil {
		predicates = append(predicates, user.FirstNameContains(*i.FirstNameContains))
	}
	if i.FirstNameHasPrefix != nil {
		predicates = append(predicates, user.FirstNameHasPrefix(*i.FirstNameHasPrefix))
	}
	if i.FirstNameHasSuffix != nil {
		predicates = append(predicates, user.FirstNameHasSuffix(*i.FirstNameHasSuffix))
	}
	if i.FirstNameEqualFold != nil {
		predicates = append(predicates, user.FirstNameEqualFold(*i.FirstNameEqualFold))
	}
	if i.FirstNameContainsFold != nil {
		predicates = append(predicates, user.FirstNameContainsFold(*i.FirstNameContainsFold))
	}
	if i.LastName != nil {
		predicates = append(predicates, user.LastNameEQ(*i.LastName))
	}
	if i.LastNameNEQ != nil {
		predicates = append(predicates, user.LastNameNEQ(*i.LastNameNEQ))
	}
	if len(i.LastNameIn) > 0 {
		predicates = append(predicates, user.LastNameIn(i.LastNameIn...))
	}
	if len(i.LastNameNotIn) > 0 {
		predicates = append(predicates, user.LastNameNotIn(i.LastNameNotIn...))
	}
	if i.LastNameGT != nil {
		predicates = append(predicates, user.LastNameGT(*i.LastNameGT))
	}
	if i.LastNameGTE != nil {
		predicates = append(predicates, user.LastNameGTE(*i.LastNameGTE))
	}
	if i.LastNameLT != nil {
		predicates = append(predicates, user.LastNameLT(*i.LastNameLT))
	}
	if i.LastNameLTE != nil {
		predicates = append(predicates, user.LastNameLTE(*i.LastNameLTE))
	}
	if i.LastNameContains != nil {
		predicates = append(predicates, user.LastNameContains(*i.LastNameContains))
	}
	if i.LastNameHasPrefix != nil {
		predicates = append(predicates, user.LastNameHasPrefix(*i.LastNameHasPrefix))
	}
	if i.LastNameHasSuffix != nil {
		predicates = append(predicates, user.LastNameHasSuffix(*i.LastNameHasSuffix))
	}
	if i.LastNameEqualFold != nil {
		predicates = append(predicates, user.LastNameEqualFold(*i.LastNameEqualFold))
	}
	if i.LastNameContainsFold != nil {
		predicates = append(predicates, user.LastNameContainsFold(*i.LastNameContainsFold))
	}
	if i.Avatar != nil {
		predicates = append(predicates, user.AvatarEQ(*i.Avatar))
	}
	if i.AvatarNEQ != nil {
		predicates = append(predicates, user.AvatarNEQ(*i.AvatarNEQ))
	}
	if len(i.AvatarIn) > 0 {
		predicates = append(predicates, user.AvatarIn(i.AvatarIn...))
	}
	if len(i.AvatarNotIn) > 0 {
		predicates = append(predicates, user.AvatarNotIn(i.AvatarNotIn...))
	}
	if i.AvatarGT != nil {
		predicates = append(predicates, user.AvatarGT(*i.AvatarGT))
	}
	if i.AvatarGTE != nil {
		predicates = append(predicates, user.AvatarGTE(*i.AvatarGTE))
	}
	if i.AvatarLT != nil {
		predicates = append(predicates, user.AvatarLT(*i.AvatarLT))
	}
	if i.AvatarLTE != nil {
		predicates = append(predicates, user.AvatarLTE(*i.AvatarLTE))
	}
	if i.AvatarContains != nil {
		predicates = append(predicates, user.AvatarContains(*i.AvatarContains))
	}
	if i.AvatarHasPrefix != nil {
		predicates = append(predicates, user.AvatarHasPrefix(*i.AvatarHasPrefix))
	}
	if i.AvatarHasSuffix != nil {
		predicates = append(predicates, user.AvatarHasSuffix(*i.AvatarHasSuffix))
	}
	if i.AvatarIsNil {
		predicates = append(predicates, user.AvatarIsNil())
	}
	if i.AvatarNotNil {
		predicates = append(predicates, user.AvatarNotNil())
	}
	if i.AvatarEqualFold != nil {
		predicates = append(predicates, user.AvatarEqualFold(*i.AvatarEqualFold))
	}
	if i.AvatarContainsFold != nil {
		predicates = append(predicates, user.AvatarContainsFold(*i.AvatarContainsFold))
	}
	if i.IsOwner != nil {
		predicates = append(predicates, user.IsOwnerEQ(*i.IsOwner))
	}
	if i.IsOwnerNEQ != nil {
		predicates = append(predicates, user.IsOwnerNEQ(*i.IsOwnerNEQ))
	}

	if i.HasProjects != nil {
		p := user.HasProjects()
		if !*i.HasProjects {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProjectsWith) > 0 {
		with := make([]predicate.Project, 0, len(i.HasProjectsWith))
		for _, w := range i.HasProjectsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProjectsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasProjectsWith(with...))
	}
	if i.HasAPIKeys != nil {
		p := user.HasAPIKeys()
		if !*i.HasAPIKeys {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAPIKeysWith) > 0 {
		with := make([]predicate.APIKey, 0, len(i.HasAPIKeysWith))
		for _, w := range i.HasAPIKeysWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAPIKeysWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasAPIKeysWith(with...))
	}
	if i.HasRoles != nil {
		p := user.HasRoles()
		if !*i.HasRoles {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRolesWith) > 0 {
		with := make([]predicate.Role, 0, len(i.HasRolesWith))
		for _, w := range i.HasRolesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRolesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasRolesWith(with...))
	}
	if i.HasChannelOverrideTemplates != nil {
		p := user.HasChannelOverrideTemplates()
		if !*i.HasChannelOverrideTemplates {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasChannelOverrideTemplatesWith) > 0 {
		with := make([]predicate.ChannelOverrideTemplate, 0, len(i.HasChannelOverrideTemplatesWith))
		for _, w := range i.HasChannelOverrideTemplatesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasChannelOverrideTemplatesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasChannelOverrideTemplatesWith(with...))
	}
	if i.HasProjectUsers != nil {
		p := user.HasProjectUsers()
		if !*i.HasProjectUsers {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProjectUsersWith) > 0 {
		with := make([]predicate.UserProject, 0, len(i.HasProjectUsersWith))
		for _, w := range i.HasProjectUsersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProjectUsersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasProjectUsersWith(with...))
	}
	if i.HasUserRoles != nil {
		p := user.HasUserRoles()
		if !*i.HasUserRoles {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserRolesWith) > 0 {
		with := make([]predicate.UserRole, 0, len(i.HasUserRolesWith))
		for _, w := range i.HasUserRolesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserRolesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasUserRolesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserWhereInput
	case 1:
		return predicates[0], nil
	default:
		return user.And(predicates...), nil
	}
}

// UserProjectWhereInput represents a where input for filtering UserProject queries.
type UserProjectWhereInput struct {
	Predicates []predicate.UserProject  `json:"-"`
	Not        *UserProjectWhereInput   `json:"not,omitempty"`
	Or         []*UserProjectWhereInput `json:"or,omitempty"`
	And        []*UserProjectWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "user_id" field predicates.
	UserID      *int  `json:"userID,omitempty"`
	UserIDNEQ   *int  `json:"userIDNEQ,omitempty"`
	UserIDIn    []int `json:"userIDIn,omitempty"`
	UserIDNotIn []int `json:"userIDNotIn,omitempty"`

	// "project_id" field predicates.
	ProjectID      *int  `json:"projectID,omitempty"`
	ProjectIDNEQ   *int  `json:"projectIDNEQ,omitempty"`
	ProjectIDIn    []int `json:"projectIDIn,omitempty"`
	ProjectIDNotIn []int `json:"projectIDNotIn,omitempty"`

	// "is_owner" field predicates.
	IsOwner    *bool `json:"isOwner,omitempty"`
	IsOwnerNEQ *bool `json:"isOwnerNEQ,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`

	// "project" edge predicates.
	HasProject     *bool                `json:"hasProject,omitempty"`
	HasProjectWith []*ProjectWhereInput `json:"hasProjectWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserProjectWhereInput) AddPredicates(predicates ...predicate.UserProject) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserProjectWhereInput filter on the UserProjectQuery builder.
func (i *UserProjectWhereInput) Filter(q *UserProjectQuery) (*UserProjectQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserProjectWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserProjectWhereInput is returned in case the UserProjectWhereInput is empty.
var ErrEmptyUserProjectWhereInput = errors.New("ent: empty predicate UserProjectWhereInput")

// P returns a predicate for filtering userprojects.
// An error is returned if the input is empty or invalid.
func (i *UserProjectWhereInput) P() (predicate.UserProject, error) {
	var predicates []predicate.UserProject
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, userproject.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.UserProject, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, userproject.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.UserProject, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, userproject.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, userproject.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, userproject.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, userproject.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, userproject.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, userproject.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, userproject.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, userproject.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, userproject.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, userproject.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, userproject.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, userproject.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, userproject.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, userproject.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, userproject.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, userproject.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, userproject.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, userproject.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, userproject.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, userproject.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, userproject.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, userproject.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, userproject.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, userproject.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, userproject.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UserID != nil {
		predicates = append(predicates, userproject.UserIDEQ(*i.UserID))
	}
	if i.UserIDNEQ != nil {
		predicates = append(predicates, userproject.UserIDNEQ(*i.UserIDNEQ))
	}
	if len(i.UserIDIn) > 0 {
		predicates = append(predicates, userproject.UserIDIn(i.UserIDIn...))
	}
	if len(i.UserIDNotIn) > 0 {
		predicates = append(predicates, userproject.UserIDNotIn(i.UserIDNotIn...))
	}
	if i.ProjectID != nil {
		predicates = append(predicates, userproject.ProjectIDEQ(*i.ProjectID))
	}
	if i.ProjectIDNEQ != nil {
		predicates = append(predicates, userproject.ProjectIDNEQ(*i.ProjectIDNEQ))
	}
	if len(i.ProjectIDIn) > 0 {
		predicates = append(predicates, userproject.ProjectIDIn(i.ProjectIDIn...))
	}
	if len(i.ProjectIDNotIn) > 0 {
		predicates = append(predicates, userproject.ProjectIDNotIn(i.ProjectIDNotIn...))
	}
	if i.IsOwner != nil {
		predicates = append(predicates, userproject.IsOwnerEQ(*i.IsOwner))
	}
	if i.IsOwnerNEQ != nil {
		predicates = append(predicates, userproject.IsOwnerNEQ(*i.IsOwnerNEQ))
	}

	if i.HasUser != nil {
		p := userproject.HasUser()
		if !*i.HasUser {
			p = userproject.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, userproject.HasUserWith(with...))
	}
	if i.HasProject != nil {
		p := userproject.HasProject()
		if !*i.HasProject {
			p = userproject.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProjectWith) > 0 {
		with := make([]predicate.Project, 0, len(i.HasProjectWith))
		for _, w := range i.HasProjectWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProjectWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, userproject.HasProjectWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserProjectWhereInput
	case 1:
		return predicates[0], nil
	default:
		return userproject.And(predicates...), nil
	}
}

// UserRoleWhereInput represents a where input for filtering UserRole queries.
type UserRoleWhereInput struct {
	Predicates []predicate.UserRole  `json:"-"`
	Not        *UserRoleWhereInput   `json:"not,omitempty"`
	Or         []*UserRoleWhereInput `json:"or,omitempty"`
	And        []*UserRoleWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "user_id" field predicates.
	UserID      *int  `json:"userID,omitempty"`
	UserIDNEQ   *int  `json:"userIDNEQ,omitempty"`
	UserIDIn    []int `json:"userIDIn,omitempty"`
	UserIDNotIn []int `json:"userIDNotIn,omitempty"`

	// "role_id" field predicates.
	RoleID      *int  `json:"roleID,omitempty"`
	RoleIDNEQ   *int  `json:"roleIDNEQ,omitempty"`
	RoleIDIn    []int `json:"roleIDIn,omitempty"`
	RoleIDNotIn []int `json:"roleIDNotIn,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`

	// "role" edge predicates.
	HasRole     *bool             `json:"hasRole,omitempty"`
	HasRoleWith []*RoleWhereInput `json:"hasRoleWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserRoleWhereInput) AddPredicates(predicates ...predicate.UserRole) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserRoleWhereInput filter on the UserRoleQuery builder.
func (i *UserRoleWhereInput) Filter(q *UserRoleQuery) (*UserRoleQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserRoleWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserRoleWhereInput is returned in case the UserRoleWhereInput is empty.
var ErrEmptyUserRoleWhereInput = errors.New("ent: empty predicate UserRoleWhereInput")

// P returns a predicate for filtering userroles.
// An error is returned if the input is empty or invalid.
func (i *UserRoleWhereInput) P() (predicate.UserRole, error) {
	var predicates []predicate.UserRole
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, userrole.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.UserRole, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, userrole.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.UserRole, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, userrole.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, userrole.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, userrole.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, userrole.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, userrole.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, userrole.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, userrole.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, userrole.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, userrole.IDLTE(*i.IDLTE))
	}
	if i.UserID != nil {
		predicates = append(predicates, userrole.UserIDEQ(*i.UserID))
	}
	if i.UserIDNEQ != nil {
		predicates = append(predicates, userrole.UserIDNEQ(*i.UserIDNEQ))
	}
	if len(i.UserIDIn) > 0 {
		predicates = append(predicates, userrole.UserIDIn(i.UserIDIn...))
	}
	if len(i.UserIDNotIn) > 0 {
		predicates = append(predicates, userrole.UserIDNotIn(i.UserIDNotIn...))
	}
	if i.RoleID != nil {
		predicates = append(predicates, userrole.RoleIDEQ(*i.RoleID))
	}
	if i.RoleIDNEQ != nil {
		predicates = append(predicates, userrole.RoleIDNEQ(*i.RoleIDNEQ))
	}
	if len(i.RoleIDIn) > 0 {
		predicates = append(predicates, userrole.RoleIDIn(i.RoleIDIn...))
	}
	if len(i.RoleIDNotIn) > 0 {
		predicates = append(predicates, userrole.RoleIDNotIn(i.RoleIDNotIn...))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, userrole.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, userrole.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, userrole.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, userrole.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, userrole.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, userrole.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, userrole.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, userrole.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, userrole.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, userrole.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, userrole.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, userrole.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, userrole.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, userrole.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, userrole.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, userrole.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, userrole.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, userrole.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, userrole.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, userrole.UpdatedAtNotNil())
	}

	if i.HasUser != nil {
		p := userrole.HasUser()
		if !*i.HasUser {
			p = userrole.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, userrole.HasUserWith(with...))
	}
	if i.HasRole != nil {
		p := userrole.HasRole()
		if !*i.HasRole {
			p = userrole.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRoleWith) > 0 {
		with := make([]predicate.Role, 0, len(i.HasRoleWith))
		for _, w := range i.HasRoleWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRoleWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, userrole.HasRoleWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserRoleWhereInput
	case 1:
		return predicates[0], nil
	default:
		return userrole.And(predicates...), nil
	}
}
