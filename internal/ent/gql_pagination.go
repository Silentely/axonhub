// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"io"
	"strconv"

	"entgo.io/contrib/entgql"
	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/errcode"
	"github.com/looplj/axonhub/internal/ent/apikey"
	"github.com/looplj/axonhub/internal/ent/channel"
	"github.com/looplj/axonhub/internal/ent/channeloverridetemplate"
	"github.com/looplj/axonhub/internal/ent/channelperformance"
	"github.com/looplj/axonhub/internal/ent/datastorage"
	"github.com/looplj/axonhub/internal/ent/model"
	"github.com/looplj/axonhub/internal/ent/project"
	"github.com/looplj/axonhub/internal/ent/request"
	"github.com/looplj/axonhub/internal/ent/requestexecution"
	"github.com/looplj/axonhub/internal/ent/role"
	"github.com/looplj/axonhub/internal/ent/system"
	"github.com/looplj/axonhub/internal/ent/thread"
	"github.com/looplj/axonhub/internal/ent/trace"
	"github.com/looplj/axonhub/internal/ent/usagelog"
	"github.com/looplj/axonhub/internal/ent/user"
	"github.com/looplj/axonhub/internal/ent/userproject"
	"github.com/looplj/axonhub/internal/ent/userrole"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// Common entgql types.
type (
	Cursor         = entgql.Cursor[int]
	PageInfo       = entgql.PageInfo[int]
	OrderDirection = entgql.OrderDirection
)

func orderFunc(o OrderDirection, field string) func(*sql.Selector) {
	if o == entgql.OrderDirectionDesc {
		return Desc(field)
	}
	return Asc(field)
}

const errInvalidPagination = "INVALID_PAGINATION"

func validateFirstLast(first, last *int) (err *gqlerror.Error) {
	switch {
	case first != nil && last != nil:
		err = &gqlerror.Error{
			Message: "Passing both `first` and `last` to paginate a connection is not supported.",
		}
	case first != nil && *first < 0:
		err = &gqlerror.Error{
			Message: "`first` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	case last != nil && *last < 0:
		err = &gqlerror.Error{
			Message: "`last` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	}
	return err
}

func collectedField(ctx context.Context, path ...string) *graphql.CollectedField {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nil
	}
	field := fc.Field
	oc := graphql.GetOperationContext(ctx)
walk:
	for _, name := range path {
		for _, f := range graphql.CollectFields(oc, field.Selections, nil) {
			if f.Alias == name {
				field = f
				continue walk
			}
		}
		return nil
	}
	return &field
}

func hasCollectedField(ctx context.Context, path ...string) bool {
	if graphql.GetFieldContext(ctx) == nil {
		return true
	}
	return collectedField(ctx, path...) != nil
}

const (
	edgesField      = "edges"
	nodeField       = "node"
	pageInfoField   = "pageInfo"
	totalCountField = "totalCount"
)

func paginateLimit(first, last *int) int {
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	return limit
}

// APIKeyEdge is the edge representation of APIKey.
type APIKeyEdge struct {
	Node   *APIKey `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// APIKeyConnection is the connection containing edges to APIKey.
type APIKeyConnection struct {
	Edges      []*APIKeyEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

func (c *APIKeyConnection) build(nodes []*APIKey, pager *apikeyPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *APIKey
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *APIKey {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *APIKey {
			return nodes[i]
		}
	}
	c.Edges = make([]*APIKeyEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &APIKeyEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// APIKeyPaginateOption enables pagination customization.
type APIKeyPaginateOption func(*apikeyPager) error

// WithAPIKeyOrder configures pagination ordering.
func WithAPIKeyOrder(order *APIKeyOrder) APIKeyPaginateOption {
	if order == nil {
		order = DefaultAPIKeyOrder
	}
	o := *order
	return func(pager *apikeyPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultAPIKeyOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithAPIKeyFilter configures pagination filter.
func WithAPIKeyFilter(filter func(*APIKeyQuery) (*APIKeyQuery, error)) APIKeyPaginateOption {
	return func(pager *apikeyPager) error {
		if filter == nil {
			return errors.New("APIKeyQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type apikeyPager struct {
	reverse bool
	order   *APIKeyOrder
	filter  func(*APIKeyQuery) (*APIKeyQuery, error)
}

func newAPIKeyPager(opts []APIKeyPaginateOption, reverse bool) (*apikeyPager, error) {
	pager := &apikeyPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultAPIKeyOrder
	}
	return pager, nil
}

func (p *apikeyPager) applyFilter(query *APIKeyQuery) (*APIKeyQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *apikeyPager) toCursor(_m *APIKey) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *apikeyPager) applyCursors(query *APIKeyQuery, after, before *Cursor) (*APIKeyQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultAPIKeyOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *apikeyPager) applyOrder(query *APIKeyQuery) *APIKeyQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultAPIKeyOrder.Field {
		query = query.Order(DefaultAPIKeyOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *apikeyPager) orderExpr(query *APIKeyQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultAPIKeyOrder.Field {
			b.Comma().Ident(DefaultAPIKeyOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to APIKey.
func (_m *APIKeyQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...APIKeyPaginateOption,
) (*APIKeyConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAPIKeyPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &APIKeyConnection{Edges: []*APIKeyEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// APIKeyOrderFieldCreatedAt orders APIKey by created_at.
	APIKeyOrderFieldCreatedAt = &APIKeyOrderField{
		Value: func(_m *APIKey) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: apikey.FieldCreatedAt,
		toTerm: apikey.ByCreatedAt,
		toCursor: func(_m *APIKey) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// APIKeyOrderFieldUpdatedAt orders APIKey by updated_at.
	APIKeyOrderFieldUpdatedAt = &APIKeyOrderField{
		Value: func(_m *APIKey) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: apikey.FieldUpdatedAt,
		toTerm: apikey.ByUpdatedAt,
		toCursor: func(_m *APIKey) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f APIKeyOrderField) String() string {
	var str string
	switch f.column {
	case APIKeyOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case APIKeyOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f APIKeyOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *APIKeyOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("APIKeyOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *APIKeyOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *APIKeyOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid APIKeyOrderField", str)
	}
	return nil
}

// APIKeyOrderField defines the ordering field of APIKey.
type APIKeyOrderField struct {
	// Value extracts the ordering value from the given APIKey.
	Value    func(*APIKey) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) apikey.OrderOption
	toCursor func(*APIKey) Cursor
}

// APIKeyOrder defines the ordering of APIKey.
type APIKeyOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *APIKeyOrderField `json:"field"`
}

// DefaultAPIKeyOrder is the default ordering of APIKey.
var DefaultAPIKeyOrder = &APIKeyOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &APIKeyOrderField{
		Value: func(_m *APIKey) (ent.Value, error) {
			return _m.ID, nil
		},
		column: apikey.FieldID,
		toTerm: apikey.ByID,
		toCursor: func(_m *APIKey) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts APIKey into APIKeyEdge.
func (_m *APIKey) ToEdge(order *APIKeyOrder) *APIKeyEdge {
	if order == nil {
		order = DefaultAPIKeyOrder
	}
	return &APIKeyEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// ChannelEdge is the edge representation of Channel.
type ChannelEdge struct {
	Node   *Channel `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// ChannelConnection is the connection containing edges to Channel.
type ChannelConnection struct {
	Edges      []*ChannelEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *ChannelConnection) build(nodes []*Channel, pager *channelPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Channel
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Channel {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Channel {
			return nodes[i]
		}
	}
	c.Edges = make([]*ChannelEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ChannelEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ChannelPaginateOption enables pagination customization.
type ChannelPaginateOption func(*channelPager) error

// WithChannelOrder configures pagination ordering.
func WithChannelOrder(order *ChannelOrder) ChannelPaginateOption {
	if order == nil {
		order = DefaultChannelOrder
	}
	o := *order
	return func(pager *channelPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultChannelOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithChannelFilter configures pagination filter.
func WithChannelFilter(filter func(*ChannelQuery) (*ChannelQuery, error)) ChannelPaginateOption {
	return func(pager *channelPager) error {
		if filter == nil {
			return errors.New("ChannelQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type channelPager struct {
	reverse bool
	order   *ChannelOrder
	filter  func(*ChannelQuery) (*ChannelQuery, error)
}

func newChannelPager(opts []ChannelPaginateOption, reverse bool) (*channelPager, error) {
	pager := &channelPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultChannelOrder
	}
	return pager, nil
}

func (p *channelPager) applyFilter(query *ChannelQuery) (*ChannelQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *channelPager) toCursor(_m *Channel) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *channelPager) applyCursors(query *ChannelQuery, after, before *Cursor) (*ChannelQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultChannelOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *channelPager) applyOrder(query *ChannelQuery) *ChannelQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultChannelOrder.Field {
		query = query.Order(DefaultChannelOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *channelPager) orderExpr(query *ChannelQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultChannelOrder.Field {
			b.Comma().Ident(DefaultChannelOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Channel.
func (_m *ChannelQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ChannelPaginateOption,
) (*ChannelConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newChannelPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &ChannelConnection{Edges: []*ChannelEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ChannelOrderFieldCreatedAt orders Channel by created_at.
	ChannelOrderFieldCreatedAt = &ChannelOrderField{
		Value: func(_m *Channel) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: channel.FieldCreatedAt,
		toTerm: channel.ByCreatedAt,
		toCursor: func(_m *Channel) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// ChannelOrderFieldUpdatedAt orders Channel by updated_at.
	ChannelOrderFieldUpdatedAt = &ChannelOrderField{
		Value: func(_m *Channel) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: channel.FieldUpdatedAt,
		toTerm: channel.ByUpdatedAt,
		toCursor: func(_m *Channel) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// ChannelOrderFieldType orders Channel by type.
	ChannelOrderFieldType = &ChannelOrderField{
		Value: func(_m *Channel) (ent.Value, error) {
			return _m.Type, nil
		},
		column: channel.FieldType,
		toTerm: channel.ByType,
		toCursor: func(_m *Channel) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Type,
			}
		},
	}
	// ChannelOrderFieldName orders Channel by name.
	ChannelOrderFieldName = &ChannelOrderField{
		Value: func(_m *Channel) (ent.Value, error) {
			return _m.Name, nil
		},
		column: channel.FieldName,
		toTerm: channel.ByName,
		toCursor: func(_m *Channel) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// ChannelOrderFieldStatus orders Channel by status.
	ChannelOrderFieldStatus = &ChannelOrderField{
		Value: func(_m *Channel) (ent.Value, error) {
			return _m.Status, nil
		},
		column: channel.FieldStatus,
		toTerm: channel.ByStatus,
		toCursor: func(_m *Channel) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
	// ChannelOrderFieldOrderingWeight orders Channel by ordering_weight.
	ChannelOrderFieldOrderingWeight = &ChannelOrderField{
		Value: func(_m *Channel) (ent.Value, error) {
			return _m.OrderingWeight, nil
		},
		column: channel.FieldOrderingWeight,
		toTerm: channel.ByOrderingWeight,
		toCursor: func(_m *Channel) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.OrderingWeight,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ChannelOrderField) String() string {
	var str string
	switch f.column {
	case ChannelOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case ChannelOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case ChannelOrderFieldType.column:
		str = "TYPE"
	case ChannelOrderFieldName.column:
		str = "NAME"
	case ChannelOrderFieldStatus.column:
		str = "STATUS"
	case ChannelOrderFieldOrderingWeight.column:
		str = "ORDERING_WEIGHT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ChannelOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ChannelOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ChannelOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *ChannelOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *ChannelOrderFieldUpdatedAt
	case "TYPE":
		*f = *ChannelOrderFieldType
	case "NAME":
		*f = *ChannelOrderFieldName
	case "STATUS":
		*f = *ChannelOrderFieldStatus
	case "ORDERING_WEIGHT":
		*f = *ChannelOrderFieldOrderingWeight
	default:
		return fmt.Errorf("%s is not a valid ChannelOrderField", str)
	}
	return nil
}

// ChannelOrderField defines the ordering field of Channel.
type ChannelOrderField struct {
	// Value extracts the ordering value from the given Channel.
	Value    func(*Channel) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) channel.OrderOption
	toCursor func(*Channel) Cursor
}

// ChannelOrder defines the ordering of Channel.
type ChannelOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *ChannelOrderField `json:"field"`
}

// DefaultChannelOrder is the default ordering of Channel.
var DefaultChannelOrder = &ChannelOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ChannelOrderField{
		Value: func(_m *Channel) (ent.Value, error) {
			return _m.ID, nil
		},
		column: channel.FieldID,
		toTerm: channel.ByID,
		toCursor: func(_m *Channel) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Channel into ChannelEdge.
func (_m *Channel) ToEdge(order *ChannelOrder) *ChannelEdge {
	if order == nil {
		order = DefaultChannelOrder
	}
	return &ChannelEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// ChannelOverrideTemplateEdge is the edge representation of ChannelOverrideTemplate.
type ChannelOverrideTemplateEdge struct {
	Node   *ChannelOverrideTemplate `json:"node"`
	Cursor Cursor                   `json:"cursor"`
}

// ChannelOverrideTemplateConnection is the connection containing edges to ChannelOverrideTemplate.
type ChannelOverrideTemplateConnection struct {
	Edges      []*ChannelOverrideTemplateEdge `json:"edges"`
	PageInfo   PageInfo                       `json:"pageInfo"`
	TotalCount int                            `json:"totalCount"`
}

func (c *ChannelOverrideTemplateConnection) build(nodes []*ChannelOverrideTemplate, pager *channeloverridetemplatePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ChannelOverrideTemplate
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ChannelOverrideTemplate {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ChannelOverrideTemplate {
			return nodes[i]
		}
	}
	c.Edges = make([]*ChannelOverrideTemplateEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ChannelOverrideTemplateEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ChannelOverrideTemplatePaginateOption enables pagination customization.
type ChannelOverrideTemplatePaginateOption func(*channeloverridetemplatePager) error

// WithChannelOverrideTemplateOrder configures pagination ordering.
func WithChannelOverrideTemplateOrder(order *ChannelOverrideTemplateOrder) ChannelOverrideTemplatePaginateOption {
	if order == nil {
		order = DefaultChannelOverrideTemplateOrder
	}
	o := *order
	return func(pager *channeloverridetemplatePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultChannelOverrideTemplateOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithChannelOverrideTemplateFilter configures pagination filter.
func WithChannelOverrideTemplateFilter(filter func(*ChannelOverrideTemplateQuery) (*ChannelOverrideTemplateQuery, error)) ChannelOverrideTemplatePaginateOption {
	return func(pager *channeloverridetemplatePager) error {
		if filter == nil {
			return errors.New("ChannelOverrideTemplateQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type channeloverridetemplatePager struct {
	reverse bool
	order   *ChannelOverrideTemplateOrder
	filter  func(*ChannelOverrideTemplateQuery) (*ChannelOverrideTemplateQuery, error)
}

func newChannelOverrideTemplatePager(opts []ChannelOverrideTemplatePaginateOption, reverse bool) (*channeloverridetemplatePager, error) {
	pager := &channeloverridetemplatePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultChannelOverrideTemplateOrder
	}
	return pager, nil
}

func (p *channeloverridetemplatePager) applyFilter(query *ChannelOverrideTemplateQuery) (*ChannelOverrideTemplateQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *channeloverridetemplatePager) toCursor(_m *ChannelOverrideTemplate) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *channeloverridetemplatePager) applyCursors(query *ChannelOverrideTemplateQuery, after, before *Cursor) (*ChannelOverrideTemplateQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultChannelOverrideTemplateOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *channeloverridetemplatePager) applyOrder(query *ChannelOverrideTemplateQuery) *ChannelOverrideTemplateQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultChannelOverrideTemplateOrder.Field {
		query = query.Order(DefaultChannelOverrideTemplateOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *channeloverridetemplatePager) orderExpr(query *ChannelOverrideTemplateQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultChannelOverrideTemplateOrder.Field {
			b.Comma().Ident(DefaultChannelOverrideTemplateOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ChannelOverrideTemplate.
func (_m *ChannelOverrideTemplateQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ChannelOverrideTemplatePaginateOption,
) (*ChannelOverrideTemplateConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newChannelOverrideTemplatePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &ChannelOverrideTemplateConnection{Edges: []*ChannelOverrideTemplateEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ChannelOverrideTemplateOrderFieldCreatedAt orders ChannelOverrideTemplate by created_at.
	ChannelOverrideTemplateOrderFieldCreatedAt = &ChannelOverrideTemplateOrderField{
		Value: func(_m *ChannelOverrideTemplate) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: channeloverridetemplate.FieldCreatedAt,
		toTerm: channeloverridetemplate.ByCreatedAt,
		toCursor: func(_m *ChannelOverrideTemplate) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// ChannelOverrideTemplateOrderFieldUpdatedAt orders ChannelOverrideTemplate by updated_at.
	ChannelOverrideTemplateOrderFieldUpdatedAt = &ChannelOverrideTemplateOrderField{
		Value: func(_m *ChannelOverrideTemplate) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: channeloverridetemplate.FieldUpdatedAt,
		toTerm: channeloverridetemplate.ByUpdatedAt,
		toCursor: func(_m *ChannelOverrideTemplate) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ChannelOverrideTemplateOrderField) String() string {
	var str string
	switch f.column {
	case ChannelOverrideTemplateOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case ChannelOverrideTemplateOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ChannelOverrideTemplateOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ChannelOverrideTemplateOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ChannelOverrideTemplateOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *ChannelOverrideTemplateOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *ChannelOverrideTemplateOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid ChannelOverrideTemplateOrderField", str)
	}
	return nil
}

// ChannelOverrideTemplateOrderField defines the ordering field of ChannelOverrideTemplate.
type ChannelOverrideTemplateOrderField struct {
	// Value extracts the ordering value from the given ChannelOverrideTemplate.
	Value    func(*ChannelOverrideTemplate) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) channeloverridetemplate.OrderOption
	toCursor func(*ChannelOverrideTemplate) Cursor
}

// ChannelOverrideTemplateOrder defines the ordering of ChannelOverrideTemplate.
type ChannelOverrideTemplateOrder struct {
	Direction OrderDirection                     `json:"direction"`
	Field     *ChannelOverrideTemplateOrderField `json:"field"`
}

// DefaultChannelOverrideTemplateOrder is the default ordering of ChannelOverrideTemplate.
var DefaultChannelOverrideTemplateOrder = &ChannelOverrideTemplateOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ChannelOverrideTemplateOrderField{
		Value: func(_m *ChannelOverrideTemplate) (ent.Value, error) {
			return _m.ID, nil
		},
		column: channeloverridetemplate.FieldID,
		toTerm: channeloverridetemplate.ByID,
		toCursor: func(_m *ChannelOverrideTemplate) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts ChannelOverrideTemplate into ChannelOverrideTemplateEdge.
func (_m *ChannelOverrideTemplate) ToEdge(order *ChannelOverrideTemplateOrder) *ChannelOverrideTemplateEdge {
	if order == nil {
		order = DefaultChannelOverrideTemplateOrder
	}
	return &ChannelOverrideTemplateEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// ChannelPerformanceEdge is the edge representation of ChannelPerformance.
type ChannelPerformanceEdge struct {
	Node   *ChannelPerformance `json:"node"`
	Cursor Cursor              `json:"cursor"`
}

// ChannelPerformanceConnection is the connection containing edges to ChannelPerformance.
type ChannelPerformanceConnection struct {
	Edges      []*ChannelPerformanceEdge `json:"edges"`
	PageInfo   PageInfo                  `json:"pageInfo"`
	TotalCount int                       `json:"totalCount"`
}

func (c *ChannelPerformanceConnection) build(nodes []*ChannelPerformance, pager *channelperformancePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ChannelPerformance
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ChannelPerformance {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ChannelPerformance {
			return nodes[i]
		}
	}
	c.Edges = make([]*ChannelPerformanceEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ChannelPerformanceEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ChannelPerformancePaginateOption enables pagination customization.
type ChannelPerformancePaginateOption func(*channelperformancePager) error

// WithChannelPerformanceOrder configures pagination ordering.
func WithChannelPerformanceOrder(order *ChannelPerformanceOrder) ChannelPerformancePaginateOption {
	if order == nil {
		order = DefaultChannelPerformanceOrder
	}
	o := *order
	return func(pager *channelperformancePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultChannelPerformanceOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithChannelPerformanceFilter configures pagination filter.
func WithChannelPerformanceFilter(filter func(*ChannelPerformanceQuery) (*ChannelPerformanceQuery, error)) ChannelPerformancePaginateOption {
	return func(pager *channelperformancePager) error {
		if filter == nil {
			return errors.New("ChannelPerformanceQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type channelperformancePager struct {
	reverse bool
	order   *ChannelPerformanceOrder
	filter  func(*ChannelPerformanceQuery) (*ChannelPerformanceQuery, error)
}

func newChannelPerformancePager(opts []ChannelPerformancePaginateOption, reverse bool) (*channelperformancePager, error) {
	pager := &channelperformancePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultChannelPerformanceOrder
	}
	return pager, nil
}

func (p *channelperformancePager) applyFilter(query *ChannelPerformanceQuery) (*ChannelPerformanceQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *channelperformancePager) toCursor(_m *ChannelPerformance) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *channelperformancePager) applyCursors(query *ChannelPerformanceQuery, after, before *Cursor) (*ChannelPerformanceQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultChannelPerformanceOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *channelperformancePager) applyOrder(query *ChannelPerformanceQuery) *ChannelPerformanceQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultChannelPerformanceOrder.Field {
		query = query.Order(DefaultChannelPerformanceOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *channelperformancePager) orderExpr(query *ChannelPerformanceQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultChannelPerformanceOrder.Field {
			b.Comma().Ident(DefaultChannelPerformanceOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ChannelPerformance.
func (_m *ChannelPerformanceQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ChannelPerformancePaginateOption,
) (*ChannelPerformanceConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newChannelPerformancePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &ChannelPerformanceConnection{Edges: []*ChannelPerformanceEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ChannelPerformanceOrderFieldCreatedAt orders ChannelPerformance by created_at.
	ChannelPerformanceOrderFieldCreatedAt = &ChannelPerformanceOrderField{
		Value: func(_m *ChannelPerformance) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: channelperformance.FieldCreatedAt,
		toTerm: channelperformance.ByCreatedAt,
		toCursor: func(_m *ChannelPerformance) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// ChannelPerformanceOrderFieldUpdatedAt orders ChannelPerformance by updated_at.
	ChannelPerformanceOrderFieldUpdatedAt = &ChannelPerformanceOrderField{
		Value: func(_m *ChannelPerformance) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: channelperformance.FieldUpdatedAt,
		toTerm: channelperformance.ByUpdatedAt,
		toCursor: func(_m *ChannelPerformance) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ChannelPerformanceOrderField) String() string {
	var str string
	switch f.column {
	case ChannelPerformanceOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case ChannelPerformanceOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ChannelPerformanceOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ChannelPerformanceOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ChannelPerformanceOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *ChannelPerformanceOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *ChannelPerformanceOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid ChannelPerformanceOrderField", str)
	}
	return nil
}

// ChannelPerformanceOrderField defines the ordering field of ChannelPerformance.
type ChannelPerformanceOrderField struct {
	// Value extracts the ordering value from the given ChannelPerformance.
	Value    func(*ChannelPerformance) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) channelperformance.OrderOption
	toCursor func(*ChannelPerformance) Cursor
}

// ChannelPerformanceOrder defines the ordering of ChannelPerformance.
type ChannelPerformanceOrder struct {
	Direction OrderDirection                `json:"direction"`
	Field     *ChannelPerformanceOrderField `json:"field"`
}

// DefaultChannelPerformanceOrder is the default ordering of ChannelPerformance.
var DefaultChannelPerformanceOrder = &ChannelPerformanceOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ChannelPerformanceOrderField{
		Value: func(_m *ChannelPerformance) (ent.Value, error) {
			return _m.ID, nil
		},
		column: channelperformance.FieldID,
		toTerm: channelperformance.ByID,
		toCursor: func(_m *ChannelPerformance) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts ChannelPerformance into ChannelPerformanceEdge.
func (_m *ChannelPerformance) ToEdge(order *ChannelPerformanceOrder) *ChannelPerformanceEdge {
	if order == nil {
		order = DefaultChannelPerformanceOrder
	}
	return &ChannelPerformanceEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// DataStorageEdge is the edge representation of DataStorage.
type DataStorageEdge struct {
	Node   *DataStorage `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// DataStorageConnection is the connection containing edges to DataStorage.
type DataStorageConnection struct {
	Edges      []*DataStorageEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *DataStorageConnection) build(nodes []*DataStorage, pager *datastoragePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *DataStorage
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DataStorage {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DataStorage {
			return nodes[i]
		}
	}
	c.Edges = make([]*DataStorageEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DataStorageEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DataStoragePaginateOption enables pagination customization.
type DataStoragePaginateOption func(*datastoragePager) error

// WithDataStorageOrder configures pagination ordering.
func WithDataStorageOrder(order *DataStorageOrder) DataStoragePaginateOption {
	if order == nil {
		order = DefaultDataStorageOrder
	}
	o := *order
	return func(pager *datastoragePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultDataStorageOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithDataStorageFilter configures pagination filter.
func WithDataStorageFilter(filter func(*DataStorageQuery) (*DataStorageQuery, error)) DataStoragePaginateOption {
	return func(pager *datastoragePager) error {
		if filter == nil {
			return errors.New("DataStorageQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type datastoragePager struct {
	reverse bool
	order   *DataStorageOrder
	filter  func(*DataStorageQuery) (*DataStorageQuery, error)
}

func newDataStoragePager(opts []DataStoragePaginateOption, reverse bool) (*datastoragePager, error) {
	pager := &datastoragePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultDataStorageOrder
	}
	return pager, nil
}

func (p *datastoragePager) applyFilter(query *DataStorageQuery) (*DataStorageQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *datastoragePager) toCursor(_m *DataStorage) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *datastoragePager) applyCursors(query *DataStorageQuery, after, before *Cursor) (*DataStorageQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultDataStorageOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *datastoragePager) applyOrder(query *DataStorageQuery) *DataStorageQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultDataStorageOrder.Field {
		query = query.Order(DefaultDataStorageOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *datastoragePager) orderExpr(query *DataStorageQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultDataStorageOrder.Field {
			b.Comma().Ident(DefaultDataStorageOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to DataStorage.
func (_m *DataStorageQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DataStoragePaginateOption,
) (*DataStorageConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDataStoragePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &DataStorageConnection{Edges: []*DataStorageEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// DataStorageOrderFieldCreatedAt orders DataStorage by created_at.
	DataStorageOrderFieldCreatedAt = &DataStorageOrderField{
		Value: func(_m *DataStorage) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: datastorage.FieldCreatedAt,
		toTerm: datastorage.ByCreatedAt,
		toCursor: func(_m *DataStorage) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// DataStorageOrderFieldUpdatedAt orders DataStorage by updated_at.
	DataStorageOrderFieldUpdatedAt = &DataStorageOrderField{
		Value: func(_m *DataStorage) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: datastorage.FieldUpdatedAt,
		toTerm: datastorage.ByUpdatedAt,
		toCursor: func(_m *DataStorage) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f DataStorageOrderField) String() string {
	var str string
	switch f.column {
	case DataStorageOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case DataStorageOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f DataStorageOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *DataStorageOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("DataStorageOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *DataStorageOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *DataStorageOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid DataStorageOrderField", str)
	}
	return nil
}

// DataStorageOrderField defines the ordering field of DataStorage.
type DataStorageOrderField struct {
	// Value extracts the ordering value from the given DataStorage.
	Value    func(*DataStorage) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) datastorage.OrderOption
	toCursor func(*DataStorage) Cursor
}

// DataStorageOrder defines the ordering of DataStorage.
type DataStorageOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *DataStorageOrderField `json:"field"`
}

// DefaultDataStorageOrder is the default ordering of DataStorage.
var DefaultDataStorageOrder = &DataStorageOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DataStorageOrderField{
		Value: func(_m *DataStorage) (ent.Value, error) {
			return _m.ID, nil
		},
		column: datastorage.FieldID,
		toTerm: datastorage.ByID,
		toCursor: func(_m *DataStorage) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts DataStorage into DataStorageEdge.
func (_m *DataStorage) ToEdge(order *DataStorageOrder) *DataStorageEdge {
	if order == nil {
		order = DefaultDataStorageOrder
	}
	return &DataStorageEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// ModelEdge is the edge representation of Model.
type ModelEdge struct {
	Node   *Model `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// ModelConnection is the connection containing edges to Model.
type ModelConnection struct {
	Edges      []*ModelEdge `json:"edges"`
	PageInfo   PageInfo     `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

func (c *ModelConnection) build(nodes []*Model, pager *modelPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Model
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Model {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Model {
			return nodes[i]
		}
	}
	c.Edges = make([]*ModelEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ModelEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ModelPaginateOption enables pagination customization.
type ModelPaginateOption func(*modelPager) error

// WithModelOrder configures pagination ordering.
func WithModelOrder(order *ModelOrder) ModelPaginateOption {
	if order == nil {
		order = DefaultModelOrder
	}
	o := *order
	return func(pager *modelPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultModelOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithModelFilter configures pagination filter.
func WithModelFilter(filter func(*ModelQuery) (*ModelQuery, error)) ModelPaginateOption {
	return func(pager *modelPager) error {
		if filter == nil {
			return errors.New("ModelQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type modelPager struct {
	reverse bool
	order   *ModelOrder
	filter  func(*ModelQuery) (*ModelQuery, error)
}

func newModelPager(opts []ModelPaginateOption, reverse bool) (*modelPager, error) {
	pager := &modelPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultModelOrder
	}
	return pager, nil
}

func (p *modelPager) applyFilter(query *ModelQuery) (*ModelQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *modelPager) toCursor(_m *Model) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *modelPager) applyCursors(query *ModelQuery, after, before *Cursor) (*ModelQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultModelOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *modelPager) applyOrder(query *ModelQuery) *ModelQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultModelOrder.Field {
		query = query.Order(DefaultModelOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *modelPager) orderExpr(query *ModelQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultModelOrder.Field {
			b.Comma().Ident(DefaultModelOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Model.
func (_m *ModelQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ModelPaginateOption,
) (*ModelConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newModelPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &ModelConnection{Edges: []*ModelEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ModelOrderFieldCreatedAt orders Model by created_at.
	ModelOrderFieldCreatedAt = &ModelOrderField{
		Value: func(_m *Model) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: model.FieldCreatedAt,
		toTerm: model.ByCreatedAt,
		toCursor: func(_m *Model) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// ModelOrderFieldUpdatedAt orders Model by updated_at.
	ModelOrderFieldUpdatedAt = &ModelOrderField{
		Value: func(_m *Model) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: model.FieldUpdatedAt,
		toTerm: model.ByUpdatedAt,
		toCursor: func(_m *Model) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// ModelOrderFieldName orders Model by name.
	ModelOrderFieldName = &ModelOrderField{
		Value: func(_m *Model) (ent.Value, error) {
			return _m.Name, nil
		},
		column: model.FieldName,
		toTerm: model.ByName,
		toCursor: func(_m *Model) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ModelOrderField) String() string {
	var str string
	switch f.column {
	case ModelOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case ModelOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case ModelOrderFieldName.column:
		str = "NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ModelOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ModelOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ModelOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *ModelOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *ModelOrderFieldUpdatedAt
	case "NAME":
		*f = *ModelOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid ModelOrderField", str)
	}
	return nil
}

// ModelOrderField defines the ordering field of Model.
type ModelOrderField struct {
	// Value extracts the ordering value from the given Model.
	Value    func(*Model) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) model.OrderOption
	toCursor func(*Model) Cursor
}

// ModelOrder defines the ordering of Model.
type ModelOrder struct {
	Direction OrderDirection   `json:"direction"`
	Field     *ModelOrderField `json:"field"`
}

// DefaultModelOrder is the default ordering of Model.
var DefaultModelOrder = &ModelOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ModelOrderField{
		Value: func(_m *Model) (ent.Value, error) {
			return _m.ID, nil
		},
		column: model.FieldID,
		toTerm: model.ByID,
		toCursor: func(_m *Model) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Model into ModelEdge.
func (_m *Model) ToEdge(order *ModelOrder) *ModelEdge {
	if order == nil {
		order = DefaultModelOrder
	}
	return &ModelEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// ProjectEdge is the edge representation of Project.
type ProjectEdge struct {
	Node   *Project `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// ProjectConnection is the connection containing edges to Project.
type ProjectConnection struct {
	Edges      []*ProjectEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *ProjectConnection) build(nodes []*Project, pager *projectPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Project
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Project {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Project {
			return nodes[i]
		}
	}
	c.Edges = make([]*ProjectEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ProjectEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ProjectPaginateOption enables pagination customization.
type ProjectPaginateOption func(*projectPager) error

// WithProjectOrder configures pagination ordering.
func WithProjectOrder(order *ProjectOrder) ProjectPaginateOption {
	if order == nil {
		order = DefaultProjectOrder
	}
	o := *order
	return func(pager *projectPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultProjectOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithProjectFilter configures pagination filter.
func WithProjectFilter(filter func(*ProjectQuery) (*ProjectQuery, error)) ProjectPaginateOption {
	return func(pager *projectPager) error {
		if filter == nil {
			return errors.New("ProjectQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type projectPager struct {
	reverse bool
	order   *ProjectOrder
	filter  func(*ProjectQuery) (*ProjectQuery, error)
}

func newProjectPager(opts []ProjectPaginateOption, reverse bool) (*projectPager, error) {
	pager := &projectPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultProjectOrder
	}
	return pager, nil
}

func (p *projectPager) applyFilter(query *ProjectQuery) (*ProjectQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *projectPager) toCursor(_m *Project) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *projectPager) applyCursors(query *ProjectQuery, after, before *Cursor) (*ProjectQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultProjectOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *projectPager) applyOrder(query *ProjectQuery) *ProjectQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultProjectOrder.Field {
		query = query.Order(DefaultProjectOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *projectPager) orderExpr(query *ProjectQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultProjectOrder.Field {
			b.Comma().Ident(DefaultProjectOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Project.
func (_m *ProjectQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProjectPaginateOption,
) (*ProjectConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProjectPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &ProjectConnection{Edges: []*ProjectEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ProjectOrderFieldCreatedAt orders Project by created_at.
	ProjectOrderFieldCreatedAt = &ProjectOrderField{
		Value: func(_m *Project) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: project.FieldCreatedAt,
		toTerm: project.ByCreatedAt,
		toCursor: func(_m *Project) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// ProjectOrderFieldUpdatedAt orders Project by updated_at.
	ProjectOrderFieldUpdatedAt = &ProjectOrderField{
		Value: func(_m *Project) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: project.FieldUpdatedAt,
		toTerm: project.ByUpdatedAt,
		toCursor: func(_m *Project) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ProjectOrderField) String() string {
	var str string
	switch f.column {
	case ProjectOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case ProjectOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ProjectOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ProjectOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ProjectOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *ProjectOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *ProjectOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid ProjectOrderField", str)
	}
	return nil
}

// ProjectOrderField defines the ordering field of Project.
type ProjectOrderField struct {
	// Value extracts the ordering value from the given Project.
	Value    func(*Project) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) project.OrderOption
	toCursor func(*Project) Cursor
}

// ProjectOrder defines the ordering of Project.
type ProjectOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *ProjectOrderField `json:"field"`
}

// DefaultProjectOrder is the default ordering of Project.
var DefaultProjectOrder = &ProjectOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ProjectOrderField{
		Value: func(_m *Project) (ent.Value, error) {
			return _m.ID, nil
		},
		column: project.FieldID,
		toTerm: project.ByID,
		toCursor: func(_m *Project) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Project into ProjectEdge.
func (_m *Project) ToEdge(order *ProjectOrder) *ProjectEdge {
	if order == nil {
		order = DefaultProjectOrder
	}
	return &ProjectEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// RequestEdge is the edge representation of Request.
type RequestEdge struct {
	Node   *Request `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// RequestConnection is the connection containing edges to Request.
type RequestConnection struct {
	Edges      []*RequestEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *RequestConnection) build(nodes []*Request, pager *requestPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Request
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Request {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Request {
			return nodes[i]
		}
	}
	c.Edges = make([]*RequestEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &RequestEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// RequestPaginateOption enables pagination customization.
type RequestPaginateOption func(*requestPager) error

// WithRequestOrder configures pagination ordering.
func WithRequestOrder(order *RequestOrder) RequestPaginateOption {
	if order == nil {
		order = DefaultRequestOrder
	}
	o := *order
	return func(pager *requestPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultRequestOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithRequestFilter configures pagination filter.
func WithRequestFilter(filter func(*RequestQuery) (*RequestQuery, error)) RequestPaginateOption {
	return func(pager *requestPager) error {
		if filter == nil {
			return errors.New("RequestQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type requestPager struct {
	reverse bool
	order   *RequestOrder
	filter  func(*RequestQuery) (*RequestQuery, error)
}

func newRequestPager(opts []RequestPaginateOption, reverse bool) (*requestPager, error) {
	pager := &requestPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultRequestOrder
	}
	return pager, nil
}

func (p *requestPager) applyFilter(query *RequestQuery) (*RequestQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *requestPager) toCursor(_m *Request) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *requestPager) applyCursors(query *RequestQuery, after, before *Cursor) (*RequestQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultRequestOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *requestPager) applyOrder(query *RequestQuery) *RequestQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultRequestOrder.Field {
		query = query.Order(DefaultRequestOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *requestPager) orderExpr(query *RequestQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultRequestOrder.Field {
			b.Comma().Ident(DefaultRequestOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Request.
func (_m *RequestQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...RequestPaginateOption,
) (*RequestConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newRequestPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &RequestConnection{Edges: []*RequestEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// RequestOrderFieldCreatedAt orders Request by created_at.
	RequestOrderFieldCreatedAt = &RequestOrderField{
		Value: func(_m *Request) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: request.FieldCreatedAt,
		toTerm: request.ByCreatedAt,
		toCursor: func(_m *Request) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// RequestOrderFieldUpdatedAt orders Request by updated_at.
	RequestOrderFieldUpdatedAt = &RequestOrderField{
		Value: func(_m *Request) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: request.FieldUpdatedAt,
		toTerm: request.ByUpdatedAt,
		toCursor: func(_m *Request) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f RequestOrderField) String() string {
	var str string
	switch f.column {
	case RequestOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case RequestOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f RequestOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *RequestOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("RequestOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *RequestOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *RequestOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid RequestOrderField", str)
	}
	return nil
}

// RequestOrderField defines the ordering field of Request.
type RequestOrderField struct {
	// Value extracts the ordering value from the given Request.
	Value    func(*Request) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) request.OrderOption
	toCursor func(*Request) Cursor
}

// RequestOrder defines the ordering of Request.
type RequestOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *RequestOrderField `json:"field"`
}

// DefaultRequestOrder is the default ordering of Request.
var DefaultRequestOrder = &RequestOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &RequestOrderField{
		Value: func(_m *Request) (ent.Value, error) {
			return _m.ID, nil
		},
		column: request.FieldID,
		toTerm: request.ByID,
		toCursor: func(_m *Request) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Request into RequestEdge.
func (_m *Request) ToEdge(order *RequestOrder) *RequestEdge {
	if order == nil {
		order = DefaultRequestOrder
	}
	return &RequestEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// RequestExecutionEdge is the edge representation of RequestExecution.
type RequestExecutionEdge struct {
	Node   *RequestExecution `json:"node"`
	Cursor Cursor            `json:"cursor"`
}

// RequestExecutionConnection is the connection containing edges to RequestExecution.
type RequestExecutionConnection struct {
	Edges      []*RequestExecutionEdge `json:"edges"`
	PageInfo   PageInfo                `json:"pageInfo"`
	TotalCount int                     `json:"totalCount"`
}

func (c *RequestExecutionConnection) build(nodes []*RequestExecution, pager *requestexecutionPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *RequestExecution
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *RequestExecution {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *RequestExecution {
			return nodes[i]
		}
	}
	c.Edges = make([]*RequestExecutionEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &RequestExecutionEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// RequestExecutionPaginateOption enables pagination customization.
type RequestExecutionPaginateOption func(*requestexecutionPager) error

// WithRequestExecutionOrder configures pagination ordering.
func WithRequestExecutionOrder(order *RequestExecutionOrder) RequestExecutionPaginateOption {
	if order == nil {
		order = DefaultRequestExecutionOrder
	}
	o := *order
	return func(pager *requestexecutionPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultRequestExecutionOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithRequestExecutionFilter configures pagination filter.
func WithRequestExecutionFilter(filter func(*RequestExecutionQuery) (*RequestExecutionQuery, error)) RequestExecutionPaginateOption {
	return func(pager *requestexecutionPager) error {
		if filter == nil {
			return errors.New("RequestExecutionQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type requestexecutionPager struct {
	reverse bool
	order   *RequestExecutionOrder
	filter  func(*RequestExecutionQuery) (*RequestExecutionQuery, error)
}

func newRequestExecutionPager(opts []RequestExecutionPaginateOption, reverse bool) (*requestexecutionPager, error) {
	pager := &requestexecutionPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultRequestExecutionOrder
	}
	return pager, nil
}

func (p *requestexecutionPager) applyFilter(query *RequestExecutionQuery) (*RequestExecutionQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *requestexecutionPager) toCursor(_m *RequestExecution) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *requestexecutionPager) applyCursors(query *RequestExecutionQuery, after, before *Cursor) (*RequestExecutionQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultRequestExecutionOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *requestexecutionPager) applyOrder(query *RequestExecutionQuery) *RequestExecutionQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultRequestExecutionOrder.Field {
		query = query.Order(DefaultRequestExecutionOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *requestexecutionPager) orderExpr(query *RequestExecutionQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultRequestExecutionOrder.Field {
			b.Comma().Ident(DefaultRequestExecutionOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to RequestExecution.
func (_m *RequestExecutionQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...RequestExecutionPaginateOption,
) (*RequestExecutionConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newRequestExecutionPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &RequestExecutionConnection{Edges: []*RequestExecutionEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// RequestExecutionOrderFieldCreatedAt orders RequestExecution by created_at.
	RequestExecutionOrderFieldCreatedAt = &RequestExecutionOrderField{
		Value: func(_m *RequestExecution) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: requestexecution.FieldCreatedAt,
		toTerm: requestexecution.ByCreatedAt,
		toCursor: func(_m *RequestExecution) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// RequestExecutionOrderFieldUpdatedAt orders RequestExecution by updated_at.
	RequestExecutionOrderFieldUpdatedAt = &RequestExecutionOrderField{
		Value: func(_m *RequestExecution) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: requestexecution.FieldUpdatedAt,
		toTerm: requestexecution.ByUpdatedAt,
		toCursor: func(_m *RequestExecution) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f RequestExecutionOrderField) String() string {
	var str string
	switch f.column {
	case RequestExecutionOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case RequestExecutionOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f RequestExecutionOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *RequestExecutionOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("RequestExecutionOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *RequestExecutionOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *RequestExecutionOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid RequestExecutionOrderField", str)
	}
	return nil
}

// RequestExecutionOrderField defines the ordering field of RequestExecution.
type RequestExecutionOrderField struct {
	// Value extracts the ordering value from the given RequestExecution.
	Value    func(*RequestExecution) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) requestexecution.OrderOption
	toCursor func(*RequestExecution) Cursor
}

// RequestExecutionOrder defines the ordering of RequestExecution.
type RequestExecutionOrder struct {
	Direction OrderDirection              `json:"direction"`
	Field     *RequestExecutionOrderField `json:"field"`
}

// DefaultRequestExecutionOrder is the default ordering of RequestExecution.
var DefaultRequestExecutionOrder = &RequestExecutionOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &RequestExecutionOrderField{
		Value: func(_m *RequestExecution) (ent.Value, error) {
			return _m.ID, nil
		},
		column: requestexecution.FieldID,
		toTerm: requestexecution.ByID,
		toCursor: func(_m *RequestExecution) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts RequestExecution into RequestExecutionEdge.
func (_m *RequestExecution) ToEdge(order *RequestExecutionOrder) *RequestExecutionEdge {
	if order == nil {
		order = DefaultRequestExecutionOrder
	}
	return &RequestExecutionEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// RoleEdge is the edge representation of Role.
type RoleEdge struct {
	Node   *Role  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// RoleConnection is the connection containing edges to Role.
type RoleConnection struct {
	Edges      []*RoleEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *RoleConnection) build(nodes []*Role, pager *rolePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Role
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Role {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Role {
			return nodes[i]
		}
	}
	c.Edges = make([]*RoleEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &RoleEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// RolePaginateOption enables pagination customization.
type RolePaginateOption func(*rolePager) error

// WithRoleOrder configures pagination ordering.
func WithRoleOrder(order *RoleOrder) RolePaginateOption {
	if order == nil {
		order = DefaultRoleOrder
	}
	o := *order
	return func(pager *rolePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultRoleOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithRoleFilter configures pagination filter.
func WithRoleFilter(filter func(*RoleQuery) (*RoleQuery, error)) RolePaginateOption {
	return func(pager *rolePager) error {
		if filter == nil {
			return errors.New("RoleQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type rolePager struct {
	reverse bool
	order   *RoleOrder
	filter  func(*RoleQuery) (*RoleQuery, error)
}

func newRolePager(opts []RolePaginateOption, reverse bool) (*rolePager, error) {
	pager := &rolePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultRoleOrder
	}
	return pager, nil
}

func (p *rolePager) applyFilter(query *RoleQuery) (*RoleQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *rolePager) toCursor(_m *Role) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *rolePager) applyCursors(query *RoleQuery, after, before *Cursor) (*RoleQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultRoleOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *rolePager) applyOrder(query *RoleQuery) *RoleQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultRoleOrder.Field {
		query = query.Order(DefaultRoleOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *rolePager) orderExpr(query *RoleQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultRoleOrder.Field {
			b.Comma().Ident(DefaultRoleOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Role.
func (_m *RoleQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...RolePaginateOption,
) (*RoleConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newRolePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &RoleConnection{Edges: []*RoleEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// RoleOrderFieldCreatedAt orders Role by created_at.
	RoleOrderFieldCreatedAt = &RoleOrderField{
		Value: func(_m *Role) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: role.FieldCreatedAt,
		toTerm: role.ByCreatedAt,
		toCursor: func(_m *Role) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// RoleOrderFieldUpdatedAt orders Role by updated_at.
	RoleOrderFieldUpdatedAt = &RoleOrderField{
		Value: func(_m *Role) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: role.FieldUpdatedAt,
		toTerm: role.ByUpdatedAt,
		toCursor: func(_m *Role) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f RoleOrderField) String() string {
	var str string
	switch f.column {
	case RoleOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case RoleOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f RoleOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *RoleOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("RoleOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *RoleOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *RoleOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid RoleOrderField", str)
	}
	return nil
}

// RoleOrderField defines the ordering field of Role.
type RoleOrderField struct {
	// Value extracts the ordering value from the given Role.
	Value    func(*Role) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) role.OrderOption
	toCursor func(*Role) Cursor
}

// RoleOrder defines the ordering of Role.
type RoleOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *RoleOrderField `json:"field"`
}

// DefaultRoleOrder is the default ordering of Role.
var DefaultRoleOrder = &RoleOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &RoleOrderField{
		Value: func(_m *Role) (ent.Value, error) {
			return _m.ID, nil
		},
		column: role.FieldID,
		toTerm: role.ByID,
		toCursor: func(_m *Role) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Role into RoleEdge.
func (_m *Role) ToEdge(order *RoleOrder) *RoleEdge {
	if order == nil {
		order = DefaultRoleOrder
	}
	return &RoleEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// SystemEdge is the edge representation of System.
type SystemEdge struct {
	Node   *System `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// SystemConnection is the connection containing edges to System.
type SystemConnection struct {
	Edges      []*SystemEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

func (c *SystemConnection) build(nodes []*System, pager *systemPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *System
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *System {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *System {
			return nodes[i]
		}
	}
	c.Edges = make([]*SystemEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &SystemEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// SystemPaginateOption enables pagination customization.
type SystemPaginateOption func(*systemPager) error

// WithSystemOrder configures pagination ordering.
func WithSystemOrder(order *SystemOrder) SystemPaginateOption {
	if order == nil {
		order = DefaultSystemOrder
	}
	o := *order
	return func(pager *systemPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultSystemOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithSystemFilter configures pagination filter.
func WithSystemFilter(filter func(*SystemQuery) (*SystemQuery, error)) SystemPaginateOption {
	return func(pager *systemPager) error {
		if filter == nil {
			return errors.New("SystemQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type systemPager struct {
	reverse bool
	order   *SystemOrder
	filter  func(*SystemQuery) (*SystemQuery, error)
}

func newSystemPager(opts []SystemPaginateOption, reverse bool) (*systemPager, error) {
	pager := &systemPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultSystemOrder
	}
	return pager, nil
}

func (p *systemPager) applyFilter(query *SystemQuery) (*SystemQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *systemPager) toCursor(_m *System) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *systemPager) applyCursors(query *SystemQuery, after, before *Cursor) (*SystemQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultSystemOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *systemPager) applyOrder(query *SystemQuery) *SystemQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultSystemOrder.Field {
		query = query.Order(DefaultSystemOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *systemPager) orderExpr(query *SystemQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultSystemOrder.Field {
			b.Comma().Ident(DefaultSystemOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to System.
func (_m *SystemQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...SystemPaginateOption,
) (*SystemConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newSystemPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &SystemConnection{Edges: []*SystemEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// SystemOrderFieldCreatedAt orders System by created_at.
	SystemOrderFieldCreatedAt = &SystemOrderField{
		Value: func(_m *System) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: system.FieldCreatedAt,
		toTerm: system.ByCreatedAt,
		toCursor: func(_m *System) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// SystemOrderFieldUpdatedAt orders System by updated_at.
	SystemOrderFieldUpdatedAt = &SystemOrderField{
		Value: func(_m *System) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: system.FieldUpdatedAt,
		toTerm: system.ByUpdatedAt,
		toCursor: func(_m *System) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f SystemOrderField) String() string {
	var str string
	switch f.column {
	case SystemOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case SystemOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f SystemOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *SystemOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("SystemOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *SystemOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *SystemOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid SystemOrderField", str)
	}
	return nil
}

// SystemOrderField defines the ordering field of System.
type SystemOrderField struct {
	// Value extracts the ordering value from the given System.
	Value    func(*System) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) system.OrderOption
	toCursor func(*System) Cursor
}

// SystemOrder defines the ordering of System.
type SystemOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *SystemOrderField `json:"field"`
}

// DefaultSystemOrder is the default ordering of System.
var DefaultSystemOrder = &SystemOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &SystemOrderField{
		Value: func(_m *System) (ent.Value, error) {
			return _m.ID, nil
		},
		column: system.FieldID,
		toTerm: system.ByID,
		toCursor: func(_m *System) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts System into SystemEdge.
func (_m *System) ToEdge(order *SystemOrder) *SystemEdge {
	if order == nil {
		order = DefaultSystemOrder
	}
	return &SystemEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// ThreadEdge is the edge representation of Thread.
type ThreadEdge struct {
	Node   *Thread `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// ThreadConnection is the connection containing edges to Thread.
type ThreadConnection struct {
	Edges      []*ThreadEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

func (c *ThreadConnection) build(nodes []*Thread, pager *threadPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Thread
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Thread {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Thread {
			return nodes[i]
		}
	}
	c.Edges = make([]*ThreadEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ThreadEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ThreadPaginateOption enables pagination customization.
type ThreadPaginateOption func(*threadPager) error

// WithThreadOrder configures pagination ordering.
func WithThreadOrder(order *ThreadOrder) ThreadPaginateOption {
	if order == nil {
		order = DefaultThreadOrder
	}
	o := *order
	return func(pager *threadPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultThreadOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithThreadFilter configures pagination filter.
func WithThreadFilter(filter func(*ThreadQuery) (*ThreadQuery, error)) ThreadPaginateOption {
	return func(pager *threadPager) error {
		if filter == nil {
			return errors.New("ThreadQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type threadPager struct {
	reverse bool
	order   *ThreadOrder
	filter  func(*ThreadQuery) (*ThreadQuery, error)
}

func newThreadPager(opts []ThreadPaginateOption, reverse bool) (*threadPager, error) {
	pager := &threadPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultThreadOrder
	}
	return pager, nil
}

func (p *threadPager) applyFilter(query *ThreadQuery) (*ThreadQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *threadPager) toCursor(_m *Thread) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *threadPager) applyCursors(query *ThreadQuery, after, before *Cursor) (*ThreadQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultThreadOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *threadPager) applyOrder(query *ThreadQuery) *ThreadQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultThreadOrder.Field {
		query = query.Order(DefaultThreadOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *threadPager) orderExpr(query *ThreadQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultThreadOrder.Field {
			b.Comma().Ident(DefaultThreadOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Thread.
func (_m *ThreadQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ThreadPaginateOption,
) (*ThreadConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newThreadPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &ThreadConnection{Edges: []*ThreadEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ThreadOrderFieldCreatedAt orders Thread by created_at.
	ThreadOrderFieldCreatedAt = &ThreadOrderField{
		Value: func(_m *Thread) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: thread.FieldCreatedAt,
		toTerm: thread.ByCreatedAt,
		toCursor: func(_m *Thread) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// ThreadOrderFieldUpdatedAt orders Thread by updated_at.
	ThreadOrderFieldUpdatedAt = &ThreadOrderField{
		Value: func(_m *Thread) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: thread.FieldUpdatedAt,
		toTerm: thread.ByUpdatedAt,
		toCursor: func(_m *Thread) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ThreadOrderField) String() string {
	var str string
	switch f.column {
	case ThreadOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case ThreadOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ThreadOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ThreadOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ThreadOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *ThreadOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *ThreadOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid ThreadOrderField", str)
	}
	return nil
}

// ThreadOrderField defines the ordering field of Thread.
type ThreadOrderField struct {
	// Value extracts the ordering value from the given Thread.
	Value    func(*Thread) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) thread.OrderOption
	toCursor func(*Thread) Cursor
}

// ThreadOrder defines the ordering of Thread.
type ThreadOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *ThreadOrderField `json:"field"`
}

// DefaultThreadOrder is the default ordering of Thread.
var DefaultThreadOrder = &ThreadOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ThreadOrderField{
		Value: func(_m *Thread) (ent.Value, error) {
			return _m.ID, nil
		},
		column: thread.FieldID,
		toTerm: thread.ByID,
		toCursor: func(_m *Thread) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Thread into ThreadEdge.
func (_m *Thread) ToEdge(order *ThreadOrder) *ThreadEdge {
	if order == nil {
		order = DefaultThreadOrder
	}
	return &ThreadEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// TraceEdge is the edge representation of Trace.
type TraceEdge struct {
	Node   *Trace `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// TraceConnection is the connection containing edges to Trace.
type TraceConnection struct {
	Edges      []*TraceEdge `json:"edges"`
	PageInfo   PageInfo     `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

func (c *TraceConnection) build(nodes []*Trace, pager *tracePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Trace
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Trace {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Trace {
			return nodes[i]
		}
	}
	c.Edges = make([]*TraceEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TraceEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TracePaginateOption enables pagination customization.
type TracePaginateOption func(*tracePager) error

// WithTraceOrder configures pagination ordering.
func WithTraceOrder(order *TraceOrder) TracePaginateOption {
	if order == nil {
		order = DefaultTraceOrder
	}
	o := *order
	return func(pager *tracePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTraceOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTraceFilter configures pagination filter.
func WithTraceFilter(filter func(*TraceQuery) (*TraceQuery, error)) TracePaginateOption {
	return func(pager *tracePager) error {
		if filter == nil {
			return errors.New("TraceQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type tracePager struct {
	reverse bool
	order   *TraceOrder
	filter  func(*TraceQuery) (*TraceQuery, error)
}

func newTracePager(opts []TracePaginateOption, reverse bool) (*tracePager, error) {
	pager := &tracePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTraceOrder
	}
	return pager, nil
}

func (p *tracePager) applyFilter(query *TraceQuery) (*TraceQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *tracePager) toCursor(_m *Trace) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *tracePager) applyCursors(query *TraceQuery, after, before *Cursor) (*TraceQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultTraceOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *tracePager) applyOrder(query *TraceQuery) *TraceQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultTraceOrder.Field {
		query = query.Order(DefaultTraceOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *tracePager) orderExpr(query *TraceQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultTraceOrder.Field {
			b.Comma().Ident(DefaultTraceOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Trace.
func (_m *TraceQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TracePaginateOption,
) (*TraceConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTracePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &TraceConnection{Edges: []*TraceEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TraceOrderFieldCreatedAt orders Trace by created_at.
	TraceOrderFieldCreatedAt = &TraceOrderField{
		Value: func(_m *Trace) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: trace.FieldCreatedAt,
		toTerm: trace.ByCreatedAt,
		toCursor: func(_m *Trace) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// TraceOrderFieldUpdatedAt orders Trace by updated_at.
	TraceOrderFieldUpdatedAt = &TraceOrderField{
		Value: func(_m *Trace) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: trace.FieldUpdatedAt,
		toTerm: trace.ByUpdatedAt,
		toCursor: func(_m *Trace) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TraceOrderField) String() string {
	var str string
	switch f.column {
	case TraceOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case TraceOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TraceOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TraceOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TraceOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *TraceOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *TraceOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid TraceOrderField", str)
	}
	return nil
}

// TraceOrderField defines the ordering field of Trace.
type TraceOrderField struct {
	// Value extracts the ordering value from the given Trace.
	Value    func(*Trace) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) trace.OrderOption
	toCursor func(*Trace) Cursor
}

// TraceOrder defines the ordering of Trace.
type TraceOrder struct {
	Direction OrderDirection   `json:"direction"`
	Field     *TraceOrderField `json:"field"`
}

// DefaultTraceOrder is the default ordering of Trace.
var DefaultTraceOrder = &TraceOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TraceOrderField{
		Value: func(_m *Trace) (ent.Value, error) {
			return _m.ID, nil
		},
		column: trace.FieldID,
		toTerm: trace.ByID,
		toCursor: func(_m *Trace) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Trace into TraceEdge.
func (_m *Trace) ToEdge(order *TraceOrder) *TraceEdge {
	if order == nil {
		order = DefaultTraceOrder
	}
	return &TraceEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// UsageLogEdge is the edge representation of UsageLog.
type UsageLogEdge struct {
	Node   *UsageLog `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// UsageLogConnection is the connection containing edges to UsageLog.
type UsageLogConnection struct {
	Edges      []*UsageLogEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *UsageLogConnection) build(nodes []*UsageLog, pager *usagelogPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *UsageLog
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *UsageLog {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *UsageLog {
			return nodes[i]
		}
	}
	c.Edges = make([]*UsageLogEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UsageLogEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UsageLogPaginateOption enables pagination customization.
type UsageLogPaginateOption func(*usagelogPager) error

// WithUsageLogOrder configures pagination ordering.
func WithUsageLogOrder(order *UsageLogOrder) UsageLogPaginateOption {
	if order == nil {
		order = DefaultUsageLogOrder
	}
	o := *order
	return func(pager *usagelogPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUsageLogOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUsageLogFilter configures pagination filter.
func WithUsageLogFilter(filter func(*UsageLogQuery) (*UsageLogQuery, error)) UsageLogPaginateOption {
	return func(pager *usagelogPager) error {
		if filter == nil {
			return errors.New("UsageLogQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type usagelogPager struct {
	reverse bool
	order   *UsageLogOrder
	filter  func(*UsageLogQuery) (*UsageLogQuery, error)
}

func newUsageLogPager(opts []UsageLogPaginateOption, reverse bool) (*usagelogPager, error) {
	pager := &usagelogPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUsageLogOrder
	}
	return pager, nil
}

func (p *usagelogPager) applyFilter(query *UsageLogQuery) (*UsageLogQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *usagelogPager) toCursor(_m *UsageLog) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *usagelogPager) applyCursors(query *UsageLogQuery, after, before *Cursor) (*UsageLogQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultUsageLogOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *usagelogPager) applyOrder(query *UsageLogQuery) *UsageLogQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultUsageLogOrder.Field {
		query = query.Order(DefaultUsageLogOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *usagelogPager) orderExpr(query *UsageLogQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultUsageLogOrder.Field {
			b.Comma().Ident(DefaultUsageLogOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to UsageLog.
func (_m *UsageLogQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UsageLogPaginateOption,
) (*UsageLogConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUsageLogPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &UsageLogConnection{Edges: []*UsageLogEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// UsageLogOrderFieldCreatedAt orders UsageLog by created_at.
	UsageLogOrderFieldCreatedAt = &UsageLogOrderField{
		Value: func(_m *UsageLog) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: usagelog.FieldCreatedAt,
		toTerm: usagelog.ByCreatedAt,
		toCursor: func(_m *UsageLog) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// UsageLogOrderFieldUpdatedAt orders UsageLog by updated_at.
	UsageLogOrderFieldUpdatedAt = &UsageLogOrderField{
		Value: func(_m *UsageLog) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: usagelog.FieldUpdatedAt,
		toTerm: usagelog.ByUpdatedAt,
		toCursor: func(_m *UsageLog) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f UsageLogOrderField) String() string {
	var str string
	switch f.column {
	case UsageLogOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case UsageLogOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f UsageLogOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *UsageLogOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("UsageLogOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *UsageLogOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *UsageLogOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid UsageLogOrderField", str)
	}
	return nil
}

// UsageLogOrderField defines the ordering field of UsageLog.
type UsageLogOrderField struct {
	// Value extracts the ordering value from the given UsageLog.
	Value    func(*UsageLog) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) usagelog.OrderOption
	toCursor func(*UsageLog) Cursor
}

// UsageLogOrder defines the ordering of UsageLog.
type UsageLogOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *UsageLogOrderField `json:"field"`
}

// DefaultUsageLogOrder is the default ordering of UsageLog.
var DefaultUsageLogOrder = &UsageLogOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &UsageLogOrderField{
		Value: func(_m *UsageLog) (ent.Value, error) {
			return _m.ID, nil
		},
		column: usagelog.FieldID,
		toTerm: usagelog.ByID,
		toCursor: func(_m *UsageLog) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts UsageLog into UsageLogEdge.
func (_m *UsageLog) ToEdge(order *UsageLogOrder) *UsageLogEdge {
	if order == nil {
		order = DefaultUsageLogOrder
	}
	return &UsageLogEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// UserEdge is the edge representation of User.
type UserEdge struct {
	Node   *User  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// UserConnection is the connection containing edges to User.
type UserConnection struct {
	Edges      []*UserEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *UserConnection) build(nodes []*User, pager *userPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *User
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *User {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *User {
			return nodes[i]
		}
	}
	c.Edges = make([]*UserEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UserEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UserPaginateOption enables pagination customization.
type UserPaginateOption func(*userPager) error

// WithUserOrder configures pagination ordering.
func WithUserOrder(order *UserOrder) UserPaginateOption {
	if order == nil {
		order = DefaultUserOrder
	}
	o := *order
	return func(pager *userPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUserOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUserFilter configures pagination filter.
func WithUserFilter(filter func(*UserQuery) (*UserQuery, error)) UserPaginateOption {
	return func(pager *userPager) error {
		if filter == nil {
			return errors.New("UserQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type userPager struct {
	reverse bool
	order   *UserOrder
	filter  func(*UserQuery) (*UserQuery, error)
}

func newUserPager(opts []UserPaginateOption, reverse bool) (*userPager, error) {
	pager := &userPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUserOrder
	}
	return pager, nil
}

func (p *userPager) applyFilter(query *UserQuery) (*UserQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *userPager) toCursor(_m *User) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *userPager) applyCursors(query *UserQuery, after, before *Cursor) (*UserQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultUserOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *userPager) applyOrder(query *UserQuery) *UserQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultUserOrder.Field {
		query = query.Order(DefaultUserOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *userPager) orderExpr(query *UserQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultUserOrder.Field {
			b.Comma().Ident(DefaultUserOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to User.
func (_m *UserQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserPaginateOption,
) (*UserConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &UserConnection{Edges: []*UserEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// UserOrderFieldCreatedAt orders User by created_at.
	UserOrderFieldCreatedAt = &UserOrderField{
		Value: func(_m *User) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: user.FieldCreatedAt,
		toTerm: user.ByCreatedAt,
		toCursor: func(_m *User) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// UserOrderFieldUpdatedAt orders User by updated_at.
	UserOrderFieldUpdatedAt = &UserOrderField{
		Value: func(_m *User) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: user.FieldUpdatedAt,
		toTerm: user.ByUpdatedAt,
		toCursor: func(_m *User) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f UserOrderField) String() string {
	var str string
	switch f.column {
	case UserOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case UserOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f UserOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *UserOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("UserOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *UserOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *UserOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid UserOrderField", str)
	}
	return nil
}

// UserOrderField defines the ordering field of User.
type UserOrderField struct {
	// Value extracts the ordering value from the given User.
	Value    func(*User) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) user.OrderOption
	toCursor func(*User) Cursor
}

// UserOrder defines the ordering of User.
type UserOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *UserOrderField `json:"field"`
}

// DefaultUserOrder is the default ordering of User.
var DefaultUserOrder = &UserOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &UserOrderField{
		Value: func(_m *User) (ent.Value, error) {
			return _m.ID, nil
		},
		column: user.FieldID,
		toTerm: user.ByID,
		toCursor: func(_m *User) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts User into UserEdge.
func (_m *User) ToEdge(order *UserOrder) *UserEdge {
	if order == nil {
		order = DefaultUserOrder
	}
	return &UserEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// UserProjectEdge is the edge representation of UserProject.
type UserProjectEdge struct {
	Node   *UserProject `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// UserProjectConnection is the connection containing edges to UserProject.
type UserProjectConnection struct {
	Edges      []*UserProjectEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *UserProjectConnection) build(nodes []*UserProject, pager *userprojectPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *UserProject
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *UserProject {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *UserProject {
			return nodes[i]
		}
	}
	c.Edges = make([]*UserProjectEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UserProjectEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UserProjectPaginateOption enables pagination customization.
type UserProjectPaginateOption func(*userprojectPager) error

// WithUserProjectOrder configures pagination ordering.
func WithUserProjectOrder(order *UserProjectOrder) UserProjectPaginateOption {
	if order == nil {
		order = DefaultUserProjectOrder
	}
	o := *order
	return func(pager *userprojectPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUserProjectOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUserProjectFilter configures pagination filter.
func WithUserProjectFilter(filter func(*UserProjectQuery) (*UserProjectQuery, error)) UserProjectPaginateOption {
	return func(pager *userprojectPager) error {
		if filter == nil {
			return errors.New("UserProjectQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type userprojectPager struct {
	reverse bool
	order   *UserProjectOrder
	filter  func(*UserProjectQuery) (*UserProjectQuery, error)
}

func newUserProjectPager(opts []UserProjectPaginateOption, reverse bool) (*userprojectPager, error) {
	pager := &userprojectPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUserProjectOrder
	}
	return pager, nil
}

func (p *userprojectPager) applyFilter(query *UserProjectQuery) (*UserProjectQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *userprojectPager) toCursor(_m *UserProject) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *userprojectPager) applyCursors(query *UserProjectQuery, after, before *Cursor) (*UserProjectQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultUserProjectOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *userprojectPager) applyOrder(query *UserProjectQuery) *UserProjectQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultUserProjectOrder.Field {
		query = query.Order(DefaultUserProjectOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *userprojectPager) orderExpr(query *UserProjectQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultUserProjectOrder.Field {
			b.Comma().Ident(DefaultUserProjectOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to UserProject.
func (_m *UserProjectQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserProjectPaginateOption,
) (*UserProjectConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserProjectPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &UserProjectConnection{Edges: []*UserProjectEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// UserProjectOrderFieldCreatedAt orders UserProject by created_at.
	UserProjectOrderFieldCreatedAt = &UserProjectOrderField{
		Value: func(_m *UserProject) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: userproject.FieldCreatedAt,
		toTerm: userproject.ByCreatedAt,
		toCursor: func(_m *UserProject) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// UserProjectOrderFieldUpdatedAt orders UserProject by updated_at.
	UserProjectOrderFieldUpdatedAt = &UserProjectOrderField{
		Value: func(_m *UserProject) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: userproject.FieldUpdatedAt,
		toTerm: userproject.ByUpdatedAt,
		toCursor: func(_m *UserProject) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f UserProjectOrderField) String() string {
	var str string
	switch f.column {
	case UserProjectOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case UserProjectOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f UserProjectOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *UserProjectOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("UserProjectOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *UserProjectOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *UserProjectOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid UserProjectOrderField", str)
	}
	return nil
}

// UserProjectOrderField defines the ordering field of UserProject.
type UserProjectOrderField struct {
	// Value extracts the ordering value from the given UserProject.
	Value    func(*UserProject) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) userproject.OrderOption
	toCursor func(*UserProject) Cursor
}

// UserProjectOrder defines the ordering of UserProject.
type UserProjectOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *UserProjectOrderField `json:"field"`
}

// DefaultUserProjectOrder is the default ordering of UserProject.
var DefaultUserProjectOrder = &UserProjectOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &UserProjectOrderField{
		Value: func(_m *UserProject) (ent.Value, error) {
			return _m.ID, nil
		},
		column: userproject.FieldID,
		toTerm: userproject.ByID,
		toCursor: func(_m *UserProject) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts UserProject into UserProjectEdge.
func (_m *UserProject) ToEdge(order *UserProjectOrder) *UserProjectEdge {
	if order == nil {
		order = DefaultUserProjectOrder
	}
	return &UserProjectEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// UserRoleEdge is the edge representation of UserRole.
type UserRoleEdge struct {
	Node   *UserRole `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// UserRoleConnection is the connection containing edges to UserRole.
type UserRoleConnection struct {
	Edges      []*UserRoleEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *UserRoleConnection) build(nodes []*UserRole, pager *userrolePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *UserRole
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *UserRole {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *UserRole {
			return nodes[i]
		}
	}
	c.Edges = make([]*UserRoleEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UserRoleEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UserRolePaginateOption enables pagination customization.
type UserRolePaginateOption func(*userrolePager) error

// WithUserRoleOrder configures pagination ordering.
func WithUserRoleOrder(order *UserRoleOrder) UserRolePaginateOption {
	if order == nil {
		order = DefaultUserRoleOrder
	}
	o := *order
	return func(pager *userrolePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUserRoleOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUserRoleFilter configures pagination filter.
func WithUserRoleFilter(filter func(*UserRoleQuery) (*UserRoleQuery, error)) UserRolePaginateOption {
	return func(pager *userrolePager) error {
		if filter == nil {
			return errors.New("UserRoleQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type userrolePager struct {
	reverse bool
	order   *UserRoleOrder
	filter  func(*UserRoleQuery) (*UserRoleQuery, error)
}

func newUserRolePager(opts []UserRolePaginateOption, reverse bool) (*userrolePager, error) {
	pager := &userrolePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUserRoleOrder
	}
	return pager, nil
}

func (p *userrolePager) applyFilter(query *UserRoleQuery) (*UserRoleQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *userrolePager) toCursor(_m *UserRole) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *userrolePager) applyCursors(query *UserRoleQuery, after, before *Cursor) (*UserRoleQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultUserRoleOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *userrolePager) applyOrder(query *UserRoleQuery) *UserRoleQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultUserRoleOrder.Field {
		query = query.Order(DefaultUserRoleOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *userrolePager) orderExpr(query *UserRoleQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultUserRoleOrder.Field {
			b.Comma().Ident(DefaultUserRoleOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to UserRole.
func (_m *UserRoleQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserRolePaginateOption,
) (*UserRoleConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserRolePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &UserRoleConnection{Edges: []*UserRoleEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// UserRoleOrderFieldCreatedAt orders UserRole by created_at.
	UserRoleOrderFieldCreatedAt = &UserRoleOrderField{
		Value: func(_m *UserRole) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: userrole.FieldCreatedAt,
		toTerm: userrole.ByCreatedAt,
		toCursor: func(_m *UserRole) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// UserRoleOrderFieldUpdatedAt orders UserRole by updated_at.
	UserRoleOrderFieldUpdatedAt = &UserRoleOrderField{
		Value: func(_m *UserRole) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: userrole.FieldUpdatedAt,
		toTerm: userrole.ByUpdatedAt,
		toCursor: func(_m *UserRole) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f UserRoleOrderField) String() string {
	var str string
	switch f.column {
	case UserRoleOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case UserRoleOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f UserRoleOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *UserRoleOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("UserRoleOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *UserRoleOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *UserRoleOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid UserRoleOrderField", str)
	}
	return nil
}

// UserRoleOrderField defines the ordering field of UserRole.
type UserRoleOrderField struct {
	// Value extracts the ordering value from the given UserRole.
	Value    func(*UserRole) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) userrole.OrderOption
	toCursor func(*UserRole) Cursor
}

// UserRoleOrder defines the ordering of UserRole.
type UserRoleOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *UserRoleOrderField `json:"field"`
}

// DefaultUserRoleOrder is the default ordering of UserRole.
var DefaultUserRoleOrder = &UserRoleOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &UserRoleOrderField{
		Value: func(_m *UserRole) (ent.Value, error) {
			return _m.ID, nil
		},
		column: userrole.FieldID,
		toTerm: userrole.ByID,
		toCursor: func(_m *UserRole) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts UserRole into UserRoleEdge.
func (_m *UserRole) ToEdge(order *UserRoleOrder) *UserRoleEdge {
	if order == nil {
		order = DefaultUserRoleOrder
	}
	return &UserRoleEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}
