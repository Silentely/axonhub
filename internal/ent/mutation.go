// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/looplj/axonhub/internal/ent/apikey"
	"github.com/looplj/axonhub/internal/ent/channel"
	"github.com/looplj/axonhub/internal/ent/channeloverridetemplate"
	"github.com/looplj/axonhub/internal/ent/channelperformance"
	"github.com/looplj/axonhub/internal/ent/channelprobe"
	"github.com/looplj/axonhub/internal/ent/datastorage"
	"github.com/looplj/axonhub/internal/ent/model"
	"github.com/looplj/axonhub/internal/ent/predicate"
	"github.com/looplj/axonhub/internal/ent/project"
	"github.com/looplj/axonhub/internal/ent/prompt"
	"github.com/looplj/axonhub/internal/ent/request"
	"github.com/looplj/axonhub/internal/ent/requestexecution"
	"github.com/looplj/axonhub/internal/ent/role"
	"github.com/looplj/axonhub/internal/ent/system"
	"github.com/looplj/axonhub/internal/ent/thread"
	"github.com/looplj/axonhub/internal/ent/trace"
	"github.com/looplj/axonhub/internal/ent/usagelog"
	"github.com/looplj/axonhub/internal/ent/user"
	"github.com/looplj/axonhub/internal/ent/userproject"
	"github.com/looplj/axonhub/internal/ent/userrole"
	"github.com/looplj/axonhub/internal/objects"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAPIKey                  = "APIKey"
	TypeChannel                 = "Channel"
	TypeChannelOverrideTemplate = "ChannelOverrideTemplate"
	TypeChannelPerformance      = "ChannelPerformance"
	TypeChannelProbe            = "ChannelProbe"
	TypeDataStorage             = "DataStorage"
	TypeModel                   = "Model"
	TypeProject                 = "Project"
	TypePrompt                  = "Prompt"
	TypeRequest                 = "Request"
	TypeRequestExecution        = "RequestExecution"
	TypeRole                    = "Role"
	TypeSystem                  = "System"
	TypeThread                  = "Thread"
	TypeTrace                   = "Trace"
	TypeUsageLog                = "UsageLog"
	TypeUser                    = "User"
	TypeUserProject             = "UserProject"
	TypeUserRole                = "UserRole"
)

// APIKeyMutation represents an operation that mutates the APIKey nodes in the graph.
type APIKeyMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *int
	adddeleted_at   *int
	key             *string
	name            *string
	_type           *apikey.Type
	status          *apikey.Status
	scopes          *[]string
	appendscopes    []string
	profiles        **objects.APIKeyProfiles
	clearedFields   map[string]struct{}
	user            *int
	cleareduser     bool
	project         *int
	clearedproject  bool
	requests        map[int]struct{}
	removedrequests map[int]struct{}
	clearedrequests bool
	done            bool
	oldValue        func(context.Context) (*APIKey, error)
	predicates      []predicate.APIKey
}

var _ ent.Mutation = (*APIKeyMutation)(nil)

// apikeyOption allows management of the mutation configuration using functional options.
type apikeyOption func(*APIKeyMutation)

// newAPIKeyMutation creates new mutation for the APIKey entity.
func newAPIKeyMutation(c config, op Op, opts ...apikeyOption) *APIKeyMutation {
	m := &APIKeyMutation{
		config:        c,
		op:            op,
		typ:           TypeAPIKey,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAPIKeyID sets the ID field of the mutation.
func withAPIKeyID(id int) apikeyOption {
	return func(m *APIKeyMutation) {
		var (
			err   error
			once  sync.Once
			value *APIKey
		)
		m.oldValue = func(ctx context.Context) (*APIKey, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().APIKey.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAPIKey sets the old APIKey of the mutation.
func withAPIKey(node *APIKey) apikeyOption {
	return func(m *APIKeyMutation) {
		m.oldValue = func(context.Context) (*APIKey, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m APIKeyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m APIKeyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *APIKeyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *APIKeyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().APIKey.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *APIKeyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *APIKeyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *APIKeyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *APIKeyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *APIKeyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *APIKeyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *APIKeyMutation) SetDeletedAt(i int) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *APIKeyMutation) DeletedAt() (r int, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldDeletedAt(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *APIKeyMutation) AddDeletedAt(i int) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *APIKeyMutation) AddedDeletedAt() (r int, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *APIKeyMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetUserID sets the "user_id" field.
func (m *APIKeyMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *APIKeyMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *APIKeyMutation) ResetUserID() {
	m.user = nil
}

// SetProjectID sets the "project_id" field.
func (m *APIKeyMutation) SetProjectID(i int) {
	m.project = &i
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *APIKeyMutation) ProjectID() (r int, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldProjectID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *APIKeyMutation) ResetProjectID() {
	m.project = nil
}

// SetKey sets the "key" field.
func (m *APIKeyMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *APIKeyMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *APIKeyMutation) ResetKey() {
	m.key = nil
}

// SetName sets the "name" field.
func (m *APIKeyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *APIKeyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *APIKeyMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *APIKeyMutation) SetType(a apikey.Type) {
	m._type = &a
}

// GetType returns the value of the "type" field in the mutation.
func (m *APIKeyMutation) GetType() (r apikey.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldType(ctx context.Context) (v apikey.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *APIKeyMutation) ResetType() {
	m._type = nil
}

// SetStatus sets the "status" field.
func (m *APIKeyMutation) SetStatus(a apikey.Status) {
	m.status = &a
}

// Status returns the value of the "status" field in the mutation.
func (m *APIKeyMutation) Status() (r apikey.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldStatus(ctx context.Context) (v apikey.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *APIKeyMutation) ResetStatus() {
	m.status = nil
}

// SetScopes sets the "scopes" field.
func (m *APIKeyMutation) SetScopes(s []string) {
	m.scopes = &s
	m.appendscopes = nil
}

// Scopes returns the value of the "scopes" field in the mutation.
func (m *APIKeyMutation) Scopes() (r []string, exists bool) {
	v := m.scopes
	if v == nil {
		return
	}
	return *v, true
}

// OldScopes returns the old "scopes" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldScopes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopes: %w", err)
	}
	return oldValue.Scopes, nil
}

// AppendScopes adds s to the "scopes" field.
func (m *APIKeyMutation) AppendScopes(s []string) {
	m.appendscopes = append(m.appendscopes, s...)
}

// AppendedScopes returns the list of values that were appended to the "scopes" field in this mutation.
func (m *APIKeyMutation) AppendedScopes() ([]string, bool) {
	if len(m.appendscopes) == 0 {
		return nil, false
	}
	return m.appendscopes, true
}

// ClearScopes clears the value of the "scopes" field.
func (m *APIKeyMutation) ClearScopes() {
	m.scopes = nil
	m.appendscopes = nil
	m.clearedFields[apikey.FieldScopes] = struct{}{}
}

// ScopesCleared returns if the "scopes" field was cleared in this mutation.
func (m *APIKeyMutation) ScopesCleared() bool {
	_, ok := m.clearedFields[apikey.FieldScopes]
	return ok
}

// ResetScopes resets all changes to the "scopes" field.
func (m *APIKeyMutation) ResetScopes() {
	m.scopes = nil
	m.appendscopes = nil
	delete(m.clearedFields, apikey.FieldScopes)
}

// SetProfiles sets the "profiles" field.
func (m *APIKeyMutation) SetProfiles(okp *objects.APIKeyProfiles) {
	m.profiles = &okp
}

// Profiles returns the value of the "profiles" field in the mutation.
func (m *APIKeyMutation) Profiles() (r *objects.APIKeyProfiles, exists bool) {
	v := m.profiles
	if v == nil {
		return
	}
	return *v, true
}

// OldProfiles returns the old "profiles" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldProfiles(ctx context.Context) (v *objects.APIKeyProfiles, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfiles is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfiles requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfiles: %w", err)
	}
	return oldValue.Profiles, nil
}

// ClearProfiles clears the value of the "profiles" field.
func (m *APIKeyMutation) ClearProfiles() {
	m.profiles = nil
	m.clearedFields[apikey.FieldProfiles] = struct{}{}
}

// ProfilesCleared returns if the "profiles" field was cleared in this mutation.
func (m *APIKeyMutation) ProfilesCleared() bool {
	_, ok := m.clearedFields[apikey.FieldProfiles]
	return ok
}

// ResetProfiles resets all changes to the "profiles" field.
func (m *APIKeyMutation) ResetProfiles() {
	m.profiles = nil
	delete(m.clearedFields, apikey.FieldProfiles)
}

// ClearUser clears the "user" edge to the User entity.
func (m *APIKeyMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[apikey.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *APIKeyMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *APIKeyMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *APIKeyMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearProject clears the "project" edge to the Project entity.
func (m *APIKeyMutation) ClearProject() {
	m.clearedproject = true
	m.clearedFields[apikey.FieldProjectID] = struct{}{}
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *APIKeyMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *APIKeyMutation) ProjectIDs() (ids []int) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *APIKeyMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// AddRequestIDs adds the "requests" edge to the Request entity by ids.
func (m *APIKeyMutation) AddRequestIDs(ids ...int) {
	if m.requests == nil {
		m.requests = make(map[int]struct{})
	}
	for i := range ids {
		m.requests[ids[i]] = struct{}{}
	}
}

// ClearRequests clears the "requests" edge to the Request entity.
func (m *APIKeyMutation) ClearRequests() {
	m.clearedrequests = true
}

// RequestsCleared reports if the "requests" edge to the Request entity was cleared.
func (m *APIKeyMutation) RequestsCleared() bool {
	return m.clearedrequests
}

// RemoveRequestIDs removes the "requests" edge to the Request entity by IDs.
func (m *APIKeyMutation) RemoveRequestIDs(ids ...int) {
	if m.removedrequests == nil {
		m.removedrequests = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.requests, ids[i])
		m.removedrequests[ids[i]] = struct{}{}
	}
}

// RemovedRequests returns the removed IDs of the "requests" edge to the Request entity.
func (m *APIKeyMutation) RemovedRequestsIDs() (ids []int) {
	for id := range m.removedrequests {
		ids = append(ids, id)
	}
	return
}

// RequestsIDs returns the "requests" edge IDs in the mutation.
func (m *APIKeyMutation) RequestsIDs() (ids []int) {
	for id := range m.requests {
		ids = append(ids, id)
	}
	return
}

// ResetRequests resets all changes to the "requests" edge.
func (m *APIKeyMutation) ResetRequests() {
	m.requests = nil
	m.clearedrequests = false
	m.removedrequests = nil
}

// Where appends a list predicates to the APIKeyMutation builder.
func (m *APIKeyMutation) Where(ps ...predicate.APIKey) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the APIKeyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *APIKeyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.APIKey, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *APIKeyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *APIKeyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (APIKey).
func (m *APIKeyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *APIKeyMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, apikey.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, apikey.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, apikey.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, apikey.FieldUserID)
	}
	if m.project != nil {
		fields = append(fields, apikey.FieldProjectID)
	}
	if m.key != nil {
		fields = append(fields, apikey.FieldKey)
	}
	if m.name != nil {
		fields = append(fields, apikey.FieldName)
	}
	if m._type != nil {
		fields = append(fields, apikey.FieldType)
	}
	if m.status != nil {
		fields = append(fields, apikey.FieldStatus)
	}
	if m.scopes != nil {
		fields = append(fields, apikey.FieldScopes)
	}
	if m.profiles != nil {
		fields = append(fields, apikey.FieldProfiles)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *APIKeyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case apikey.FieldCreatedAt:
		return m.CreatedAt()
	case apikey.FieldUpdatedAt:
		return m.UpdatedAt()
	case apikey.FieldDeletedAt:
		return m.DeletedAt()
	case apikey.FieldUserID:
		return m.UserID()
	case apikey.FieldProjectID:
		return m.ProjectID()
	case apikey.FieldKey:
		return m.Key()
	case apikey.FieldName:
		return m.Name()
	case apikey.FieldType:
		return m.GetType()
	case apikey.FieldStatus:
		return m.Status()
	case apikey.FieldScopes:
		return m.Scopes()
	case apikey.FieldProfiles:
		return m.Profiles()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *APIKeyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case apikey.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case apikey.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case apikey.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case apikey.FieldUserID:
		return m.OldUserID(ctx)
	case apikey.FieldProjectID:
		return m.OldProjectID(ctx)
	case apikey.FieldKey:
		return m.OldKey(ctx)
	case apikey.FieldName:
		return m.OldName(ctx)
	case apikey.FieldType:
		return m.OldType(ctx)
	case apikey.FieldStatus:
		return m.OldStatus(ctx)
	case apikey.FieldScopes:
		return m.OldScopes(ctx)
	case apikey.FieldProfiles:
		return m.OldProfiles(ctx)
	}
	return nil, fmt.Errorf("unknown APIKey field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *APIKeyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case apikey.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case apikey.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case apikey.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case apikey.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case apikey.FieldProjectID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case apikey.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case apikey.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case apikey.FieldType:
		v, ok := value.(apikey.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case apikey.FieldStatus:
		v, ok := value.(apikey.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case apikey.FieldScopes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopes(v)
		return nil
	case apikey.FieldProfiles:
		v, ok := value.(*objects.APIKeyProfiles)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfiles(v)
		return nil
	}
	return fmt.Errorf("unknown APIKey field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *APIKeyMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, apikey.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *APIKeyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case apikey.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *APIKeyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case apikey.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown APIKey numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *APIKeyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(apikey.FieldScopes) {
		fields = append(fields, apikey.FieldScopes)
	}
	if m.FieldCleared(apikey.FieldProfiles) {
		fields = append(fields, apikey.FieldProfiles)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *APIKeyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *APIKeyMutation) ClearField(name string) error {
	switch name {
	case apikey.FieldScopes:
		m.ClearScopes()
		return nil
	case apikey.FieldProfiles:
		m.ClearProfiles()
		return nil
	}
	return fmt.Errorf("unknown APIKey nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *APIKeyMutation) ResetField(name string) error {
	switch name {
	case apikey.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case apikey.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case apikey.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case apikey.FieldUserID:
		m.ResetUserID()
		return nil
	case apikey.FieldProjectID:
		m.ResetProjectID()
		return nil
	case apikey.FieldKey:
		m.ResetKey()
		return nil
	case apikey.FieldName:
		m.ResetName()
		return nil
	case apikey.FieldType:
		m.ResetType()
		return nil
	case apikey.FieldStatus:
		m.ResetStatus()
		return nil
	case apikey.FieldScopes:
		m.ResetScopes()
		return nil
	case apikey.FieldProfiles:
		m.ResetProfiles()
		return nil
	}
	return fmt.Errorf("unknown APIKey field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *APIKeyMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user != nil {
		edges = append(edges, apikey.EdgeUser)
	}
	if m.project != nil {
		edges = append(edges, apikey.EdgeProject)
	}
	if m.requests != nil {
		edges = append(edges, apikey.EdgeRequests)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *APIKeyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case apikey.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case apikey.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case apikey.EdgeRequests:
		ids := make([]ent.Value, 0, len(m.requests))
		for id := range m.requests {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *APIKeyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedrequests != nil {
		edges = append(edges, apikey.EdgeRequests)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *APIKeyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case apikey.EdgeRequests:
		ids := make([]ent.Value, 0, len(m.removedrequests))
		for id := range m.removedrequests {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *APIKeyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, apikey.EdgeUser)
	}
	if m.clearedproject {
		edges = append(edges, apikey.EdgeProject)
	}
	if m.clearedrequests {
		edges = append(edges, apikey.EdgeRequests)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *APIKeyMutation) EdgeCleared(name string) bool {
	switch name {
	case apikey.EdgeUser:
		return m.cleareduser
	case apikey.EdgeProject:
		return m.clearedproject
	case apikey.EdgeRequests:
		return m.clearedrequests
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *APIKeyMutation) ClearEdge(name string) error {
	switch name {
	case apikey.EdgeUser:
		m.ClearUser()
		return nil
	case apikey.EdgeProject:
		m.ClearProject()
		return nil
	}
	return fmt.Errorf("unknown APIKey unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *APIKeyMutation) ResetEdge(name string) error {
	switch name {
	case apikey.EdgeUser:
		m.ResetUser()
		return nil
	case apikey.EdgeProject:
		m.ResetProject()
		return nil
	case apikey.EdgeRequests:
		m.ResetRequests()
		return nil
	}
	return fmt.Errorf("unknown APIKey edge %s", name)
}

// ChannelMutation represents an operation that mutates the Channel nodes in the graph.
type ChannelMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	created_at                 *time.Time
	updated_at                 *time.Time
	deleted_at                 *int
	adddeleted_at              *int
	_type                      *channel.Type
	base_url                   *string
	name                       *string
	status                     *channel.Status
	credentials                **objects.ChannelCredentials
	supported_models           *[]string
	appendsupported_models     []string
	auto_sync_supported_models *bool
	tags                       *[]string
	appendtags                 []string
	default_test_model         *string
	settings                   **objects.ChannelSettings
	ordering_weight            *int
	addordering_weight         *int
	error_message              *string
	remark                     *string
	clearedFields              map[string]struct{}
	requests                   map[int]struct{}
	removedrequests            map[int]struct{}
	clearedrequests            bool
	executions                 map[int]struct{}
	removedexecutions          map[int]struct{}
	clearedexecutions          bool
	usage_logs                 map[int]struct{}
	removedusage_logs          map[int]struct{}
	clearedusage_logs          bool
	channel_performance        *int
	clearedchannel_performance bool
	channel_probes             map[int]struct{}
	removedchannel_probes      map[int]struct{}
	clearedchannel_probes      bool
	done                       bool
	oldValue                   func(context.Context) (*Channel, error)
	predicates                 []predicate.Channel
}

var _ ent.Mutation = (*ChannelMutation)(nil)

// channelOption allows management of the mutation configuration using functional options.
type channelOption func(*ChannelMutation)

// newChannelMutation creates new mutation for the Channel entity.
func newChannelMutation(c config, op Op, opts ...channelOption) *ChannelMutation {
	m := &ChannelMutation{
		config:        c,
		op:            op,
		typ:           TypeChannel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChannelID sets the ID field of the mutation.
func withChannelID(id int) channelOption {
	return func(m *ChannelMutation) {
		var (
			err   error
			once  sync.Once
			value *Channel
		)
		m.oldValue = func(ctx context.Context) (*Channel, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Channel.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChannel sets the old Channel of the mutation.
func withChannel(node *Channel) channelOption {
	return func(m *ChannelMutation) {
		m.oldValue = func(context.Context) (*Channel, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChannelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChannelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChannelMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChannelMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Channel.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ChannelMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ChannelMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ChannelMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ChannelMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ChannelMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ChannelMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ChannelMutation) SetDeletedAt(i int) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ChannelMutation) DeletedAt() (r int, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldDeletedAt(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *ChannelMutation) AddDeletedAt(i int) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *ChannelMutation) AddedDeletedAt() (r int, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ChannelMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetType sets the "type" field.
func (m *ChannelMutation) SetType(c channel.Type) {
	m._type = &c
}

// GetType returns the value of the "type" field in the mutation.
func (m *ChannelMutation) GetType() (r channel.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldType(ctx context.Context) (v channel.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ChannelMutation) ResetType() {
	m._type = nil
}

// SetBaseURL sets the "base_url" field.
func (m *ChannelMutation) SetBaseURL(s string) {
	m.base_url = &s
}

// BaseURL returns the value of the "base_url" field in the mutation.
func (m *ChannelMutation) BaseURL() (r string, exists bool) {
	v := m.base_url
	if v == nil {
		return
	}
	return *v, true
}

// OldBaseURL returns the old "base_url" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldBaseURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaseURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaseURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaseURL: %w", err)
	}
	return oldValue.BaseURL, nil
}

// ClearBaseURL clears the value of the "base_url" field.
func (m *ChannelMutation) ClearBaseURL() {
	m.base_url = nil
	m.clearedFields[channel.FieldBaseURL] = struct{}{}
}

// BaseURLCleared returns if the "base_url" field was cleared in this mutation.
func (m *ChannelMutation) BaseURLCleared() bool {
	_, ok := m.clearedFields[channel.FieldBaseURL]
	return ok
}

// ResetBaseURL resets all changes to the "base_url" field.
func (m *ChannelMutation) ResetBaseURL() {
	m.base_url = nil
	delete(m.clearedFields, channel.FieldBaseURL)
}

// SetName sets the "name" field.
func (m *ChannelMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ChannelMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ChannelMutation) ResetName() {
	m.name = nil
}

// SetStatus sets the "status" field.
func (m *ChannelMutation) SetStatus(c channel.Status) {
	m.status = &c
}

// Status returns the value of the "status" field in the mutation.
func (m *ChannelMutation) Status() (r channel.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldStatus(ctx context.Context) (v channel.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ChannelMutation) ResetStatus() {
	m.status = nil
}

// SetCredentials sets the "credentials" field.
func (m *ChannelMutation) SetCredentials(oc *objects.ChannelCredentials) {
	m.credentials = &oc
}

// Credentials returns the value of the "credentials" field in the mutation.
func (m *ChannelMutation) Credentials() (r *objects.ChannelCredentials, exists bool) {
	v := m.credentials
	if v == nil {
		return
	}
	return *v, true
}

// OldCredentials returns the old "credentials" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldCredentials(ctx context.Context) (v *objects.ChannelCredentials, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCredentials is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCredentials requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCredentials: %w", err)
	}
	return oldValue.Credentials, nil
}

// ResetCredentials resets all changes to the "credentials" field.
func (m *ChannelMutation) ResetCredentials() {
	m.credentials = nil
}

// SetSupportedModels sets the "supported_models" field.
func (m *ChannelMutation) SetSupportedModels(s []string) {
	m.supported_models = &s
	m.appendsupported_models = nil
}

// SupportedModels returns the value of the "supported_models" field in the mutation.
func (m *ChannelMutation) SupportedModels() (r []string, exists bool) {
	v := m.supported_models
	if v == nil {
		return
	}
	return *v, true
}

// OldSupportedModels returns the old "supported_models" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldSupportedModels(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupportedModels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupportedModels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupportedModels: %w", err)
	}
	return oldValue.SupportedModels, nil
}

// AppendSupportedModels adds s to the "supported_models" field.
func (m *ChannelMutation) AppendSupportedModels(s []string) {
	m.appendsupported_models = append(m.appendsupported_models, s...)
}

// AppendedSupportedModels returns the list of values that were appended to the "supported_models" field in this mutation.
func (m *ChannelMutation) AppendedSupportedModels() ([]string, bool) {
	if len(m.appendsupported_models) == 0 {
		return nil, false
	}
	return m.appendsupported_models, true
}

// ResetSupportedModels resets all changes to the "supported_models" field.
func (m *ChannelMutation) ResetSupportedModels() {
	m.supported_models = nil
	m.appendsupported_models = nil
}

// SetAutoSyncSupportedModels sets the "auto_sync_supported_models" field.
func (m *ChannelMutation) SetAutoSyncSupportedModels(b bool) {
	m.auto_sync_supported_models = &b
}

// AutoSyncSupportedModels returns the value of the "auto_sync_supported_models" field in the mutation.
func (m *ChannelMutation) AutoSyncSupportedModels() (r bool, exists bool) {
	v := m.auto_sync_supported_models
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoSyncSupportedModels returns the old "auto_sync_supported_models" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldAutoSyncSupportedModels(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAutoSyncSupportedModels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAutoSyncSupportedModels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoSyncSupportedModels: %w", err)
	}
	return oldValue.AutoSyncSupportedModels, nil
}

// ResetAutoSyncSupportedModels resets all changes to the "auto_sync_supported_models" field.
func (m *ChannelMutation) ResetAutoSyncSupportedModels() {
	m.auto_sync_supported_models = nil
}

// SetTags sets the "tags" field.
func (m *ChannelMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *ChannelMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *ChannelMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *ChannelMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *ChannelMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[channel.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *ChannelMutation) TagsCleared() bool {
	_, ok := m.clearedFields[channel.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *ChannelMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, channel.FieldTags)
}

// SetDefaultTestModel sets the "default_test_model" field.
func (m *ChannelMutation) SetDefaultTestModel(s string) {
	m.default_test_model = &s
}

// DefaultTestModel returns the value of the "default_test_model" field in the mutation.
func (m *ChannelMutation) DefaultTestModel() (r string, exists bool) {
	v := m.default_test_model
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultTestModel returns the old "default_test_model" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldDefaultTestModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultTestModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultTestModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultTestModel: %w", err)
	}
	return oldValue.DefaultTestModel, nil
}

// ResetDefaultTestModel resets all changes to the "default_test_model" field.
func (m *ChannelMutation) ResetDefaultTestModel() {
	m.default_test_model = nil
}

// SetSettings sets the "settings" field.
func (m *ChannelMutation) SetSettings(os *objects.ChannelSettings) {
	m.settings = &os
}

// Settings returns the value of the "settings" field in the mutation.
func (m *ChannelMutation) Settings() (r *objects.ChannelSettings, exists bool) {
	v := m.settings
	if v == nil {
		return
	}
	return *v, true
}

// OldSettings returns the old "settings" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldSettings(ctx context.Context) (v *objects.ChannelSettings, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettings: %w", err)
	}
	return oldValue.Settings, nil
}

// ClearSettings clears the value of the "settings" field.
func (m *ChannelMutation) ClearSettings() {
	m.settings = nil
	m.clearedFields[channel.FieldSettings] = struct{}{}
}

// SettingsCleared returns if the "settings" field was cleared in this mutation.
func (m *ChannelMutation) SettingsCleared() bool {
	_, ok := m.clearedFields[channel.FieldSettings]
	return ok
}

// ResetSettings resets all changes to the "settings" field.
func (m *ChannelMutation) ResetSettings() {
	m.settings = nil
	delete(m.clearedFields, channel.FieldSettings)
}

// SetOrderingWeight sets the "ordering_weight" field.
func (m *ChannelMutation) SetOrderingWeight(i int) {
	m.ordering_weight = &i
	m.addordering_weight = nil
}

// OrderingWeight returns the value of the "ordering_weight" field in the mutation.
func (m *ChannelMutation) OrderingWeight() (r int, exists bool) {
	v := m.ordering_weight
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderingWeight returns the old "ordering_weight" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldOrderingWeight(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderingWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderingWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderingWeight: %w", err)
	}
	return oldValue.OrderingWeight, nil
}

// AddOrderingWeight adds i to the "ordering_weight" field.
func (m *ChannelMutation) AddOrderingWeight(i int) {
	if m.addordering_weight != nil {
		*m.addordering_weight += i
	} else {
		m.addordering_weight = &i
	}
}

// AddedOrderingWeight returns the value that was added to the "ordering_weight" field in this mutation.
func (m *ChannelMutation) AddedOrderingWeight() (r int, exists bool) {
	v := m.addordering_weight
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderingWeight resets all changes to the "ordering_weight" field.
func (m *ChannelMutation) ResetOrderingWeight() {
	m.ordering_weight = nil
	m.addordering_weight = nil
}

// SetErrorMessage sets the "error_message" field.
func (m *ChannelMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *ChannelMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldErrorMessage(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *ChannelMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[channel.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *ChannelMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[channel.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *ChannelMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, channel.FieldErrorMessage)
}

// SetRemark sets the "remark" field.
func (m *ChannelMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *ChannelMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldRemark(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *ChannelMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[channel.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *ChannelMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[channel.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *ChannelMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, channel.FieldRemark)
}

// AddRequestIDs adds the "requests" edge to the Request entity by ids.
func (m *ChannelMutation) AddRequestIDs(ids ...int) {
	if m.requests == nil {
		m.requests = make(map[int]struct{})
	}
	for i := range ids {
		m.requests[ids[i]] = struct{}{}
	}
}

// ClearRequests clears the "requests" edge to the Request entity.
func (m *ChannelMutation) ClearRequests() {
	m.clearedrequests = true
}

// RequestsCleared reports if the "requests" edge to the Request entity was cleared.
func (m *ChannelMutation) RequestsCleared() bool {
	return m.clearedrequests
}

// RemoveRequestIDs removes the "requests" edge to the Request entity by IDs.
func (m *ChannelMutation) RemoveRequestIDs(ids ...int) {
	if m.removedrequests == nil {
		m.removedrequests = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.requests, ids[i])
		m.removedrequests[ids[i]] = struct{}{}
	}
}

// RemovedRequests returns the removed IDs of the "requests" edge to the Request entity.
func (m *ChannelMutation) RemovedRequestsIDs() (ids []int) {
	for id := range m.removedrequests {
		ids = append(ids, id)
	}
	return
}

// RequestsIDs returns the "requests" edge IDs in the mutation.
func (m *ChannelMutation) RequestsIDs() (ids []int) {
	for id := range m.requests {
		ids = append(ids, id)
	}
	return
}

// ResetRequests resets all changes to the "requests" edge.
func (m *ChannelMutation) ResetRequests() {
	m.requests = nil
	m.clearedrequests = false
	m.removedrequests = nil
}

// AddExecutionIDs adds the "executions" edge to the RequestExecution entity by ids.
func (m *ChannelMutation) AddExecutionIDs(ids ...int) {
	if m.executions == nil {
		m.executions = make(map[int]struct{})
	}
	for i := range ids {
		m.executions[ids[i]] = struct{}{}
	}
}

// ClearExecutions clears the "executions" edge to the RequestExecution entity.
func (m *ChannelMutation) ClearExecutions() {
	m.clearedexecutions = true
}

// ExecutionsCleared reports if the "executions" edge to the RequestExecution entity was cleared.
func (m *ChannelMutation) ExecutionsCleared() bool {
	return m.clearedexecutions
}

// RemoveExecutionIDs removes the "executions" edge to the RequestExecution entity by IDs.
func (m *ChannelMutation) RemoveExecutionIDs(ids ...int) {
	if m.removedexecutions == nil {
		m.removedexecutions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.executions, ids[i])
		m.removedexecutions[ids[i]] = struct{}{}
	}
}

// RemovedExecutions returns the removed IDs of the "executions" edge to the RequestExecution entity.
func (m *ChannelMutation) RemovedExecutionsIDs() (ids []int) {
	for id := range m.removedexecutions {
		ids = append(ids, id)
	}
	return
}

// ExecutionsIDs returns the "executions" edge IDs in the mutation.
func (m *ChannelMutation) ExecutionsIDs() (ids []int) {
	for id := range m.executions {
		ids = append(ids, id)
	}
	return
}

// ResetExecutions resets all changes to the "executions" edge.
func (m *ChannelMutation) ResetExecutions() {
	m.executions = nil
	m.clearedexecutions = false
	m.removedexecutions = nil
}

// AddUsageLogIDs adds the "usage_logs" edge to the UsageLog entity by ids.
func (m *ChannelMutation) AddUsageLogIDs(ids ...int) {
	if m.usage_logs == nil {
		m.usage_logs = make(map[int]struct{})
	}
	for i := range ids {
		m.usage_logs[ids[i]] = struct{}{}
	}
}

// ClearUsageLogs clears the "usage_logs" edge to the UsageLog entity.
func (m *ChannelMutation) ClearUsageLogs() {
	m.clearedusage_logs = true
}

// UsageLogsCleared reports if the "usage_logs" edge to the UsageLog entity was cleared.
func (m *ChannelMutation) UsageLogsCleared() bool {
	return m.clearedusage_logs
}

// RemoveUsageLogIDs removes the "usage_logs" edge to the UsageLog entity by IDs.
func (m *ChannelMutation) RemoveUsageLogIDs(ids ...int) {
	if m.removedusage_logs == nil {
		m.removedusage_logs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.usage_logs, ids[i])
		m.removedusage_logs[ids[i]] = struct{}{}
	}
}

// RemovedUsageLogs returns the removed IDs of the "usage_logs" edge to the UsageLog entity.
func (m *ChannelMutation) RemovedUsageLogsIDs() (ids []int) {
	for id := range m.removedusage_logs {
		ids = append(ids, id)
	}
	return
}

// UsageLogsIDs returns the "usage_logs" edge IDs in the mutation.
func (m *ChannelMutation) UsageLogsIDs() (ids []int) {
	for id := range m.usage_logs {
		ids = append(ids, id)
	}
	return
}

// ResetUsageLogs resets all changes to the "usage_logs" edge.
func (m *ChannelMutation) ResetUsageLogs() {
	m.usage_logs = nil
	m.clearedusage_logs = false
	m.removedusage_logs = nil
}

// SetChannelPerformanceID sets the "channel_performance" edge to the ChannelPerformance entity by id.
func (m *ChannelMutation) SetChannelPerformanceID(id int) {
	m.channel_performance = &id
}

// ClearChannelPerformance clears the "channel_performance" edge to the ChannelPerformance entity.
func (m *ChannelMutation) ClearChannelPerformance() {
	m.clearedchannel_performance = true
}

// ChannelPerformanceCleared reports if the "channel_performance" edge to the ChannelPerformance entity was cleared.
func (m *ChannelMutation) ChannelPerformanceCleared() bool {
	return m.clearedchannel_performance
}

// ChannelPerformanceID returns the "channel_performance" edge ID in the mutation.
func (m *ChannelMutation) ChannelPerformanceID() (id int, exists bool) {
	if m.channel_performance != nil {
		return *m.channel_performance, true
	}
	return
}

// ChannelPerformanceIDs returns the "channel_performance" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChannelPerformanceID instead. It exists only for internal usage by the builders.
func (m *ChannelMutation) ChannelPerformanceIDs() (ids []int) {
	if id := m.channel_performance; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChannelPerformance resets all changes to the "channel_performance" edge.
func (m *ChannelMutation) ResetChannelPerformance() {
	m.channel_performance = nil
	m.clearedchannel_performance = false
}

// AddChannelProbeIDs adds the "channel_probes" edge to the ChannelProbe entity by ids.
func (m *ChannelMutation) AddChannelProbeIDs(ids ...int) {
	if m.channel_probes == nil {
		m.channel_probes = make(map[int]struct{})
	}
	for i := range ids {
		m.channel_probes[ids[i]] = struct{}{}
	}
}

// ClearChannelProbes clears the "channel_probes" edge to the ChannelProbe entity.
func (m *ChannelMutation) ClearChannelProbes() {
	m.clearedchannel_probes = true
}

// ChannelProbesCleared reports if the "channel_probes" edge to the ChannelProbe entity was cleared.
func (m *ChannelMutation) ChannelProbesCleared() bool {
	return m.clearedchannel_probes
}

// RemoveChannelProbeIDs removes the "channel_probes" edge to the ChannelProbe entity by IDs.
func (m *ChannelMutation) RemoveChannelProbeIDs(ids ...int) {
	if m.removedchannel_probes == nil {
		m.removedchannel_probes = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.channel_probes, ids[i])
		m.removedchannel_probes[ids[i]] = struct{}{}
	}
}

// RemovedChannelProbes returns the removed IDs of the "channel_probes" edge to the ChannelProbe entity.
func (m *ChannelMutation) RemovedChannelProbesIDs() (ids []int) {
	for id := range m.removedchannel_probes {
		ids = append(ids, id)
	}
	return
}

// ChannelProbesIDs returns the "channel_probes" edge IDs in the mutation.
func (m *ChannelMutation) ChannelProbesIDs() (ids []int) {
	for id := range m.channel_probes {
		ids = append(ids, id)
	}
	return
}

// ResetChannelProbes resets all changes to the "channel_probes" edge.
func (m *ChannelMutation) ResetChannelProbes() {
	m.channel_probes = nil
	m.clearedchannel_probes = false
	m.removedchannel_probes = nil
}

// Where appends a list predicates to the ChannelMutation builder.
func (m *ChannelMutation) Where(ps ...predicate.Channel) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ChannelMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ChannelMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Channel, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ChannelMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ChannelMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Channel).
func (m *ChannelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChannelMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_at != nil {
		fields = append(fields, channel.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, channel.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, channel.FieldDeletedAt)
	}
	if m._type != nil {
		fields = append(fields, channel.FieldType)
	}
	if m.base_url != nil {
		fields = append(fields, channel.FieldBaseURL)
	}
	if m.name != nil {
		fields = append(fields, channel.FieldName)
	}
	if m.status != nil {
		fields = append(fields, channel.FieldStatus)
	}
	if m.credentials != nil {
		fields = append(fields, channel.FieldCredentials)
	}
	if m.supported_models != nil {
		fields = append(fields, channel.FieldSupportedModels)
	}
	if m.auto_sync_supported_models != nil {
		fields = append(fields, channel.FieldAutoSyncSupportedModels)
	}
	if m.tags != nil {
		fields = append(fields, channel.FieldTags)
	}
	if m.default_test_model != nil {
		fields = append(fields, channel.FieldDefaultTestModel)
	}
	if m.settings != nil {
		fields = append(fields, channel.FieldSettings)
	}
	if m.ordering_weight != nil {
		fields = append(fields, channel.FieldOrderingWeight)
	}
	if m.error_message != nil {
		fields = append(fields, channel.FieldErrorMessage)
	}
	if m.remark != nil {
		fields = append(fields, channel.FieldRemark)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChannelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case channel.FieldCreatedAt:
		return m.CreatedAt()
	case channel.FieldUpdatedAt:
		return m.UpdatedAt()
	case channel.FieldDeletedAt:
		return m.DeletedAt()
	case channel.FieldType:
		return m.GetType()
	case channel.FieldBaseURL:
		return m.BaseURL()
	case channel.FieldName:
		return m.Name()
	case channel.FieldStatus:
		return m.Status()
	case channel.FieldCredentials:
		return m.Credentials()
	case channel.FieldSupportedModels:
		return m.SupportedModels()
	case channel.FieldAutoSyncSupportedModels:
		return m.AutoSyncSupportedModels()
	case channel.FieldTags:
		return m.Tags()
	case channel.FieldDefaultTestModel:
		return m.DefaultTestModel()
	case channel.FieldSettings:
		return m.Settings()
	case channel.FieldOrderingWeight:
		return m.OrderingWeight()
	case channel.FieldErrorMessage:
		return m.ErrorMessage()
	case channel.FieldRemark:
		return m.Remark()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChannelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case channel.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case channel.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case channel.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case channel.FieldType:
		return m.OldType(ctx)
	case channel.FieldBaseURL:
		return m.OldBaseURL(ctx)
	case channel.FieldName:
		return m.OldName(ctx)
	case channel.FieldStatus:
		return m.OldStatus(ctx)
	case channel.FieldCredentials:
		return m.OldCredentials(ctx)
	case channel.FieldSupportedModels:
		return m.OldSupportedModels(ctx)
	case channel.FieldAutoSyncSupportedModels:
		return m.OldAutoSyncSupportedModels(ctx)
	case channel.FieldTags:
		return m.OldTags(ctx)
	case channel.FieldDefaultTestModel:
		return m.OldDefaultTestModel(ctx)
	case channel.FieldSettings:
		return m.OldSettings(ctx)
	case channel.FieldOrderingWeight:
		return m.OldOrderingWeight(ctx)
	case channel.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case channel.FieldRemark:
		return m.OldRemark(ctx)
	}
	return nil, fmt.Errorf("unknown Channel field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChannelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case channel.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case channel.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case channel.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case channel.FieldType:
		v, ok := value.(channel.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case channel.FieldBaseURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaseURL(v)
		return nil
	case channel.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case channel.FieldStatus:
		v, ok := value.(channel.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case channel.FieldCredentials:
		v, ok := value.(*objects.ChannelCredentials)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCredentials(v)
		return nil
	case channel.FieldSupportedModels:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupportedModels(v)
		return nil
	case channel.FieldAutoSyncSupportedModels:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoSyncSupportedModels(v)
		return nil
	case channel.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case channel.FieldDefaultTestModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultTestModel(v)
		return nil
	case channel.FieldSettings:
		v, ok := value.(*objects.ChannelSettings)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettings(v)
		return nil
	case channel.FieldOrderingWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderingWeight(v)
		return nil
	case channel.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case channel.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	}
	return fmt.Errorf("unknown Channel field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChannelMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, channel.FieldDeletedAt)
	}
	if m.addordering_weight != nil {
		fields = append(fields, channel.FieldOrderingWeight)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChannelMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case channel.FieldDeletedAt:
		return m.AddedDeletedAt()
	case channel.FieldOrderingWeight:
		return m.AddedOrderingWeight()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChannelMutation) AddField(name string, value ent.Value) error {
	switch name {
	case channel.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case channel.FieldOrderingWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderingWeight(v)
		return nil
	}
	return fmt.Errorf("unknown Channel numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChannelMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(channel.FieldBaseURL) {
		fields = append(fields, channel.FieldBaseURL)
	}
	if m.FieldCleared(channel.FieldTags) {
		fields = append(fields, channel.FieldTags)
	}
	if m.FieldCleared(channel.FieldSettings) {
		fields = append(fields, channel.FieldSettings)
	}
	if m.FieldCleared(channel.FieldErrorMessage) {
		fields = append(fields, channel.FieldErrorMessage)
	}
	if m.FieldCleared(channel.FieldRemark) {
		fields = append(fields, channel.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChannelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChannelMutation) ClearField(name string) error {
	switch name {
	case channel.FieldBaseURL:
		m.ClearBaseURL()
		return nil
	case channel.FieldTags:
		m.ClearTags()
		return nil
	case channel.FieldSettings:
		m.ClearSettings()
		return nil
	case channel.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	case channel.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown Channel nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChannelMutation) ResetField(name string) error {
	switch name {
	case channel.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case channel.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case channel.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case channel.FieldType:
		m.ResetType()
		return nil
	case channel.FieldBaseURL:
		m.ResetBaseURL()
		return nil
	case channel.FieldName:
		m.ResetName()
		return nil
	case channel.FieldStatus:
		m.ResetStatus()
		return nil
	case channel.FieldCredentials:
		m.ResetCredentials()
		return nil
	case channel.FieldSupportedModels:
		m.ResetSupportedModels()
		return nil
	case channel.FieldAutoSyncSupportedModels:
		m.ResetAutoSyncSupportedModels()
		return nil
	case channel.FieldTags:
		m.ResetTags()
		return nil
	case channel.FieldDefaultTestModel:
		m.ResetDefaultTestModel()
		return nil
	case channel.FieldSettings:
		m.ResetSettings()
		return nil
	case channel.FieldOrderingWeight:
		m.ResetOrderingWeight()
		return nil
	case channel.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case channel.FieldRemark:
		m.ResetRemark()
		return nil
	}
	return fmt.Errorf("unknown Channel field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChannelMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.requests != nil {
		edges = append(edges, channel.EdgeRequests)
	}
	if m.executions != nil {
		edges = append(edges, channel.EdgeExecutions)
	}
	if m.usage_logs != nil {
		edges = append(edges, channel.EdgeUsageLogs)
	}
	if m.channel_performance != nil {
		edges = append(edges, channel.EdgeChannelPerformance)
	}
	if m.channel_probes != nil {
		edges = append(edges, channel.EdgeChannelProbes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChannelMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case channel.EdgeRequests:
		ids := make([]ent.Value, 0, len(m.requests))
		for id := range m.requests {
			ids = append(ids, id)
		}
		return ids
	case channel.EdgeExecutions:
		ids := make([]ent.Value, 0, len(m.executions))
		for id := range m.executions {
			ids = append(ids, id)
		}
		return ids
	case channel.EdgeUsageLogs:
		ids := make([]ent.Value, 0, len(m.usage_logs))
		for id := range m.usage_logs {
			ids = append(ids, id)
		}
		return ids
	case channel.EdgeChannelPerformance:
		if id := m.channel_performance; id != nil {
			return []ent.Value{*id}
		}
	case channel.EdgeChannelProbes:
		ids := make([]ent.Value, 0, len(m.channel_probes))
		for id := range m.channel_probes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChannelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedrequests != nil {
		edges = append(edges, channel.EdgeRequests)
	}
	if m.removedexecutions != nil {
		edges = append(edges, channel.EdgeExecutions)
	}
	if m.removedusage_logs != nil {
		edges = append(edges, channel.EdgeUsageLogs)
	}
	if m.removedchannel_probes != nil {
		edges = append(edges, channel.EdgeChannelProbes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChannelMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case channel.EdgeRequests:
		ids := make([]ent.Value, 0, len(m.removedrequests))
		for id := range m.removedrequests {
			ids = append(ids, id)
		}
		return ids
	case channel.EdgeExecutions:
		ids := make([]ent.Value, 0, len(m.removedexecutions))
		for id := range m.removedexecutions {
			ids = append(ids, id)
		}
		return ids
	case channel.EdgeUsageLogs:
		ids := make([]ent.Value, 0, len(m.removedusage_logs))
		for id := range m.removedusage_logs {
			ids = append(ids, id)
		}
		return ids
	case channel.EdgeChannelProbes:
		ids := make([]ent.Value, 0, len(m.removedchannel_probes))
		for id := range m.removedchannel_probes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChannelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedrequests {
		edges = append(edges, channel.EdgeRequests)
	}
	if m.clearedexecutions {
		edges = append(edges, channel.EdgeExecutions)
	}
	if m.clearedusage_logs {
		edges = append(edges, channel.EdgeUsageLogs)
	}
	if m.clearedchannel_performance {
		edges = append(edges, channel.EdgeChannelPerformance)
	}
	if m.clearedchannel_probes {
		edges = append(edges, channel.EdgeChannelProbes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChannelMutation) EdgeCleared(name string) bool {
	switch name {
	case channel.EdgeRequests:
		return m.clearedrequests
	case channel.EdgeExecutions:
		return m.clearedexecutions
	case channel.EdgeUsageLogs:
		return m.clearedusage_logs
	case channel.EdgeChannelPerformance:
		return m.clearedchannel_performance
	case channel.EdgeChannelProbes:
		return m.clearedchannel_probes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChannelMutation) ClearEdge(name string) error {
	switch name {
	case channel.EdgeChannelPerformance:
		m.ClearChannelPerformance()
		return nil
	}
	return fmt.Errorf("unknown Channel unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChannelMutation) ResetEdge(name string) error {
	switch name {
	case channel.EdgeRequests:
		m.ResetRequests()
		return nil
	case channel.EdgeExecutions:
		m.ResetExecutions()
		return nil
	case channel.EdgeUsageLogs:
		m.ResetUsageLogs()
		return nil
	case channel.EdgeChannelPerformance:
		m.ResetChannelPerformance()
		return nil
	case channel.EdgeChannelProbes:
		m.ResetChannelProbes()
		return nil
	}
	return fmt.Errorf("unknown Channel edge %s", name)
}

// ChannelOverrideTemplateMutation represents an operation that mutates the ChannelOverrideTemplate nodes in the graph.
type ChannelOverrideTemplateMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	created_at             *time.Time
	updated_at             *time.Time
	deleted_at             *int
	adddeleted_at          *int
	name                   *string
	description            *string
	channel_type           *string
	override_parameters    *string
	override_headers       *[]objects.HeaderEntry
	appendoverride_headers []objects.HeaderEntry
	clearedFields          map[string]struct{}
	user                   *int
	cleareduser            bool
	done                   bool
	oldValue               func(context.Context) (*ChannelOverrideTemplate, error)
	predicates             []predicate.ChannelOverrideTemplate
}

var _ ent.Mutation = (*ChannelOverrideTemplateMutation)(nil)

// channeloverridetemplateOption allows management of the mutation configuration using functional options.
type channeloverridetemplateOption func(*ChannelOverrideTemplateMutation)

// newChannelOverrideTemplateMutation creates new mutation for the ChannelOverrideTemplate entity.
func newChannelOverrideTemplateMutation(c config, op Op, opts ...channeloverridetemplateOption) *ChannelOverrideTemplateMutation {
	m := &ChannelOverrideTemplateMutation{
		config:        c,
		op:            op,
		typ:           TypeChannelOverrideTemplate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChannelOverrideTemplateID sets the ID field of the mutation.
func withChannelOverrideTemplateID(id int) channeloverridetemplateOption {
	return func(m *ChannelOverrideTemplateMutation) {
		var (
			err   error
			once  sync.Once
			value *ChannelOverrideTemplate
		)
		m.oldValue = func(ctx context.Context) (*ChannelOverrideTemplate, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ChannelOverrideTemplate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChannelOverrideTemplate sets the old ChannelOverrideTemplate of the mutation.
func withChannelOverrideTemplate(node *ChannelOverrideTemplate) channeloverridetemplateOption {
	return func(m *ChannelOverrideTemplateMutation) {
		m.oldValue = func(context.Context) (*ChannelOverrideTemplate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChannelOverrideTemplateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChannelOverrideTemplateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChannelOverrideTemplateMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChannelOverrideTemplateMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ChannelOverrideTemplate.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ChannelOverrideTemplateMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ChannelOverrideTemplateMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ChannelOverrideTemplate entity.
// If the ChannelOverrideTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelOverrideTemplateMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ChannelOverrideTemplateMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ChannelOverrideTemplateMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ChannelOverrideTemplateMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ChannelOverrideTemplate entity.
// If the ChannelOverrideTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelOverrideTemplateMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ChannelOverrideTemplateMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ChannelOverrideTemplateMutation) SetDeletedAt(i int) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ChannelOverrideTemplateMutation) DeletedAt() (r int, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ChannelOverrideTemplate entity.
// If the ChannelOverrideTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelOverrideTemplateMutation) OldDeletedAt(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *ChannelOverrideTemplateMutation) AddDeletedAt(i int) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *ChannelOverrideTemplateMutation) AddedDeletedAt() (r int, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ChannelOverrideTemplateMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetUserID sets the "user_id" field.
func (m *ChannelOverrideTemplateMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ChannelOverrideTemplateMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the ChannelOverrideTemplate entity.
// If the ChannelOverrideTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelOverrideTemplateMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ChannelOverrideTemplateMutation) ResetUserID() {
	m.user = nil
}

// SetName sets the "name" field.
func (m *ChannelOverrideTemplateMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ChannelOverrideTemplateMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ChannelOverrideTemplate entity.
// If the ChannelOverrideTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelOverrideTemplateMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ChannelOverrideTemplateMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ChannelOverrideTemplateMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ChannelOverrideTemplateMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ChannelOverrideTemplate entity.
// If the ChannelOverrideTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelOverrideTemplateMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ChannelOverrideTemplateMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[channeloverridetemplate.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ChannelOverrideTemplateMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[channeloverridetemplate.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ChannelOverrideTemplateMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, channeloverridetemplate.FieldDescription)
}

// SetChannelType sets the "channel_type" field.
func (m *ChannelOverrideTemplateMutation) SetChannelType(s string) {
	m.channel_type = &s
}

// ChannelType returns the value of the "channel_type" field in the mutation.
func (m *ChannelOverrideTemplateMutation) ChannelType() (r string, exists bool) {
	v := m.channel_type
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelType returns the old "channel_type" field's value of the ChannelOverrideTemplate entity.
// If the ChannelOverrideTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelOverrideTemplateMutation) OldChannelType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelType: %w", err)
	}
	return oldValue.ChannelType, nil
}

// ResetChannelType resets all changes to the "channel_type" field.
func (m *ChannelOverrideTemplateMutation) ResetChannelType() {
	m.channel_type = nil
}

// SetOverrideParameters sets the "override_parameters" field.
func (m *ChannelOverrideTemplateMutation) SetOverrideParameters(s string) {
	m.override_parameters = &s
}

// OverrideParameters returns the value of the "override_parameters" field in the mutation.
func (m *ChannelOverrideTemplateMutation) OverrideParameters() (r string, exists bool) {
	v := m.override_parameters
	if v == nil {
		return
	}
	return *v, true
}

// OldOverrideParameters returns the old "override_parameters" field's value of the ChannelOverrideTemplate entity.
// If the ChannelOverrideTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelOverrideTemplateMutation) OldOverrideParameters(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOverrideParameters is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOverrideParameters requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOverrideParameters: %w", err)
	}
	return oldValue.OverrideParameters, nil
}

// ResetOverrideParameters resets all changes to the "override_parameters" field.
func (m *ChannelOverrideTemplateMutation) ResetOverrideParameters() {
	m.override_parameters = nil
}

// SetOverrideHeaders sets the "override_headers" field.
func (m *ChannelOverrideTemplateMutation) SetOverrideHeaders(oe []objects.HeaderEntry) {
	m.override_headers = &oe
	m.appendoverride_headers = nil
}

// OverrideHeaders returns the value of the "override_headers" field in the mutation.
func (m *ChannelOverrideTemplateMutation) OverrideHeaders() (r []objects.HeaderEntry, exists bool) {
	v := m.override_headers
	if v == nil {
		return
	}
	return *v, true
}

// OldOverrideHeaders returns the old "override_headers" field's value of the ChannelOverrideTemplate entity.
// If the ChannelOverrideTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelOverrideTemplateMutation) OldOverrideHeaders(ctx context.Context) (v []objects.HeaderEntry, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOverrideHeaders is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOverrideHeaders requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOverrideHeaders: %w", err)
	}
	return oldValue.OverrideHeaders, nil
}

// AppendOverrideHeaders adds oe to the "override_headers" field.
func (m *ChannelOverrideTemplateMutation) AppendOverrideHeaders(oe []objects.HeaderEntry) {
	m.appendoverride_headers = append(m.appendoverride_headers, oe...)
}

// AppendedOverrideHeaders returns the list of values that were appended to the "override_headers" field in this mutation.
func (m *ChannelOverrideTemplateMutation) AppendedOverrideHeaders() ([]objects.HeaderEntry, bool) {
	if len(m.appendoverride_headers) == 0 {
		return nil, false
	}
	return m.appendoverride_headers, true
}

// ResetOverrideHeaders resets all changes to the "override_headers" field.
func (m *ChannelOverrideTemplateMutation) ResetOverrideHeaders() {
	m.override_headers = nil
	m.appendoverride_headers = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *ChannelOverrideTemplateMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[channeloverridetemplate.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ChannelOverrideTemplateMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ChannelOverrideTemplateMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ChannelOverrideTemplateMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the ChannelOverrideTemplateMutation builder.
func (m *ChannelOverrideTemplateMutation) Where(ps ...predicate.ChannelOverrideTemplate) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ChannelOverrideTemplateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ChannelOverrideTemplateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ChannelOverrideTemplate, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ChannelOverrideTemplateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ChannelOverrideTemplateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ChannelOverrideTemplate).
func (m *ChannelOverrideTemplateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChannelOverrideTemplateMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, channeloverridetemplate.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, channeloverridetemplate.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, channeloverridetemplate.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, channeloverridetemplate.FieldUserID)
	}
	if m.name != nil {
		fields = append(fields, channeloverridetemplate.FieldName)
	}
	if m.description != nil {
		fields = append(fields, channeloverridetemplate.FieldDescription)
	}
	if m.channel_type != nil {
		fields = append(fields, channeloverridetemplate.FieldChannelType)
	}
	if m.override_parameters != nil {
		fields = append(fields, channeloverridetemplate.FieldOverrideParameters)
	}
	if m.override_headers != nil {
		fields = append(fields, channeloverridetemplate.FieldOverrideHeaders)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChannelOverrideTemplateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case channeloverridetemplate.FieldCreatedAt:
		return m.CreatedAt()
	case channeloverridetemplate.FieldUpdatedAt:
		return m.UpdatedAt()
	case channeloverridetemplate.FieldDeletedAt:
		return m.DeletedAt()
	case channeloverridetemplate.FieldUserID:
		return m.UserID()
	case channeloverridetemplate.FieldName:
		return m.Name()
	case channeloverridetemplate.FieldDescription:
		return m.Description()
	case channeloverridetemplate.FieldChannelType:
		return m.ChannelType()
	case channeloverridetemplate.FieldOverrideParameters:
		return m.OverrideParameters()
	case channeloverridetemplate.FieldOverrideHeaders:
		return m.OverrideHeaders()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChannelOverrideTemplateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case channeloverridetemplate.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case channeloverridetemplate.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case channeloverridetemplate.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case channeloverridetemplate.FieldUserID:
		return m.OldUserID(ctx)
	case channeloverridetemplate.FieldName:
		return m.OldName(ctx)
	case channeloverridetemplate.FieldDescription:
		return m.OldDescription(ctx)
	case channeloverridetemplate.FieldChannelType:
		return m.OldChannelType(ctx)
	case channeloverridetemplate.FieldOverrideParameters:
		return m.OldOverrideParameters(ctx)
	case channeloverridetemplate.FieldOverrideHeaders:
		return m.OldOverrideHeaders(ctx)
	}
	return nil, fmt.Errorf("unknown ChannelOverrideTemplate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChannelOverrideTemplateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case channeloverridetemplate.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case channeloverridetemplate.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case channeloverridetemplate.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case channeloverridetemplate.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case channeloverridetemplate.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case channeloverridetemplate.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case channeloverridetemplate.FieldChannelType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelType(v)
		return nil
	case channeloverridetemplate.FieldOverrideParameters:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOverrideParameters(v)
		return nil
	case channeloverridetemplate.FieldOverrideHeaders:
		v, ok := value.([]objects.HeaderEntry)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOverrideHeaders(v)
		return nil
	}
	return fmt.Errorf("unknown ChannelOverrideTemplate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChannelOverrideTemplateMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, channeloverridetemplate.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChannelOverrideTemplateMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case channeloverridetemplate.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChannelOverrideTemplateMutation) AddField(name string, value ent.Value) error {
	switch name {
	case channeloverridetemplate.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ChannelOverrideTemplate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChannelOverrideTemplateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(channeloverridetemplate.FieldDescription) {
		fields = append(fields, channeloverridetemplate.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChannelOverrideTemplateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChannelOverrideTemplateMutation) ClearField(name string) error {
	switch name {
	case channeloverridetemplate.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown ChannelOverrideTemplate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChannelOverrideTemplateMutation) ResetField(name string) error {
	switch name {
	case channeloverridetemplate.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case channeloverridetemplate.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case channeloverridetemplate.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case channeloverridetemplate.FieldUserID:
		m.ResetUserID()
		return nil
	case channeloverridetemplate.FieldName:
		m.ResetName()
		return nil
	case channeloverridetemplate.FieldDescription:
		m.ResetDescription()
		return nil
	case channeloverridetemplate.FieldChannelType:
		m.ResetChannelType()
		return nil
	case channeloverridetemplate.FieldOverrideParameters:
		m.ResetOverrideParameters()
		return nil
	case channeloverridetemplate.FieldOverrideHeaders:
		m.ResetOverrideHeaders()
		return nil
	}
	return fmt.Errorf("unknown ChannelOverrideTemplate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChannelOverrideTemplateMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, channeloverridetemplate.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChannelOverrideTemplateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case channeloverridetemplate.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChannelOverrideTemplateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChannelOverrideTemplateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChannelOverrideTemplateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, channeloverridetemplate.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChannelOverrideTemplateMutation) EdgeCleared(name string) bool {
	switch name {
	case channeloverridetemplate.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChannelOverrideTemplateMutation) ClearEdge(name string) error {
	switch name {
	case channeloverridetemplate.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown ChannelOverrideTemplate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChannelOverrideTemplateMutation) ResetEdge(name string) error {
	switch name {
	case channeloverridetemplate.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown ChannelOverrideTemplate edge %s", name)
}

// ChannelPerformanceMutation represents an operation that mutates the ChannelPerformance nodes in the graph.
type ChannelPerformanceMutation struct {
	config
	op                                     Op
	typ                                    string
	id                                     *int
	created_at                             *time.Time
	updated_at                             *time.Time
	deleted_at                             *int
	adddeleted_at                          *int
	success_rate                           *int
	addsuccess_rate                        *int
	avg_latency_ms                         *int
	addavg_latency_ms                      *int
	avg_token_per_second                   *int
	addavg_token_per_second                *int
	avg_stream_first_token_latency_ms      *int
	addavg_stream_first_token_latency_ms   *int
	avg_stream_token_per_second            *float64
	addavg_stream_token_per_second         *float64
	last_success_at                        *time.Time
	last_failure_at                        *time.Time
	request_count                          *int64
	addrequest_count                       *int64
	success_count                          *int64
	addsuccess_count                       *int64
	failure_count                          *int64
	addfailure_count                       *int64
	total_token_count                      *int64
	addtotal_token_count                   *int64
	total_request_latency_ms               *int64
	addtotal_request_latency_ms            *int64
	stream_success_count                   *int64
	addstream_success_count                *int64
	stream_total_request_count             *int64
	addstream_total_request_count          *int64
	stream_total_token_count               *int64
	addstream_total_token_count            *int64
	stream_total_request_latency_ms        *int64
	addstream_total_request_latency_ms     *int64
	stream_total_first_token_latency_ms    *int64
	addstream_total_first_token_latency_ms *int64
	consecutive_failures                   *int64
	addconsecutive_failures                *int64
	clearedFields                          map[string]struct{}
	channel                                *int
	clearedchannel                         bool
	done                                   bool
	oldValue                               func(context.Context) (*ChannelPerformance, error)
	predicates                             []predicate.ChannelPerformance
}

var _ ent.Mutation = (*ChannelPerformanceMutation)(nil)

// channelperformanceOption allows management of the mutation configuration using functional options.
type channelperformanceOption func(*ChannelPerformanceMutation)

// newChannelPerformanceMutation creates new mutation for the ChannelPerformance entity.
func newChannelPerformanceMutation(c config, op Op, opts ...channelperformanceOption) *ChannelPerformanceMutation {
	m := &ChannelPerformanceMutation{
		config:        c,
		op:            op,
		typ:           TypeChannelPerformance,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChannelPerformanceID sets the ID field of the mutation.
func withChannelPerformanceID(id int) channelperformanceOption {
	return func(m *ChannelPerformanceMutation) {
		var (
			err   error
			once  sync.Once
			value *ChannelPerformance
		)
		m.oldValue = func(ctx context.Context) (*ChannelPerformance, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ChannelPerformance.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChannelPerformance sets the old ChannelPerformance of the mutation.
func withChannelPerformance(node *ChannelPerformance) channelperformanceOption {
	return func(m *ChannelPerformanceMutation) {
		m.oldValue = func(context.Context) (*ChannelPerformance, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChannelPerformanceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChannelPerformanceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChannelPerformanceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChannelPerformanceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ChannelPerformance.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ChannelPerformanceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ChannelPerformanceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ChannelPerformance entity.
// If the ChannelPerformance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelPerformanceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ChannelPerformanceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ChannelPerformanceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ChannelPerformanceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ChannelPerformance entity.
// If the ChannelPerformance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelPerformanceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ChannelPerformanceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ChannelPerformanceMutation) SetDeletedAt(i int) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ChannelPerformanceMutation) DeletedAt() (r int, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ChannelPerformance entity.
// If the ChannelPerformance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelPerformanceMutation) OldDeletedAt(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *ChannelPerformanceMutation) AddDeletedAt(i int) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *ChannelPerformanceMutation) AddedDeletedAt() (r int, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ChannelPerformanceMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetChannelID sets the "channel_id" field.
func (m *ChannelPerformanceMutation) SetChannelID(i int) {
	m.channel = &i
}

// ChannelID returns the value of the "channel_id" field in the mutation.
func (m *ChannelPerformanceMutation) ChannelID() (r int, exists bool) {
	v := m.channel
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelID returns the old "channel_id" field's value of the ChannelPerformance entity.
// If the ChannelPerformance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelPerformanceMutation) OldChannelID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelID: %w", err)
	}
	return oldValue.ChannelID, nil
}

// ResetChannelID resets all changes to the "channel_id" field.
func (m *ChannelPerformanceMutation) ResetChannelID() {
	m.channel = nil
}

// SetSuccessRate sets the "success_rate" field.
func (m *ChannelPerformanceMutation) SetSuccessRate(i int) {
	m.success_rate = &i
	m.addsuccess_rate = nil
}

// SuccessRate returns the value of the "success_rate" field in the mutation.
func (m *ChannelPerformanceMutation) SuccessRate() (r int, exists bool) {
	v := m.success_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldSuccessRate returns the old "success_rate" field's value of the ChannelPerformance entity.
// If the ChannelPerformance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelPerformanceMutation) OldSuccessRate(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuccessRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuccessRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuccessRate: %w", err)
	}
	return oldValue.SuccessRate, nil
}

// AddSuccessRate adds i to the "success_rate" field.
func (m *ChannelPerformanceMutation) AddSuccessRate(i int) {
	if m.addsuccess_rate != nil {
		*m.addsuccess_rate += i
	} else {
		m.addsuccess_rate = &i
	}
}

// AddedSuccessRate returns the value that was added to the "success_rate" field in this mutation.
func (m *ChannelPerformanceMutation) AddedSuccessRate() (r int, exists bool) {
	v := m.addsuccess_rate
	if v == nil {
		return
	}
	return *v, true
}

// ResetSuccessRate resets all changes to the "success_rate" field.
func (m *ChannelPerformanceMutation) ResetSuccessRate() {
	m.success_rate = nil
	m.addsuccess_rate = nil
}

// SetAvgLatencyMs sets the "avg_latency_ms" field.
func (m *ChannelPerformanceMutation) SetAvgLatencyMs(i int) {
	m.avg_latency_ms = &i
	m.addavg_latency_ms = nil
}

// AvgLatencyMs returns the value of the "avg_latency_ms" field in the mutation.
func (m *ChannelPerformanceMutation) AvgLatencyMs() (r int, exists bool) {
	v := m.avg_latency_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldAvgLatencyMs returns the old "avg_latency_ms" field's value of the ChannelPerformance entity.
// If the ChannelPerformance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelPerformanceMutation) OldAvgLatencyMs(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvgLatencyMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvgLatencyMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvgLatencyMs: %w", err)
	}
	return oldValue.AvgLatencyMs, nil
}

// AddAvgLatencyMs adds i to the "avg_latency_ms" field.
func (m *ChannelPerformanceMutation) AddAvgLatencyMs(i int) {
	if m.addavg_latency_ms != nil {
		*m.addavg_latency_ms += i
	} else {
		m.addavg_latency_ms = &i
	}
}

// AddedAvgLatencyMs returns the value that was added to the "avg_latency_ms" field in this mutation.
func (m *ChannelPerformanceMutation) AddedAvgLatencyMs() (r int, exists bool) {
	v := m.addavg_latency_ms
	if v == nil {
		return
	}
	return *v, true
}

// ResetAvgLatencyMs resets all changes to the "avg_latency_ms" field.
func (m *ChannelPerformanceMutation) ResetAvgLatencyMs() {
	m.avg_latency_ms = nil
	m.addavg_latency_ms = nil
}

// SetAvgTokenPerSecond sets the "avg_token_per_second" field.
func (m *ChannelPerformanceMutation) SetAvgTokenPerSecond(i int) {
	m.avg_token_per_second = &i
	m.addavg_token_per_second = nil
}

// AvgTokenPerSecond returns the value of the "avg_token_per_second" field in the mutation.
func (m *ChannelPerformanceMutation) AvgTokenPerSecond() (r int, exists bool) {
	v := m.avg_token_per_second
	if v == nil {
		return
	}
	return *v, true
}

// OldAvgTokenPerSecond returns the old "avg_token_per_second" field's value of the ChannelPerformance entity.
// If the ChannelPerformance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelPerformanceMutation) OldAvgTokenPerSecond(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvgTokenPerSecond is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvgTokenPerSecond requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvgTokenPerSecond: %w", err)
	}
	return oldValue.AvgTokenPerSecond, nil
}

// AddAvgTokenPerSecond adds i to the "avg_token_per_second" field.
func (m *ChannelPerformanceMutation) AddAvgTokenPerSecond(i int) {
	if m.addavg_token_per_second != nil {
		*m.addavg_token_per_second += i
	} else {
		m.addavg_token_per_second = &i
	}
}

// AddedAvgTokenPerSecond returns the value that was added to the "avg_token_per_second" field in this mutation.
func (m *ChannelPerformanceMutation) AddedAvgTokenPerSecond() (r int, exists bool) {
	v := m.addavg_token_per_second
	if v == nil {
		return
	}
	return *v, true
}

// ResetAvgTokenPerSecond resets all changes to the "avg_token_per_second" field.
func (m *ChannelPerformanceMutation) ResetAvgTokenPerSecond() {
	m.avg_token_per_second = nil
	m.addavg_token_per_second = nil
}

// SetAvgStreamFirstTokenLatencyMs sets the "avg_stream_first_token_latency_ms" field.
func (m *ChannelPerformanceMutation) SetAvgStreamFirstTokenLatencyMs(i int) {
	m.avg_stream_first_token_latency_ms = &i
	m.addavg_stream_first_token_latency_ms = nil
}

// AvgStreamFirstTokenLatencyMs returns the value of the "avg_stream_first_token_latency_ms" field in the mutation.
func (m *ChannelPerformanceMutation) AvgStreamFirstTokenLatencyMs() (r int, exists bool) {
	v := m.avg_stream_first_token_latency_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldAvgStreamFirstTokenLatencyMs returns the old "avg_stream_first_token_latency_ms" field's value of the ChannelPerformance entity.
// If the ChannelPerformance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelPerformanceMutation) OldAvgStreamFirstTokenLatencyMs(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvgStreamFirstTokenLatencyMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvgStreamFirstTokenLatencyMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvgStreamFirstTokenLatencyMs: %w", err)
	}
	return oldValue.AvgStreamFirstTokenLatencyMs, nil
}

// AddAvgStreamFirstTokenLatencyMs adds i to the "avg_stream_first_token_latency_ms" field.
func (m *ChannelPerformanceMutation) AddAvgStreamFirstTokenLatencyMs(i int) {
	if m.addavg_stream_first_token_latency_ms != nil {
		*m.addavg_stream_first_token_latency_ms += i
	} else {
		m.addavg_stream_first_token_latency_ms = &i
	}
}

// AddedAvgStreamFirstTokenLatencyMs returns the value that was added to the "avg_stream_first_token_latency_ms" field in this mutation.
func (m *ChannelPerformanceMutation) AddedAvgStreamFirstTokenLatencyMs() (r int, exists bool) {
	v := m.addavg_stream_first_token_latency_ms
	if v == nil {
		return
	}
	return *v, true
}

// ResetAvgStreamFirstTokenLatencyMs resets all changes to the "avg_stream_first_token_latency_ms" field.
func (m *ChannelPerformanceMutation) ResetAvgStreamFirstTokenLatencyMs() {
	m.avg_stream_first_token_latency_ms = nil
	m.addavg_stream_first_token_latency_ms = nil
}

// SetAvgStreamTokenPerSecond sets the "avg_stream_token_per_second" field.
func (m *ChannelPerformanceMutation) SetAvgStreamTokenPerSecond(f float64) {
	m.avg_stream_token_per_second = &f
	m.addavg_stream_token_per_second = nil
}

// AvgStreamTokenPerSecond returns the value of the "avg_stream_token_per_second" field in the mutation.
func (m *ChannelPerformanceMutation) AvgStreamTokenPerSecond() (r float64, exists bool) {
	v := m.avg_stream_token_per_second
	if v == nil {
		return
	}
	return *v, true
}

// OldAvgStreamTokenPerSecond returns the old "avg_stream_token_per_second" field's value of the ChannelPerformance entity.
// If the ChannelPerformance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelPerformanceMutation) OldAvgStreamTokenPerSecond(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvgStreamTokenPerSecond is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvgStreamTokenPerSecond requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvgStreamTokenPerSecond: %w", err)
	}
	return oldValue.AvgStreamTokenPerSecond, nil
}

// AddAvgStreamTokenPerSecond adds f to the "avg_stream_token_per_second" field.
func (m *ChannelPerformanceMutation) AddAvgStreamTokenPerSecond(f float64) {
	if m.addavg_stream_token_per_second != nil {
		*m.addavg_stream_token_per_second += f
	} else {
		m.addavg_stream_token_per_second = &f
	}
}

// AddedAvgStreamTokenPerSecond returns the value that was added to the "avg_stream_token_per_second" field in this mutation.
func (m *ChannelPerformanceMutation) AddedAvgStreamTokenPerSecond() (r float64, exists bool) {
	v := m.addavg_stream_token_per_second
	if v == nil {
		return
	}
	return *v, true
}

// ResetAvgStreamTokenPerSecond resets all changes to the "avg_stream_token_per_second" field.
func (m *ChannelPerformanceMutation) ResetAvgStreamTokenPerSecond() {
	m.avg_stream_token_per_second = nil
	m.addavg_stream_token_per_second = nil
}

// SetLastSuccessAt sets the "last_success_at" field.
func (m *ChannelPerformanceMutation) SetLastSuccessAt(t time.Time) {
	m.last_success_at = &t
}

// LastSuccessAt returns the value of the "last_success_at" field in the mutation.
func (m *ChannelPerformanceMutation) LastSuccessAt() (r time.Time, exists bool) {
	v := m.last_success_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSuccessAt returns the old "last_success_at" field's value of the ChannelPerformance entity.
// If the ChannelPerformance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelPerformanceMutation) OldLastSuccessAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSuccessAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSuccessAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSuccessAt: %w", err)
	}
	return oldValue.LastSuccessAt, nil
}

// ClearLastSuccessAt clears the value of the "last_success_at" field.
func (m *ChannelPerformanceMutation) ClearLastSuccessAt() {
	m.last_success_at = nil
	m.clearedFields[channelperformance.FieldLastSuccessAt] = struct{}{}
}

// LastSuccessAtCleared returns if the "last_success_at" field was cleared in this mutation.
func (m *ChannelPerformanceMutation) LastSuccessAtCleared() bool {
	_, ok := m.clearedFields[channelperformance.FieldLastSuccessAt]
	return ok
}

// ResetLastSuccessAt resets all changes to the "last_success_at" field.
func (m *ChannelPerformanceMutation) ResetLastSuccessAt() {
	m.last_success_at = nil
	delete(m.clearedFields, channelperformance.FieldLastSuccessAt)
}

// SetLastFailureAt sets the "last_failure_at" field.
func (m *ChannelPerformanceMutation) SetLastFailureAt(t time.Time) {
	m.last_failure_at = &t
}

// LastFailureAt returns the value of the "last_failure_at" field in the mutation.
func (m *ChannelPerformanceMutation) LastFailureAt() (r time.Time, exists bool) {
	v := m.last_failure_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastFailureAt returns the old "last_failure_at" field's value of the ChannelPerformance entity.
// If the ChannelPerformance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelPerformanceMutation) OldLastFailureAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastFailureAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastFailureAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastFailureAt: %w", err)
	}
	return oldValue.LastFailureAt, nil
}

// ClearLastFailureAt clears the value of the "last_failure_at" field.
func (m *ChannelPerformanceMutation) ClearLastFailureAt() {
	m.last_failure_at = nil
	m.clearedFields[channelperformance.FieldLastFailureAt] = struct{}{}
}

// LastFailureAtCleared returns if the "last_failure_at" field was cleared in this mutation.
func (m *ChannelPerformanceMutation) LastFailureAtCleared() bool {
	_, ok := m.clearedFields[channelperformance.FieldLastFailureAt]
	return ok
}

// ResetLastFailureAt resets all changes to the "last_failure_at" field.
func (m *ChannelPerformanceMutation) ResetLastFailureAt() {
	m.last_failure_at = nil
	delete(m.clearedFields, channelperformance.FieldLastFailureAt)
}

// SetRequestCount sets the "request_count" field.
func (m *ChannelPerformanceMutation) SetRequestCount(i int64) {
	m.request_count = &i
	m.addrequest_count = nil
}

// RequestCount returns the value of the "request_count" field in the mutation.
func (m *ChannelPerformanceMutation) RequestCount() (r int64, exists bool) {
	v := m.request_count
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestCount returns the old "request_count" field's value of the ChannelPerformance entity.
// If the ChannelPerformance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelPerformanceMutation) OldRequestCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestCount: %w", err)
	}
	return oldValue.RequestCount, nil
}

// AddRequestCount adds i to the "request_count" field.
func (m *ChannelPerformanceMutation) AddRequestCount(i int64) {
	if m.addrequest_count != nil {
		*m.addrequest_count += i
	} else {
		m.addrequest_count = &i
	}
}

// AddedRequestCount returns the value that was added to the "request_count" field in this mutation.
func (m *ChannelPerformanceMutation) AddedRequestCount() (r int64, exists bool) {
	v := m.addrequest_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetRequestCount resets all changes to the "request_count" field.
func (m *ChannelPerformanceMutation) ResetRequestCount() {
	m.request_count = nil
	m.addrequest_count = nil
}

// SetSuccessCount sets the "success_count" field.
func (m *ChannelPerformanceMutation) SetSuccessCount(i int64) {
	m.success_count = &i
	m.addsuccess_count = nil
}

// SuccessCount returns the value of the "success_count" field in the mutation.
func (m *ChannelPerformanceMutation) SuccessCount() (r int64, exists bool) {
	v := m.success_count
	if v == nil {
		return
	}
	return *v, true
}

// OldSuccessCount returns the old "success_count" field's value of the ChannelPerformance entity.
// If the ChannelPerformance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelPerformanceMutation) OldSuccessCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuccessCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuccessCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuccessCount: %w", err)
	}
	return oldValue.SuccessCount, nil
}

// AddSuccessCount adds i to the "success_count" field.
func (m *ChannelPerformanceMutation) AddSuccessCount(i int64) {
	if m.addsuccess_count != nil {
		*m.addsuccess_count += i
	} else {
		m.addsuccess_count = &i
	}
}

// AddedSuccessCount returns the value that was added to the "success_count" field in this mutation.
func (m *ChannelPerformanceMutation) AddedSuccessCount() (r int64, exists bool) {
	v := m.addsuccess_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetSuccessCount resets all changes to the "success_count" field.
func (m *ChannelPerformanceMutation) ResetSuccessCount() {
	m.success_count = nil
	m.addsuccess_count = nil
}

// SetFailureCount sets the "failure_count" field.
func (m *ChannelPerformanceMutation) SetFailureCount(i int64) {
	m.failure_count = &i
	m.addfailure_count = nil
}

// FailureCount returns the value of the "failure_count" field in the mutation.
func (m *ChannelPerformanceMutation) FailureCount() (r int64, exists bool) {
	v := m.failure_count
	if v == nil {
		return
	}
	return *v, true
}

// OldFailureCount returns the old "failure_count" field's value of the ChannelPerformance entity.
// If the ChannelPerformance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelPerformanceMutation) OldFailureCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFailureCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFailureCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFailureCount: %w", err)
	}
	return oldValue.FailureCount, nil
}

// AddFailureCount adds i to the "failure_count" field.
func (m *ChannelPerformanceMutation) AddFailureCount(i int64) {
	if m.addfailure_count != nil {
		*m.addfailure_count += i
	} else {
		m.addfailure_count = &i
	}
}

// AddedFailureCount returns the value that was added to the "failure_count" field in this mutation.
func (m *ChannelPerformanceMutation) AddedFailureCount() (r int64, exists bool) {
	v := m.addfailure_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetFailureCount resets all changes to the "failure_count" field.
func (m *ChannelPerformanceMutation) ResetFailureCount() {
	m.failure_count = nil
	m.addfailure_count = nil
}

// SetTotalTokenCount sets the "total_token_count" field.
func (m *ChannelPerformanceMutation) SetTotalTokenCount(i int64) {
	m.total_token_count = &i
	m.addtotal_token_count = nil
}

// TotalTokenCount returns the value of the "total_token_count" field in the mutation.
func (m *ChannelPerformanceMutation) TotalTokenCount() (r int64, exists bool) {
	v := m.total_token_count
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalTokenCount returns the old "total_token_count" field's value of the ChannelPerformance entity.
// If the ChannelPerformance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelPerformanceMutation) OldTotalTokenCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalTokenCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalTokenCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalTokenCount: %w", err)
	}
	return oldValue.TotalTokenCount, nil
}

// AddTotalTokenCount adds i to the "total_token_count" field.
func (m *ChannelPerformanceMutation) AddTotalTokenCount(i int64) {
	if m.addtotal_token_count != nil {
		*m.addtotal_token_count += i
	} else {
		m.addtotal_token_count = &i
	}
}

// AddedTotalTokenCount returns the value that was added to the "total_token_count" field in this mutation.
func (m *ChannelPerformanceMutation) AddedTotalTokenCount() (r int64, exists bool) {
	v := m.addtotal_token_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalTokenCount resets all changes to the "total_token_count" field.
func (m *ChannelPerformanceMutation) ResetTotalTokenCount() {
	m.total_token_count = nil
	m.addtotal_token_count = nil
}

// SetTotalRequestLatencyMs sets the "total_request_latency_ms" field.
func (m *ChannelPerformanceMutation) SetTotalRequestLatencyMs(i int64) {
	m.total_request_latency_ms = &i
	m.addtotal_request_latency_ms = nil
}

// TotalRequestLatencyMs returns the value of the "total_request_latency_ms" field in the mutation.
func (m *ChannelPerformanceMutation) TotalRequestLatencyMs() (r int64, exists bool) {
	v := m.total_request_latency_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalRequestLatencyMs returns the old "total_request_latency_ms" field's value of the ChannelPerformance entity.
// If the ChannelPerformance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelPerformanceMutation) OldTotalRequestLatencyMs(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalRequestLatencyMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalRequestLatencyMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalRequestLatencyMs: %w", err)
	}
	return oldValue.TotalRequestLatencyMs, nil
}

// AddTotalRequestLatencyMs adds i to the "total_request_latency_ms" field.
func (m *ChannelPerformanceMutation) AddTotalRequestLatencyMs(i int64) {
	if m.addtotal_request_latency_ms != nil {
		*m.addtotal_request_latency_ms += i
	} else {
		m.addtotal_request_latency_ms = &i
	}
}

// AddedTotalRequestLatencyMs returns the value that was added to the "total_request_latency_ms" field in this mutation.
func (m *ChannelPerformanceMutation) AddedTotalRequestLatencyMs() (r int64, exists bool) {
	v := m.addtotal_request_latency_ms
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalRequestLatencyMs resets all changes to the "total_request_latency_ms" field.
func (m *ChannelPerformanceMutation) ResetTotalRequestLatencyMs() {
	m.total_request_latency_ms = nil
	m.addtotal_request_latency_ms = nil
}

// SetStreamSuccessCount sets the "stream_success_count" field.
func (m *ChannelPerformanceMutation) SetStreamSuccessCount(i int64) {
	m.stream_success_count = &i
	m.addstream_success_count = nil
}

// StreamSuccessCount returns the value of the "stream_success_count" field in the mutation.
func (m *ChannelPerformanceMutation) StreamSuccessCount() (r int64, exists bool) {
	v := m.stream_success_count
	if v == nil {
		return
	}
	return *v, true
}

// OldStreamSuccessCount returns the old "stream_success_count" field's value of the ChannelPerformance entity.
// If the ChannelPerformance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelPerformanceMutation) OldStreamSuccessCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStreamSuccessCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStreamSuccessCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStreamSuccessCount: %w", err)
	}
	return oldValue.StreamSuccessCount, nil
}

// AddStreamSuccessCount adds i to the "stream_success_count" field.
func (m *ChannelPerformanceMutation) AddStreamSuccessCount(i int64) {
	if m.addstream_success_count != nil {
		*m.addstream_success_count += i
	} else {
		m.addstream_success_count = &i
	}
}

// AddedStreamSuccessCount returns the value that was added to the "stream_success_count" field in this mutation.
func (m *ChannelPerformanceMutation) AddedStreamSuccessCount() (r int64, exists bool) {
	v := m.addstream_success_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetStreamSuccessCount resets all changes to the "stream_success_count" field.
func (m *ChannelPerformanceMutation) ResetStreamSuccessCount() {
	m.stream_success_count = nil
	m.addstream_success_count = nil
}

// SetStreamTotalRequestCount sets the "stream_total_request_count" field.
func (m *ChannelPerformanceMutation) SetStreamTotalRequestCount(i int64) {
	m.stream_total_request_count = &i
	m.addstream_total_request_count = nil
}

// StreamTotalRequestCount returns the value of the "stream_total_request_count" field in the mutation.
func (m *ChannelPerformanceMutation) StreamTotalRequestCount() (r int64, exists bool) {
	v := m.stream_total_request_count
	if v == nil {
		return
	}
	return *v, true
}

// OldStreamTotalRequestCount returns the old "stream_total_request_count" field's value of the ChannelPerformance entity.
// If the ChannelPerformance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelPerformanceMutation) OldStreamTotalRequestCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStreamTotalRequestCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStreamTotalRequestCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStreamTotalRequestCount: %w", err)
	}
	return oldValue.StreamTotalRequestCount, nil
}

// AddStreamTotalRequestCount adds i to the "stream_total_request_count" field.
func (m *ChannelPerformanceMutation) AddStreamTotalRequestCount(i int64) {
	if m.addstream_total_request_count != nil {
		*m.addstream_total_request_count += i
	} else {
		m.addstream_total_request_count = &i
	}
}

// AddedStreamTotalRequestCount returns the value that was added to the "stream_total_request_count" field in this mutation.
func (m *ChannelPerformanceMutation) AddedStreamTotalRequestCount() (r int64, exists bool) {
	v := m.addstream_total_request_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetStreamTotalRequestCount resets all changes to the "stream_total_request_count" field.
func (m *ChannelPerformanceMutation) ResetStreamTotalRequestCount() {
	m.stream_total_request_count = nil
	m.addstream_total_request_count = nil
}

// SetStreamTotalTokenCount sets the "stream_total_token_count" field.
func (m *ChannelPerformanceMutation) SetStreamTotalTokenCount(i int64) {
	m.stream_total_token_count = &i
	m.addstream_total_token_count = nil
}

// StreamTotalTokenCount returns the value of the "stream_total_token_count" field in the mutation.
func (m *ChannelPerformanceMutation) StreamTotalTokenCount() (r int64, exists bool) {
	v := m.stream_total_token_count
	if v == nil {
		return
	}
	return *v, true
}

// OldStreamTotalTokenCount returns the old "stream_total_token_count" field's value of the ChannelPerformance entity.
// If the ChannelPerformance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelPerformanceMutation) OldStreamTotalTokenCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStreamTotalTokenCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStreamTotalTokenCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStreamTotalTokenCount: %w", err)
	}
	return oldValue.StreamTotalTokenCount, nil
}

// AddStreamTotalTokenCount adds i to the "stream_total_token_count" field.
func (m *ChannelPerformanceMutation) AddStreamTotalTokenCount(i int64) {
	if m.addstream_total_token_count != nil {
		*m.addstream_total_token_count += i
	} else {
		m.addstream_total_token_count = &i
	}
}

// AddedStreamTotalTokenCount returns the value that was added to the "stream_total_token_count" field in this mutation.
func (m *ChannelPerformanceMutation) AddedStreamTotalTokenCount() (r int64, exists bool) {
	v := m.addstream_total_token_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetStreamTotalTokenCount resets all changes to the "stream_total_token_count" field.
func (m *ChannelPerformanceMutation) ResetStreamTotalTokenCount() {
	m.stream_total_token_count = nil
	m.addstream_total_token_count = nil
}

// SetStreamTotalRequestLatencyMs sets the "stream_total_request_latency_ms" field.
func (m *ChannelPerformanceMutation) SetStreamTotalRequestLatencyMs(i int64) {
	m.stream_total_request_latency_ms = &i
	m.addstream_total_request_latency_ms = nil
}

// StreamTotalRequestLatencyMs returns the value of the "stream_total_request_latency_ms" field in the mutation.
func (m *ChannelPerformanceMutation) StreamTotalRequestLatencyMs() (r int64, exists bool) {
	v := m.stream_total_request_latency_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldStreamTotalRequestLatencyMs returns the old "stream_total_request_latency_ms" field's value of the ChannelPerformance entity.
// If the ChannelPerformance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelPerformanceMutation) OldStreamTotalRequestLatencyMs(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStreamTotalRequestLatencyMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStreamTotalRequestLatencyMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStreamTotalRequestLatencyMs: %w", err)
	}
	return oldValue.StreamTotalRequestLatencyMs, nil
}

// AddStreamTotalRequestLatencyMs adds i to the "stream_total_request_latency_ms" field.
func (m *ChannelPerformanceMutation) AddStreamTotalRequestLatencyMs(i int64) {
	if m.addstream_total_request_latency_ms != nil {
		*m.addstream_total_request_latency_ms += i
	} else {
		m.addstream_total_request_latency_ms = &i
	}
}

// AddedStreamTotalRequestLatencyMs returns the value that was added to the "stream_total_request_latency_ms" field in this mutation.
func (m *ChannelPerformanceMutation) AddedStreamTotalRequestLatencyMs() (r int64, exists bool) {
	v := m.addstream_total_request_latency_ms
	if v == nil {
		return
	}
	return *v, true
}

// ResetStreamTotalRequestLatencyMs resets all changes to the "stream_total_request_latency_ms" field.
func (m *ChannelPerformanceMutation) ResetStreamTotalRequestLatencyMs() {
	m.stream_total_request_latency_ms = nil
	m.addstream_total_request_latency_ms = nil
}

// SetStreamTotalFirstTokenLatencyMs sets the "stream_total_first_token_latency_ms" field.
func (m *ChannelPerformanceMutation) SetStreamTotalFirstTokenLatencyMs(i int64) {
	m.stream_total_first_token_latency_ms = &i
	m.addstream_total_first_token_latency_ms = nil
}

// StreamTotalFirstTokenLatencyMs returns the value of the "stream_total_first_token_latency_ms" field in the mutation.
func (m *ChannelPerformanceMutation) StreamTotalFirstTokenLatencyMs() (r int64, exists bool) {
	v := m.stream_total_first_token_latency_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldStreamTotalFirstTokenLatencyMs returns the old "stream_total_first_token_latency_ms" field's value of the ChannelPerformance entity.
// If the ChannelPerformance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelPerformanceMutation) OldStreamTotalFirstTokenLatencyMs(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStreamTotalFirstTokenLatencyMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStreamTotalFirstTokenLatencyMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStreamTotalFirstTokenLatencyMs: %w", err)
	}
	return oldValue.StreamTotalFirstTokenLatencyMs, nil
}

// AddStreamTotalFirstTokenLatencyMs adds i to the "stream_total_first_token_latency_ms" field.
func (m *ChannelPerformanceMutation) AddStreamTotalFirstTokenLatencyMs(i int64) {
	if m.addstream_total_first_token_latency_ms != nil {
		*m.addstream_total_first_token_latency_ms += i
	} else {
		m.addstream_total_first_token_latency_ms = &i
	}
}

// AddedStreamTotalFirstTokenLatencyMs returns the value that was added to the "stream_total_first_token_latency_ms" field in this mutation.
func (m *ChannelPerformanceMutation) AddedStreamTotalFirstTokenLatencyMs() (r int64, exists bool) {
	v := m.addstream_total_first_token_latency_ms
	if v == nil {
		return
	}
	return *v, true
}

// ResetStreamTotalFirstTokenLatencyMs resets all changes to the "stream_total_first_token_latency_ms" field.
func (m *ChannelPerformanceMutation) ResetStreamTotalFirstTokenLatencyMs() {
	m.stream_total_first_token_latency_ms = nil
	m.addstream_total_first_token_latency_ms = nil
}

// SetConsecutiveFailures sets the "consecutive_failures" field.
func (m *ChannelPerformanceMutation) SetConsecutiveFailures(i int64) {
	m.consecutive_failures = &i
	m.addconsecutive_failures = nil
}

// ConsecutiveFailures returns the value of the "consecutive_failures" field in the mutation.
func (m *ChannelPerformanceMutation) ConsecutiveFailures() (r int64, exists bool) {
	v := m.consecutive_failures
	if v == nil {
		return
	}
	return *v, true
}

// OldConsecutiveFailures returns the old "consecutive_failures" field's value of the ChannelPerformance entity.
// If the ChannelPerformance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelPerformanceMutation) OldConsecutiveFailures(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConsecutiveFailures is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConsecutiveFailures requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConsecutiveFailures: %w", err)
	}
	return oldValue.ConsecutiveFailures, nil
}

// AddConsecutiveFailures adds i to the "consecutive_failures" field.
func (m *ChannelPerformanceMutation) AddConsecutiveFailures(i int64) {
	if m.addconsecutive_failures != nil {
		*m.addconsecutive_failures += i
	} else {
		m.addconsecutive_failures = &i
	}
}

// AddedConsecutiveFailures returns the value that was added to the "consecutive_failures" field in this mutation.
func (m *ChannelPerformanceMutation) AddedConsecutiveFailures() (r int64, exists bool) {
	v := m.addconsecutive_failures
	if v == nil {
		return
	}
	return *v, true
}

// ResetConsecutiveFailures resets all changes to the "consecutive_failures" field.
func (m *ChannelPerformanceMutation) ResetConsecutiveFailures() {
	m.consecutive_failures = nil
	m.addconsecutive_failures = nil
}

// ClearChannel clears the "channel" edge to the Channel entity.
func (m *ChannelPerformanceMutation) ClearChannel() {
	m.clearedchannel = true
	m.clearedFields[channelperformance.FieldChannelID] = struct{}{}
}

// ChannelCleared reports if the "channel" edge to the Channel entity was cleared.
func (m *ChannelPerformanceMutation) ChannelCleared() bool {
	return m.clearedchannel
}

// ChannelIDs returns the "channel" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChannelID instead. It exists only for internal usage by the builders.
func (m *ChannelPerformanceMutation) ChannelIDs() (ids []int) {
	if id := m.channel; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChannel resets all changes to the "channel" edge.
func (m *ChannelPerformanceMutation) ResetChannel() {
	m.channel = nil
	m.clearedchannel = false
}

// Where appends a list predicates to the ChannelPerformanceMutation builder.
func (m *ChannelPerformanceMutation) Where(ps ...predicate.ChannelPerformance) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ChannelPerformanceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ChannelPerformanceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ChannelPerformance, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ChannelPerformanceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ChannelPerformanceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ChannelPerformance).
func (m *ChannelPerformanceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChannelPerformanceMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m.created_at != nil {
		fields = append(fields, channelperformance.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, channelperformance.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, channelperformance.FieldDeletedAt)
	}
	if m.channel != nil {
		fields = append(fields, channelperformance.FieldChannelID)
	}
	if m.success_rate != nil {
		fields = append(fields, channelperformance.FieldSuccessRate)
	}
	if m.avg_latency_ms != nil {
		fields = append(fields, channelperformance.FieldAvgLatencyMs)
	}
	if m.avg_token_per_second != nil {
		fields = append(fields, channelperformance.FieldAvgTokenPerSecond)
	}
	if m.avg_stream_first_token_latency_ms != nil {
		fields = append(fields, channelperformance.FieldAvgStreamFirstTokenLatencyMs)
	}
	if m.avg_stream_token_per_second != nil {
		fields = append(fields, channelperformance.FieldAvgStreamTokenPerSecond)
	}
	if m.last_success_at != nil {
		fields = append(fields, channelperformance.FieldLastSuccessAt)
	}
	if m.last_failure_at != nil {
		fields = append(fields, channelperformance.FieldLastFailureAt)
	}
	if m.request_count != nil {
		fields = append(fields, channelperformance.FieldRequestCount)
	}
	if m.success_count != nil {
		fields = append(fields, channelperformance.FieldSuccessCount)
	}
	if m.failure_count != nil {
		fields = append(fields, channelperformance.FieldFailureCount)
	}
	if m.total_token_count != nil {
		fields = append(fields, channelperformance.FieldTotalTokenCount)
	}
	if m.total_request_latency_ms != nil {
		fields = append(fields, channelperformance.FieldTotalRequestLatencyMs)
	}
	if m.stream_success_count != nil {
		fields = append(fields, channelperformance.FieldStreamSuccessCount)
	}
	if m.stream_total_request_count != nil {
		fields = append(fields, channelperformance.FieldStreamTotalRequestCount)
	}
	if m.stream_total_token_count != nil {
		fields = append(fields, channelperformance.FieldStreamTotalTokenCount)
	}
	if m.stream_total_request_latency_ms != nil {
		fields = append(fields, channelperformance.FieldStreamTotalRequestLatencyMs)
	}
	if m.stream_total_first_token_latency_ms != nil {
		fields = append(fields, channelperformance.FieldStreamTotalFirstTokenLatencyMs)
	}
	if m.consecutive_failures != nil {
		fields = append(fields, channelperformance.FieldConsecutiveFailures)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChannelPerformanceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case channelperformance.FieldCreatedAt:
		return m.CreatedAt()
	case channelperformance.FieldUpdatedAt:
		return m.UpdatedAt()
	case channelperformance.FieldDeletedAt:
		return m.DeletedAt()
	case channelperformance.FieldChannelID:
		return m.ChannelID()
	case channelperformance.FieldSuccessRate:
		return m.SuccessRate()
	case channelperformance.FieldAvgLatencyMs:
		return m.AvgLatencyMs()
	case channelperformance.FieldAvgTokenPerSecond:
		return m.AvgTokenPerSecond()
	case channelperformance.FieldAvgStreamFirstTokenLatencyMs:
		return m.AvgStreamFirstTokenLatencyMs()
	case channelperformance.FieldAvgStreamTokenPerSecond:
		return m.AvgStreamTokenPerSecond()
	case channelperformance.FieldLastSuccessAt:
		return m.LastSuccessAt()
	case channelperformance.FieldLastFailureAt:
		return m.LastFailureAt()
	case channelperformance.FieldRequestCount:
		return m.RequestCount()
	case channelperformance.FieldSuccessCount:
		return m.SuccessCount()
	case channelperformance.FieldFailureCount:
		return m.FailureCount()
	case channelperformance.FieldTotalTokenCount:
		return m.TotalTokenCount()
	case channelperformance.FieldTotalRequestLatencyMs:
		return m.TotalRequestLatencyMs()
	case channelperformance.FieldStreamSuccessCount:
		return m.StreamSuccessCount()
	case channelperformance.FieldStreamTotalRequestCount:
		return m.StreamTotalRequestCount()
	case channelperformance.FieldStreamTotalTokenCount:
		return m.StreamTotalTokenCount()
	case channelperformance.FieldStreamTotalRequestLatencyMs:
		return m.StreamTotalRequestLatencyMs()
	case channelperformance.FieldStreamTotalFirstTokenLatencyMs:
		return m.StreamTotalFirstTokenLatencyMs()
	case channelperformance.FieldConsecutiveFailures:
		return m.ConsecutiveFailures()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChannelPerformanceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case channelperformance.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case channelperformance.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case channelperformance.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case channelperformance.FieldChannelID:
		return m.OldChannelID(ctx)
	case channelperformance.FieldSuccessRate:
		return m.OldSuccessRate(ctx)
	case channelperformance.FieldAvgLatencyMs:
		return m.OldAvgLatencyMs(ctx)
	case channelperformance.FieldAvgTokenPerSecond:
		return m.OldAvgTokenPerSecond(ctx)
	case channelperformance.FieldAvgStreamFirstTokenLatencyMs:
		return m.OldAvgStreamFirstTokenLatencyMs(ctx)
	case channelperformance.FieldAvgStreamTokenPerSecond:
		return m.OldAvgStreamTokenPerSecond(ctx)
	case channelperformance.FieldLastSuccessAt:
		return m.OldLastSuccessAt(ctx)
	case channelperformance.FieldLastFailureAt:
		return m.OldLastFailureAt(ctx)
	case channelperformance.FieldRequestCount:
		return m.OldRequestCount(ctx)
	case channelperformance.FieldSuccessCount:
		return m.OldSuccessCount(ctx)
	case channelperformance.FieldFailureCount:
		return m.OldFailureCount(ctx)
	case channelperformance.FieldTotalTokenCount:
		return m.OldTotalTokenCount(ctx)
	case channelperformance.FieldTotalRequestLatencyMs:
		return m.OldTotalRequestLatencyMs(ctx)
	case channelperformance.FieldStreamSuccessCount:
		return m.OldStreamSuccessCount(ctx)
	case channelperformance.FieldStreamTotalRequestCount:
		return m.OldStreamTotalRequestCount(ctx)
	case channelperformance.FieldStreamTotalTokenCount:
		return m.OldStreamTotalTokenCount(ctx)
	case channelperformance.FieldStreamTotalRequestLatencyMs:
		return m.OldStreamTotalRequestLatencyMs(ctx)
	case channelperformance.FieldStreamTotalFirstTokenLatencyMs:
		return m.OldStreamTotalFirstTokenLatencyMs(ctx)
	case channelperformance.FieldConsecutiveFailures:
		return m.OldConsecutiveFailures(ctx)
	}
	return nil, fmt.Errorf("unknown ChannelPerformance field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChannelPerformanceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case channelperformance.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case channelperformance.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case channelperformance.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case channelperformance.FieldChannelID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelID(v)
		return nil
	case channelperformance.FieldSuccessRate:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuccessRate(v)
		return nil
	case channelperformance.FieldAvgLatencyMs:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvgLatencyMs(v)
		return nil
	case channelperformance.FieldAvgTokenPerSecond:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvgTokenPerSecond(v)
		return nil
	case channelperformance.FieldAvgStreamFirstTokenLatencyMs:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvgStreamFirstTokenLatencyMs(v)
		return nil
	case channelperformance.FieldAvgStreamTokenPerSecond:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvgStreamTokenPerSecond(v)
		return nil
	case channelperformance.FieldLastSuccessAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSuccessAt(v)
		return nil
	case channelperformance.FieldLastFailureAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastFailureAt(v)
		return nil
	case channelperformance.FieldRequestCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestCount(v)
		return nil
	case channelperformance.FieldSuccessCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuccessCount(v)
		return nil
	case channelperformance.FieldFailureCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFailureCount(v)
		return nil
	case channelperformance.FieldTotalTokenCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalTokenCount(v)
		return nil
	case channelperformance.FieldTotalRequestLatencyMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalRequestLatencyMs(v)
		return nil
	case channelperformance.FieldStreamSuccessCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStreamSuccessCount(v)
		return nil
	case channelperformance.FieldStreamTotalRequestCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStreamTotalRequestCount(v)
		return nil
	case channelperformance.FieldStreamTotalTokenCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStreamTotalTokenCount(v)
		return nil
	case channelperformance.FieldStreamTotalRequestLatencyMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStreamTotalRequestLatencyMs(v)
		return nil
	case channelperformance.FieldStreamTotalFirstTokenLatencyMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStreamTotalFirstTokenLatencyMs(v)
		return nil
	case channelperformance.FieldConsecutiveFailures:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConsecutiveFailures(v)
		return nil
	}
	return fmt.Errorf("unknown ChannelPerformance field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChannelPerformanceMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, channelperformance.FieldDeletedAt)
	}
	if m.addsuccess_rate != nil {
		fields = append(fields, channelperformance.FieldSuccessRate)
	}
	if m.addavg_latency_ms != nil {
		fields = append(fields, channelperformance.FieldAvgLatencyMs)
	}
	if m.addavg_token_per_second != nil {
		fields = append(fields, channelperformance.FieldAvgTokenPerSecond)
	}
	if m.addavg_stream_first_token_latency_ms != nil {
		fields = append(fields, channelperformance.FieldAvgStreamFirstTokenLatencyMs)
	}
	if m.addavg_stream_token_per_second != nil {
		fields = append(fields, channelperformance.FieldAvgStreamTokenPerSecond)
	}
	if m.addrequest_count != nil {
		fields = append(fields, channelperformance.FieldRequestCount)
	}
	if m.addsuccess_count != nil {
		fields = append(fields, channelperformance.FieldSuccessCount)
	}
	if m.addfailure_count != nil {
		fields = append(fields, channelperformance.FieldFailureCount)
	}
	if m.addtotal_token_count != nil {
		fields = append(fields, channelperformance.FieldTotalTokenCount)
	}
	if m.addtotal_request_latency_ms != nil {
		fields = append(fields, channelperformance.FieldTotalRequestLatencyMs)
	}
	if m.addstream_success_count != nil {
		fields = append(fields, channelperformance.FieldStreamSuccessCount)
	}
	if m.addstream_total_request_count != nil {
		fields = append(fields, channelperformance.FieldStreamTotalRequestCount)
	}
	if m.addstream_total_token_count != nil {
		fields = append(fields, channelperformance.FieldStreamTotalTokenCount)
	}
	if m.addstream_total_request_latency_ms != nil {
		fields = append(fields, channelperformance.FieldStreamTotalRequestLatencyMs)
	}
	if m.addstream_total_first_token_latency_ms != nil {
		fields = append(fields, channelperformance.FieldStreamTotalFirstTokenLatencyMs)
	}
	if m.addconsecutive_failures != nil {
		fields = append(fields, channelperformance.FieldConsecutiveFailures)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChannelPerformanceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case channelperformance.FieldDeletedAt:
		return m.AddedDeletedAt()
	case channelperformance.FieldSuccessRate:
		return m.AddedSuccessRate()
	case channelperformance.FieldAvgLatencyMs:
		return m.AddedAvgLatencyMs()
	case channelperformance.FieldAvgTokenPerSecond:
		return m.AddedAvgTokenPerSecond()
	case channelperformance.FieldAvgStreamFirstTokenLatencyMs:
		return m.AddedAvgStreamFirstTokenLatencyMs()
	case channelperformance.FieldAvgStreamTokenPerSecond:
		return m.AddedAvgStreamTokenPerSecond()
	case channelperformance.FieldRequestCount:
		return m.AddedRequestCount()
	case channelperformance.FieldSuccessCount:
		return m.AddedSuccessCount()
	case channelperformance.FieldFailureCount:
		return m.AddedFailureCount()
	case channelperformance.FieldTotalTokenCount:
		return m.AddedTotalTokenCount()
	case channelperformance.FieldTotalRequestLatencyMs:
		return m.AddedTotalRequestLatencyMs()
	case channelperformance.FieldStreamSuccessCount:
		return m.AddedStreamSuccessCount()
	case channelperformance.FieldStreamTotalRequestCount:
		return m.AddedStreamTotalRequestCount()
	case channelperformance.FieldStreamTotalTokenCount:
		return m.AddedStreamTotalTokenCount()
	case channelperformance.FieldStreamTotalRequestLatencyMs:
		return m.AddedStreamTotalRequestLatencyMs()
	case channelperformance.FieldStreamTotalFirstTokenLatencyMs:
		return m.AddedStreamTotalFirstTokenLatencyMs()
	case channelperformance.FieldConsecutiveFailures:
		return m.AddedConsecutiveFailures()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChannelPerformanceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case channelperformance.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case channelperformance.FieldSuccessRate:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSuccessRate(v)
		return nil
	case channelperformance.FieldAvgLatencyMs:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAvgLatencyMs(v)
		return nil
	case channelperformance.FieldAvgTokenPerSecond:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAvgTokenPerSecond(v)
		return nil
	case channelperformance.FieldAvgStreamFirstTokenLatencyMs:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAvgStreamFirstTokenLatencyMs(v)
		return nil
	case channelperformance.FieldAvgStreamTokenPerSecond:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAvgStreamTokenPerSecond(v)
		return nil
	case channelperformance.FieldRequestCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRequestCount(v)
		return nil
	case channelperformance.FieldSuccessCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSuccessCount(v)
		return nil
	case channelperformance.FieldFailureCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFailureCount(v)
		return nil
	case channelperformance.FieldTotalTokenCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalTokenCount(v)
		return nil
	case channelperformance.FieldTotalRequestLatencyMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalRequestLatencyMs(v)
		return nil
	case channelperformance.FieldStreamSuccessCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStreamSuccessCount(v)
		return nil
	case channelperformance.FieldStreamTotalRequestCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStreamTotalRequestCount(v)
		return nil
	case channelperformance.FieldStreamTotalTokenCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStreamTotalTokenCount(v)
		return nil
	case channelperformance.FieldStreamTotalRequestLatencyMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStreamTotalRequestLatencyMs(v)
		return nil
	case channelperformance.FieldStreamTotalFirstTokenLatencyMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStreamTotalFirstTokenLatencyMs(v)
		return nil
	case channelperformance.FieldConsecutiveFailures:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddConsecutiveFailures(v)
		return nil
	}
	return fmt.Errorf("unknown ChannelPerformance numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChannelPerformanceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(channelperformance.FieldLastSuccessAt) {
		fields = append(fields, channelperformance.FieldLastSuccessAt)
	}
	if m.FieldCleared(channelperformance.FieldLastFailureAt) {
		fields = append(fields, channelperformance.FieldLastFailureAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChannelPerformanceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChannelPerformanceMutation) ClearField(name string) error {
	switch name {
	case channelperformance.FieldLastSuccessAt:
		m.ClearLastSuccessAt()
		return nil
	case channelperformance.FieldLastFailureAt:
		m.ClearLastFailureAt()
		return nil
	}
	return fmt.Errorf("unknown ChannelPerformance nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChannelPerformanceMutation) ResetField(name string) error {
	switch name {
	case channelperformance.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case channelperformance.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case channelperformance.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case channelperformance.FieldChannelID:
		m.ResetChannelID()
		return nil
	case channelperformance.FieldSuccessRate:
		m.ResetSuccessRate()
		return nil
	case channelperformance.FieldAvgLatencyMs:
		m.ResetAvgLatencyMs()
		return nil
	case channelperformance.FieldAvgTokenPerSecond:
		m.ResetAvgTokenPerSecond()
		return nil
	case channelperformance.FieldAvgStreamFirstTokenLatencyMs:
		m.ResetAvgStreamFirstTokenLatencyMs()
		return nil
	case channelperformance.FieldAvgStreamTokenPerSecond:
		m.ResetAvgStreamTokenPerSecond()
		return nil
	case channelperformance.FieldLastSuccessAt:
		m.ResetLastSuccessAt()
		return nil
	case channelperformance.FieldLastFailureAt:
		m.ResetLastFailureAt()
		return nil
	case channelperformance.FieldRequestCount:
		m.ResetRequestCount()
		return nil
	case channelperformance.FieldSuccessCount:
		m.ResetSuccessCount()
		return nil
	case channelperformance.FieldFailureCount:
		m.ResetFailureCount()
		return nil
	case channelperformance.FieldTotalTokenCount:
		m.ResetTotalTokenCount()
		return nil
	case channelperformance.FieldTotalRequestLatencyMs:
		m.ResetTotalRequestLatencyMs()
		return nil
	case channelperformance.FieldStreamSuccessCount:
		m.ResetStreamSuccessCount()
		return nil
	case channelperformance.FieldStreamTotalRequestCount:
		m.ResetStreamTotalRequestCount()
		return nil
	case channelperformance.FieldStreamTotalTokenCount:
		m.ResetStreamTotalTokenCount()
		return nil
	case channelperformance.FieldStreamTotalRequestLatencyMs:
		m.ResetStreamTotalRequestLatencyMs()
		return nil
	case channelperformance.FieldStreamTotalFirstTokenLatencyMs:
		m.ResetStreamTotalFirstTokenLatencyMs()
		return nil
	case channelperformance.FieldConsecutiveFailures:
		m.ResetConsecutiveFailures()
		return nil
	}
	return fmt.Errorf("unknown ChannelPerformance field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChannelPerformanceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.channel != nil {
		edges = append(edges, channelperformance.EdgeChannel)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChannelPerformanceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case channelperformance.EdgeChannel:
		if id := m.channel; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChannelPerformanceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChannelPerformanceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChannelPerformanceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedchannel {
		edges = append(edges, channelperformance.EdgeChannel)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChannelPerformanceMutation) EdgeCleared(name string) bool {
	switch name {
	case channelperformance.EdgeChannel:
		return m.clearedchannel
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChannelPerformanceMutation) ClearEdge(name string) error {
	switch name {
	case channelperformance.EdgeChannel:
		m.ClearChannel()
		return nil
	}
	return fmt.Errorf("unknown ChannelPerformance unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChannelPerformanceMutation) ResetEdge(name string) error {
	switch name {
	case channelperformance.EdgeChannel:
		m.ResetChannel()
		return nil
	}
	return fmt.Errorf("unknown ChannelPerformance edge %s", name)
}

// ChannelProbeMutation represents an operation that mutates the ChannelProbe nodes in the graph.
type ChannelProbeMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	total_request_count      *int
	addtotal_request_count   *int
	success_request_count    *int
	addsuccess_request_count *int
	timestamp                *int64
	addtimestamp             *int64
	clearedFields            map[string]struct{}
	channel                  *int
	clearedchannel           bool
	done                     bool
	oldValue                 func(context.Context) (*ChannelProbe, error)
	predicates               []predicate.ChannelProbe
}

var _ ent.Mutation = (*ChannelProbeMutation)(nil)

// channelprobeOption allows management of the mutation configuration using functional options.
type channelprobeOption func(*ChannelProbeMutation)

// newChannelProbeMutation creates new mutation for the ChannelProbe entity.
func newChannelProbeMutation(c config, op Op, opts ...channelprobeOption) *ChannelProbeMutation {
	m := &ChannelProbeMutation{
		config:        c,
		op:            op,
		typ:           TypeChannelProbe,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChannelProbeID sets the ID field of the mutation.
func withChannelProbeID(id int) channelprobeOption {
	return func(m *ChannelProbeMutation) {
		var (
			err   error
			once  sync.Once
			value *ChannelProbe
		)
		m.oldValue = func(ctx context.Context) (*ChannelProbe, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ChannelProbe.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChannelProbe sets the old ChannelProbe of the mutation.
func withChannelProbe(node *ChannelProbe) channelprobeOption {
	return func(m *ChannelProbeMutation) {
		m.oldValue = func(context.Context) (*ChannelProbe, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChannelProbeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChannelProbeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChannelProbeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChannelProbeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ChannelProbe.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetChannelID sets the "channel_id" field.
func (m *ChannelProbeMutation) SetChannelID(i int) {
	m.channel = &i
}

// ChannelID returns the value of the "channel_id" field in the mutation.
func (m *ChannelProbeMutation) ChannelID() (r int, exists bool) {
	v := m.channel
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelID returns the old "channel_id" field's value of the ChannelProbe entity.
// If the ChannelProbe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelProbeMutation) OldChannelID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelID: %w", err)
	}
	return oldValue.ChannelID, nil
}

// ResetChannelID resets all changes to the "channel_id" field.
func (m *ChannelProbeMutation) ResetChannelID() {
	m.channel = nil
}

// SetTotalRequestCount sets the "total_request_count" field.
func (m *ChannelProbeMutation) SetTotalRequestCount(i int) {
	m.total_request_count = &i
	m.addtotal_request_count = nil
}

// TotalRequestCount returns the value of the "total_request_count" field in the mutation.
func (m *ChannelProbeMutation) TotalRequestCount() (r int, exists bool) {
	v := m.total_request_count
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalRequestCount returns the old "total_request_count" field's value of the ChannelProbe entity.
// If the ChannelProbe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelProbeMutation) OldTotalRequestCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalRequestCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalRequestCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalRequestCount: %w", err)
	}
	return oldValue.TotalRequestCount, nil
}

// AddTotalRequestCount adds i to the "total_request_count" field.
func (m *ChannelProbeMutation) AddTotalRequestCount(i int) {
	if m.addtotal_request_count != nil {
		*m.addtotal_request_count += i
	} else {
		m.addtotal_request_count = &i
	}
}

// AddedTotalRequestCount returns the value that was added to the "total_request_count" field in this mutation.
func (m *ChannelProbeMutation) AddedTotalRequestCount() (r int, exists bool) {
	v := m.addtotal_request_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalRequestCount resets all changes to the "total_request_count" field.
func (m *ChannelProbeMutation) ResetTotalRequestCount() {
	m.total_request_count = nil
	m.addtotal_request_count = nil
}

// SetSuccessRequestCount sets the "success_request_count" field.
func (m *ChannelProbeMutation) SetSuccessRequestCount(i int) {
	m.success_request_count = &i
	m.addsuccess_request_count = nil
}

// SuccessRequestCount returns the value of the "success_request_count" field in the mutation.
func (m *ChannelProbeMutation) SuccessRequestCount() (r int, exists bool) {
	v := m.success_request_count
	if v == nil {
		return
	}
	return *v, true
}

// OldSuccessRequestCount returns the old "success_request_count" field's value of the ChannelProbe entity.
// If the ChannelProbe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelProbeMutation) OldSuccessRequestCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuccessRequestCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuccessRequestCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuccessRequestCount: %w", err)
	}
	return oldValue.SuccessRequestCount, nil
}

// AddSuccessRequestCount adds i to the "success_request_count" field.
func (m *ChannelProbeMutation) AddSuccessRequestCount(i int) {
	if m.addsuccess_request_count != nil {
		*m.addsuccess_request_count += i
	} else {
		m.addsuccess_request_count = &i
	}
}

// AddedSuccessRequestCount returns the value that was added to the "success_request_count" field in this mutation.
func (m *ChannelProbeMutation) AddedSuccessRequestCount() (r int, exists bool) {
	v := m.addsuccess_request_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetSuccessRequestCount resets all changes to the "success_request_count" field.
func (m *ChannelProbeMutation) ResetSuccessRequestCount() {
	m.success_request_count = nil
	m.addsuccess_request_count = nil
}

// SetTimestamp sets the "timestamp" field.
func (m *ChannelProbeMutation) SetTimestamp(i int64) {
	m.timestamp = &i
	m.addtimestamp = nil
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *ChannelProbeMutation) Timestamp() (r int64, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the ChannelProbe entity.
// If the ChannelProbe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelProbeMutation) OldTimestamp(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// AddTimestamp adds i to the "timestamp" field.
func (m *ChannelProbeMutation) AddTimestamp(i int64) {
	if m.addtimestamp != nil {
		*m.addtimestamp += i
	} else {
		m.addtimestamp = &i
	}
}

// AddedTimestamp returns the value that was added to the "timestamp" field in this mutation.
func (m *ChannelProbeMutation) AddedTimestamp() (r int64, exists bool) {
	v := m.addtimestamp
	if v == nil {
		return
	}
	return *v, true
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *ChannelProbeMutation) ResetTimestamp() {
	m.timestamp = nil
	m.addtimestamp = nil
}

// ClearChannel clears the "channel" edge to the Channel entity.
func (m *ChannelProbeMutation) ClearChannel() {
	m.clearedchannel = true
	m.clearedFields[channelprobe.FieldChannelID] = struct{}{}
}

// ChannelCleared reports if the "channel" edge to the Channel entity was cleared.
func (m *ChannelProbeMutation) ChannelCleared() bool {
	return m.clearedchannel
}

// ChannelIDs returns the "channel" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChannelID instead. It exists only for internal usage by the builders.
func (m *ChannelProbeMutation) ChannelIDs() (ids []int) {
	if id := m.channel; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChannel resets all changes to the "channel" edge.
func (m *ChannelProbeMutation) ResetChannel() {
	m.channel = nil
	m.clearedchannel = false
}

// Where appends a list predicates to the ChannelProbeMutation builder.
func (m *ChannelProbeMutation) Where(ps ...predicate.ChannelProbe) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ChannelProbeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ChannelProbeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ChannelProbe, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ChannelProbeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ChannelProbeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ChannelProbe).
func (m *ChannelProbeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChannelProbeMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.channel != nil {
		fields = append(fields, channelprobe.FieldChannelID)
	}
	if m.total_request_count != nil {
		fields = append(fields, channelprobe.FieldTotalRequestCount)
	}
	if m.success_request_count != nil {
		fields = append(fields, channelprobe.FieldSuccessRequestCount)
	}
	if m.timestamp != nil {
		fields = append(fields, channelprobe.FieldTimestamp)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChannelProbeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case channelprobe.FieldChannelID:
		return m.ChannelID()
	case channelprobe.FieldTotalRequestCount:
		return m.TotalRequestCount()
	case channelprobe.FieldSuccessRequestCount:
		return m.SuccessRequestCount()
	case channelprobe.FieldTimestamp:
		return m.Timestamp()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChannelProbeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case channelprobe.FieldChannelID:
		return m.OldChannelID(ctx)
	case channelprobe.FieldTotalRequestCount:
		return m.OldTotalRequestCount(ctx)
	case channelprobe.FieldSuccessRequestCount:
		return m.OldSuccessRequestCount(ctx)
	case channelprobe.FieldTimestamp:
		return m.OldTimestamp(ctx)
	}
	return nil, fmt.Errorf("unknown ChannelProbe field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChannelProbeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case channelprobe.FieldChannelID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelID(v)
		return nil
	case channelprobe.FieldTotalRequestCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalRequestCount(v)
		return nil
	case channelprobe.FieldSuccessRequestCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuccessRequestCount(v)
		return nil
	case channelprobe.FieldTimestamp:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	}
	return fmt.Errorf("unknown ChannelProbe field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChannelProbeMutation) AddedFields() []string {
	var fields []string
	if m.addtotal_request_count != nil {
		fields = append(fields, channelprobe.FieldTotalRequestCount)
	}
	if m.addsuccess_request_count != nil {
		fields = append(fields, channelprobe.FieldSuccessRequestCount)
	}
	if m.addtimestamp != nil {
		fields = append(fields, channelprobe.FieldTimestamp)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChannelProbeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case channelprobe.FieldTotalRequestCount:
		return m.AddedTotalRequestCount()
	case channelprobe.FieldSuccessRequestCount:
		return m.AddedSuccessRequestCount()
	case channelprobe.FieldTimestamp:
		return m.AddedTimestamp()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChannelProbeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case channelprobe.FieldTotalRequestCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalRequestCount(v)
		return nil
	case channelprobe.FieldSuccessRequestCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSuccessRequestCount(v)
		return nil
	case channelprobe.FieldTimestamp:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimestamp(v)
		return nil
	}
	return fmt.Errorf("unknown ChannelProbe numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChannelProbeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChannelProbeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChannelProbeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ChannelProbe nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChannelProbeMutation) ResetField(name string) error {
	switch name {
	case channelprobe.FieldChannelID:
		m.ResetChannelID()
		return nil
	case channelprobe.FieldTotalRequestCount:
		m.ResetTotalRequestCount()
		return nil
	case channelprobe.FieldSuccessRequestCount:
		m.ResetSuccessRequestCount()
		return nil
	case channelprobe.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	}
	return fmt.Errorf("unknown ChannelProbe field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChannelProbeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.channel != nil {
		edges = append(edges, channelprobe.EdgeChannel)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChannelProbeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case channelprobe.EdgeChannel:
		if id := m.channel; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChannelProbeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChannelProbeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChannelProbeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedchannel {
		edges = append(edges, channelprobe.EdgeChannel)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChannelProbeMutation) EdgeCleared(name string) bool {
	switch name {
	case channelprobe.EdgeChannel:
		return m.clearedchannel
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChannelProbeMutation) ClearEdge(name string) error {
	switch name {
	case channelprobe.EdgeChannel:
		m.ClearChannel()
		return nil
	}
	return fmt.Errorf("unknown ChannelProbe unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChannelProbeMutation) ResetEdge(name string) error {
	switch name {
	case channelprobe.EdgeChannel:
		m.ResetChannel()
		return nil
	}
	return fmt.Errorf("unknown ChannelProbe edge %s", name)
}

// DataStorageMutation represents an operation that mutates the DataStorage nodes in the graph.
type DataStorageMutation struct {
	config
	op                Op
	typ               string
	id                *int
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *int
	adddeleted_at     *int
	name              *string
	description       *string
	primary           *bool
	_type             *datastorage.Type
	settings          **objects.DataStorageSettings
	status            *datastorage.Status
	clearedFields     map[string]struct{}
	requests          map[int]struct{}
	removedrequests   map[int]struct{}
	clearedrequests   bool
	executions        map[int]struct{}
	removedexecutions map[int]struct{}
	clearedexecutions bool
	done              bool
	oldValue          func(context.Context) (*DataStorage, error)
	predicates        []predicate.DataStorage
}

var _ ent.Mutation = (*DataStorageMutation)(nil)

// datastorageOption allows management of the mutation configuration using functional options.
type datastorageOption func(*DataStorageMutation)

// newDataStorageMutation creates new mutation for the DataStorage entity.
func newDataStorageMutation(c config, op Op, opts ...datastorageOption) *DataStorageMutation {
	m := &DataStorageMutation{
		config:        c,
		op:            op,
		typ:           TypeDataStorage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDataStorageID sets the ID field of the mutation.
func withDataStorageID(id int) datastorageOption {
	return func(m *DataStorageMutation) {
		var (
			err   error
			once  sync.Once
			value *DataStorage
		)
		m.oldValue = func(ctx context.Context) (*DataStorage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DataStorage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDataStorage sets the old DataStorage of the mutation.
func withDataStorage(node *DataStorage) datastorageOption {
	return func(m *DataStorageMutation) {
		m.oldValue = func(context.Context) (*DataStorage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DataStorageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DataStorageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DataStorageMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DataStorageMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DataStorage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DataStorageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DataStorageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DataStorage entity.
// If the DataStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataStorageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DataStorageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DataStorageMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DataStorageMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DataStorage entity.
// If the DataStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataStorageMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DataStorageMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *DataStorageMutation) SetDeletedAt(i int) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *DataStorageMutation) DeletedAt() (r int, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the DataStorage entity.
// If the DataStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataStorageMutation) OldDeletedAt(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *DataStorageMutation) AddDeletedAt(i int) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *DataStorageMutation) AddedDeletedAt() (r int, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *DataStorageMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetName sets the "name" field.
func (m *DataStorageMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DataStorageMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the DataStorage entity.
// If the DataStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataStorageMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DataStorageMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *DataStorageMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *DataStorageMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the DataStorage entity.
// If the DataStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataStorageMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *DataStorageMutation) ResetDescription() {
	m.description = nil
}

// SetPrimary sets the "primary" field.
func (m *DataStorageMutation) SetPrimary(b bool) {
	m.primary = &b
}

// Primary returns the value of the "primary" field in the mutation.
func (m *DataStorageMutation) Primary() (r bool, exists bool) {
	v := m.primary
	if v == nil {
		return
	}
	return *v, true
}

// OldPrimary returns the old "primary" field's value of the DataStorage entity.
// If the DataStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataStorageMutation) OldPrimary(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrimary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrimary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrimary: %w", err)
	}
	return oldValue.Primary, nil
}

// ResetPrimary resets all changes to the "primary" field.
func (m *DataStorageMutation) ResetPrimary() {
	m.primary = nil
}

// SetType sets the "type" field.
func (m *DataStorageMutation) SetType(d datastorage.Type) {
	m._type = &d
}

// GetType returns the value of the "type" field in the mutation.
func (m *DataStorageMutation) GetType() (r datastorage.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the DataStorage entity.
// If the DataStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataStorageMutation) OldType(ctx context.Context) (v datastorage.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *DataStorageMutation) ResetType() {
	m._type = nil
}

// SetSettings sets the "settings" field.
func (m *DataStorageMutation) SetSettings(oss *objects.DataStorageSettings) {
	m.settings = &oss
}

// Settings returns the value of the "settings" field in the mutation.
func (m *DataStorageMutation) Settings() (r *objects.DataStorageSettings, exists bool) {
	v := m.settings
	if v == nil {
		return
	}
	return *v, true
}

// OldSettings returns the old "settings" field's value of the DataStorage entity.
// If the DataStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataStorageMutation) OldSettings(ctx context.Context) (v *objects.DataStorageSettings, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettings: %w", err)
	}
	return oldValue.Settings, nil
}

// ResetSettings resets all changes to the "settings" field.
func (m *DataStorageMutation) ResetSettings() {
	m.settings = nil
}

// SetStatus sets the "status" field.
func (m *DataStorageMutation) SetStatus(d datastorage.Status) {
	m.status = &d
}

// Status returns the value of the "status" field in the mutation.
func (m *DataStorageMutation) Status() (r datastorage.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the DataStorage entity.
// If the DataStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataStorageMutation) OldStatus(ctx context.Context) (v datastorage.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *DataStorageMutation) ResetStatus() {
	m.status = nil
}

// AddRequestIDs adds the "requests" edge to the Request entity by ids.
func (m *DataStorageMutation) AddRequestIDs(ids ...int) {
	if m.requests == nil {
		m.requests = make(map[int]struct{})
	}
	for i := range ids {
		m.requests[ids[i]] = struct{}{}
	}
}

// ClearRequests clears the "requests" edge to the Request entity.
func (m *DataStorageMutation) ClearRequests() {
	m.clearedrequests = true
}

// RequestsCleared reports if the "requests" edge to the Request entity was cleared.
func (m *DataStorageMutation) RequestsCleared() bool {
	return m.clearedrequests
}

// RemoveRequestIDs removes the "requests" edge to the Request entity by IDs.
func (m *DataStorageMutation) RemoveRequestIDs(ids ...int) {
	if m.removedrequests == nil {
		m.removedrequests = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.requests, ids[i])
		m.removedrequests[ids[i]] = struct{}{}
	}
}

// RemovedRequests returns the removed IDs of the "requests" edge to the Request entity.
func (m *DataStorageMutation) RemovedRequestsIDs() (ids []int) {
	for id := range m.removedrequests {
		ids = append(ids, id)
	}
	return
}

// RequestsIDs returns the "requests" edge IDs in the mutation.
func (m *DataStorageMutation) RequestsIDs() (ids []int) {
	for id := range m.requests {
		ids = append(ids, id)
	}
	return
}

// ResetRequests resets all changes to the "requests" edge.
func (m *DataStorageMutation) ResetRequests() {
	m.requests = nil
	m.clearedrequests = false
	m.removedrequests = nil
}

// AddExecutionIDs adds the "executions" edge to the RequestExecution entity by ids.
func (m *DataStorageMutation) AddExecutionIDs(ids ...int) {
	if m.executions == nil {
		m.executions = make(map[int]struct{})
	}
	for i := range ids {
		m.executions[ids[i]] = struct{}{}
	}
}

// ClearExecutions clears the "executions" edge to the RequestExecution entity.
func (m *DataStorageMutation) ClearExecutions() {
	m.clearedexecutions = true
}

// ExecutionsCleared reports if the "executions" edge to the RequestExecution entity was cleared.
func (m *DataStorageMutation) ExecutionsCleared() bool {
	return m.clearedexecutions
}

// RemoveExecutionIDs removes the "executions" edge to the RequestExecution entity by IDs.
func (m *DataStorageMutation) RemoveExecutionIDs(ids ...int) {
	if m.removedexecutions == nil {
		m.removedexecutions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.executions, ids[i])
		m.removedexecutions[ids[i]] = struct{}{}
	}
}

// RemovedExecutions returns the removed IDs of the "executions" edge to the RequestExecution entity.
func (m *DataStorageMutation) RemovedExecutionsIDs() (ids []int) {
	for id := range m.removedexecutions {
		ids = append(ids, id)
	}
	return
}

// ExecutionsIDs returns the "executions" edge IDs in the mutation.
func (m *DataStorageMutation) ExecutionsIDs() (ids []int) {
	for id := range m.executions {
		ids = append(ids, id)
	}
	return
}

// ResetExecutions resets all changes to the "executions" edge.
func (m *DataStorageMutation) ResetExecutions() {
	m.executions = nil
	m.clearedexecutions = false
	m.removedexecutions = nil
}

// Where appends a list predicates to the DataStorageMutation builder.
func (m *DataStorageMutation) Where(ps ...predicate.DataStorage) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DataStorageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DataStorageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DataStorage, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DataStorageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DataStorageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DataStorage).
func (m *DataStorageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DataStorageMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, datastorage.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, datastorage.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, datastorage.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, datastorage.FieldName)
	}
	if m.description != nil {
		fields = append(fields, datastorage.FieldDescription)
	}
	if m.primary != nil {
		fields = append(fields, datastorage.FieldPrimary)
	}
	if m._type != nil {
		fields = append(fields, datastorage.FieldType)
	}
	if m.settings != nil {
		fields = append(fields, datastorage.FieldSettings)
	}
	if m.status != nil {
		fields = append(fields, datastorage.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DataStorageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case datastorage.FieldCreatedAt:
		return m.CreatedAt()
	case datastorage.FieldUpdatedAt:
		return m.UpdatedAt()
	case datastorage.FieldDeletedAt:
		return m.DeletedAt()
	case datastorage.FieldName:
		return m.Name()
	case datastorage.FieldDescription:
		return m.Description()
	case datastorage.FieldPrimary:
		return m.Primary()
	case datastorage.FieldType:
		return m.GetType()
	case datastorage.FieldSettings:
		return m.Settings()
	case datastorage.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DataStorageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case datastorage.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case datastorage.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case datastorage.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case datastorage.FieldName:
		return m.OldName(ctx)
	case datastorage.FieldDescription:
		return m.OldDescription(ctx)
	case datastorage.FieldPrimary:
		return m.OldPrimary(ctx)
	case datastorage.FieldType:
		return m.OldType(ctx)
	case datastorage.FieldSettings:
		return m.OldSettings(ctx)
	case datastorage.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown DataStorage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DataStorageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case datastorage.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case datastorage.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case datastorage.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case datastorage.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case datastorage.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case datastorage.FieldPrimary:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrimary(v)
		return nil
	case datastorage.FieldType:
		v, ok := value.(datastorage.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case datastorage.FieldSettings:
		v, ok := value.(*objects.DataStorageSettings)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettings(v)
		return nil
	case datastorage.FieldStatus:
		v, ok := value.(datastorage.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown DataStorage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DataStorageMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, datastorage.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DataStorageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case datastorage.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DataStorageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case datastorage.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown DataStorage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DataStorageMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DataStorageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DataStorageMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DataStorage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DataStorageMutation) ResetField(name string) error {
	switch name {
	case datastorage.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case datastorage.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case datastorage.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case datastorage.FieldName:
		m.ResetName()
		return nil
	case datastorage.FieldDescription:
		m.ResetDescription()
		return nil
	case datastorage.FieldPrimary:
		m.ResetPrimary()
		return nil
	case datastorage.FieldType:
		m.ResetType()
		return nil
	case datastorage.FieldSettings:
		m.ResetSettings()
		return nil
	case datastorage.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown DataStorage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DataStorageMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.requests != nil {
		edges = append(edges, datastorage.EdgeRequests)
	}
	if m.executions != nil {
		edges = append(edges, datastorage.EdgeExecutions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DataStorageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case datastorage.EdgeRequests:
		ids := make([]ent.Value, 0, len(m.requests))
		for id := range m.requests {
			ids = append(ids, id)
		}
		return ids
	case datastorage.EdgeExecutions:
		ids := make([]ent.Value, 0, len(m.executions))
		for id := range m.executions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DataStorageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedrequests != nil {
		edges = append(edges, datastorage.EdgeRequests)
	}
	if m.removedexecutions != nil {
		edges = append(edges, datastorage.EdgeExecutions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DataStorageMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case datastorage.EdgeRequests:
		ids := make([]ent.Value, 0, len(m.removedrequests))
		for id := range m.removedrequests {
			ids = append(ids, id)
		}
		return ids
	case datastorage.EdgeExecutions:
		ids := make([]ent.Value, 0, len(m.removedexecutions))
		for id := range m.removedexecutions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DataStorageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedrequests {
		edges = append(edges, datastorage.EdgeRequests)
	}
	if m.clearedexecutions {
		edges = append(edges, datastorage.EdgeExecutions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DataStorageMutation) EdgeCleared(name string) bool {
	switch name {
	case datastorage.EdgeRequests:
		return m.clearedrequests
	case datastorage.EdgeExecutions:
		return m.clearedexecutions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DataStorageMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown DataStorage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DataStorageMutation) ResetEdge(name string) error {
	switch name {
	case datastorage.EdgeRequests:
		m.ResetRequests()
		return nil
	case datastorage.EdgeExecutions:
		m.ResetExecutions()
		return nil
	}
	return fmt.Errorf("unknown DataStorage edge %s", name)
}

// ModelMutation represents an operation that mutates the Model nodes in the graph.
type ModelMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *int
	adddeleted_at *int
	developer     *string
	model_id      *string
	_type         *model.Type
	name          *string
	icon          *string
	group         *string
	model_card    **objects.ModelCard
	settings      **objects.ModelSettings
	status        *model.Status
	remark        *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Model, error)
	predicates    []predicate.Model
}

var _ ent.Mutation = (*ModelMutation)(nil)

// modelOption allows management of the mutation configuration using functional options.
type modelOption func(*ModelMutation)

// newModelMutation creates new mutation for the Model entity.
func newModelMutation(c config, op Op, opts ...modelOption) *ModelMutation {
	m := &ModelMutation{
		config:        c,
		op:            op,
		typ:           TypeModel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withModelID sets the ID field of the mutation.
func withModelID(id int) modelOption {
	return func(m *ModelMutation) {
		var (
			err   error
			once  sync.Once
			value *Model
		)
		m.oldValue = func(ctx context.Context) (*Model, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Model.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withModel sets the old Model of the mutation.
func withModel(node *Model) modelOption {
	return func(m *ModelMutation) {
		m.oldValue = func(context.Context) (*Model, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ModelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ModelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ModelMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ModelMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Model.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ModelMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ModelMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ModelMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ModelMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ModelMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ModelMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ModelMutation) SetDeletedAt(i int) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ModelMutation) DeletedAt() (r int, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldDeletedAt(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *ModelMutation) AddDeletedAt(i int) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *ModelMutation) AddedDeletedAt() (r int, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ModelMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetDeveloper sets the "developer" field.
func (m *ModelMutation) SetDeveloper(s string) {
	m.developer = &s
}

// Developer returns the value of the "developer" field in the mutation.
func (m *ModelMutation) Developer() (r string, exists bool) {
	v := m.developer
	if v == nil {
		return
	}
	return *v, true
}

// OldDeveloper returns the old "developer" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldDeveloper(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeveloper is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeveloper requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeveloper: %w", err)
	}
	return oldValue.Developer, nil
}

// ResetDeveloper resets all changes to the "developer" field.
func (m *ModelMutation) ResetDeveloper() {
	m.developer = nil
}

// SetModelID sets the "model_id" field.
func (m *ModelMutation) SetModelID(s string) {
	m.model_id = &s
}

// ModelID returns the value of the "model_id" field in the mutation.
func (m *ModelMutation) ModelID() (r string, exists bool) {
	v := m.model_id
	if v == nil {
		return
	}
	return *v, true
}

// OldModelID returns the old "model_id" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldModelID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModelID: %w", err)
	}
	return oldValue.ModelID, nil
}

// ResetModelID resets all changes to the "model_id" field.
func (m *ModelMutation) ResetModelID() {
	m.model_id = nil
}

// SetType sets the "type" field.
func (m *ModelMutation) SetType(value model.Type) {
	m._type = &value
}

// GetType returns the value of the "type" field in the mutation.
func (m *ModelMutation) GetType() (r model.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldType(ctx context.Context) (v model.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ModelMutation) ResetType() {
	m._type = nil
}

// SetName sets the "name" field.
func (m *ModelMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ModelMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ModelMutation) ResetName() {
	m.name = nil
}

// SetIcon sets the "icon" field.
func (m *ModelMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *ModelMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldIcon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ResetIcon resets all changes to the "icon" field.
func (m *ModelMutation) ResetIcon() {
	m.icon = nil
}

// SetGroup sets the "group" field.
func (m *ModelMutation) SetGroup(s string) {
	m.group = &s
}

// Group returns the value of the "group" field in the mutation.
func (m *ModelMutation) Group() (r string, exists bool) {
	v := m.group
	if v == nil {
		return
	}
	return *v, true
}

// OldGroup returns the old "group" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldGroup(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroup is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroup requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroup: %w", err)
	}
	return oldValue.Group, nil
}

// ResetGroup resets all changes to the "group" field.
func (m *ModelMutation) ResetGroup() {
	m.group = nil
}

// SetModelCard sets the "model_card" field.
func (m *ModelMutation) SetModelCard(oc *objects.ModelCard) {
	m.model_card = &oc
}

// ModelCard returns the value of the "model_card" field in the mutation.
func (m *ModelMutation) ModelCard() (r *objects.ModelCard, exists bool) {
	v := m.model_card
	if v == nil {
		return
	}
	return *v, true
}

// OldModelCard returns the old "model_card" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldModelCard(ctx context.Context) (v *objects.ModelCard, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModelCard is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModelCard requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModelCard: %w", err)
	}
	return oldValue.ModelCard, nil
}

// ResetModelCard resets all changes to the "model_card" field.
func (m *ModelMutation) ResetModelCard() {
	m.model_card = nil
}

// SetSettings sets the "settings" field.
func (m *ModelMutation) SetSettings(os *objects.ModelSettings) {
	m.settings = &os
}

// Settings returns the value of the "settings" field in the mutation.
func (m *ModelMutation) Settings() (r *objects.ModelSettings, exists bool) {
	v := m.settings
	if v == nil {
		return
	}
	return *v, true
}

// OldSettings returns the old "settings" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldSettings(ctx context.Context) (v *objects.ModelSettings, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettings: %w", err)
	}
	return oldValue.Settings, nil
}

// ResetSettings resets all changes to the "settings" field.
func (m *ModelMutation) ResetSettings() {
	m.settings = nil
}

// SetStatus sets the "status" field.
func (m *ModelMutation) SetStatus(value model.Status) {
	m.status = &value
}

// Status returns the value of the "status" field in the mutation.
func (m *ModelMutation) Status() (r model.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldStatus(ctx context.Context) (v model.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ModelMutation) ResetStatus() {
	m.status = nil
}

// SetRemark sets the "remark" field.
func (m *ModelMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *ModelMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldRemark(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *ModelMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[model.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *ModelMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[model.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *ModelMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, model.FieldRemark)
}

// Where appends a list predicates to the ModelMutation builder.
func (m *ModelMutation) Where(ps ...predicate.Model) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ModelMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ModelMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Model, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ModelMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ModelMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Model).
func (m *ModelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ModelMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, model.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, model.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, model.FieldDeletedAt)
	}
	if m.developer != nil {
		fields = append(fields, model.FieldDeveloper)
	}
	if m.model_id != nil {
		fields = append(fields, model.FieldModelID)
	}
	if m._type != nil {
		fields = append(fields, model.FieldType)
	}
	if m.name != nil {
		fields = append(fields, model.FieldName)
	}
	if m.icon != nil {
		fields = append(fields, model.FieldIcon)
	}
	if m.group != nil {
		fields = append(fields, model.FieldGroup)
	}
	if m.model_card != nil {
		fields = append(fields, model.FieldModelCard)
	}
	if m.settings != nil {
		fields = append(fields, model.FieldSettings)
	}
	if m.status != nil {
		fields = append(fields, model.FieldStatus)
	}
	if m.remark != nil {
		fields = append(fields, model.FieldRemark)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ModelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case model.FieldCreatedAt:
		return m.CreatedAt()
	case model.FieldUpdatedAt:
		return m.UpdatedAt()
	case model.FieldDeletedAt:
		return m.DeletedAt()
	case model.FieldDeveloper:
		return m.Developer()
	case model.FieldModelID:
		return m.ModelID()
	case model.FieldType:
		return m.GetType()
	case model.FieldName:
		return m.Name()
	case model.FieldIcon:
		return m.Icon()
	case model.FieldGroup:
		return m.Group()
	case model.FieldModelCard:
		return m.ModelCard()
	case model.FieldSettings:
		return m.Settings()
	case model.FieldStatus:
		return m.Status()
	case model.FieldRemark:
		return m.Remark()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ModelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case model.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case model.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case model.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case model.FieldDeveloper:
		return m.OldDeveloper(ctx)
	case model.FieldModelID:
		return m.OldModelID(ctx)
	case model.FieldType:
		return m.OldType(ctx)
	case model.FieldName:
		return m.OldName(ctx)
	case model.FieldIcon:
		return m.OldIcon(ctx)
	case model.FieldGroup:
		return m.OldGroup(ctx)
	case model.FieldModelCard:
		return m.OldModelCard(ctx)
	case model.FieldSettings:
		return m.OldSettings(ctx)
	case model.FieldStatus:
		return m.OldStatus(ctx)
	case model.FieldRemark:
		return m.OldRemark(ctx)
	}
	return nil, fmt.Errorf("unknown Model field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ModelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case model.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case model.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case model.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case model.FieldDeveloper:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeveloper(v)
		return nil
	case model.FieldModelID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModelID(v)
		return nil
	case model.FieldType:
		v, ok := value.(model.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case model.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case model.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case model.FieldGroup:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroup(v)
		return nil
	case model.FieldModelCard:
		v, ok := value.(*objects.ModelCard)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModelCard(v)
		return nil
	case model.FieldSettings:
		v, ok := value.(*objects.ModelSettings)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettings(v)
		return nil
	case model.FieldStatus:
		v, ok := value.(model.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case model.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	}
	return fmt.Errorf("unknown Model field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ModelMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, model.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ModelMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case model.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ModelMutation) AddField(name string, value ent.Value) error {
	switch name {
	case model.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Model numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ModelMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(model.FieldRemark) {
		fields = append(fields, model.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ModelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ModelMutation) ClearField(name string) error {
	switch name {
	case model.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown Model nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ModelMutation) ResetField(name string) error {
	switch name {
	case model.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case model.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case model.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case model.FieldDeveloper:
		m.ResetDeveloper()
		return nil
	case model.FieldModelID:
		m.ResetModelID()
		return nil
	case model.FieldType:
		m.ResetType()
		return nil
	case model.FieldName:
		m.ResetName()
		return nil
	case model.FieldIcon:
		m.ResetIcon()
		return nil
	case model.FieldGroup:
		m.ResetGroup()
		return nil
	case model.FieldModelCard:
		m.ResetModelCard()
		return nil
	case model.FieldSettings:
		m.ResetSettings()
		return nil
	case model.FieldStatus:
		m.ResetStatus()
		return nil
	case model.FieldRemark:
		m.ResetRemark()
		return nil
	}
	return fmt.Errorf("unknown Model field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ModelMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ModelMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ModelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ModelMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ModelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ModelMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ModelMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Model unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ModelMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Model edge %s", name)
}

// ProjectMutation represents an operation that mutates the Project nodes in the graph.
type ProjectMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	created_at           *time.Time
	updated_at           *time.Time
	deleted_at           *int
	adddeleted_at        *int
	name                 *string
	description          *string
	status               *project.Status
	clearedFields        map[string]struct{}
	users                map[int]struct{}
	removedusers         map[int]struct{}
	clearedusers         bool
	roles                map[int]struct{}
	removedroles         map[int]struct{}
	clearedroles         bool
	api_keys             map[int]struct{}
	removedapi_keys      map[int]struct{}
	clearedapi_keys      bool
	requests             map[int]struct{}
	removedrequests      map[int]struct{}
	clearedrequests      bool
	usage_logs           map[int]struct{}
	removedusage_logs    map[int]struct{}
	clearedusage_logs    bool
	threads              map[int]struct{}
	removedthreads       map[int]struct{}
	clearedthreads       bool
	traces               map[int]struct{}
	removedtraces        map[int]struct{}
	clearedtraces        bool
	prompts              map[int]struct{}
	removedprompts       map[int]struct{}
	clearedprompts       bool
	project_users        map[int]struct{}
	removedproject_users map[int]struct{}
	clearedproject_users bool
	done                 bool
	oldValue             func(context.Context) (*Project, error)
	predicates           []predicate.Project
}

var _ ent.Mutation = (*ProjectMutation)(nil)

// projectOption allows management of the mutation configuration using functional options.
type projectOption func(*ProjectMutation)

// newProjectMutation creates new mutation for the Project entity.
func newProjectMutation(c config, op Op, opts ...projectOption) *ProjectMutation {
	m := &ProjectMutation{
		config:        c,
		op:            op,
		typ:           TypeProject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectID sets the ID field of the mutation.
func withProjectID(id int) projectOption {
	return func(m *ProjectMutation) {
		var (
			err   error
			once  sync.Once
			value *Project
		)
		m.oldValue = func(ctx context.Context) (*Project, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Project.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProject sets the old Project of the mutation.
func withProject(node *Project) projectOption {
	return func(m *ProjectMutation) {
		m.oldValue = func(context.Context) (*Project, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProjectMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Project.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProjectMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProjectMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProjectMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProjectMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProjectMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProjectMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ProjectMutation) SetDeletedAt(i int) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ProjectMutation) DeletedAt() (r int, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldDeletedAt(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *ProjectMutation) AddDeletedAt(i int) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *ProjectMutation) AddedDeletedAt() (r int, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ProjectMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetName sets the "name" field.
func (m *ProjectMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProjectMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProjectMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ProjectMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProjectMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ProjectMutation) ResetDescription() {
	m.description = nil
}

// SetStatus sets the "status" field.
func (m *ProjectMutation) SetStatus(pr project.Status) {
	m.status = &pr
}

// Status returns the value of the "status" field in the mutation.
func (m *ProjectMutation) Status() (r project.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldStatus(ctx context.Context) (v project.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ProjectMutation) ResetStatus() {
	m.status = nil
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *ProjectMutation) AddUserIDs(ids ...int) {
	if m.users == nil {
		m.users = make(map[int]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *ProjectMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *ProjectMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *ProjectMutation) RemoveUserIDs(ids ...int) {
	if m.removedusers == nil {
		m.removedusers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *ProjectMutation) RemovedUsersIDs() (ids []int) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *ProjectMutation) UsersIDs() (ids []int) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *ProjectMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddRoleIDs adds the "roles" edge to the Role entity by ids.
func (m *ProjectMutation) AddRoleIDs(ids ...int) {
	if m.roles == nil {
		m.roles = make(map[int]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the Role entity.
func (m *ProjectMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the Role entity was cleared.
func (m *ProjectMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the Role entity by IDs.
func (m *ProjectMutation) RemoveRoleIDs(ids ...int) {
	if m.removedroles == nil {
		m.removedroles = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the Role entity.
func (m *ProjectMutation) RemovedRolesIDs() (ids []int) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *ProjectMutation) RolesIDs() (ids []int) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *ProjectMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// AddAPIKeyIDs adds the "api_keys" edge to the APIKey entity by ids.
func (m *ProjectMutation) AddAPIKeyIDs(ids ...int) {
	if m.api_keys == nil {
		m.api_keys = make(map[int]struct{})
	}
	for i := range ids {
		m.api_keys[ids[i]] = struct{}{}
	}
}

// ClearAPIKeys clears the "api_keys" edge to the APIKey entity.
func (m *ProjectMutation) ClearAPIKeys() {
	m.clearedapi_keys = true
}

// APIKeysCleared reports if the "api_keys" edge to the APIKey entity was cleared.
func (m *ProjectMutation) APIKeysCleared() bool {
	return m.clearedapi_keys
}

// RemoveAPIKeyIDs removes the "api_keys" edge to the APIKey entity by IDs.
func (m *ProjectMutation) RemoveAPIKeyIDs(ids ...int) {
	if m.removedapi_keys == nil {
		m.removedapi_keys = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.api_keys, ids[i])
		m.removedapi_keys[ids[i]] = struct{}{}
	}
}

// RemovedAPIKeys returns the removed IDs of the "api_keys" edge to the APIKey entity.
func (m *ProjectMutation) RemovedAPIKeysIDs() (ids []int) {
	for id := range m.removedapi_keys {
		ids = append(ids, id)
	}
	return
}

// APIKeysIDs returns the "api_keys" edge IDs in the mutation.
func (m *ProjectMutation) APIKeysIDs() (ids []int) {
	for id := range m.api_keys {
		ids = append(ids, id)
	}
	return
}

// ResetAPIKeys resets all changes to the "api_keys" edge.
func (m *ProjectMutation) ResetAPIKeys() {
	m.api_keys = nil
	m.clearedapi_keys = false
	m.removedapi_keys = nil
}

// AddRequestIDs adds the "requests" edge to the Request entity by ids.
func (m *ProjectMutation) AddRequestIDs(ids ...int) {
	if m.requests == nil {
		m.requests = make(map[int]struct{})
	}
	for i := range ids {
		m.requests[ids[i]] = struct{}{}
	}
}

// ClearRequests clears the "requests" edge to the Request entity.
func (m *ProjectMutation) ClearRequests() {
	m.clearedrequests = true
}

// RequestsCleared reports if the "requests" edge to the Request entity was cleared.
func (m *ProjectMutation) RequestsCleared() bool {
	return m.clearedrequests
}

// RemoveRequestIDs removes the "requests" edge to the Request entity by IDs.
func (m *ProjectMutation) RemoveRequestIDs(ids ...int) {
	if m.removedrequests == nil {
		m.removedrequests = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.requests, ids[i])
		m.removedrequests[ids[i]] = struct{}{}
	}
}

// RemovedRequests returns the removed IDs of the "requests" edge to the Request entity.
func (m *ProjectMutation) RemovedRequestsIDs() (ids []int) {
	for id := range m.removedrequests {
		ids = append(ids, id)
	}
	return
}

// RequestsIDs returns the "requests" edge IDs in the mutation.
func (m *ProjectMutation) RequestsIDs() (ids []int) {
	for id := range m.requests {
		ids = append(ids, id)
	}
	return
}

// ResetRequests resets all changes to the "requests" edge.
func (m *ProjectMutation) ResetRequests() {
	m.requests = nil
	m.clearedrequests = false
	m.removedrequests = nil
}

// AddUsageLogIDs adds the "usage_logs" edge to the UsageLog entity by ids.
func (m *ProjectMutation) AddUsageLogIDs(ids ...int) {
	if m.usage_logs == nil {
		m.usage_logs = make(map[int]struct{})
	}
	for i := range ids {
		m.usage_logs[ids[i]] = struct{}{}
	}
}

// ClearUsageLogs clears the "usage_logs" edge to the UsageLog entity.
func (m *ProjectMutation) ClearUsageLogs() {
	m.clearedusage_logs = true
}

// UsageLogsCleared reports if the "usage_logs" edge to the UsageLog entity was cleared.
func (m *ProjectMutation) UsageLogsCleared() bool {
	return m.clearedusage_logs
}

// RemoveUsageLogIDs removes the "usage_logs" edge to the UsageLog entity by IDs.
func (m *ProjectMutation) RemoveUsageLogIDs(ids ...int) {
	if m.removedusage_logs == nil {
		m.removedusage_logs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.usage_logs, ids[i])
		m.removedusage_logs[ids[i]] = struct{}{}
	}
}

// RemovedUsageLogs returns the removed IDs of the "usage_logs" edge to the UsageLog entity.
func (m *ProjectMutation) RemovedUsageLogsIDs() (ids []int) {
	for id := range m.removedusage_logs {
		ids = append(ids, id)
	}
	return
}

// UsageLogsIDs returns the "usage_logs" edge IDs in the mutation.
func (m *ProjectMutation) UsageLogsIDs() (ids []int) {
	for id := range m.usage_logs {
		ids = append(ids, id)
	}
	return
}

// ResetUsageLogs resets all changes to the "usage_logs" edge.
func (m *ProjectMutation) ResetUsageLogs() {
	m.usage_logs = nil
	m.clearedusage_logs = false
	m.removedusage_logs = nil
}

// AddThreadIDs adds the "threads" edge to the Thread entity by ids.
func (m *ProjectMutation) AddThreadIDs(ids ...int) {
	if m.threads == nil {
		m.threads = make(map[int]struct{})
	}
	for i := range ids {
		m.threads[ids[i]] = struct{}{}
	}
}

// ClearThreads clears the "threads" edge to the Thread entity.
func (m *ProjectMutation) ClearThreads() {
	m.clearedthreads = true
}

// ThreadsCleared reports if the "threads" edge to the Thread entity was cleared.
func (m *ProjectMutation) ThreadsCleared() bool {
	return m.clearedthreads
}

// RemoveThreadIDs removes the "threads" edge to the Thread entity by IDs.
func (m *ProjectMutation) RemoveThreadIDs(ids ...int) {
	if m.removedthreads == nil {
		m.removedthreads = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.threads, ids[i])
		m.removedthreads[ids[i]] = struct{}{}
	}
}

// RemovedThreads returns the removed IDs of the "threads" edge to the Thread entity.
func (m *ProjectMutation) RemovedThreadsIDs() (ids []int) {
	for id := range m.removedthreads {
		ids = append(ids, id)
	}
	return
}

// ThreadsIDs returns the "threads" edge IDs in the mutation.
func (m *ProjectMutation) ThreadsIDs() (ids []int) {
	for id := range m.threads {
		ids = append(ids, id)
	}
	return
}

// ResetThreads resets all changes to the "threads" edge.
func (m *ProjectMutation) ResetThreads() {
	m.threads = nil
	m.clearedthreads = false
	m.removedthreads = nil
}

// AddTraceIDs adds the "traces" edge to the Trace entity by ids.
func (m *ProjectMutation) AddTraceIDs(ids ...int) {
	if m.traces == nil {
		m.traces = make(map[int]struct{})
	}
	for i := range ids {
		m.traces[ids[i]] = struct{}{}
	}
}

// ClearTraces clears the "traces" edge to the Trace entity.
func (m *ProjectMutation) ClearTraces() {
	m.clearedtraces = true
}

// TracesCleared reports if the "traces" edge to the Trace entity was cleared.
func (m *ProjectMutation) TracesCleared() bool {
	return m.clearedtraces
}

// RemoveTraceIDs removes the "traces" edge to the Trace entity by IDs.
func (m *ProjectMutation) RemoveTraceIDs(ids ...int) {
	if m.removedtraces == nil {
		m.removedtraces = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.traces, ids[i])
		m.removedtraces[ids[i]] = struct{}{}
	}
}

// RemovedTraces returns the removed IDs of the "traces" edge to the Trace entity.
func (m *ProjectMutation) RemovedTracesIDs() (ids []int) {
	for id := range m.removedtraces {
		ids = append(ids, id)
	}
	return
}

// TracesIDs returns the "traces" edge IDs in the mutation.
func (m *ProjectMutation) TracesIDs() (ids []int) {
	for id := range m.traces {
		ids = append(ids, id)
	}
	return
}

// ResetTraces resets all changes to the "traces" edge.
func (m *ProjectMutation) ResetTraces() {
	m.traces = nil
	m.clearedtraces = false
	m.removedtraces = nil
}

// AddPromptIDs adds the "prompts" edge to the Prompt entity by ids.
func (m *ProjectMutation) AddPromptIDs(ids ...int) {
	if m.prompts == nil {
		m.prompts = make(map[int]struct{})
	}
	for i := range ids {
		m.prompts[ids[i]] = struct{}{}
	}
}

// ClearPrompts clears the "prompts" edge to the Prompt entity.
func (m *ProjectMutation) ClearPrompts() {
	m.clearedprompts = true
}

// PromptsCleared reports if the "prompts" edge to the Prompt entity was cleared.
func (m *ProjectMutation) PromptsCleared() bool {
	return m.clearedprompts
}

// RemovePromptIDs removes the "prompts" edge to the Prompt entity by IDs.
func (m *ProjectMutation) RemovePromptIDs(ids ...int) {
	if m.removedprompts == nil {
		m.removedprompts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.prompts, ids[i])
		m.removedprompts[ids[i]] = struct{}{}
	}
}

// RemovedPrompts returns the removed IDs of the "prompts" edge to the Prompt entity.
func (m *ProjectMutation) RemovedPromptsIDs() (ids []int) {
	for id := range m.removedprompts {
		ids = append(ids, id)
	}
	return
}

// PromptsIDs returns the "prompts" edge IDs in the mutation.
func (m *ProjectMutation) PromptsIDs() (ids []int) {
	for id := range m.prompts {
		ids = append(ids, id)
	}
	return
}

// ResetPrompts resets all changes to the "prompts" edge.
func (m *ProjectMutation) ResetPrompts() {
	m.prompts = nil
	m.clearedprompts = false
	m.removedprompts = nil
}

// AddProjectUserIDs adds the "project_users" edge to the UserProject entity by ids.
func (m *ProjectMutation) AddProjectUserIDs(ids ...int) {
	if m.project_users == nil {
		m.project_users = make(map[int]struct{})
	}
	for i := range ids {
		m.project_users[ids[i]] = struct{}{}
	}
}

// ClearProjectUsers clears the "project_users" edge to the UserProject entity.
func (m *ProjectMutation) ClearProjectUsers() {
	m.clearedproject_users = true
}

// ProjectUsersCleared reports if the "project_users" edge to the UserProject entity was cleared.
func (m *ProjectMutation) ProjectUsersCleared() bool {
	return m.clearedproject_users
}

// RemoveProjectUserIDs removes the "project_users" edge to the UserProject entity by IDs.
func (m *ProjectMutation) RemoveProjectUserIDs(ids ...int) {
	if m.removedproject_users == nil {
		m.removedproject_users = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.project_users, ids[i])
		m.removedproject_users[ids[i]] = struct{}{}
	}
}

// RemovedProjectUsers returns the removed IDs of the "project_users" edge to the UserProject entity.
func (m *ProjectMutation) RemovedProjectUsersIDs() (ids []int) {
	for id := range m.removedproject_users {
		ids = append(ids, id)
	}
	return
}

// ProjectUsersIDs returns the "project_users" edge IDs in the mutation.
func (m *ProjectMutation) ProjectUsersIDs() (ids []int) {
	for id := range m.project_users {
		ids = append(ids, id)
	}
	return
}

// ResetProjectUsers resets all changes to the "project_users" edge.
func (m *ProjectMutation) ResetProjectUsers() {
	m.project_users = nil
	m.clearedproject_users = false
	m.removedproject_users = nil
}

// Where appends a list predicates to the ProjectMutation builder.
func (m *ProjectMutation) Where(ps ...predicate.Project) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProjectMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProjectMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Project, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProjectMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProjectMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Project).
func (m *ProjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, project.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, project.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, project.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, project.FieldName)
	}
	if m.description != nil {
		fields = append(fields, project.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, project.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case project.FieldCreatedAt:
		return m.CreatedAt()
	case project.FieldUpdatedAt:
		return m.UpdatedAt()
	case project.FieldDeletedAt:
		return m.DeletedAt()
	case project.FieldName:
		return m.Name()
	case project.FieldDescription:
		return m.Description()
	case project.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case project.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case project.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case project.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case project.FieldName:
		return m.OldName(ctx)
	case project.FieldDescription:
		return m.OldDescription(ctx)
	case project.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Project field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case project.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case project.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case project.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case project.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case project.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case project.FieldStatus:
		v, ok := value.(project.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, project.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case project.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	case project.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Project numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Project nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectMutation) ResetField(name string) error {
	switch name {
	case project.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case project.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case project.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case project.FieldName:
		m.ResetName()
		return nil
	case project.FieldDescription:
		m.ResetDescription()
		return nil
	case project.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 9)
	if m.users != nil {
		edges = append(edges, project.EdgeUsers)
	}
	if m.roles != nil {
		edges = append(edges, project.EdgeRoles)
	}
	if m.api_keys != nil {
		edges = append(edges, project.EdgeAPIKeys)
	}
	if m.requests != nil {
		edges = append(edges, project.EdgeRequests)
	}
	if m.usage_logs != nil {
		edges = append(edges, project.EdgeUsageLogs)
	}
	if m.threads != nil {
		edges = append(edges, project.EdgeThreads)
	}
	if m.traces != nil {
		edges = append(edges, project.EdgeTraces)
	}
	if m.prompts != nil {
		edges = append(edges, project.EdgePrompts)
	}
	if m.project_users != nil {
		edges = append(edges, project.EdgeProjectUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeAPIKeys:
		ids := make([]ent.Value, 0, len(m.api_keys))
		for id := range m.api_keys {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeRequests:
		ids := make([]ent.Value, 0, len(m.requests))
		for id := range m.requests {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeUsageLogs:
		ids := make([]ent.Value, 0, len(m.usage_logs))
		for id := range m.usage_logs {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeThreads:
		ids := make([]ent.Value, 0, len(m.threads))
		for id := range m.threads {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeTraces:
		ids := make([]ent.Value, 0, len(m.traces))
		for id := range m.traces {
			ids = append(ids, id)
		}
		return ids
	case project.EdgePrompts:
		ids := make([]ent.Value, 0, len(m.prompts))
		for id := range m.prompts {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeProjectUsers:
		ids := make([]ent.Value, 0, len(m.project_users))
		for id := range m.project_users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 9)
	if m.removedusers != nil {
		edges = append(edges, project.EdgeUsers)
	}
	if m.removedroles != nil {
		edges = append(edges, project.EdgeRoles)
	}
	if m.removedapi_keys != nil {
		edges = append(edges, project.EdgeAPIKeys)
	}
	if m.removedrequests != nil {
		edges = append(edges, project.EdgeRequests)
	}
	if m.removedusage_logs != nil {
		edges = append(edges, project.EdgeUsageLogs)
	}
	if m.removedthreads != nil {
		edges = append(edges, project.EdgeThreads)
	}
	if m.removedtraces != nil {
		edges = append(edges, project.EdgeTraces)
	}
	if m.removedprompts != nil {
		edges = append(edges, project.EdgePrompts)
	}
	if m.removedproject_users != nil {
		edges = append(edges, project.EdgeProjectUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeAPIKeys:
		ids := make([]ent.Value, 0, len(m.removedapi_keys))
		for id := range m.removedapi_keys {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeRequests:
		ids := make([]ent.Value, 0, len(m.removedrequests))
		for id := range m.removedrequests {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeUsageLogs:
		ids := make([]ent.Value, 0, len(m.removedusage_logs))
		for id := range m.removedusage_logs {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeThreads:
		ids := make([]ent.Value, 0, len(m.removedthreads))
		for id := range m.removedthreads {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeTraces:
		ids := make([]ent.Value, 0, len(m.removedtraces))
		for id := range m.removedtraces {
			ids = append(ids, id)
		}
		return ids
	case project.EdgePrompts:
		ids := make([]ent.Value, 0, len(m.removedprompts))
		for id := range m.removedprompts {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeProjectUsers:
		ids := make([]ent.Value, 0, len(m.removedproject_users))
		for id := range m.removedproject_users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 9)
	if m.clearedusers {
		edges = append(edges, project.EdgeUsers)
	}
	if m.clearedroles {
		edges = append(edges, project.EdgeRoles)
	}
	if m.clearedapi_keys {
		edges = append(edges, project.EdgeAPIKeys)
	}
	if m.clearedrequests {
		edges = append(edges, project.EdgeRequests)
	}
	if m.clearedusage_logs {
		edges = append(edges, project.EdgeUsageLogs)
	}
	if m.clearedthreads {
		edges = append(edges, project.EdgeThreads)
	}
	if m.clearedtraces {
		edges = append(edges, project.EdgeTraces)
	}
	if m.clearedprompts {
		edges = append(edges, project.EdgePrompts)
	}
	if m.clearedproject_users {
		edges = append(edges, project.EdgeProjectUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectMutation) EdgeCleared(name string) bool {
	switch name {
	case project.EdgeUsers:
		return m.clearedusers
	case project.EdgeRoles:
		return m.clearedroles
	case project.EdgeAPIKeys:
		return m.clearedapi_keys
	case project.EdgeRequests:
		return m.clearedrequests
	case project.EdgeUsageLogs:
		return m.clearedusage_logs
	case project.EdgeThreads:
		return m.clearedthreads
	case project.EdgeTraces:
		return m.clearedtraces
	case project.EdgePrompts:
		return m.clearedprompts
	case project.EdgeProjectUsers:
		return m.clearedproject_users
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Project unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectMutation) ResetEdge(name string) error {
	switch name {
	case project.EdgeUsers:
		m.ResetUsers()
		return nil
	case project.EdgeRoles:
		m.ResetRoles()
		return nil
	case project.EdgeAPIKeys:
		m.ResetAPIKeys()
		return nil
	case project.EdgeRequests:
		m.ResetRequests()
		return nil
	case project.EdgeUsageLogs:
		m.ResetUsageLogs()
		return nil
	case project.EdgeThreads:
		m.ResetThreads()
		return nil
	case project.EdgeTraces:
		m.ResetTraces()
		return nil
	case project.EdgePrompts:
		m.ResetPrompts()
		return nil
	case project.EdgeProjectUsers:
		m.ResetProjectUsers()
		return nil
	}
	return fmt.Errorf("unknown Project edge %s", name)
}

// PromptMutation represents an operation that mutates the Prompt nodes in the graph.
type PromptMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *int
	adddeleted_at   *int
	project_id      *int
	addproject_id   *int
	name            *string
	description     *string
	role            *string
	content         *string
	status          *prompt.Status
	settings        *objects.PromptSettings
	clearedFields   map[string]struct{}
	projects        map[int]struct{}
	removedprojects map[int]struct{}
	clearedprojects bool
	done            bool
	oldValue        func(context.Context) (*Prompt, error)
	predicates      []predicate.Prompt
}

var _ ent.Mutation = (*PromptMutation)(nil)

// promptOption allows management of the mutation configuration using functional options.
type promptOption func(*PromptMutation)

// newPromptMutation creates new mutation for the Prompt entity.
func newPromptMutation(c config, op Op, opts ...promptOption) *PromptMutation {
	m := &PromptMutation{
		config:        c,
		op:            op,
		typ:           TypePrompt,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPromptID sets the ID field of the mutation.
func withPromptID(id int) promptOption {
	return func(m *PromptMutation) {
		var (
			err   error
			once  sync.Once
			value *Prompt
		)
		m.oldValue = func(ctx context.Context) (*Prompt, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Prompt.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPrompt sets the old Prompt of the mutation.
func withPrompt(node *Prompt) promptOption {
	return func(m *PromptMutation) {
		m.oldValue = func(context.Context) (*Prompt, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PromptMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PromptMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PromptMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PromptMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Prompt.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PromptMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PromptMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PromptMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PromptMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PromptMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PromptMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PromptMutation) SetDeletedAt(i int) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PromptMutation) DeletedAt() (r int, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldDeletedAt(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *PromptMutation) AddDeletedAt(i int) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *PromptMutation) AddedDeletedAt() (r int, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PromptMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetProjectID sets the "project_id" field.
func (m *PromptMutation) SetProjectID(i int) {
	m.project_id = &i
	m.addproject_id = nil
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *PromptMutation) ProjectID() (r int, exists bool) {
	v := m.project_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldProjectID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// AddProjectID adds i to the "project_id" field.
func (m *PromptMutation) AddProjectID(i int) {
	if m.addproject_id != nil {
		*m.addproject_id += i
	} else {
		m.addproject_id = &i
	}
}

// AddedProjectID returns the value that was added to the "project_id" field in this mutation.
func (m *PromptMutation) AddedProjectID() (r int, exists bool) {
	v := m.addproject_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *PromptMutation) ResetProjectID() {
	m.project_id = nil
	m.addproject_id = nil
}

// SetName sets the "name" field.
func (m *PromptMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PromptMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PromptMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *PromptMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PromptMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *PromptMutation) ResetDescription() {
	m.description = nil
}

// SetRole sets the "role" field.
func (m *PromptMutation) SetRole(s string) {
	m.role = &s
}

// Role returns the value of the "role" field in the mutation.
func (m *PromptMutation) Role() (r string, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldRole(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *PromptMutation) ResetRole() {
	m.role = nil
}

// SetContent sets the "content" field.
func (m *PromptMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *PromptMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *PromptMutation) ResetContent() {
	m.content = nil
}

// SetStatus sets the "status" field.
func (m *PromptMutation) SetStatus(pr prompt.Status) {
	m.status = &pr
}

// Status returns the value of the "status" field in the mutation.
func (m *PromptMutation) Status() (r prompt.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldStatus(ctx context.Context) (v prompt.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *PromptMutation) ResetStatus() {
	m.status = nil
}

// SetSettings sets the "settings" field.
func (m *PromptMutation) SetSettings(os objects.PromptSettings) {
	m.settings = &os
}

// Settings returns the value of the "settings" field in the mutation.
func (m *PromptMutation) Settings() (r objects.PromptSettings, exists bool) {
	v := m.settings
	if v == nil {
		return
	}
	return *v, true
}

// OldSettings returns the old "settings" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldSettings(ctx context.Context) (v objects.PromptSettings, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettings: %w", err)
	}
	return oldValue.Settings, nil
}

// ResetSettings resets all changes to the "settings" field.
func (m *PromptMutation) ResetSettings() {
	m.settings = nil
}

// AddProjectIDs adds the "projects" edge to the Project entity by ids.
func (m *PromptMutation) AddProjectIDs(ids ...int) {
	if m.projects == nil {
		m.projects = make(map[int]struct{})
	}
	for i := range ids {
		m.projects[ids[i]] = struct{}{}
	}
}

// ClearProjects clears the "projects" edge to the Project entity.
func (m *PromptMutation) ClearProjects() {
	m.clearedprojects = true
}

// ProjectsCleared reports if the "projects" edge to the Project entity was cleared.
func (m *PromptMutation) ProjectsCleared() bool {
	return m.clearedprojects
}

// RemoveProjectIDs removes the "projects" edge to the Project entity by IDs.
func (m *PromptMutation) RemoveProjectIDs(ids ...int) {
	if m.removedprojects == nil {
		m.removedprojects = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.projects, ids[i])
		m.removedprojects[ids[i]] = struct{}{}
	}
}

// RemovedProjects returns the removed IDs of the "projects" edge to the Project entity.
func (m *PromptMutation) RemovedProjectsIDs() (ids []int) {
	for id := range m.removedprojects {
		ids = append(ids, id)
	}
	return
}

// ProjectsIDs returns the "projects" edge IDs in the mutation.
func (m *PromptMutation) ProjectsIDs() (ids []int) {
	for id := range m.projects {
		ids = append(ids, id)
	}
	return
}

// ResetProjects resets all changes to the "projects" edge.
func (m *PromptMutation) ResetProjects() {
	m.projects = nil
	m.clearedprojects = false
	m.removedprojects = nil
}

// Where appends a list predicates to the PromptMutation builder.
func (m *PromptMutation) Where(ps ...predicate.Prompt) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PromptMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PromptMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Prompt, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PromptMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PromptMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Prompt).
func (m *PromptMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PromptMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, prompt.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, prompt.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, prompt.FieldDeletedAt)
	}
	if m.project_id != nil {
		fields = append(fields, prompt.FieldProjectID)
	}
	if m.name != nil {
		fields = append(fields, prompt.FieldName)
	}
	if m.description != nil {
		fields = append(fields, prompt.FieldDescription)
	}
	if m.role != nil {
		fields = append(fields, prompt.FieldRole)
	}
	if m.content != nil {
		fields = append(fields, prompt.FieldContent)
	}
	if m.status != nil {
		fields = append(fields, prompt.FieldStatus)
	}
	if m.settings != nil {
		fields = append(fields, prompt.FieldSettings)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PromptMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case prompt.FieldCreatedAt:
		return m.CreatedAt()
	case prompt.FieldUpdatedAt:
		return m.UpdatedAt()
	case prompt.FieldDeletedAt:
		return m.DeletedAt()
	case prompt.FieldProjectID:
		return m.ProjectID()
	case prompt.FieldName:
		return m.Name()
	case prompt.FieldDescription:
		return m.Description()
	case prompt.FieldRole:
		return m.Role()
	case prompt.FieldContent:
		return m.Content()
	case prompt.FieldStatus:
		return m.Status()
	case prompt.FieldSettings:
		return m.Settings()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PromptMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case prompt.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case prompt.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case prompt.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case prompt.FieldProjectID:
		return m.OldProjectID(ctx)
	case prompt.FieldName:
		return m.OldName(ctx)
	case prompt.FieldDescription:
		return m.OldDescription(ctx)
	case prompt.FieldRole:
		return m.OldRole(ctx)
	case prompt.FieldContent:
		return m.OldContent(ctx)
	case prompt.FieldStatus:
		return m.OldStatus(ctx)
	case prompt.FieldSettings:
		return m.OldSettings(ctx)
	}
	return nil, fmt.Errorf("unknown Prompt field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromptMutation) SetField(name string, value ent.Value) error {
	switch name {
	case prompt.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case prompt.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case prompt.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case prompt.FieldProjectID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case prompt.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case prompt.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case prompt.FieldRole:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case prompt.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case prompt.FieldStatus:
		v, ok := value.(prompt.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case prompt.FieldSettings:
		v, ok := value.(objects.PromptSettings)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettings(v)
		return nil
	}
	return fmt.Errorf("unknown Prompt field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PromptMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, prompt.FieldDeletedAt)
	}
	if m.addproject_id != nil {
		fields = append(fields, prompt.FieldProjectID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PromptMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case prompt.FieldDeletedAt:
		return m.AddedDeletedAt()
	case prompt.FieldProjectID:
		return m.AddedProjectID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromptMutation) AddField(name string, value ent.Value) error {
	switch name {
	case prompt.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case prompt.FieldProjectID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProjectID(v)
		return nil
	}
	return fmt.Errorf("unknown Prompt numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PromptMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PromptMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PromptMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Prompt nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PromptMutation) ResetField(name string) error {
	switch name {
	case prompt.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case prompt.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case prompt.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case prompt.FieldProjectID:
		m.ResetProjectID()
		return nil
	case prompt.FieldName:
		m.ResetName()
		return nil
	case prompt.FieldDescription:
		m.ResetDescription()
		return nil
	case prompt.FieldRole:
		m.ResetRole()
		return nil
	case prompt.FieldContent:
		m.ResetContent()
		return nil
	case prompt.FieldStatus:
		m.ResetStatus()
		return nil
	case prompt.FieldSettings:
		m.ResetSettings()
		return nil
	}
	return fmt.Errorf("unknown Prompt field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PromptMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.projects != nil {
		edges = append(edges, prompt.EdgeProjects)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PromptMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case prompt.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.projects))
		for id := range m.projects {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PromptMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedprojects != nil {
		edges = append(edges, prompt.EdgeProjects)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PromptMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case prompt.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.removedprojects))
		for id := range m.removedprojects {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PromptMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedprojects {
		edges = append(edges, prompt.EdgeProjects)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PromptMutation) EdgeCleared(name string) bool {
	switch name {
	case prompt.EdgeProjects:
		return m.clearedprojects
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PromptMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Prompt unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PromptMutation) ResetEdge(name string) error {
	switch name {
	case prompt.EdgeProjects:
		m.ResetProjects()
		return nil
	}
	return fmt.Errorf("unknown Prompt edge %s", name)
}

// RequestMutation represents an operation that mutates the Request nodes in the graph.
type RequestMutation struct {
	config
	op                                Op
	typ                               string
	id                                *int
	created_at                        *time.Time
	updated_at                        *time.Time
	source                            *request.Source
	model_id                          *string
	format                            *string
	request_headers                   *objects.JSONRawMessage
	appendrequest_headers             objects.JSONRawMessage
	request_body                      *objects.JSONRawMessage
	appendrequest_body                objects.JSONRawMessage
	response_body                     *objects.JSONRawMessage
	appendresponse_body               objects.JSONRawMessage
	response_chunks                   *[]objects.JSONRawMessage
	appendresponse_chunks             []objects.JSONRawMessage
	external_id                       *string
	status                            *request.Status
	stream                            *bool
	client_ip                         *string
	metrics_latency_ms                *int64
	addmetrics_latency_ms             *int64
	metrics_first_token_latency_ms    *int64
	addmetrics_first_token_latency_ms *int64
	clearedFields                     map[string]struct{}
	api_key                           *int
	clearedapi_key                    bool
	project                           *int
	clearedproject                    bool
	trace                             *int
	clearedtrace                      bool
	data_storage                      *int
	cleareddata_storage               bool
	executions                        map[int]struct{}
	removedexecutions                 map[int]struct{}
	clearedexecutions                 bool
	channel                           *int
	clearedchannel                    bool
	usage_logs                        map[int]struct{}
	removedusage_logs                 map[int]struct{}
	clearedusage_logs                 bool
	done                              bool
	oldValue                          func(context.Context) (*Request, error)
	predicates                        []predicate.Request
}

var _ ent.Mutation = (*RequestMutation)(nil)

// requestOption allows management of the mutation configuration using functional options.
type requestOption func(*RequestMutation)

// newRequestMutation creates new mutation for the Request entity.
func newRequestMutation(c config, op Op, opts ...requestOption) *RequestMutation {
	m := &RequestMutation{
		config:        c,
		op:            op,
		typ:           TypeRequest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRequestID sets the ID field of the mutation.
func withRequestID(id int) requestOption {
	return func(m *RequestMutation) {
		var (
			err   error
			once  sync.Once
			value *Request
		)
		m.oldValue = func(ctx context.Context) (*Request, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Request.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRequest sets the old Request of the mutation.
func withRequest(node *Request) requestOption {
	return func(m *RequestMutation) {
		m.oldValue = func(context.Context) (*Request, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RequestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RequestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RequestMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RequestMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Request.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RequestMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RequestMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RequestMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RequestMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RequestMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RequestMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetAPIKeyID sets the "api_key_id" field.
func (m *RequestMutation) SetAPIKeyID(i int) {
	m.api_key = &i
}

// APIKeyID returns the value of the "api_key_id" field in the mutation.
func (m *RequestMutation) APIKeyID() (r int, exists bool) {
	v := m.api_key
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIKeyID returns the old "api_key_id" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldAPIKeyID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPIKeyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPIKeyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIKeyID: %w", err)
	}
	return oldValue.APIKeyID, nil
}

// ClearAPIKeyID clears the value of the "api_key_id" field.
func (m *RequestMutation) ClearAPIKeyID() {
	m.api_key = nil
	m.clearedFields[request.FieldAPIKeyID] = struct{}{}
}

// APIKeyIDCleared returns if the "api_key_id" field was cleared in this mutation.
func (m *RequestMutation) APIKeyIDCleared() bool {
	_, ok := m.clearedFields[request.FieldAPIKeyID]
	return ok
}

// ResetAPIKeyID resets all changes to the "api_key_id" field.
func (m *RequestMutation) ResetAPIKeyID() {
	m.api_key = nil
	delete(m.clearedFields, request.FieldAPIKeyID)
}

// SetProjectID sets the "project_id" field.
func (m *RequestMutation) SetProjectID(i int) {
	m.project = &i
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *RequestMutation) ProjectID() (r int, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldProjectID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *RequestMutation) ResetProjectID() {
	m.project = nil
}

// SetTraceID sets the "trace_id" field.
func (m *RequestMutation) SetTraceID(i int) {
	m.trace = &i
}

// TraceID returns the value of the "trace_id" field in the mutation.
func (m *RequestMutation) TraceID() (r int, exists bool) {
	v := m.trace
	if v == nil {
		return
	}
	return *v, true
}

// OldTraceID returns the old "trace_id" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldTraceID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTraceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTraceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTraceID: %w", err)
	}
	return oldValue.TraceID, nil
}

// ClearTraceID clears the value of the "trace_id" field.
func (m *RequestMutation) ClearTraceID() {
	m.trace = nil
	m.clearedFields[request.FieldTraceID] = struct{}{}
}

// TraceIDCleared returns if the "trace_id" field was cleared in this mutation.
func (m *RequestMutation) TraceIDCleared() bool {
	_, ok := m.clearedFields[request.FieldTraceID]
	return ok
}

// ResetTraceID resets all changes to the "trace_id" field.
func (m *RequestMutation) ResetTraceID() {
	m.trace = nil
	delete(m.clearedFields, request.FieldTraceID)
}

// SetDataStorageID sets the "data_storage_id" field.
func (m *RequestMutation) SetDataStorageID(i int) {
	m.data_storage = &i
}

// DataStorageID returns the value of the "data_storage_id" field in the mutation.
func (m *RequestMutation) DataStorageID() (r int, exists bool) {
	v := m.data_storage
	if v == nil {
		return
	}
	return *v, true
}

// OldDataStorageID returns the old "data_storage_id" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldDataStorageID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDataStorageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDataStorageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDataStorageID: %w", err)
	}
	return oldValue.DataStorageID, nil
}

// ClearDataStorageID clears the value of the "data_storage_id" field.
func (m *RequestMutation) ClearDataStorageID() {
	m.data_storage = nil
	m.clearedFields[request.FieldDataStorageID] = struct{}{}
}

// DataStorageIDCleared returns if the "data_storage_id" field was cleared in this mutation.
func (m *RequestMutation) DataStorageIDCleared() bool {
	_, ok := m.clearedFields[request.FieldDataStorageID]
	return ok
}

// ResetDataStorageID resets all changes to the "data_storage_id" field.
func (m *RequestMutation) ResetDataStorageID() {
	m.data_storage = nil
	delete(m.clearedFields, request.FieldDataStorageID)
}

// SetSource sets the "source" field.
func (m *RequestMutation) SetSource(r request.Source) {
	m.source = &r
}

// Source returns the value of the "source" field in the mutation.
func (m *RequestMutation) Source() (r request.Source, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldSource(ctx context.Context) (v request.Source, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *RequestMutation) ResetSource() {
	m.source = nil
}

// SetModelID sets the "model_id" field.
func (m *RequestMutation) SetModelID(s string) {
	m.model_id = &s
}

// ModelID returns the value of the "model_id" field in the mutation.
func (m *RequestMutation) ModelID() (r string, exists bool) {
	v := m.model_id
	if v == nil {
		return
	}
	return *v, true
}

// OldModelID returns the old "model_id" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldModelID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModelID: %w", err)
	}
	return oldValue.ModelID, nil
}

// ResetModelID resets all changes to the "model_id" field.
func (m *RequestMutation) ResetModelID() {
	m.model_id = nil
}

// SetFormat sets the "format" field.
func (m *RequestMutation) SetFormat(s string) {
	m.format = &s
}

// Format returns the value of the "format" field in the mutation.
func (m *RequestMutation) Format() (r string, exists bool) {
	v := m.format
	if v == nil {
		return
	}
	return *v, true
}

// OldFormat returns the old "format" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldFormat(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFormat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFormat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormat: %w", err)
	}
	return oldValue.Format, nil
}

// ResetFormat resets all changes to the "format" field.
func (m *RequestMutation) ResetFormat() {
	m.format = nil
}

// SetRequestHeaders sets the "request_headers" field.
func (m *RequestMutation) SetRequestHeaders(orm objects.JSONRawMessage) {
	m.request_headers = &orm
	m.appendrequest_headers = nil
}

// RequestHeaders returns the value of the "request_headers" field in the mutation.
func (m *RequestMutation) RequestHeaders() (r objects.JSONRawMessage, exists bool) {
	v := m.request_headers
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestHeaders returns the old "request_headers" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldRequestHeaders(ctx context.Context) (v objects.JSONRawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestHeaders is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestHeaders requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestHeaders: %w", err)
	}
	return oldValue.RequestHeaders, nil
}

// AppendRequestHeaders adds orm to the "request_headers" field.
func (m *RequestMutation) AppendRequestHeaders(orm objects.JSONRawMessage) {
	m.appendrequest_headers = append(m.appendrequest_headers, orm...)
}

// AppendedRequestHeaders returns the list of values that were appended to the "request_headers" field in this mutation.
func (m *RequestMutation) AppendedRequestHeaders() (objects.JSONRawMessage, bool) {
	if len(m.appendrequest_headers) == 0 {
		return nil, false
	}
	return m.appendrequest_headers, true
}

// ClearRequestHeaders clears the value of the "request_headers" field.
func (m *RequestMutation) ClearRequestHeaders() {
	m.request_headers = nil
	m.appendrequest_headers = nil
	m.clearedFields[request.FieldRequestHeaders] = struct{}{}
}

// RequestHeadersCleared returns if the "request_headers" field was cleared in this mutation.
func (m *RequestMutation) RequestHeadersCleared() bool {
	_, ok := m.clearedFields[request.FieldRequestHeaders]
	return ok
}

// ResetRequestHeaders resets all changes to the "request_headers" field.
func (m *RequestMutation) ResetRequestHeaders() {
	m.request_headers = nil
	m.appendrequest_headers = nil
	delete(m.clearedFields, request.FieldRequestHeaders)
}

// SetRequestBody sets the "request_body" field.
func (m *RequestMutation) SetRequestBody(orm objects.JSONRawMessage) {
	m.request_body = &orm
	m.appendrequest_body = nil
}

// RequestBody returns the value of the "request_body" field in the mutation.
func (m *RequestMutation) RequestBody() (r objects.JSONRawMessage, exists bool) {
	v := m.request_body
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestBody returns the old "request_body" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldRequestBody(ctx context.Context) (v objects.JSONRawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestBody: %w", err)
	}
	return oldValue.RequestBody, nil
}

// AppendRequestBody adds orm to the "request_body" field.
func (m *RequestMutation) AppendRequestBody(orm objects.JSONRawMessage) {
	m.appendrequest_body = append(m.appendrequest_body, orm...)
}

// AppendedRequestBody returns the list of values that were appended to the "request_body" field in this mutation.
func (m *RequestMutation) AppendedRequestBody() (objects.JSONRawMessage, bool) {
	if len(m.appendrequest_body) == 0 {
		return nil, false
	}
	return m.appendrequest_body, true
}

// ResetRequestBody resets all changes to the "request_body" field.
func (m *RequestMutation) ResetRequestBody() {
	m.request_body = nil
	m.appendrequest_body = nil
}

// SetResponseBody sets the "response_body" field.
func (m *RequestMutation) SetResponseBody(orm objects.JSONRawMessage) {
	m.response_body = &orm
	m.appendresponse_body = nil
}

// ResponseBody returns the value of the "response_body" field in the mutation.
func (m *RequestMutation) ResponseBody() (r objects.JSONRawMessage, exists bool) {
	v := m.response_body
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseBody returns the old "response_body" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldResponseBody(ctx context.Context) (v objects.JSONRawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseBody: %w", err)
	}
	return oldValue.ResponseBody, nil
}

// AppendResponseBody adds orm to the "response_body" field.
func (m *RequestMutation) AppendResponseBody(orm objects.JSONRawMessage) {
	m.appendresponse_body = append(m.appendresponse_body, orm...)
}

// AppendedResponseBody returns the list of values that were appended to the "response_body" field in this mutation.
func (m *RequestMutation) AppendedResponseBody() (objects.JSONRawMessage, bool) {
	if len(m.appendresponse_body) == 0 {
		return nil, false
	}
	return m.appendresponse_body, true
}

// ClearResponseBody clears the value of the "response_body" field.
func (m *RequestMutation) ClearResponseBody() {
	m.response_body = nil
	m.appendresponse_body = nil
	m.clearedFields[request.FieldResponseBody] = struct{}{}
}

// ResponseBodyCleared returns if the "response_body" field was cleared in this mutation.
func (m *RequestMutation) ResponseBodyCleared() bool {
	_, ok := m.clearedFields[request.FieldResponseBody]
	return ok
}

// ResetResponseBody resets all changes to the "response_body" field.
func (m *RequestMutation) ResetResponseBody() {
	m.response_body = nil
	m.appendresponse_body = nil
	delete(m.clearedFields, request.FieldResponseBody)
}

// SetResponseChunks sets the "response_chunks" field.
func (m *RequestMutation) SetResponseChunks(orm []objects.JSONRawMessage) {
	m.response_chunks = &orm
	m.appendresponse_chunks = nil
}

// ResponseChunks returns the value of the "response_chunks" field in the mutation.
func (m *RequestMutation) ResponseChunks() (r []objects.JSONRawMessage, exists bool) {
	v := m.response_chunks
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseChunks returns the old "response_chunks" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldResponseChunks(ctx context.Context) (v []objects.JSONRawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseChunks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseChunks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseChunks: %w", err)
	}
	return oldValue.ResponseChunks, nil
}

// AppendResponseChunks adds orm to the "response_chunks" field.
func (m *RequestMutation) AppendResponseChunks(orm []objects.JSONRawMessage) {
	m.appendresponse_chunks = append(m.appendresponse_chunks, orm...)
}

// AppendedResponseChunks returns the list of values that were appended to the "response_chunks" field in this mutation.
func (m *RequestMutation) AppendedResponseChunks() ([]objects.JSONRawMessage, bool) {
	if len(m.appendresponse_chunks) == 0 {
		return nil, false
	}
	return m.appendresponse_chunks, true
}

// ClearResponseChunks clears the value of the "response_chunks" field.
func (m *RequestMutation) ClearResponseChunks() {
	m.response_chunks = nil
	m.appendresponse_chunks = nil
	m.clearedFields[request.FieldResponseChunks] = struct{}{}
}

// ResponseChunksCleared returns if the "response_chunks" field was cleared in this mutation.
func (m *RequestMutation) ResponseChunksCleared() bool {
	_, ok := m.clearedFields[request.FieldResponseChunks]
	return ok
}

// ResetResponseChunks resets all changes to the "response_chunks" field.
func (m *RequestMutation) ResetResponseChunks() {
	m.response_chunks = nil
	m.appendresponse_chunks = nil
	delete(m.clearedFields, request.FieldResponseChunks)
}

// SetChannelID sets the "channel_id" field.
func (m *RequestMutation) SetChannelID(i int) {
	m.channel = &i
}

// ChannelID returns the value of the "channel_id" field in the mutation.
func (m *RequestMutation) ChannelID() (r int, exists bool) {
	v := m.channel
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelID returns the old "channel_id" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldChannelID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelID: %w", err)
	}
	return oldValue.ChannelID, nil
}

// ClearChannelID clears the value of the "channel_id" field.
func (m *RequestMutation) ClearChannelID() {
	m.channel = nil
	m.clearedFields[request.FieldChannelID] = struct{}{}
}

// ChannelIDCleared returns if the "channel_id" field was cleared in this mutation.
func (m *RequestMutation) ChannelIDCleared() bool {
	_, ok := m.clearedFields[request.FieldChannelID]
	return ok
}

// ResetChannelID resets all changes to the "channel_id" field.
func (m *RequestMutation) ResetChannelID() {
	m.channel = nil
	delete(m.clearedFields, request.FieldChannelID)
}

// SetExternalID sets the "external_id" field.
func (m *RequestMutation) SetExternalID(s string) {
	m.external_id = &s
}

// ExternalID returns the value of the "external_id" field in the mutation.
func (m *RequestMutation) ExternalID() (r string, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old "external_id" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldExternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// ClearExternalID clears the value of the "external_id" field.
func (m *RequestMutation) ClearExternalID() {
	m.external_id = nil
	m.clearedFields[request.FieldExternalID] = struct{}{}
}

// ExternalIDCleared returns if the "external_id" field was cleared in this mutation.
func (m *RequestMutation) ExternalIDCleared() bool {
	_, ok := m.clearedFields[request.FieldExternalID]
	return ok
}

// ResetExternalID resets all changes to the "external_id" field.
func (m *RequestMutation) ResetExternalID() {
	m.external_id = nil
	delete(m.clearedFields, request.FieldExternalID)
}

// SetStatus sets the "status" field.
func (m *RequestMutation) SetStatus(r request.Status) {
	m.status = &r
}

// Status returns the value of the "status" field in the mutation.
func (m *RequestMutation) Status() (r request.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldStatus(ctx context.Context) (v request.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *RequestMutation) ResetStatus() {
	m.status = nil
}

// SetStream sets the "stream" field.
func (m *RequestMutation) SetStream(b bool) {
	m.stream = &b
}

// Stream returns the value of the "stream" field in the mutation.
func (m *RequestMutation) Stream() (r bool, exists bool) {
	v := m.stream
	if v == nil {
		return
	}
	return *v, true
}

// OldStream returns the old "stream" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldStream(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStream is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStream requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStream: %w", err)
	}
	return oldValue.Stream, nil
}

// ResetStream resets all changes to the "stream" field.
func (m *RequestMutation) ResetStream() {
	m.stream = nil
}

// SetClientIP sets the "client_ip" field.
func (m *RequestMutation) SetClientIP(s string) {
	m.client_ip = &s
}

// ClientIP returns the value of the "client_ip" field in the mutation.
func (m *RequestMutation) ClientIP() (r string, exists bool) {
	v := m.client_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldClientIP returns the old "client_ip" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldClientIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientIP: %w", err)
	}
	return oldValue.ClientIP, nil
}

// ResetClientIP resets all changes to the "client_ip" field.
func (m *RequestMutation) ResetClientIP() {
	m.client_ip = nil
}

// SetMetricsLatencyMs sets the "metrics_latency_ms" field.
func (m *RequestMutation) SetMetricsLatencyMs(i int64) {
	m.metrics_latency_ms = &i
	m.addmetrics_latency_ms = nil
}

// MetricsLatencyMs returns the value of the "metrics_latency_ms" field in the mutation.
func (m *RequestMutation) MetricsLatencyMs() (r int64, exists bool) {
	v := m.metrics_latency_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldMetricsLatencyMs returns the old "metrics_latency_ms" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldMetricsLatencyMs(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetricsLatencyMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetricsLatencyMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetricsLatencyMs: %w", err)
	}
	return oldValue.MetricsLatencyMs, nil
}

// AddMetricsLatencyMs adds i to the "metrics_latency_ms" field.
func (m *RequestMutation) AddMetricsLatencyMs(i int64) {
	if m.addmetrics_latency_ms != nil {
		*m.addmetrics_latency_ms += i
	} else {
		m.addmetrics_latency_ms = &i
	}
}

// AddedMetricsLatencyMs returns the value that was added to the "metrics_latency_ms" field in this mutation.
func (m *RequestMutation) AddedMetricsLatencyMs() (r int64, exists bool) {
	v := m.addmetrics_latency_ms
	if v == nil {
		return
	}
	return *v, true
}

// ClearMetricsLatencyMs clears the value of the "metrics_latency_ms" field.
func (m *RequestMutation) ClearMetricsLatencyMs() {
	m.metrics_latency_ms = nil
	m.addmetrics_latency_ms = nil
	m.clearedFields[request.FieldMetricsLatencyMs] = struct{}{}
}

// MetricsLatencyMsCleared returns if the "metrics_latency_ms" field was cleared in this mutation.
func (m *RequestMutation) MetricsLatencyMsCleared() bool {
	_, ok := m.clearedFields[request.FieldMetricsLatencyMs]
	return ok
}

// ResetMetricsLatencyMs resets all changes to the "metrics_latency_ms" field.
func (m *RequestMutation) ResetMetricsLatencyMs() {
	m.metrics_latency_ms = nil
	m.addmetrics_latency_ms = nil
	delete(m.clearedFields, request.FieldMetricsLatencyMs)
}

// SetMetricsFirstTokenLatencyMs sets the "metrics_first_token_latency_ms" field.
func (m *RequestMutation) SetMetricsFirstTokenLatencyMs(i int64) {
	m.metrics_first_token_latency_ms = &i
	m.addmetrics_first_token_latency_ms = nil
}

// MetricsFirstTokenLatencyMs returns the value of the "metrics_first_token_latency_ms" field in the mutation.
func (m *RequestMutation) MetricsFirstTokenLatencyMs() (r int64, exists bool) {
	v := m.metrics_first_token_latency_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldMetricsFirstTokenLatencyMs returns the old "metrics_first_token_latency_ms" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldMetricsFirstTokenLatencyMs(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetricsFirstTokenLatencyMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetricsFirstTokenLatencyMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetricsFirstTokenLatencyMs: %w", err)
	}
	return oldValue.MetricsFirstTokenLatencyMs, nil
}

// AddMetricsFirstTokenLatencyMs adds i to the "metrics_first_token_latency_ms" field.
func (m *RequestMutation) AddMetricsFirstTokenLatencyMs(i int64) {
	if m.addmetrics_first_token_latency_ms != nil {
		*m.addmetrics_first_token_latency_ms += i
	} else {
		m.addmetrics_first_token_latency_ms = &i
	}
}

// AddedMetricsFirstTokenLatencyMs returns the value that was added to the "metrics_first_token_latency_ms" field in this mutation.
func (m *RequestMutation) AddedMetricsFirstTokenLatencyMs() (r int64, exists bool) {
	v := m.addmetrics_first_token_latency_ms
	if v == nil {
		return
	}
	return *v, true
}

// ClearMetricsFirstTokenLatencyMs clears the value of the "metrics_first_token_latency_ms" field.
func (m *RequestMutation) ClearMetricsFirstTokenLatencyMs() {
	m.metrics_first_token_latency_ms = nil
	m.addmetrics_first_token_latency_ms = nil
	m.clearedFields[request.FieldMetricsFirstTokenLatencyMs] = struct{}{}
}

// MetricsFirstTokenLatencyMsCleared returns if the "metrics_first_token_latency_ms" field was cleared in this mutation.
func (m *RequestMutation) MetricsFirstTokenLatencyMsCleared() bool {
	_, ok := m.clearedFields[request.FieldMetricsFirstTokenLatencyMs]
	return ok
}

// ResetMetricsFirstTokenLatencyMs resets all changes to the "metrics_first_token_latency_ms" field.
func (m *RequestMutation) ResetMetricsFirstTokenLatencyMs() {
	m.metrics_first_token_latency_ms = nil
	m.addmetrics_first_token_latency_ms = nil
	delete(m.clearedFields, request.FieldMetricsFirstTokenLatencyMs)
}

// ClearAPIKey clears the "api_key" edge to the APIKey entity.
func (m *RequestMutation) ClearAPIKey() {
	m.clearedapi_key = true
	m.clearedFields[request.FieldAPIKeyID] = struct{}{}
}

// APIKeyCleared reports if the "api_key" edge to the APIKey entity was cleared.
func (m *RequestMutation) APIKeyCleared() bool {
	return m.APIKeyIDCleared() || m.clearedapi_key
}

// APIKeyIDs returns the "api_key" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// APIKeyID instead. It exists only for internal usage by the builders.
func (m *RequestMutation) APIKeyIDs() (ids []int) {
	if id := m.api_key; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAPIKey resets all changes to the "api_key" edge.
func (m *RequestMutation) ResetAPIKey() {
	m.api_key = nil
	m.clearedapi_key = false
}

// ClearProject clears the "project" edge to the Project entity.
func (m *RequestMutation) ClearProject() {
	m.clearedproject = true
	m.clearedFields[request.FieldProjectID] = struct{}{}
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *RequestMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *RequestMutation) ProjectIDs() (ids []int) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *RequestMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// ClearTrace clears the "trace" edge to the Trace entity.
func (m *RequestMutation) ClearTrace() {
	m.clearedtrace = true
	m.clearedFields[request.FieldTraceID] = struct{}{}
}

// TraceCleared reports if the "trace" edge to the Trace entity was cleared.
func (m *RequestMutation) TraceCleared() bool {
	return m.TraceIDCleared() || m.clearedtrace
}

// TraceIDs returns the "trace" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TraceID instead. It exists only for internal usage by the builders.
func (m *RequestMutation) TraceIDs() (ids []int) {
	if id := m.trace; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTrace resets all changes to the "trace" edge.
func (m *RequestMutation) ResetTrace() {
	m.trace = nil
	m.clearedtrace = false
}

// ClearDataStorage clears the "data_storage" edge to the DataStorage entity.
func (m *RequestMutation) ClearDataStorage() {
	m.cleareddata_storage = true
	m.clearedFields[request.FieldDataStorageID] = struct{}{}
}

// DataStorageCleared reports if the "data_storage" edge to the DataStorage entity was cleared.
func (m *RequestMutation) DataStorageCleared() bool {
	return m.DataStorageIDCleared() || m.cleareddata_storage
}

// DataStorageIDs returns the "data_storage" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DataStorageID instead. It exists only for internal usage by the builders.
func (m *RequestMutation) DataStorageIDs() (ids []int) {
	if id := m.data_storage; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDataStorage resets all changes to the "data_storage" edge.
func (m *RequestMutation) ResetDataStorage() {
	m.data_storage = nil
	m.cleareddata_storage = false
}

// AddExecutionIDs adds the "executions" edge to the RequestExecution entity by ids.
func (m *RequestMutation) AddExecutionIDs(ids ...int) {
	if m.executions == nil {
		m.executions = make(map[int]struct{})
	}
	for i := range ids {
		m.executions[ids[i]] = struct{}{}
	}
}

// ClearExecutions clears the "executions" edge to the RequestExecution entity.
func (m *RequestMutation) ClearExecutions() {
	m.clearedexecutions = true
}

// ExecutionsCleared reports if the "executions" edge to the RequestExecution entity was cleared.
func (m *RequestMutation) ExecutionsCleared() bool {
	return m.clearedexecutions
}

// RemoveExecutionIDs removes the "executions" edge to the RequestExecution entity by IDs.
func (m *RequestMutation) RemoveExecutionIDs(ids ...int) {
	if m.removedexecutions == nil {
		m.removedexecutions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.executions, ids[i])
		m.removedexecutions[ids[i]] = struct{}{}
	}
}

// RemovedExecutions returns the removed IDs of the "executions" edge to the RequestExecution entity.
func (m *RequestMutation) RemovedExecutionsIDs() (ids []int) {
	for id := range m.removedexecutions {
		ids = append(ids, id)
	}
	return
}

// ExecutionsIDs returns the "executions" edge IDs in the mutation.
func (m *RequestMutation) ExecutionsIDs() (ids []int) {
	for id := range m.executions {
		ids = append(ids, id)
	}
	return
}

// ResetExecutions resets all changes to the "executions" edge.
func (m *RequestMutation) ResetExecutions() {
	m.executions = nil
	m.clearedexecutions = false
	m.removedexecutions = nil
}

// ClearChannel clears the "channel" edge to the Channel entity.
func (m *RequestMutation) ClearChannel() {
	m.clearedchannel = true
	m.clearedFields[request.FieldChannelID] = struct{}{}
}

// ChannelCleared reports if the "channel" edge to the Channel entity was cleared.
func (m *RequestMutation) ChannelCleared() bool {
	return m.ChannelIDCleared() || m.clearedchannel
}

// ChannelIDs returns the "channel" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChannelID instead. It exists only for internal usage by the builders.
func (m *RequestMutation) ChannelIDs() (ids []int) {
	if id := m.channel; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChannel resets all changes to the "channel" edge.
func (m *RequestMutation) ResetChannel() {
	m.channel = nil
	m.clearedchannel = false
}

// AddUsageLogIDs adds the "usage_logs" edge to the UsageLog entity by ids.
func (m *RequestMutation) AddUsageLogIDs(ids ...int) {
	if m.usage_logs == nil {
		m.usage_logs = make(map[int]struct{})
	}
	for i := range ids {
		m.usage_logs[ids[i]] = struct{}{}
	}
}

// ClearUsageLogs clears the "usage_logs" edge to the UsageLog entity.
func (m *RequestMutation) ClearUsageLogs() {
	m.clearedusage_logs = true
}

// UsageLogsCleared reports if the "usage_logs" edge to the UsageLog entity was cleared.
func (m *RequestMutation) UsageLogsCleared() bool {
	return m.clearedusage_logs
}

// RemoveUsageLogIDs removes the "usage_logs" edge to the UsageLog entity by IDs.
func (m *RequestMutation) RemoveUsageLogIDs(ids ...int) {
	if m.removedusage_logs == nil {
		m.removedusage_logs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.usage_logs, ids[i])
		m.removedusage_logs[ids[i]] = struct{}{}
	}
}

// RemovedUsageLogs returns the removed IDs of the "usage_logs" edge to the UsageLog entity.
func (m *RequestMutation) RemovedUsageLogsIDs() (ids []int) {
	for id := range m.removedusage_logs {
		ids = append(ids, id)
	}
	return
}

// UsageLogsIDs returns the "usage_logs" edge IDs in the mutation.
func (m *RequestMutation) UsageLogsIDs() (ids []int) {
	for id := range m.usage_logs {
		ids = append(ids, id)
	}
	return
}

// ResetUsageLogs resets all changes to the "usage_logs" edge.
func (m *RequestMutation) ResetUsageLogs() {
	m.usage_logs = nil
	m.clearedusage_logs = false
	m.removedusage_logs = nil
}

// Where appends a list predicates to the RequestMutation builder.
func (m *RequestMutation) Where(ps ...predicate.Request) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RequestMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RequestMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Request, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RequestMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RequestMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Request).
func (m *RequestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RequestMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.created_at != nil {
		fields = append(fields, request.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, request.FieldUpdatedAt)
	}
	if m.api_key != nil {
		fields = append(fields, request.FieldAPIKeyID)
	}
	if m.project != nil {
		fields = append(fields, request.FieldProjectID)
	}
	if m.trace != nil {
		fields = append(fields, request.FieldTraceID)
	}
	if m.data_storage != nil {
		fields = append(fields, request.FieldDataStorageID)
	}
	if m.source != nil {
		fields = append(fields, request.FieldSource)
	}
	if m.model_id != nil {
		fields = append(fields, request.FieldModelID)
	}
	if m.format != nil {
		fields = append(fields, request.FieldFormat)
	}
	if m.request_headers != nil {
		fields = append(fields, request.FieldRequestHeaders)
	}
	if m.request_body != nil {
		fields = append(fields, request.FieldRequestBody)
	}
	if m.response_body != nil {
		fields = append(fields, request.FieldResponseBody)
	}
	if m.response_chunks != nil {
		fields = append(fields, request.FieldResponseChunks)
	}
	if m.channel != nil {
		fields = append(fields, request.FieldChannelID)
	}
	if m.external_id != nil {
		fields = append(fields, request.FieldExternalID)
	}
	if m.status != nil {
		fields = append(fields, request.FieldStatus)
	}
	if m.stream != nil {
		fields = append(fields, request.FieldStream)
	}
	if m.client_ip != nil {
		fields = append(fields, request.FieldClientIP)
	}
	if m.metrics_latency_ms != nil {
		fields = append(fields, request.FieldMetricsLatencyMs)
	}
	if m.metrics_first_token_latency_ms != nil {
		fields = append(fields, request.FieldMetricsFirstTokenLatencyMs)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RequestMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case request.FieldCreatedAt:
		return m.CreatedAt()
	case request.FieldUpdatedAt:
		return m.UpdatedAt()
	case request.FieldAPIKeyID:
		return m.APIKeyID()
	case request.FieldProjectID:
		return m.ProjectID()
	case request.FieldTraceID:
		return m.TraceID()
	case request.FieldDataStorageID:
		return m.DataStorageID()
	case request.FieldSource:
		return m.Source()
	case request.FieldModelID:
		return m.ModelID()
	case request.FieldFormat:
		return m.Format()
	case request.FieldRequestHeaders:
		return m.RequestHeaders()
	case request.FieldRequestBody:
		return m.RequestBody()
	case request.FieldResponseBody:
		return m.ResponseBody()
	case request.FieldResponseChunks:
		return m.ResponseChunks()
	case request.FieldChannelID:
		return m.ChannelID()
	case request.FieldExternalID:
		return m.ExternalID()
	case request.FieldStatus:
		return m.Status()
	case request.FieldStream:
		return m.Stream()
	case request.FieldClientIP:
		return m.ClientIP()
	case request.FieldMetricsLatencyMs:
		return m.MetricsLatencyMs()
	case request.FieldMetricsFirstTokenLatencyMs:
		return m.MetricsFirstTokenLatencyMs()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RequestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case request.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case request.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case request.FieldAPIKeyID:
		return m.OldAPIKeyID(ctx)
	case request.FieldProjectID:
		return m.OldProjectID(ctx)
	case request.FieldTraceID:
		return m.OldTraceID(ctx)
	case request.FieldDataStorageID:
		return m.OldDataStorageID(ctx)
	case request.FieldSource:
		return m.OldSource(ctx)
	case request.FieldModelID:
		return m.OldModelID(ctx)
	case request.FieldFormat:
		return m.OldFormat(ctx)
	case request.FieldRequestHeaders:
		return m.OldRequestHeaders(ctx)
	case request.FieldRequestBody:
		return m.OldRequestBody(ctx)
	case request.FieldResponseBody:
		return m.OldResponseBody(ctx)
	case request.FieldResponseChunks:
		return m.OldResponseChunks(ctx)
	case request.FieldChannelID:
		return m.OldChannelID(ctx)
	case request.FieldExternalID:
		return m.OldExternalID(ctx)
	case request.FieldStatus:
		return m.OldStatus(ctx)
	case request.FieldStream:
		return m.OldStream(ctx)
	case request.FieldClientIP:
		return m.OldClientIP(ctx)
	case request.FieldMetricsLatencyMs:
		return m.OldMetricsLatencyMs(ctx)
	case request.FieldMetricsFirstTokenLatencyMs:
		return m.OldMetricsFirstTokenLatencyMs(ctx)
	}
	return nil, fmt.Errorf("unknown Request field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RequestMutation) SetField(name string, value ent.Value) error {
	switch name {
	case request.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case request.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case request.FieldAPIKeyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIKeyID(v)
		return nil
	case request.FieldProjectID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case request.FieldTraceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTraceID(v)
		return nil
	case request.FieldDataStorageID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDataStorageID(v)
		return nil
	case request.FieldSource:
		v, ok := value.(request.Source)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case request.FieldModelID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModelID(v)
		return nil
	case request.FieldFormat:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormat(v)
		return nil
	case request.FieldRequestHeaders:
		v, ok := value.(objects.JSONRawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestHeaders(v)
		return nil
	case request.FieldRequestBody:
		v, ok := value.(objects.JSONRawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestBody(v)
		return nil
	case request.FieldResponseBody:
		v, ok := value.(objects.JSONRawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseBody(v)
		return nil
	case request.FieldResponseChunks:
		v, ok := value.([]objects.JSONRawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseChunks(v)
		return nil
	case request.FieldChannelID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelID(v)
		return nil
	case request.FieldExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	case request.FieldStatus:
		v, ok := value.(request.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case request.FieldStream:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStream(v)
		return nil
	case request.FieldClientIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientIP(v)
		return nil
	case request.FieldMetricsLatencyMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetricsLatencyMs(v)
		return nil
	case request.FieldMetricsFirstTokenLatencyMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetricsFirstTokenLatencyMs(v)
		return nil
	}
	return fmt.Errorf("unknown Request field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RequestMutation) AddedFields() []string {
	var fields []string
	if m.addmetrics_latency_ms != nil {
		fields = append(fields, request.FieldMetricsLatencyMs)
	}
	if m.addmetrics_first_token_latency_ms != nil {
		fields = append(fields, request.FieldMetricsFirstTokenLatencyMs)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RequestMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case request.FieldMetricsLatencyMs:
		return m.AddedMetricsLatencyMs()
	case request.FieldMetricsFirstTokenLatencyMs:
		return m.AddedMetricsFirstTokenLatencyMs()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RequestMutation) AddField(name string, value ent.Value) error {
	switch name {
	case request.FieldMetricsLatencyMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMetricsLatencyMs(v)
		return nil
	case request.FieldMetricsFirstTokenLatencyMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMetricsFirstTokenLatencyMs(v)
		return nil
	}
	return fmt.Errorf("unknown Request numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RequestMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(request.FieldAPIKeyID) {
		fields = append(fields, request.FieldAPIKeyID)
	}
	if m.FieldCleared(request.FieldTraceID) {
		fields = append(fields, request.FieldTraceID)
	}
	if m.FieldCleared(request.FieldDataStorageID) {
		fields = append(fields, request.FieldDataStorageID)
	}
	if m.FieldCleared(request.FieldRequestHeaders) {
		fields = append(fields, request.FieldRequestHeaders)
	}
	if m.FieldCleared(request.FieldResponseBody) {
		fields = append(fields, request.FieldResponseBody)
	}
	if m.FieldCleared(request.FieldResponseChunks) {
		fields = append(fields, request.FieldResponseChunks)
	}
	if m.FieldCleared(request.FieldChannelID) {
		fields = append(fields, request.FieldChannelID)
	}
	if m.FieldCleared(request.FieldExternalID) {
		fields = append(fields, request.FieldExternalID)
	}
	if m.FieldCleared(request.FieldMetricsLatencyMs) {
		fields = append(fields, request.FieldMetricsLatencyMs)
	}
	if m.FieldCleared(request.FieldMetricsFirstTokenLatencyMs) {
		fields = append(fields, request.FieldMetricsFirstTokenLatencyMs)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RequestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RequestMutation) ClearField(name string) error {
	switch name {
	case request.FieldAPIKeyID:
		m.ClearAPIKeyID()
		return nil
	case request.FieldTraceID:
		m.ClearTraceID()
		return nil
	case request.FieldDataStorageID:
		m.ClearDataStorageID()
		return nil
	case request.FieldRequestHeaders:
		m.ClearRequestHeaders()
		return nil
	case request.FieldResponseBody:
		m.ClearResponseBody()
		return nil
	case request.FieldResponseChunks:
		m.ClearResponseChunks()
		return nil
	case request.FieldChannelID:
		m.ClearChannelID()
		return nil
	case request.FieldExternalID:
		m.ClearExternalID()
		return nil
	case request.FieldMetricsLatencyMs:
		m.ClearMetricsLatencyMs()
		return nil
	case request.FieldMetricsFirstTokenLatencyMs:
		m.ClearMetricsFirstTokenLatencyMs()
		return nil
	}
	return fmt.Errorf("unknown Request nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RequestMutation) ResetField(name string) error {
	switch name {
	case request.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case request.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case request.FieldAPIKeyID:
		m.ResetAPIKeyID()
		return nil
	case request.FieldProjectID:
		m.ResetProjectID()
		return nil
	case request.FieldTraceID:
		m.ResetTraceID()
		return nil
	case request.FieldDataStorageID:
		m.ResetDataStorageID()
		return nil
	case request.FieldSource:
		m.ResetSource()
		return nil
	case request.FieldModelID:
		m.ResetModelID()
		return nil
	case request.FieldFormat:
		m.ResetFormat()
		return nil
	case request.FieldRequestHeaders:
		m.ResetRequestHeaders()
		return nil
	case request.FieldRequestBody:
		m.ResetRequestBody()
		return nil
	case request.FieldResponseBody:
		m.ResetResponseBody()
		return nil
	case request.FieldResponseChunks:
		m.ResetResponseChunks()
		return nil
	case request.FieldChannelID:
		m.ResetChannelID()
		return nil
	case request.FieldExternalID:
		m.ResetExternalID()
		return nil
	case request.FieldStatus:
		m.ResetStatus()
		return nil
	case request.FieldStream:
		m.ResetStream()
		return nil
	case request.FieldClientIP:
		m.ResetClientIP()
		return nil
	case request.FieldMetricsLatencyMs:
		m.ResetMetricsLatencyMs()
		return nil
	case request.FieldMetricsFirstTokenLatencyMs:
		m.ResetMetricsFirstTokenLatencyMs()
		return nil
	}
	return fmt.Errorf("unknown Request field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RequestMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.api_key != nil {
		edges = append(edges, request.EdgeAPIKey)
	}
	if m.project != nil {
		edges = append(edges, request.EdgeProject)
	}
	if m.trace != nil {
		edges = append(edges, request.EdgeTrace)
	}
	if m.data_storage != nil {
		edges = append(edges, request.EdgeDataStorage)
	}
	if m.executions != nil {
		edges = append(edges, request.EdgeExecutions)
	}
	if m.channel != nil {
		edges = append(edges, request.EdgeChannel)
	}
	if m.usage_logs != nil {
		edges = append(edges, request.EdgeUsageLogs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RequestMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case request.EdgeAPIKey:
		if id := m.api_key; id != nil {
			return []ent.Value{*id}
		}
	case request.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case request.EdgeTrace:
		if id := m.trace; id != nil {
			return []ent.Value{*id}
		}
	case request.EdgeDataStorage:
		if id := m.data_storage; id != nil {
			return []ent.Value{*id}
		}
	case request.EdgeExecutions:
		ids := make([]ent.Value, 0, len(m.executions))
		for id := range m.executions {
			ids = append(ids, id)
		}
		return ids
	case request.EdgeChannel:
		if id := m.channel; id != nil {
			return []ent.Value{*id}
		}
	case request.EdgeUsageLogs:
		ids := make([]ent.Value, 0, len(m.usage_logs))
		for id := range m.usage_logs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RequestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedexecutions != nil {
		edges = append(edges, request.EdgeExecutions)
	}
	if m.removedusage_logs != nil {
		edges = append(edges, request.EdgeUsageLogs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RequestMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case request.EdgeExecutions:
		ids := make([]ent.Value, 0, len(m.removedexecutions))
		for id := range m.removedexecutions {
			ids = append(ids, id)
		}
		return ids
	case request.EdgeUsageLogs:
		ids := make([]ent.Value, 0, len(m.removedusage_logs))
		for id := range m.removedusage_logs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RequestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedapi_key {
		edges = append(edges, request.EdgeAPIKey)
	}
	if m.clearedproject {
		edges = append(edges, request.EdgeProject)
	}
	if m.clearedtrace {
		edges = append(edges, request.EdgeTrace)
	}
	if m.cleareddata_storage {
		edges = append(edges, request.EdgeDataStorage)
	}
	if m.clearedexecutions {
		edges = append(edges, request.EdgeExecutions)
	}
	if m.clearedchannel {
		edges = append(edges, request.EdgeChannel)
	}
	if m.clearedusage_logs {
		edges = append(edges, request.EdgeUsageLogs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RequestMutation) EdgeCleared(name string) bool {
	switch name {
	case request.EdgeAPIKey:
		return m.clearedapi_key
	case request.EdgeProject:
		return m.clearedproject
	case request.EdgeTrace:
		return m.clearedtrace
	case request.EdgeDataStorage:
		return m.cleareddata_storage
	case request.EdgeExecutions:
		return m.clearedexecutions
	case request.EdgeChannel:
		return m.clearedchannel
	case request.EdgeUsageLogs:
		return m.clearedusage_logs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RequestMutation) ClearEdge(name string) error {
	switch name {
	case request.EdgeAPIKey:
		m.ClearAPIKey()
		return nil
	case request.EdgeProject:
		m.ClearProject()
		return nil
	case request.EdgeTrace:
		m.ClearTrace()
		return nil
	case request.EdgeDataStorage:
		m.ClearDataStorage()
		return nil
	case request.EdgeChannel:
		m.ClearChannel()
		return nil
	}
	return fmt.Errorf("unknown Request unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RequestMutation) ResetEdge(name string) error {
	switch name {
	case request.EdgeAPIKey:
		m.ResetAPIKey()
		return nil
	case request.EdgeProject:
		m.ResetProject()
		return nil
	case request.EdgeTrace:
		m.ResetTrace()
		return nil
	case request.EdgeDataStorage:
		m.ResetDataStorage()
		return nil
	case request.EdgeExecutions:
		m.ResetExecutions()
		return nil
	case request.EdgeChannel:
		m.ResetChannel()
		return nil
	case request.EdgeUsageLogs:
		m.ResetUsageLogs()
		return nil
	}
	return fmt.Errorf("unknown Request edge %s", name)
}

// RequestExecutionMutation represents an operation that mutates the RequestExecution nodes in the graph.
type RequestExecutionMutation struct {
	config
	op                                Op
	typ                               string
	id                                *int
	created_at                        *time.Time
	updated_at                        *time.Time
	project_id                        *int
	addproject_id                     *int
	external_id                       *string
	model_id                          *string
	format                            *string
	request_body                      *objects.JSONRawMessage
	appendrequest_body                objects.JSONRawMessage
	response_body                     *objects.JSONRawMessage
	appendresponse_body               objects.JSONRawMessage
	response_chunks                   *[]objects.JSONRawMessage
	appendresponse_chunks             []objects.JSONRawMessage
	error_message                     *string
	status                            *requestexecution.Status
	stream                            *bool
	metrics_latency_ms                *int64
	addmetrics_latency_ms             *int64
	metrics_first_token_latency_ms    *int64
	addmetrics_first_token_latency_ms *int64
	request_headers                   *objects.JSONRawMessage
	appendrequest_headers             objects.JSONRawMessage
	clearedFields                     map[string]struct{}
	request                           *int
	clearedrequest                    bool
	channel                           *int
	clearedchannel                    bool
	data_storage                      *int
	cleareddata_storage               bool
	done                              bool
	oldValue                          func(context.Context) (*RequestExecution, error)
	predicates                        []predicate.RequestExecution
}

var _ ent.Mutation = (*RequestExecutionMutation)(nil)

// requestexecutionOption allows management of the mutation configuration using functional options.
type requestexecutionOption func(*RequestExecutionMutation)

// newRequestExecutionMutation creates new mutation for the RequestExecution entity.
func newRequestExecutionMutation(c config, op Op, opts ...requestexecutionOption) *RequestExecutionMutation {
	m := &RequestExecutionMutation{
		config:        c,
		op:            op,
		typ:           TypeRequestExecution,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRequestExecutionID sets the ID field of the mutation.
func withRequestExecutionID(id int) requestexecutionOption {
	return func(m *RequestExecutionMutation) {
		var (
			err   error
			once  sync.Once
			value *RequestExecution
		)
		m.oldValue = func(ctx context.Context) (*RequestExecution, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RequestExecution.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRequestExecution sets the old RequestExecution of the mutation.
func withRequestExecution(node *RequestExecution) requestexecutionOption {
	return func(m *RequestExecutionMutation) {
		m.oldValue = func(context.Context) (*RequestExecution, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RequestExecutionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RequestExecutionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RequestExecutionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RequestExecutionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RequestExecution.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RequestExecutionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RequestExecutionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RequestExecution entity.
// If the RequestExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestExecutionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RequestExecutionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RequestExecutionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RequestExecutionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RequestExecution entity.
// If the RequestExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestExecutionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RequestExecutionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetProjectID sets the "project_id" field.
func (m *RequestExecutionMutation) SetProjectID(i int) {
	m.project_id = &i
	m.addproject_id = nil
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *RequestExecutionMutation) ProjectID() (r int, exists bool) {
	v := m.project_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the RequestExecution entity.
// If the RequestExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestExecutionMutation) OldProjectID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// AddProjectID adds i to the "project_id" field.
func (m *RequestExecutionMutation) AddProjectID(i int) {
	if m.addproject_id != nil {
		*m.addproject_id += i
	} else {
		m.addproject_id = &i
	}
}

// AddedProjectID returns the value that was added to the "project_id" field in this mutation.
func (m *RequestExecutionMutation) AddedProjectID() (r int, exists bool) {
	v := m.addproject_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *RequestExecutionMutation) ResetProjectID() {
	m.project_id = nil
	m.addproject_id = nil
}

// SetRequestID sets the "request_id" field.
func (m *RequestExecutionMutation) SetRequestID(i int) {
	m.request = &i
}

// RequestID returns the value of the "request_id" field in the mutation.
func (m *RequestExecutionMutation) RequestID() (r int, exists bool) {
	v := m.request
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestID returns the old "request_id" field's value of the RequestExecution entity.
// If the RequestExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestExecutionMutation) OldRequestID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestID: %w", err)
	}
	return oldValue.RequestID, nil
}

// ResetRequestID resets all changes to the "request_id" field.
func (m *RequestExecutionMutation) ResetRequestID() {
	m.request = nil
}

// SetChannelID sets the "channel_id" field.
func (m *RequestExecutionMutation) SetChannelID(i int) {
	m.channel = &i
}

// ChannelID returns the value of the "channel_id" field in the mutation.
func (m *RequestExecutionMutation) ChannelID() (r int, exists bool) {
	v := m.channel
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelID returns the old "channel_id" field's value of the RequestExecution entity.
// If the RequestExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestExecutionMutation) OldChannelID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelID: %w", err)
	}
	return oldValue.ChannelID, nil
}

// ClearChannelID clears the value of the "channel_id" field.
func (m *RequestExecutionMutation) ClearChannelID() {
	m.channel = nil
	m.clearedFields[requestexecution.FieldChannelID] = struct{}{}
}

// ChannelIDCleared returns if the "channel_id" field was cleared in this mutation.
func (m *RequestExecutionMutation) ChannelIDCleared() bool {
	_, ok := m.clearedFields[requestexecution.FieldChannelID]
	return ok
}

// ResetChannelID resets all changes to the "channel_id" field.
func (m *RequestExecutionMutation) ResetChannelID() {
	m.channel = nil
	delete(m.clearedFields, requestexecution.FieldChannelID)
}

// SetDataStorageID sets the "data_storage_id" field.
func (m *RequestExecutionMutation) SetDataStorageID(i int) {
	m.data_storage = &i
}

// DataStorageID returns the value of the "data_storage_id" field in the mutation.
func (m *RequestExecutionMutation) DataStorageID() (r int, exists bool) {
	v := m.data_storage
	if v == nil {
		return
	}
	return *v, true
}

// OldDataStorageID returns the old "data_storage_id" field's value of the RequestExecution entity.
// If the RequestExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestExecutionMutation) OldDataStorageID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDataStorageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDataStorageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDataStorageID: %w", err)
	}
	return oldValue.DataStorageID, nil
}

// ClearDataStorageID clears the value of the "data_storage_id" field.
func (m *RequestExecutionMutation) ClearDataStorageID() {
	m.data_storage = nil
	m.clearedFields[requestexecution.FieldDataStorageID] = struct{}{}
}

// DataStorageIDCleared returns if the "data_storage_id" field was cleared in this mutation.
func (m *RequestExecutionMutation) DataStorageIDCleared() bool {
	_, ok := m.clearedFields[requestexecution.FieldDataStorageID]
	return ok
}

// ResetDataStorageID resets all changes to the "data_storage_id" field.
func (m *RequestExecutionMutation) ResetDataStorageID() {
	m.data_storage = nil
	delete(m.clearedFields, requestexecution.FieldDataStorageID)
}

// SetExternalID sets the "external_id" field.
func (m *RequestExecutionMutation) SetExternalID(s string) {
	m.external_id = &s
}

// ExternalID returns the value of the "external_id" field in the mutation.
func (m *RequestExecutionMutation) ExternalID() (r string, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old "external_id" field's value of the RequestExecution entity.
// If the RequestExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestExecutionMutation) OldExternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// ClearExternalID clears the value of the "external_id" field.
func (m *RequestExecutionMutation) ClearExternalID() {
	m.external_id = nil
	m.clearedFields[requestexecution.FieldExternalID] = struct{}{}
}

// ExternalIDCleared returns if the "external_id" field was cleared in this mutation.
func (m *RequestExecutionMutation) ExternalIDCleared() bool {
	_, ok := m.clearedFields[requestexecution.FieldExternalID]
	return ok
}

// ResetExternalID resets all changes to the "external_id" field.
func (m *RequestExecutionMutation) ResetExternalID() {
	m.external_id = nil
	delete(m.clearedFields, requestexecution.FieldExternalID)
}

// SetModelID sets the "model_id" field.
func (m *RequestExecutionMutation) SetModelID(s string) {
	m.model_id = &s
}

// ModelID returns the value of the "model_id" field in the mutation.
func (m *RequestExecutionMutation) ModelID() (r string, exists bool) {
	v := m.model_id
	if v == nil {
		return
	}
	return *v, true
}

// OldModelID returns the old "model_id" field's value of the RequestExecution entity.
// If the RequestExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestExecutionMutation) OldModelID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModelID: %w", err)
	}
	return oldValue.ModelID, nil
}

// ResetModelID resets all changes to the "model_id" field.
func (m *RequestExecutionMutation) ResetModelID() {
	m.model_id = nil
}

// SetFormat sets the "format" field.
func (m *RequestExecutionMutation) SetFormat(s string) {
	m.format = &s
}

// Format returns the value of the "format" field in the mutation.
func (m *RequestExecutionMutation) Format() (r string, exists bool) {
	v := m.format
	if v == nil {
		return
	}
	return *v, true
}

// OldFormat returns the old "format" field's value of the RequestExecution entity.
// If the RequestExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestExecutionMutation) OldFormat(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFormat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFormat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormat: %w", err)
	}
	return oldValue.Format, nil
}

// ResetFormat resets all changes to the "format" field.
func (m *RequestExecutionMutation) ResetFormat() {
	m.format = nil
}

// SetRequestBody sets the "request_body" field.
func (m *RequestExecutionMutation) SetRequestBody(orm objects.JSONRawMessage) {
	m.request_body = &orm
	m.appendrequest_body = nil
}

// RequestBody returns the value of the "request_body" field in the mutation.
func (m *RequestExecutionMutation) RequestBody() (r objects.JSONRawMessage, exists bool) {
	v := m.request_body
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestBody returns the old "request_body" field's value of the RequestExecution entity.
// If the RequestExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestExecutionMutation) OldRequestBody(ctx context.Context) (v objects.JSONRawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestBody: %w", err)
	}
	return oldValue.RequestBody, nil
}

// AppendRequestBody adds orm to the "request_body" field.
func (m *RequestExecutionMutation) AppendRequestBody(orm objects.JSONRawMessage) {
	m.appendrequest_body = append(m.appendrequest_body, orm...)
}

// AppendedRequestBody returns the list of values that were appended to the "request_body" field in this mutation.
func (m *RequestExecutionMutation) AppendedRequestBody() (objects.JSONRawMessage, bool) {
	if len(m.appendrequest_body) == 0 {
		return nil, false
	}
	return m.appendrequest_body, true
}

// ResetRequestBody resets all changes to the "request_body" field.
func (m *RequestExecutionMutation) ResetRequestBody() {
	m.request_body = nil
	m.appendrequest_body = nil
}

// SetResponseBody sets the "response_body" field.
func (m *RequestExecutionMutation) SetResponseBody(orm objects.JSONRawMessage) {
	m.response_body = &orm
	m.appendresponse_body = nil
}

// ResponseBody returns the value of the "response_body" field in the mutation.
func (m *RequestExecutionMutation) ResponseBody() (r objects.JSONRawMessage, exists bool) {
	v := m.response_body
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseBody returns the old "response_body" field's value of the RequestExecution entity.
// If the RequestExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestExecutionMutation) OldResponseBody(ctx context.Context) (v objects.JSONRawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseBody: %w", err)
	}
	return oldValue.ResponseBody, nil
}

// AppendResponseBody adds orm to the "response_body" field.
func (m *RequestExecutionMutation) AppendResponseBody(orm objects.JSONRawMessage) {
	m.appendresponse_body = append(m.appendresponse_body, orm...)
}

// AppendedResponseBody returns the list of values that were appended to the "response_body" field in this mutation.
func (m *RequestExecutionMutation) AppendedResponseBody() (objects.JSONRawMessage, bool) {
	if len(m.appendresponse_body) == 0 {
		return nil, false
	}
	return m.appendresponse_body, true
}

// ClearResponseBody clears the value of the "response_body" field.
func (m *RequestExecutionMutation) ClearResponseBody() {
	m.response_body = nil
	m.appendresponse_body = nil
	m.clearedFields[requestexecution.FieldResponseBody] = struct{}{}
}

// ResponseBodyCleared returns if the "response_body" field was cleared in this mutation.
func (m *RequestExecutionMutation) ResponseBodyCleared() bool {
	_, ok := m.clearedFields[requestexecution.FieldResponseBody]
	return ok
}

// ResetResponseBody resets all changes to the "response_body" field.
func (m *RequestExecutionMutation) ResetResponseBody() {
	m.response_body = nil
	m.appendresponse_body = nil
	delete(m.clearedFields, requestexecution.FieldResponseBody)
}

// SetResponseChunks sets the "response_chunks" field.
func (m *RequestExecutionMutation) SetResponseChunks(orm []objects.JSONRawMessage) {
	m.response_chunks = &orm
	m.appendresponse_chunks = nil
}

// ResponseChunks returns the value of the "response_chunks" field in the mutation.
func (m *RequestExecutionMutation) ResponseChunks() (r []objects.JSONRawMessage, exists bool) {
	v := m.response_chunks
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseChunks returns the old "response_chunks" field's value of the RequestExecution entity.
// If the RequestExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestExecutionMutation) OldResponseChunks(ctx context.Context) (v []objects.JSONRawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseChunks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseChunks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseChunks: %w", err)
	}
	return oldValue.ResponseChunks, nil
}

// AppendResponseChunks adds orm to the "response_chunks" field.
func (m *RequestExecutionMutation) AppendResponseChunks(orm []objects.JSONRawMessage) {
	m.appendresponse_chunks = append(m.appendresponse_chunks, orm...)
}

// AppendedResponseChunks returns the list of values that were appended to the "response_chunks" field in this mutation.
func (m *RequestExecutionMutation) AppendedResponseChunks() ([]objects.JSONRawMessage, bool) {
	if len(m.appendresponse_chunks) == 0 {
		return nil, false
	}
	return m.appendresponse_chunks, true
}

// ClearResponseChunks clears the value of the "response_chunks" field.
func (m *RequestExecutionMutation) ClearResponseChunks() {
	m.response_chunks = nil
	m.appendresponse_chunks = nil
	m.clearedFields[requestexecution.FieldResponseChunks] = struct{}{}
}

// ResponseChunksCleared returns if the "response_chunks" field was cleared in this mutation.
func (m *RequestExecutionMutation) ResponseChunksCleared() bool {
	_, ok := m.clearedFields[requestexecution.FieldResponseChunks]
	return ok
}

// ResetResponseChunks resets all changes to the "response_chunks" field.
func (m *RequestExecutionMutation) ResetResponseChunks() {
	m.response_chunks = nil
	m.appendresponse_chunks = nil
	delete(m.clearedFields, requestexecution.FieldResponseChunks)
}

// SetErrorMessage sets the "error_message" field.
func (m *RequestExecutionMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *RequestExecutionMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the RequestExecution entity.
// If the RequestExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestExecutionMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *RequestExecutionMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[requestexecution.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *RequestExecutionMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[requestexecution.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *RequestExecutionMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, requestexecution.FieldErrorMessage)
}

// SetStatus sets the "status" field.
func (m *RequestExecutionMutation) SetStatus(r requestexecution.Status) {
	m.status = &r
}

// Status returns the value of the "status" field in the mutation.
func (m *RequestExecutionMutation) Status() (r requestexecution.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the RequestExecution entity.
// If the RequestExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestExecutionMutation) OldStatus(ctx context.Context) (v requestexecution.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *RequestExecutionMutation) ResetStatus() {
	m.status = nil
}

// SetStream sets the "stream" field.
func (m *RequestExecutionMutation) SetStream(b bool) {
	m.stream = &b
}

// Stream returns the value of the "stream" field in the mutation.
func (m *RequestExecutionMutation) Stream() (r bool, exists bool) {
	v := m.stream
	if v == nil {
		return
	}
	return *v, true
}

// OldStream returns the old "stream" field's value of the RequestExecution entity.
// If the RequestExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestExecutionMutation) OldStream(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStream is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStream requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStream: %w", err)
	}
	return oldValue.Stream, nil
}

// ResetStream resets all changes to the "stream" field.
func (m *RequestExecutionMutation) ResetStream() {
	m.stream = nil
}

// SetMetricsLatencyMs sets the "metrics_latency_ms" field.
func (m *RequestExecutionMutation) SetMetricsLatencyMs(i int64) {
	m.metrics_latency_ms = &i
	m.addmetrics_latency_ms = nil
}

// MetricsLatencyMs returns the value of the "metrics_latency_ms" field in the mutation.
func (m *RequestExecutionMutation) MetricsLatencyMs() (r int64, exists bool) {
	v := m.metrics_latency_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldMetricsLatencyMs returns the old "metrics_latency_ms" field's value of the RequestExecution entity.
// If the RequestExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestExecutionMutation) OldMetricsLatencyMs(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetricsLatencyMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetricsLatencyMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetricsLatencyMs: %w", err)
	}
	return oldValue.MetricsLatencyMs, nil
}

// AddMetricsLatencyMs adds i to the "metrics_latency_ms" field.
func (m *RequestExecutionMutation) AddMetricsLatencyMs(i int64) {
	if m.addmetrics_latency_ms != nil {
		*m.addmetrics_latency_ms += i
	} else {
		m.addmetrics_latency_ms = &i
	}
}

// AddedMetricsLatencyMs returns the value that was added to the "metrics_latency_ms" field in this mutation.
func (m *RequestExecutionMutation) AddedMetricsLatencyMs() (r int64, exists bool) {
	v := m.addmetrics_latency_ms
	if v == nil {
		return
	}
	return *v, true
}

// ClearMetricsLatencyMs clears the value of the "metrics_latency_ms" field.
func (m *RequestExecutionMutation) ClearMetricsLatencyMs() {
	m.metrics_latency_ms = nil
	m.addmetrics_latency_ms = nil
	m.clearedFields[requestexecution.FieldMetricsLatencyMs] = struct{}{}
}

// MetricsLatencyMsCleared returns if the "metrics_latency_ms" field was cleared in this mutation.
func (m *RequestExecutionMutation) MetricsLatencyMsCleared() bool {
	_, ok := m.clearedFields[requestexecution.FieldMetricsLatencyMs]
	return ok
}

// ResetMetricsLatencyMs resets all changes to the "metrics_latency_ms" field.
func (m *RequestExecutionMutation) ResetMetricsLatencyMs() {
	m.metrics_latency_ms = nil
	m.addmetrics_latency_ms = nil
	delete(m.clearedFields, requestexecution.FieldMetricsLatencyMs)
}

// SetMetricsFirstTokenLatencyMs sets the "metrics_first_token_latency_ms" field.
func (m *RequestExecutionMutation) SetMetricsFirstTokenLatencyMs(i int64) {
	m.metrics_first_token_latency_ms = &i
	m.addmetrics_first_token_latency_ms = nil
}

// MetricsFirstTokenLatencyMs returns the value of the "metrics_first_token_latency_ms" field in the mutation.
func (m *RequestExecutionMutation) MetricsFirstTokenLatencyMs() (r int64, exists bool) {
	v := m.metrics_first_token_latency_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldMetricsFirstTokenLatencyMs returns the old "metrics_first_token_latency_ms" field's value of the RequestExecution entity.
// If the RequestExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestExecutionMutation) OldMetricsFirstTokenLatencyMs(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetricsFirstTokenLatencyMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetricsFirstTokenLatencyMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetricsFirstTokenLatencyMs: %w", err)
	}
	return oldValue.MetricsFirstTokenLatencyMs, nil
}

// AddMetricsFirstTokenLatencyMs adds i to the "metrics_first_token_latency_ms" field.
func (m *RequestExecutionMutation) AddMetricsFirstTokenLatencyMs(i int64) {
	if m.addmetrics_first_token_latency_ms != nil {
		*m.addmetrics_first_token_latency_ms += i
	} else {
		m.addmetrics_first_token_latency_ms = &i
	}
}

// AddedMetricsFirstTokenLatencyMs returns the value that was added to the "metrics_first_token_latency_ms" field in this mutation.
func (m *RequestExecutionMutation) AddedMetricsFirstTokenLatencyMs() (r int64, exists bool) {
	v := m.addmetrics_first_token_latency_ms
	if v == nil {
		return
	}
	return *v, true
}

// ClearMetricsFirstTokenLatencyMs clears the value of the "metrics_first_token_latency_ms" field.
func (m *RequestExecutionMutation) ClearMetricsFirstTokenLatencyMs() {
	m.metrics_first_token_latency_ms = nil
	m.addmetrics_first_token_latency_ms = nil
	m.clearedFields[requestexecution.FieldMetricsFirstTokenLatencyMs] = struct{}{}
}

// MetricsFirstTokenLatencyMsCleared returns if the "metrics_first_token_latency_ms" field was cleared in this mutation.
func (m *RequestExecutionMutation) MetricsFirstTokenLatencyMsCleared() bool {
	_, ok := m.clearedFields[requestexecution.FieldMetricsFirstTokenLatencyMs]
	return ok
}

// ResetMetricsFirstTokenLatencyMs resets all changes to the "metrics_first_token_latency_ms" field.
func (m *RequestExecutionMutation) ResetMetricsFirstTokenLatencyMs() {
	m.metrics_first_token_latency_ms = nil
	m.addmetrics_first_token_latency_ms = nil
	delete(m.clearedFields, requestexecution.FieldMetricsFirstTokenLatencyMs)
}

// SetRequestHeaders sets the "request_headers" field.
func (m *RequestExecutionMutation) SetRequestHeaders(orm objects.JSONRawMessage) {
	m.request_headers = &orm
	m.appendrequest_headers = nil
}

// RequestHeaders returns the value of the "request_headers" field in the mutation.
func (m *RequestExecutionMutation) RequestHeaders() (r objects.JSONRawMessage, exists bool) {
	v := m.request_headers
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestHeaders returns the old "request_headers" field's value of the RequestExecution entity.
// If the RequestExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestExecutionMutation) OldRequestHeaders(ctx context.Context) (v objects.JSONRawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestHeaders is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestHeaders requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestHeaders: %w", err)
	}
	return oldValue.RequestHeaders, nil
}

// AppendRequestHeaders adds orm to the "request_headers" field.
func (m *RequestExecutionMutation) AppendRequestHeaders(orm objects.JSONRawMessage) {
	m.appendrequest_headers = append(m.appendrequest_headers, orm...)
}

// AppendedRequestHeaders returns the list of values that were appended to the "request_headers" field in this mutation.
func (m *RequestExecutionMutation) AppendedRequestHeaders() (objects.JSONRawMessage, bool) {
	if len(m.appendrequest_headers) == 0 {
		return nil, false
	}
	return m.appendrequest_headers, true
}

// ClearRequestHeaders clears the value of the "request_headers" field.
func (m *RequestExecutionMutation) ClearRequestHeaders() {
	m.request_headers = nil
	m.appendrequest_headers = nil
	m.clearedFields[requestexecution.FieldRequestHeaders] = struct{}{}
}

// RequestHeadersCleared returns if the "request_headers" field was cleared in this mutation.
func (m *RequestExecutionMutation) RequestHeadersCleared() bool {
	_, ok := m.clearedFields[requestexecution.FieldRequestHeaders]
	return ok
}

// ResetRequestHeaders resets all changes to the "request_headers" field.
func (m *RequestExecutionMutation) ResetRequestHeaders() {
	m.request_headers = nil
	m.appendrequest_headers = nil
	delete(m.clearedFields, requestexecution.FieldRequestHeaders)
}

// ClearRequest clears the "request" edge to the Request entity.
func (m *RequestExecutionMutation) ClearRequest() {
	m.clearedrequest = true
	m.clearedFields[requestexecution.FieldRequestID] = struct{}{}
}

// RequestCleared reports if the "request" edge to the Request entity was cleared.
func (m *RequestExecutionMutation) RequestCleared() bool {
	return m.clearedrequest
}

// RequestIDs returns the "request" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RequestID instead. It exists only for internal usage by the builders.
func (m *RequestExecutionMutation) RequestIDs() (ids []int) {
	if id := m.request; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRequest resets all changes to the "request" edge.
func (m *RequestExecutionMutation) ResetRequest() {
	m.request = nil
	m.clearedrequest = false
}

// ClearChannel clears the "channel" edge to the Channel entity.
func (m *RequestExecutionMutation) ClearChannel() {
	m.clearedchannel = true
	m.clearedFields[requestexecution.FieldChannelID] = struct{}{}
}

// ChannelCleared reports if the "channel" edge to the Channel entity was cleared.
func (m *RequestExecutionMutation) ChannelCleared() bool {
	return m.ChannelIDCleared() || m.clearedchannel
}

// ChannelIDs returns the "channel" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChannelID instead. It exists only for internal usage by the builders.
func (m *RequestExecutionMutation) ChannelIDs() (ids []int) {
	if id := m.channel; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChannel resets all changes to the "channel" edge.
func (m *RequestExecutionMutation) ResetChannel() {
	m.channel = nil
	m.clearedchannel = false
}

// ClearDataStorage clears the "data_storage" edge to the DataStorage entity.
func (m *RequestExecutionMutation) ClearDataStorage() {
	m.cleareddata_storage = true
	m.clearedFields[requestexecution.FieldDataStorageID] = struct{}{}
}

// DataStorageCleared reports if the "data_storage" edge to the DataStorage entity was cleared.
func (m *RequestExecutionMutation) DataStorageCleared() bool {
	return m.DataStorageIDCleared() || m.cleareddata_storage
}

// DataStorageIDs returns the "data_storage" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DataStorageID instead. It exists only for internal usage by the builders.
func (m *RequestExecutionMutation) DataStorageIDs() (ids []int) {
	if id := m.data_storage; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDataStorage resets all changes to the "data_storage" edge.
func (m *RequestExecutionMutation) ResetDataStorage() {
	m.data_storage = nil
	m.cleareddata_storage = false
}

// Where appends a list predicates to the RequestExecutionMutation builder.
func (m *RequestExecutionMutation) Where(ps ...predicate.RequestExecution) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RequestExecutionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RequestExecutionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RequestExecution, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RequestExecutionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RequestExecutionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RequestExecution).
func (m *RequestExecutionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RequestExecutionMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.created_at != nil {
		fields = append(fields, requestexecution.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, requestexecution.FieldUpdatedAt)
	}
	if m.project_id != nil {
		fields = append(fields, requestexecution.FieldProjectID)
	}
	if m.request != nil {
		fields = append(fields, requestexecution.FieldRequestID)
	}
	if m.channel != nil {
		fields = append(fields, requestexecution.FieldChannelID)
	}
	if m.data_storage != nil {
		fields = append(fields, requestexecution.FieldDataStorageID)
	}
	if m.external_id != nil {
		fields = append(fields, requestexecution.FieldExternalID)
	}
	if m.model_id != nil {
		fields = append(fields, requestexecution.FieldModelID)
	}
	if m.format != nil {
		fields = append(fields, requestexecution.FieldFormat)
	}
	if m.request_body != nil {
		fields = append(fields, requestexecution.FieldRequestBody)
	}
	if m.response_body != nil {
		fields = append(fields, requestexecution.FieldResponseBody)
	}
	if m.response_chunks != nil {
		fields = append(fields, requestexecution.FieldResponseChunks)
	}
	if m.error_message != nil {
		fields = append(fields, requestexecution.FieldErrorMessage)
	}
	if m.status != nil {
		fields = append(fields, requestexecution.FieldStatus)
	}
	if m.stream != nil {
		fields = append(fields, requestexecution.FieldStream)
	}
	if m.metrics_latency_ms != nil {
		fields = append(fields, requestexecution.FieldMetricsLatencyMs)
	}
	if m.metrics_first_token_latency_ms != nil {
		fields = append(fields, requestexecution.FieldMetricsFirstTokenLatencyMs)
	}
	if m.request_headers != nil {
		fields = append(fields, requestexecution.FieldRequestHeaders)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RequestExecutionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case requestexecution.FieldCreatedAt:
		return m.CreatedAt()
	case requestexecution.FieldUpdatedAt:
		return m.UpdatedAt()
	case requestexecution.FieldProjectID:
		return m.ProjectID()
	case requestexecution.FieldRequestID:
		return m.RequestID()
	case requestexecution.FieldChannelID:
		return m.ChannelID()
	case requestexecution.FieldDataStorageID:
		return m.DataStorageID()
	case requestexecution.FieldExternalID:
		return m.ExternalID()
	case requestexecution.FieldModelID:
		return m.ModelID()
	case requestexecution.FieldFormat:
		return m.Format()
	case requestexecution.FieldRequestBody:
		return m.RequestBody()
	case requestexecution.FieldResponseBody:
		return m.ResponseBody()
	case requestexecution.FieldResponseChunks:
		return m.ResponseChunks()
	case requestexecution.FieldErrorMessage:
		return m.ErrorMessage()
	case requestexecution.FieldStatus:
		return m.Status()
	case requestexecution.FieldStream:
		return m.Stream()
	case requestexecution.FieldMetricsLatencyMs:
		return m.MetricsLatencyMs()
	case requestexecution.FieldMetricsFirstTokenLatencyMs:
		return m.MetricsFirstTokenLatencyMs()
	case requestexecution.FieldRequestHeaders:
		return m.RequestHeaders()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RequestExecutionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case requestexecution.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case requestexecution.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case requestexecution.FieldProjectID:
		return m.OldProjectID(ctx)
	case requestexecution.FieldRequestID:
		return m.OldRequestID(ctx)
	case requestexecution.FieldChannelID:
		return m.OldChannelID(ctx)
	case requestexecution.FieldDataStorageID:
		return m.OldDataStorageID(ctx)
	case requestexecution.FieldExternalID:
		return m.OldExternalID(ctx)
	case requestexecution.FieldModelID:
		return m.OldModelID(ctx)
	case requestexecution.FieldFormat:
		return m.OldFormat(ctx)
	case requestexecution.FieldRequestBody:
		return m.OldRequestBody(ctx)
	case requestexecution.FieldResponseBody:
		return m.OldResponseBody(ctx)
	case requestexecution.FieldResponseChunks:
		return m.OldResponseChunks(ctx)
	case requestexecution.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case requestexecution.FieldStatus:
		return m.OldStatus(ctx)
	case requestexecution.FieldStream:
		return m.OldStream(ctx)
	case requestexecution.FieldMetricsLatencyMs:
		return m.OldMetricsLatencyMs(ctx)
	case requestexecution.FieldMetricsFirstTokenLatencyMs:
		return m.OldMetricsFirstTokenLatencyMs(ctx)
	case requestexecution.FieldRequestHeaders:
		return m.OldRequestHeaders(ctx)
	}
	return nil, fmt.Errorf("unknown RequestExecution field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RequestExecutionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case requestexecution.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case requestexecution.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case requestexecution.FieldProjectID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case requestexecution.FieldRequestID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestID(v)
		return nil
	case requestexecution.FieldChannelID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelID(v)
		return nil
	case requestexecution.FieldDataStorageID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDataStorageID(v)
		return nil
	case requestexecution.FieldExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	case requestexecution.FieldModelID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModelID(v)
		return nil
	case requestexecution.FieldFormat:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormat(v)
		return nil
	case requestexecution.FieldRequestBody:
		v, ok := value.(objects.JSONRawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestBody(v)
		return nil
	case requestexecution.FieldResponseBody:
		v, ok := value.(objects.JSONRawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseBody(v)
		return nil
	case requestexecution.FieldResponseChunks:
		v, ok := value.([]objects.JSONRawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseChunks(v)
		return nil
	case requestexecution.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case requestexecution.FieldStatus:
		v, ok := value.(requestexecution.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case requestexecution.FieldStream:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStream(v)
		return nil
	case requestexecution.FieldMetricsLatencyMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetricsLatencyMs(v)
		return nil
	case requestexecution.FieldMetricsFirstTokenLatencyMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetricsFirstTokenLatencyMs(v)
		return nil
	case requestexecution.FieldRequestHeaders:
		v, ok := value.(objects.JSONRawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestHeaders(v)
		return nil
	}
	return fmt.Errorf("unknown RequestExecution field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RequestExecutionMutation) AddedFields() []string {
	var fields []string
	if m.addproject_id != nil {
		fields = append(fields, requestexecution.FieldProjectID)
	}
	if m.addmetrics_latency_ms != nil {
		fields = append(fields, requestexecution.FieldMetricsLatencyMs)
	}
	if m.addmetrics_first_token_latency_ms != nil {
		fields = append(fields, requestexecution.FieldMetricsFirstTokenLatencyMs)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RequestExecutionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case requestexecution.FieldProjectID:
		return m.AddedProjectID()
	case requestexecution.FieldMetricsLatencyMs:
		return m.AddedMetricsLatencyMs()
	case requestexecution.FieldMetricsFirstTokenLatencyMs:
		return m.AddedMetricsFirstTokenLatencyMs()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RequestExecutionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case requestexecution.FieldProjectID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProjectID(v)
		return nil
	case requestexecution.FieldMetricsLatencyMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMetricsLatencyMs(v)
		return nil
	case requestexecution.FieldMetricsFirstTokenLatencyMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMetricsFirstTokenLatencyMs(v)
		return nil
	}
	return fmt.Errorf("unknown RequestExecution numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RequestExecutionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(requestexecution.FieldChannelID) {
		fields = append(fields, requestexecution.FieldChannelID)
	}
	if m.FieldCleared(requestexecution.FieldDataStorageID) {
		fields = append(fields, requestexecution.FieldDataStorageID)
	}
	if m.FieldCleared(requestexecution.FieldExternalID) {
		fields = append(fields, requestexecution.FieldExternalID)
	}
	if m.FieldCleared(requestexecution.FieldResponseBody) {
		fields = append(fields, requestexecution.FieldResponseBody)
	}
	if m.FieldCleared(requestexecution.FieldResponseChunks) {
		fields = append(fields, requestexecution.FieldResponseChunks)
	}
	if m.FieldCleared(requestexecution.FieldErrorMessage) {
		fields = append(fields, requestexecution.FieldErrorMessage)
	}
	if m.FieldCleared(requestexecution.FieldMetricsLatencyMs) {
		fields = append(fields, requestexecution.FieldMetricsLatencyMs)
	}
	if m.FieldCleared(requestexecution.FieldMetricsFirstTokenLatencyMs) {
		fields = append(fields, requestexecution.FieldMetricsFirstTokenLatencyMs)
	}
	if m.FieldCleared(requestexecution.FieldRequestHeaders) {
		fields = append(fields, requestexecution.FieldRequestHeaders)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RequestExecutionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RequestExecutionMutation) ClearField(name string) error {
	switch name {
	case requestexecution.FieldChannelID:
		m.ClearChannelID()
		return nil
	case requestexecution.FieldDataStorageID:
		m.ClearDataStorageID()
		return nil
	case requestexecution.FieldExternalID:
		m.ClearExternalID()
		return nil
	case requestexecution.FieldResponseBody:
		m.ClearResponseBody()
		return nil
	case requestexecution.FieldResponseChunks:
		m.ClearResponseChunks()
		return nil
	case requestexecution.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	case requestexecution.FieldMetricsLatencyMs:
		m.ClearMetricsLatencyMs()
		return nil
	case requestexecution.FieldMetricsFirstTokenLatencyMs:
		m.ClearMetricsFirstTokenLatencyMs()
		return nil
	case requestexecution.FieldRequestHeaders:
		m.ClearRequestHeaders()
		return nil
	}
	return fmt.Errorf("unknown RequestExecution nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RequestExecutionMutation) ResetField(name string) error {
	switch name {
	case requestexecution.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case requestexecution.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case requestexecution.FieldProjectID:
		m.ResetProjectID()
		return nil
	case requestexecution.FieldRequestID:
		m.ResetRequestID()
		return nil
	case requestexecution.FieldChannelID:
		m.ResetChannelID()
		return nil
	case requestexecution.FieldDataStorageID:
		m.ResetDataStorageID()
		return nil
	case requestexecution.FieldExternalID:
		m.ResetExternalID()
		return nil
	case requestexecution.FieldModelID:
		m.ResetModelID()
		return nil
	case requestexecution.FieldFormat:
		m.ResetFormat()
		return nil
	case requestexecution.FieldRequestBody:
		m.ResetRequestBody()
		return nil
	case requestexecution.FieldResponseBody:
		m.ResetResponseBody()
		return nil
	case requestexecution.FieldResponseChunks:
		m.ResetResponseChunks()
		return nil
	case requestexecution.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case requestexecution.FieldStatus:
		m.ResetStatus()
		return nil
	case requestexecution.FieldStream:
		m.ResetStream()
		return nil
	case requestexecution.FieldMetricsLatencyMs:
		m.ResetMetricsLatencyMs()
		return nil
	case requestexecution.FieldMetricsFirstTokenLatencyMs:
		m.ResetMetricsFirstTokenLatencyMs()
		return nil
	case requestexecution.FieldRequestHeaders:
		m.ResetRequestHeaders()
		return nil
	}
	return fmt.Errorf("unknown RequestExecution field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RequestExecutionMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.request != nil {
		edges = append(edges, requestexecution.EdgeRequest)
	}
	if m.channel != nil {
		edges = append(edges, requestexecution.EdgeChannel)
	}
	if m.data_storage != nil {
		edges = append(edges, requestexecution.EdgeDataStorage)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RequestExecutionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case requestexecution.EdgeRequest:
		if id := m.request; id != nil {
			return []ent.Value{*id}
		}
	case requestexecution.EdgeChannel:
		if id := m.channel; id != nil {
			return []ent.Value{*id}
		}
	case requestexecution.EdgeDataStorage:
		if id := m.data_storage; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RequestExecutionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RequestExecutionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RequestExecutionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedrequest {
		edges = append(edges, requestexecution.EdgeRequest)
	}
	if m.clearedchannel {
		edges = append(edges, requestexecution.EdgeChannel)
	}
	if m.cleareddata_storage {
		edges = append(edges, requestexecution.EdgeDataStorage)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RequestExecutionMutation) EdgeCleared(name string) bool {
	switch name {
	case requestexecution.EdgeRequest:
		return m.clearedrequest
	case requestexecution.EdgeChannel:
		return m.clearedchannel
	case requestexecution.EdgeDataStorage:
		return m.cleareddata_storage
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RequestExecutionMutation) ClearEdge(name string) error {
	switch name {
	case requestexecution.EdgeRequest:
		m.ClearRequest()
		return nil
	case requestexecution.EdgeChannel:
		m.ClearChannel()
		return nil
	case requestexecution.EdgeDataStorage:
		m.ClearDataStorage()
		return nil
	}
	return fmt.Errorf("unknown RequestExecution unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RequestExecutionMutation) ResetEdge(name string) error {
	switch name {
	case requestexecution.EdgeRequest:
		m.ResetRequest()
		return nil
	case requestexecution.EdgeChannel:
		m.ResetChannel()
		return nil
	case requestexecution.EdgeDataStorage:
		m.ResetDataStorage()
		return nil
	}
	return fmt.Errorf("unknown RequestExecution edge %s", name)
}

// RoleMutation represents an operation that mutates the Role nodes in the graph.
type RoleMutation struct {
	config
	op                Op
	typ               string
	id                *int
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *int
	adddeleted_at     *int
	name              *string
	level             *role.Level
	scopes            *[]string
	appendscopes      []string
	clearedFields     map[string]struct{}
	users             map[int]struct{}
	removedusers      map[int]struct{}
	clearedusers      bool
	project           *int
	clearedproject    bool
	user_roles        map[int]struct{}
	removeduser_roles map[int]struct{}
	cleareduser_roles bool
	done              bool
	oldValue          func(context.Context) (*Role, error)
	predicates        []predicate.Role
}

var _ ent.Mutation = (*RoleMutation)(nil)

// roleOption allows management of the mutation configuration using functional options.
type roleOption func(*RoleMutation)

// newRoleMutation creates new mutation for the Role entity.
func newRoleMutation(c config, op Op, opts ...roleOption) *RoleMutation {
	m := &RoleMutation{
		config:        c,
		op:            op,
		typ:           TypeRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleID sets the ID field of the mutation.
func withRoleID(id int) roleOption {
	return func(m *RoleMutation) {
		var (
			err   error
			once  sync.Once
			value *Role
		)
		m.oldValue = func(ctx context.Context) (*Role, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Role.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRole sets the old Role of the mutation.
func withRole(node *Role) roleOption {
	return func(m *RoleMutation) {
		m.oldValue = func(context.Context) (*Role, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Role.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RoleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RoleMutation) SetDeletedAt(i int) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RoleMutation) DeletedAt() (r int, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldDeletedAt(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *RoleMutation) AddDeletedAt(i int) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *RoleMutation) AddedDeletedAt() (r int, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RoleMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetName sets the "name" field.
func (m *RoleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RoleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RoleMutation) ResetName() {
	m.name = nil
}

// SetLevel sets the "level" field.
func (m *RoleMutation) SetLevel(r role.Level) {
	m.level = &r
}

// Level returns the value of the "level" field in the mutation.
func (m *RoleMutation) Level() (r role.Level, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldLevel(ctx context.Context) (v role.Level, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// ResetLevel resets all changes to the "level" field.
func (m *RoleMutation) ResetLevel() {
	m.level = nil
}

// SetProjectID sets the "project_id" field.
func (m *RoleMutation) SetProjectID(i int) {
	m.project = &i
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *RoleMutation) ProjectID() (r int, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldProjectID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ClearProjectID clears the value of the "project_id" field.
func (m *RoleMutation) ClearProjectID() {
	m.project = nil
	m.clearedFields[role.FieldProjectID] = struct{}{}
}

// ProjectIDCleared returns if the "project_id" field was cleared in this mutation.
func (m *RoleMutation) ProjectIDCleared() bool {
	_, ok := m.clearedFields[role.FieldProjectID]
	return ok
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *RoleMutation) ResetProjectID() {
	m.project = nil
	delete(m.clearedFields, role.FieldProjectID)
}

// SetScopes sets the "scopes" field.
func (m *RoleMutation) SetScopes(s []string) {
	m.scopes = &s
	m.appendscopes = nil
}

// Scopes returns the value of the "scopes" field in the mutation.
func (m *RoleMutation) Scopes() (r []string, exists bool) {
	v := m.scopes
	if v == nil {
		return
	}
	return *v, true
}

// OldScopes returns the old "scopes" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldScopes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopes: %w", err)
	}
	return oldValue.Scopes, nil
}

// AppendScopes adds s to the "scopes" field.
func (m *RoleMutation) AppendScopes(s []string) {
	m.appendscopes = append(m.appendscopes, s...)
}

// AppendedScopes returns the list of values that were appended to the "scopes" field in this mutation.
func (m *RoleMutation) AppendedScopes() ([]string, bool) {
	if len(m.appendscopes) == 0 {
		return nil, false
	}
	return m.appendscopes, true
}

// ClearScopes clears the value of the "scopes" field.
func (m *RoleMutation) ClearScopes() {
	m.scopes = nil
	m.appendscopes = nil
	m.clearedFields[role.FieldScopes] = struct{}{}
}

// ScopesCleared returns if the "scopes" field was cleared in this mutation.
func (m *RoleMutation) ScopesCleared() bool {
	_, ok := m.clearedFields[role.FieldScopes]
	return ok
}

// ResetScopes resets all changes to the "scopes" field.
func (m *RoleMutation) ResetScopes() {
	m.scopes = nil
	m.appendscopes = nil
	delete(m.clearedFields, role.FieldScopes)
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *RoleMutation) AddUserIDs(ids ...int) {
	if m.users == nil {
		m.users = make(map[int]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *RoleMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *RoleMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *RoleMutation) RemoveUserIDs(ids ...int) {
	if m.removedusers == nil {
		m.removedusers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *RoleMutation) RemovedUsersIDs() (ids []int) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *RoleMutation) UsersIDs() (ids []int) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *RoleMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// ClearProject clears the "project" edge to the Project entity.
func (m *RoleMutation) ClearProject() {
	m.clearedproject = true
	m.clearedFields[role.FieldProjectID] = struct{}{}
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *RoleMutation) ProjectCleared() bool {
	return m.ProjectIDCleared() || m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *RoleMutation) ProjectIDs() (ids []int) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *RoleMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// AddUserRoleIDs adds the "user_roles" edge to the UserRole entity by ids.
func (m *RoleMutation) AddUserRoleIDs(ids ...int) {
	if m.user_roles == nil {
		m.user_roles = make(map[int]struct{})
	}
	for i := range ids {
		m.user_roles[ids[i]] = struct{}{}
	}
}

// ClearUserRoles clears the "user_roles" edge to the UserRole entity.
func (m *RoleMutation) ClearUserRoles() {
	m.cleareduser_roles = true
}

// UserRolesCleared reports if the "user_roles" edge to the UserRole entity was cleared.
func (m *RoleMutation) UserRolesCleared() bool {
	return m.cleareduser_roles
}

// RemoveUserRoleIDs removes the "user_roles" edge to the UserRole entity by IDs.
func (m *RoleMutation) RemoveUserRoleIDs(ids ...int) {
	if m.removeduser_roles == nil {
		m.removeduser_roles = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user_roles, ids[i])
		m.removeduser_roles[ids[i]] = struct{}{}
	}
}

// RemovedUserRoles returns the removed IDs of the "user_roles" edge to the UserRole entity.
func (m *RoleMutation) RemovedUserRolesIDs() (ids []int) {
	for id := range m.removeduser_roles {
		ids = append(ids, id)
	}
	return
}

// UserRolesIDs returns the "user_roles" edge IDs in the mutation.
func (m *RoleMutation) UserRolesIDs() (ids []int) {
	for id := range m.user_roles {
		ids = append(ids, id)
	}
	return
}

// ResetUserRoles resets all changes to the "user_roles" edge.
func (m *RoleMutation) ResetUserRoles() {
	m.user_roles = nil
	m.cleareduser_roles = false
	m.removeduser_roles = nil
}

// Where appends a list predicates to the RoleMutation builder.
func (m *RoleMutation) Where(ps ...predicate.Role) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Role, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Role).
func (m *RoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, role.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, role.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, role.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, role.FieldName)
	}
	if m.level != nil {
		fields = append(fields, role.FieldLevel)
	}
	if m.project != nil {
		fields = append(fields, role.FieldProjectID)
	}
	if m.scopes != nil {
		fields = append(fields, role.FieldScopes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case role.FieldCreatedAt:
		return m.CreatedAt()
	case role.FieldUpdatedAt:
		return m.UpdatedAt()
	case role.FieldDeletedAt:
		return m.DeletedAt()
	case role.FieldName:
		return m.Name()
	case role.FieldLevel:
		return m.Level()
	case role.FieldProjectID:
		return m.ProjectID()
	case role.FieldScopes:
		return m.Scopes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case role.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case role.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case role.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case role.FieldName:
		return m.OldName(ctx)
	case role.FieldLevel:
		return m.OldLevel(ctx)
	case role.FieldProjectID:
		return m.OldProjectID(ctx)
	case role.FieldScopes:
		return m.OldScopes(ctx)
	}
	return nil, fmt.Errorf("unknown Role field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case role.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case role.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case role.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case role.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case role.FieldLevel:
		v, ok := value.(role.Level)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case role.FieldProjectID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case role.FieldScopes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopes(v)
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, role.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case role.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case role.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Role numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(role.FieldProjectID) {
		fields = append(fields, role.FieldProjectID)
	}
	if m.FieldCleared(role.FieldScopes) {
		fields = append(fields, role.FieldScopes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleMutation) ClearField(name string) error {
	switch name {
	case role.FieldProjectID:
		m.ClearProjectID()
		return nil
	case role.FieldScopes:
		m.ClearScopes()
		return nil
	}
	return fmt.Errorf("unknown Role nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleMutation) ResetField(name string) error {
	switch name {
	case role.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case role.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case role.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case role.FieldName:
		m.ResetName()
		return nil
	case role.FieldLevel:
		m.ResetLevel()
		return nil
	case role.FieldProjectID:
		m.ResetProjectID()
		return nil
	case role.FieldScopes:
		m.ResetScopes()
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.users != nil {
		edges = append(edges, role.EdgeUsers)
	}
	if m.project != nil {
		edges = append(edges, role.EdgeProject)
	}
	if m.user_roles != nil {
		edges = append(edges, role.EdgeUserRoles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case role.EdgeUserRoles:
		ids := make([]ent.Value, 0, len(m.user_roles))
		for id := range m.user_roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedusers != nil {
		edges = append(edges, role.EdgeUsers)
	}
	if m.removeduser_roles != nil {
		edges = append(edges, role.EdgeUserRoles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeUserRoles:
		ids := make([]ent.Value, 0, len(m.removeduser_roles))
		for id := range m.removeduser_roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedusers {
		edges = append(edges, role.EdgeUsers)
	}
	if m.clearedproject {
		edges = append(edges, role.EdgeProject)
	}
	if m.cleareduser_roles {
		edges = append(edges, role.EdgeUserRoles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleMutation) EdgeCleared(name string) bool {
	switch name {
	case role.EdgeUsers:
		return m.clearedusers
	case role.EdgeProject:
		return m.clearedproject
	case role.EdgeUserRoles:
		return m.cleareduser_roles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleMutation) ClearEdge(name string) error {
	switch name {
	case role.EdgeProject:
		m.ClearProject()
		return nil
	}
	return fmt.Errorf("unknown Role unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleMutation) ResetEdge(name string) error {
	switch name {
	case role.EdgeUsers:
		m.ResetUsers()
		return nil
	case role.EdgeProject:
		m.ResetProject()
		return nil
	case role.EdgeUserRoles:
		m.ResetUserRoles()
		return nil
	}
	return fmt.Errorf("unknown Role edge %s", name)
}

// SystemMutation represents an operation that mutates the System nodes in the graph.
type SystemMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *int
	adddeleted_at *int
	key           *string
	value         *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*System, error)
	predicates    []predicate.System
}

var _ ent.Mutation = (*SystemMutation)(nil)

// systemOption allows management of the mutation configuration using functional options.
type systemOption func(*SystemMutation)

// newSystemMutation creates new mutation for the System entity.
func newSystemMutation(c config, op Op, opts ...systemOption) *SystemMutation {
	m := &SystemMutation{
		config:        c,
		op:            op,
		typ:           TypeSystem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSystemID sets the ID field of the mutation.
func withSystemID(id int) systemOption {
	return func(m *SystemMutation) {
		var (
			err   error
			once  sync.Once
			value *System
		)
		m.oldValue = func(ctx context.Context) (*System, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().System.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSystem sets the old System of the mutation.
func withSystem(node *System) systemOption {
	return func(m *SystemMutation) {
		m.oldValue = func(context.Context) (*System, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SystemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SystemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SystemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SystemMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().System.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SystemMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SystemMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the System entity.
// If the System object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SystemMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SystemMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SystemMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the System entity.
// If the System object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SystemMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SystemMutation) SetDeletedAt(i int) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SystemMutation) DeletedAt() (r int, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the System entity.
// If the System object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemMutation) OldDeletedAt(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *SystemMutation) AddDeletedAt(i int) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *SystemMutation) AddedDeletedAt() (r int, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SystemMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetKey sets the "key" field.
func (m *SystemMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *SystemMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the System entity.
// If the System object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *SystemMutation) ResetKey() {
	m.key = nil
}

// SetValue sets the "value" field.
func (m *SystemMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *SystemMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the System entity.
// If the System object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *SystemMutation) ResetValue() {
	m.value = nil
}

// Where appends a list predicates to the SystemMutation builder.
func (m *SystemMutation) Where(ps ...predicate.System) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SystemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SystemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.System, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SystemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SystemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (System).
func (m *SystemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SystemMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, system.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, system.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, system.FieldDeletedAt)
	}
	if m.key != nil {
		fields = append(fields, system.FieldKey)
	}
	if m.value != nil {
		fields = append(fields, system.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SystemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case system.FieldCreatedAt:
		return m.CreatedAt()
	case system.FieldUpdatedAt:
		return m.UpdatedAt()
	case system.FieldDeletedAt:
		return m.DeletedAt()
	case system.FieldKey:
		return m.Key()
	case system.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SystemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case system.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case system.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case system.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case system.FieldKey:
		return m.OldKey(ctx)
	case system.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown System field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case system.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case system.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case system.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case system.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case system.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown System field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SystemMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, system.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SystemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case system.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case system.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown System numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SystemMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SystemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SystemMutation) ClearField(name string) error {
	return fmt.Errorf("unknown System nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SystemMutation) ResetField(name string) error {
	switch name {
	case system.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case system.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case system.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case system.FieldKey:
		m.ResetKey()
		return nil
	case system.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown System field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SystemMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SystemMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SystemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SystemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SystemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SystemMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SystemMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown System unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SystemMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown System edge %s", name)
}

// ThreadMutation represents an operation that mutates the Thread nodes in the graph.
type ThreadMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	updated_at     *time.Time
	thread_id      *string
	clearedFields  map[string]struct{}
	project        *int
	clearedproject bool
	traces         map[int]struct{}
	removedtraces  map[int]struct{}
	clearedtraces  bool
	done           bool
	oldValue       func(context.Context) (*Thread, error)
	predicates     []predicate.Thread
}

var _ ent.Mutation = (*ThreadMutation)(nil)

// threadOption allows management of the mutation configuration using functional options.
type threadOption func(*ThreadMutation)

// newThreadMutation creates new mutation for the Thread entity.
func newThreadMutation(c config, op Op, opts ...threadOption) *ThreadMutation {
	m := &ThreadMutation{
		config:        c,
		op:            op,
		typ:           TypeThread,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withThreadID sets the ID field of the mutation.
func withThreadID(id int) threadOption {
	return func(m *ThreadMutation) {
		var (
			err   error
			once  sync.Once
			value *Thread
		)
		m.oldValue = func(ctx context.Context) (*Thread, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Thread.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withThread sets the old Thread of the mutation.
func withThread(node *Thread) threadOption {
	return func(m *ThreadMutation) {
		m.oldValue = func(context.Context) (*Thread, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ThreadMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ThreadMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ThreadMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ThreadMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Thread.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ThreadMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ThreadMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ThreadMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ThreadMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ThreadMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ThreadMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetProjectID sets the "project_id" field.
func (m *ThreadMutation) SetProjectID(i int) {
	m.project = &i
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *ThreadMutation) ProjectID() (r int, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldProjectID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *ThreadMutation) ResetProjectID() {
	m.project = nil
}

// SetThreadID sets the "thread_id" field.
func (m *ThreadMutation) SetThreadID(s string) {
	m.thread_id = &s
}

// ThreadID returns the value of the "thread_id" field in the mutation.
func (m *ThreadMutation) ThreadID() (r string, exists bool) {
	v := m.thread_id
	if v == nil {
		return
	}
	return *v, true
}

// OldThreadID returns the old "thread_id" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldThreadID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThreadID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThreadID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThreadID: %w", err)
	}
	return oldValue.ThreadID, nil
}

// ResetThreadID resets all changes to the "thread_id" field.
func (m *ThreadMutation) ResetThreadID() {
	m.thread_id = nil
}

// ClearProject clears the "project" edge to the Project entity.
func (m *ThreadMutation) ClearProject() {
	m.clearedproject = true
	m.clearedFields[thread.FieldProjectID] = struct{}{}
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *ThreadMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *ThreadMutation) ProjectIDs() (ids []int) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *ThreadMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// AddTraceIDs adds the "traces" edge to the Trace entity by ids.
func (m *ThreadMutation) AddTraceIDs(ids ...int) {
	if m.traces == nil {
		m.traces = make(map[int]struct{})
	}
	for i := range ids {
		m.traces[ids[i]] = struct{}{}
	}
}

// ClearTraces clears the "traces" edge to the Trace entity.
func (m *ThreadMutation) ClearTraces() {
	m.clearedtraces = true
}

// TracesCleared reports if the "traces" edge to the Trace entity was cleared.
func (m *ThreadMutation) TracesCleared() bool {
	return m.clearedtraces
}

// RemoveTraceIDs removes the "traces" edge to the Trace entity by IDs.
func (m *ThreadMutation) RemoveTraceIDs(ids ...int) {
	if m.removedtraces == nil {
		m.removedtraces = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.traces, ids[i])
		m.removedtraces[ids[i]] = struct{}{}
	}
}

// RemovedTraces returns the removed IDs of the "traces" edge to the Trace entity.
func (m *ThreadMutation) RemovedTracesIDs() (ids []int) {
	for id := range m.removedtraces {
		ids = append(ids, id)
	}
	return
}

// TracesIDs returns the "traces" edge IDs in the mutation.
func (m *ThreadMutation) TracesIDs() (ids []int) {
	for id := range m.traces {
		ids = append(ids, id)
	}
	return
}

// ResetTraces resets all changes to the "traces" edge.
func (m *ThreadMutation) ResetTraces() {
	m.traces = nil
	m.clearedtraces = false
	m.removedtraces = nil
}

// Where appends a list predicates to the ThreadMutation builder.
func (m *ThreadMutation) Where(ps ...predicate.Thread) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ThreadMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ThreadMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Thread, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ThreadMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ThreadMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Thread).
func (m *ThreadMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ThreadMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, thread.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, thread.FieldUpdatedAt)
	}
	if m.project != nil {
		fields = append(fields, thread.FieldProjectID)
	}
	if m.thread_id != nil {
		fields = append(fields, thread.FieldThreadID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ThreadMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case thread.FieldCreatedAt:
		return m.CreatedAt()
	case thread.FieldUpdatedAt:
		return m.UpdatedAt()
	case thread.FieldProjectID:
		return m.ProjectID()
	case thread.FieldThreadID:
		return m.ThreadID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ThreadMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case thread.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case thread.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case thread.FieldProjectID:
		return m.OldProjectID(ctx)
	case thread.FieldThreadID:
		return m.OldThreadID(ctx)
	}
	return nil, fmt.Errorf("unknown Thread field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ThreadMutation) SetField(name string, value ent.Value) error {
	switch name {
	case thread.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case thread.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case thread.FieldProjectID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case thread.FieldThreadID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThreadID(v)
		return nil
	}
	return fmt.Errorf("unknown Thread field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ThreadMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ThreadMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ThreadMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Thread numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ThreadMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ThreadMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ThreadMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Thread nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ThreadMutation) ResetField(name string) error {
	switch name {
	case thread.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case thread.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case thread.FieldProjectID:
		m.ResetProjectID()
		return nil
	case thread.FieldThreadID:
		m.ResetThreadID()
		return nil
	}
	return fmt.Errorf("unknown Thread field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ThreadMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.project != nil {
		edges = append(edges, thread.EdgeProject)
	}
	if m.traces != nil {
		edges = append(edges, thread.EdgeTraces)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ThreadMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case thread.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case thread.EdgeTraces:
		ids := make([]ent.Value, 0, len(m.traces))
		for id := range m.traces {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ThreadMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtraces != nil {
		edges = append(edges, thread.EdgeTraces)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ThreadMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case thread.EdgeTraces:
		ids := make([]ent.Value, 0, len(m.removedtraces))
		for id := range m.removedtraces {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ThreadMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproject {
		edges = append(edges, thread.EdgeProject)
	}
	if m.clearedtraces {
		edges = append(edges, thread.EdgeTraces)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ThreadMutation) EdgeCleared(name string) bool {
	switch name {
	case thread.EdgeProject:
		return m.clearedproject
	case thread.EdgeTraces:
		return m.clearedtraces
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ThreadMutation) ClearEdge(name string) error {
	switch name {
	case thread.EdgeProject:
		m.ClearProject()
		return nil
	}
	return fmt.Errorf("unknown Thread unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ThreadMutation) ResetEdge(name string) error {
	switch name {
	case thread.EdgeProject:
		m.ResetProject()
		return nil
	case thread.EdgeTraces:
		m.ResetTraces()
		return nil
	}
	return fmt.Errorf("unknown Thread edge %s", name)
}

// TraceMutation represents an operation that mutates the Trace nodes in the graph.
type TraceMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	updated_at      *time.Time
	trace_id        *string
	clearedFields   map[string]struct{}
	project         *int
	clearedproject  bool
	thread          *int
	clearedthread   bool
	requests        map[int]struct{}
	removedrequests map[int]struct{}
	clearedrequests bool
	done            bool
	oldValue        func(context.Context) (*Trace, error)
	predicates      []predicate.Trace
}

var _ ent.Mutation = (*TraceMutation)(nil)

// traceOption allows management of the mutation configuration using functional options.
type traceOption func(*TraceMutation)

// newTraceMutation creates new mutation for the Trace entity.
func newTraceMutation(c config, op Op, opts ...traceOption) *TraceMutation {
	m := &TraceMutation{
		config:        c,
		op:            op,
		typ:           TypeTrace,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTraceID sets the ID field of the mutation.
func withTraceID(id int) traceOption {
	return func(m *TraceMutation) {
		var (
			err   error
			once  sync.Once
			value *Trace
		)
		m.oldValue = func(ctx context.Context) (*Trace, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Trace.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTrace sets the old Trace of the mutation.
func withTrace(node *Trace) traceOption {
	return func(m *TraceMutation) {
		m.oldValue = func(context.Context) (*Trace, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TraceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TraceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TraceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TraceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Trace.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TraceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TraceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Trace entity.
// If the Trace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TraceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TraceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TraceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TraceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Trace entity.
// If the Trace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TraceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TraceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetProjectID sets the "project_id" field.
func (m *TraceMutation) SetProjectID(i int) {
	m.project = &i
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *TraceMutation) ProjectID() (r int, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the Trace entity.
// If the Trace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TraceMutation) OldProjectID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *TraceMutation) ResetProjectID() {
	m.project = nil
}

// SetTraceID sets the "trace_id" field.
func (m *TraceMutation) SetTraceID(s string) {
	m.trace_id = &s
}

// TraceID returns the value of the "trace_id" field in the mutation.
func (m *TraceMutation) TraceID() (r string, exists bool) {
	v := m.trace_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTraceID returns the old "trace_id" field's value of the Trace entity.
// If the Trace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TraceMutation) OldTraceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTraceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTraceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTraceID: %w", err)
	}
	return oldValue.TraceID, nil
}

// ResetTraceID resets all changes to the "trace_id" field.
func (m *TraceMutation) ResetTraceID() {
	m.trace_id = nil
}

// SetThreadID sets the "thread_id" field.
func (m *TraceMutation) SetThreadID(i int) {
	m.thread = &i
}

// ThreadID returns the value of the "thread_id" field in the mutation.
func (m *TraceMutation) ThreadID() (r int, exists bool) {
	v := m.thread
	if v == nil {
		return
	}
	return *v, true
}

// OldThreadID returns the old "thread_id" field's value of the Trace entity.
// If the Trace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TraceMutation) OldThreadID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThreadID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThreadID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThreadID: %w", err)
	}
	return oldValue.ThreadID, nil
}

// ClearThreadID clears the value of the "thread_id" field.
func (m *TraceMutation) ClearThreadID() {
	m.thread = nil
	m.clearedFields[trace.FieldThreadID] = struct{}{}
}

// ThreadIDCleared returns if the "thread_id" field was cleared in this mutation.
func (m *TraceMutation) ThreadIDCleared() bool {
	_, ok := m.clearedFields[trace.FieldThreadID]
	return ok
}

// ResetThreadID resets all changes to the "thread_id" field.
func (m *TraceMutation) ResetThreadID() {
	m.thread = nil
	delete(m.clearedFields, trace.FieldThreadID)
}

// ClearProject clears the "project" edge to the Project entity.
func (m *TraceMutation) ClearProject() {
	m.clearedproject = true
	m.clearedFields[trace.FieldProjectID] = struct{}{}
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *TraceMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *TraceMutation) ProjectIDs() (ids []int) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *TraceMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// ClearThread clears the "thread" edge to the Thread entity.
func (m *TraceMutation) ClearThread() {
	m.clearedthread = true
	m.clearedFields[trace.FieldThreadID] = struct{}{}
}

// ThreadCleared reports if the "thread" edge to the Thread entity was cleared.
func (m *TraceMutation) ThreadCleared() bool {
	return m.ThreadIDCleared() || m.clearedthread
}

// ThreadIDs returns the "thread" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ThreadID instead. It exists only for internal usage by the builders.
func (m *TraceMutation) ThreadIDs() (ids []int) {
	if id := m.thread; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetThread resets all changes to the "thread" edge.
func (m *TraceMutation) ResetThread() {
	m.thread = nil
	m.clearedthread = false
}

// AddRequestIDs adds the "requests" edge to the Request entity by ids.
func (m *TraceMutation) AddRequestIDs(ids ...int) {
	if m.requests == nil {
		m.requests = make(map[int]struct{})
	}
	for i := range ids {
		m.requests[ids[i]] = struct{}{}
	}
}

// ClearRequests clears the "requests" edge to the Request entity.
func (m *TraceMutation) ClearRequests() {
	m.clearedrequests = true
}

// RequestsCleared reports if the "requests" edge to the Request entity was cleared.
func (m *TraceMutation) RequestsCleared() bool {
	return m.clearedrequests
}

// RemoveRequestIDs removes the "requests" edge to the Request entity by IDs.
func (m *TraceMutation) RemoveRequestIDs(ids ...int) {
	if m.removedrequests == nil {
		m.removedrequests = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.requests, ids[i])
		m.removedrequests[ids[i]] = struct{}{}
	}
}

// RemovedRequests returns the removed IDs of the "requests" edge to the Request entity.
func (m *TraceMutation) RemovedRequestsIDs() (ids []int) {
	for id := range m.removedrequests {
		ids = append(ids, id)
	}
	return
}

// RequestsIDs returns the "requests" edge IDs in the mutation.
func (m *TraceMutation) RequestsIDs() (ids []int) {
	for id := range m.requests {
		ids = append(ids, id)
	}
	return
}

// ResetRequests resets all changes to the "requests" edge.
func (m *TraceMutation) ResetRequests() {
	m.requests = nil
	m.clearedrequests = false
	m.removedrequests = nil
}

// Where appends a list predicates to the TraceMutation builder.
func (m *TraceMutation) Where(ps ...predicate.Trace) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TraceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TraceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Trace, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TraceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TraceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Trace).
func (m *TraceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TraceMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, trace.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, trace.FieldUpdatedAt)
	}
	if m.project != nil {
		fields = append(fields, trace.FieldProjectID)
	}
	if m.trace_id != nil {
		fields = append(fields, trace.FieldTraceID)
	}
	if m.thread != nil {
		fields = append(fields, trace.FieldThreadID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TraceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case trace.FieldCreatedAt:
		return m.CreatedAt()
	case trace.FieldUpdatedAt:
		return m.UpdatedAt()
	case trace.FieldProjectID:
		return m.ProjectID()
	case trace.FieldTraceID:
		return m.TraceID()
	case trace.FieldThreadID:
		return m.ThreadID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TraceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case trace.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case trace.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case trace.FieldProjectID:
		return m.OldProjectID(ctx)
	case trace.FieldTraceID:
		return m.OldTraceID(ctx)
	case trace.FieldThreadID:
		return m.OldThreadID(ctx)
	}
	return nil, fmt.Errorf("unknown Trace field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TraceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case trace.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case trace.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case trace.FieldProjectID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case trace.FieldTraceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTraceID(v)
		return nil
	case trace.FieldThreadID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThreadID(v)
		return nil
	}
	return fmt.Errorf("unknown Trace field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TraceMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TraceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TraceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Trace numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TraceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(trace.FieldThreadID) {
		fields = append(fields, trace.FieldThreadID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TraceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TraceMutation) ClearField(name string) error {
	switch name {
	case trace.FieldThreadID:
		m.ClearThreadID()
		return nil
	}
	return fmt.Errorf("unknown Trace nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TraceMutation) ResetField(name string) error {
	switch name {
	case trace.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case trace.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case trace.FieldProjectID:
		m.ResetProjectID()
		return nil
	case trace.FieldTraceID:
		m.ResetTraceID()
		return nil
	case trace.FieldThreadID:
		m.ResetThreadID()
		return nil
	}
	return fmt.Errorf("unknown Trace field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TraceMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.project != nil {
		edges = append(edges, trace.EdgeProject)
	}
	if m.thread != nil {
		edges = append(edges, trace.EdgeThread)
	}
	if m.requests != nil {
		edges = append(edges, trace.EdgeRequests)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TraceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case trace.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case trace.EdgeThread:
		if id := m.thread; id != nil {
			return []ent.Value{*id}
		}
	case trace.EdgeRequests:
		ids := make([]ent.Value, 0, len(m.requests))
		for id := range m.requests {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TraceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedrequests != nil {
		edges = append(edges, trace.EdgeRequests)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TraceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case trace.EdgeRequests:
		ids := make([]ent.Value, 0, len(m.removedrequests))
		for id := range m.removedrequests {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TraceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedproject {
		edges = append(edges, trace.EdgeProject)
	}
	if m.clearedthread {
		edges = append(edges, trace.EdgeThread)
	}
	if m.clearedrequests {
		edges = append(edges, trace.EdgeRequests)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TraceMutation) EdgeCleared(name string) bool {
	switch name {
	case trace.EdgeProject:
		return m.clearedproject
	case trace.EdgeThread:
		return m.clearedthread
	case trace.EdgeRequests:
		return m.clearedrequests
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TraceMutation) ClearEdge(name string) error {
	switch name {
	case trace.EdgeProject:
		m.ClearProject()
		return nil
	case trace.EdgeThread:
		m.ClearThread()
		return nil
	}
	return fmt.Errorf("unknown Trace unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TraceMutation) ResetEdge(name string) error {
	switch name {
	case trace.EdgeProject:
		m.ResetProject()
		return nil
	case trace.EdgeThread:
		m.ResetThread()
		return nil
	case trace.EdgeRequests:
		m.ResetRequests()
		return nil
	}
	return fmt.Errorf("unknown Trace edge %s", name)
}

// UsageLogMutation represents an operation that mutates the UsageLog nodes in the graph.
type UsageLogMutation struct {
	config
	op                                       Op
	typ                                      string
	id                                       *int
	created_at                               *time.Time
	updated_at                               *time.Time
	model_id                                 *string
	prompt_tokens                            *int64
	addprompt_tokens                         *int64
	completion_tokens                        *int64
	addcompletion_tokens                     *int64
	total_tokens                             *int64
	addtotal_tokens                          *int64
	prompt_audio_tokens                      *int64
	addprompt_audio_tokens                   *int64
	prompt_cached_tokens                     *int64
	addprompt_cached_tokens                  *int64
	prompt_write_cached_tokens               *int64
	addprompt_write_cached_tokens            *int64
	completion_audio_tokens                  *int64
	addcompletion_audio_tokens               *int64
	completion_reasoning_tokens              *int64
	addcompletion_reasoning_tokens           *int64
	completion_accepted_prediction_tokens    *int64
	addcompletion_accepted_prediction_tokens *int64
	completion_rejected_prediction_tokens    *int64
	addcompletion_rejected_prediction_tokens *int64
	source                                   *usagelog.Source
	format                                   *string
	clearedFields                            map[string]struct{}
	request                                  *int
	clearedrequest                           bool
	project                                  *int
	clearedproject                           bool
	channel                                  *int
	clearedchannel                           bool
	done                                     bool
	oldValue                                 func(context.Context) (*UsageLog, error)
	predicates                               []predicate.UsageLog
}

var _ ent.Mutation = (*UsageLogMutation)(nil)

// usagelogOption allows management of the mutation configuration using functional options.
type usagelogOption func(*UsageLogMutation)

// newUsageLogMutation creates new mutation for the UsageLog entity.
func newUsageLogMutation(c config, op Op, opts ...usagelogOption) *UsageLogMutation {
	m := &UsageLogMutation{
		config:        c,
		op:            op,
		typ:           TypeUsageLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUsageLogID sets the ID field of the mutation.
func withUsageLogID(id int) usagelogOption {
	return func(m *UsageLogMutation) {
		var (
			err   error
			once  sync.Once
			value *UsageLog
		)
		m.oldValue = func(ctx context.Context) (*UsageLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UsageLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUsageLog sets the old UsageLog of the mutation.
func withUsageLog(node *UsageLog) usagelogOption {
	return func(m *UsageLogMutation) {
		m.oldValue = func(context.Context) (*UsageLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UsageLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UsageLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UsageLogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UsageLogMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UsageLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UsageLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UsageLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UsageLogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UsageLogMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UsageLogMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UsageLogMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetRequestID sets the "request_id" field.
func (m *UsageLogMutation) SetRequestID(i int) {
	m.request = &i
}

// RequestID returns the value of the "request_id" field in the mutation.
func (m *UsageLogMutation) RequestID() (r int, exists bool) {
	v := m.request
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestID returns the old "request_id" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldRequestID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestID: %w", err)
	}
	return oldValue.RequestID, nil
}

// ResetRequestID resets all changes to the "request_id" field.
func (m *UsageLogMutation) ResetRequestID() {
	m.request = nil
}

// SetProjectID sets the "project_id" field.
func (m *UsageLogMutation) SetProjectID(i int) {
	m.project = &i
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *UsageLogMutation) ProjectID() (r int, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldProjectID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *UsageLogMutation) ResetProjectID() {
	m.project = nil
}

// SetChannelID sets the "channel_id" field.
func (m *UsageLogMutation) SetChannelID(i int) {
	m.channel = &i
}

// ChannelID returns the value of the "channel_id" field in the mutation.
func (m *UsageLogMutation) ChannelID() (r int, exists bool) {
	v := m.channel
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelID returns the old "channel_id" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldChannelID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelID: %w", err)
	}
	return oldValue.ChannelID, nil
}

// ClearChannelID clears the value of the "channel_id" field.
func (m *UsageLogMutation) ClearChannelID() {
	m.channel = nil
	m.clearedFields[usagelog.FieldChannelID] = struct{}{}
}

// ChannelIDCleared returns if the "channel_id" field was cleared in this mutation.
func (m *UsageLogMutation) ChannelIDCleared() bool {
	_, ok := m.clearedFields[usagelog.FieldChannelID]
	return ok
}

// ResetChannelID resets all changes to the "channel_id" field.
func (m *UsageLogMutation) ResetChannelID() {
	m.channel = nil
	delete(m.clearedFields, usagelog.FieldChannelID)
}

// SetModelID sets the "model_id" field.
func (m *UsageLogMutation) SetModelID(s string) {
	m.model_id = &s
}

// ModelID returns the value of the "model_id" field in the mutation.
func (m *UsageLogMutation) ModelID() (r string, exists bool) {
	v := m.model_id
	if v == nil {
		return
	}
	return *v, true
}

// OldModelID returns the old "model_id" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldModelID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModelID: %w", err)
	}
	return oldValue.ModelID, nil
}

// ResetModelID resets all changes to the "model_id" field.
func (m *UsageLogMutation) ResetModelID() {
	m.model_id = nil
}

// SetPromptTokens sets the "prompt_tokens" field.
func (m *UsageLogMutation) SetPromptTokens(i int64) {
	m.prompt_tokens = &i
	m.addprompt_tokens = nil
}

// PromptTokens returns the value of the "prompt_tokens" field in the mutation.
func (m *UsageLogMutation) PromptTokens() (r int64, exists bool) {
	v := m.prompt_tokens
	if v == nil {
		return
	}
	return *v, true
}

// OldPromptTokens returns the old "prompt_tokens" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldPromptTokens(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPromptTokens is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPromptTokens requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPromptTokens: %w", err)
	}
	return oldValue.PromptTokens, nil
}

// AddPromptTokens adds i to the "prompt_tokens" field.
func (m *UsageLogMutation) AddPromptTokens(i int64) {
	if m.addprompt_tokens != nil {
		*m.addprompt_tokens += i
	} else {
		m.addprompt_tokens = &i
	}
}

// AddedPromptTokens returns the value that was added to the "prompt_tokens" field in this mutation.
func (m *UsageLogMutation) AddedPromptTokens() (r int64, exists bool) {
	v := m.addprompt_tokens
	if v == nil {
		return
	}
	return *v, true
}

// ResetPromptTokens resets all changes to the "prompt_tokens" field.
func (m *UsageLogMutation) ResetPromptTokens() {
	m.prompt_tokens = nil
	m.addprompt_tokens = nil
}

// SetCompletionTokens sets the "completion_tokens" field.
func (m *UsageLogMutation) SetCompletionTokens(i int64) {
	m.completion_tokens = &i
	m.addcompletion_tokens = nil
}

// CompletionTokens returns the value of the "completion_tokens" field in the mutation.
func (m *UsageLogMutation) CompletionTokens() (r int64, exists bool) {
	v := m.completion_tokens
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletionTokens returns the old "completion_tokens" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldCompletionTokens(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletionTokens is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletionTokens requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletionTokens: %w", err)
	}
	return oldValue.CompletionTokens, nil
}

// AddCompletionTokens adds i to the "completion_tokens" field.
func (m *UsageLogMutation) AddCompletionTokens(i int64) {
	if m.addcompletion_tokens != nil {
		*m.addcompletion_tokens += i
	} else {
		m.addcompletion_tokens = &i
	}
}

// AddedCompletionTokens returns the value that was added to the "completion_tokens" field in this mutation.
func (m *UsageLogMutation) AddedCompletionTokens() (r int64, exists bool) {
	v := m.addcompletion_tokens
	if v == nil {
		return
	}
	return *v, true
}

// ResetCompletionTokens resets all changes to the "completion_tokens" field.
func (m *UsageLogMutation) ResetCompletionTokens() {
	m.completion_tokens = nil
	m.addcompletion_tokens = nil
}

// SetTotalTokens sets the "total_tokens" field.
func (m *UsageLogMutation) SetTotalTokens(i int64) {
	m.total_tokens = &i
	m.addtotal_tokens = nil
}

// TotalTokens returns the value of the "total_tokens" field in the mutation.
func (m *UsageLogMutation) TotalTokens() (r int64, exists bool) {
	v := m.total_tokens
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalTokens returns the old "total_tokens" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldTotalTokens(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalTokens is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalTokens requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalTokens: %w", err)
	}
	return oldValue.TotalTokens, nil
}

// AddTotalTokens adds i to the "total_tokens" field.
func (m *UsageLogMutation) AddTotalTokens(i int64) {
	if m.addtotal_tokens != nil {
		*m.addtotal_tokens += i
	} else {
		m.addtotal_tokens = &i
	}
}

// AddedTotalTokens returns the value that was added to the "total_tokens" field in this mutation.
func (m *UsageLogMutation) AddedTotalTokens() (r int64, exists bool) {
	v := m.addtotal_tokens
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalTokens resets all changes to the "total_tokens" field.
func (m *UsageLogMutation) ResetTotalTokens() {
	m.total_tokens = nil
	m.addtotal_tokens = nil
}

// SetPromptAudioTokens sets the "prompt_audio_tokens" field.
func (m *UsageLogMutation) SetPromptAudioTokens(i int64) {
	m.prompt_audio_tokens = &i
	m.addprompt_audio_tokens = nil
}

// PromptAudioTokens returns the value of the "prompt_audio_tokens" field in the mutation.
func (m *UsageLogMutation) PromptAudioTokens() (r int64, exists bool) {
	v := m.prompt_audio_tokens
	if v == nil {
		return
	}
	return *v, true
}

// OldPromptAudioTokens returns the old "prompt_audio_tokens" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldPromptAudioTokens(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPromptAudioTokens is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPromptAudioTokens requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPromptAudioTokens: %w", err)
	}
	return oldValue.PromptAudioTokens, nil
}

// AddPromptAudioTokens adds i to the "prompt_audio_tokens" field.
func (m *UsageLogMutation) AddPromptAudioTokens(i int64) {
	if m.addprompt_audio_tokens != nil {
		*m.addprompt_audio_tokens += i
	} else {
		m.addprompt_audio_tokens = &i
	}
}

// AddedPromptAudioTokens returns the value that was added to the "prompt_audio_tokens" field in this mutation.
func (m *UsageLogMutation) AddedPromptAudioTokens() (r int64, exists bool) {
	v := m.addprompt_audio_tokens
	if v == nil {
		return
	}
	return *v, true
}

// ClearPromptAudioTokens clears the value of the "prompt_audio_tokens" field.
func (m *UsageLogMutation) ClearPromptAudioTokens() {
	m.prompt_audio_tokens = nil
	m.addprompt_audio_tokens = nil
	m.clearedFields[usagelog.FieldPromptAudioTokens] = struct{}{}
}

// PromptAudioTokensCleared returns if the "prompt_audio_tokens" field was cleared in this mutation.
func (m *UsageLogMutation) PromptAudioTokensCleared() bool {
	_, ok := m.clearedFields[usagelog.FieldPromptAudioTokens]
	return ok
}

// ResetPromptAudioTokens resets all changes to the "prompt_audio_tokens" field.
func (m *UsageLogMutation) ResetPromptAudioTokens() {
	m.prompt_audio_tokens = nil
	m.addprompt_audio_tokens = nil
	delete(m.clearedFields, usagelog.FieldPromptAudioTokens)
}

// SetPromptCachedTokens sets the "prompt_cached_tokens" field.
func (m *UsageLogMutation) SetPromptCachedTokens(i int64) {
	m.prompt_cached_tokens = &i
	m.addprompt_cached_tokens = nil
}

// PromptCachedTokens returns the value of the "prompt_cached_tokens" field in the mutation.
func (m *UsageLogMutation) PromptCachedTokens() (r int64, exists bool) {
	v := m.prompt_cached_tokens
	if v == nil {
		return
	}
	return *v, true
}

// OldPromptCachedTokens returns the old "prompt_cached_tokens" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldPromptCachedTokens(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPromptCachedTokens is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPromptCachedTokens requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPromptCachedTokens: %w", err)
	}
	return oldValue.PromptCachedTokens, nil
}

// AddPromptCachedTokens adds i to the "prompt_cached_tokens" field.
func (m *UsageLogMutation) AddPromptCachedTokens(i int64) {
	if m.addprompt_cached_tokens != nil {
		*m.addprompt_cached_tokens += i
	} else {
		m.addprompt_cached_tokens = &i
	}
}

// AddedPromptCachedTokens returns the value that was added to the "prompt_cached_tokens" field in this mutation.
func (m *UsageLogMutation) AddedPromptCachedTokens() (r int64, exists bool) {
	v := m.addprompt_cached_tokens
	if v == nil {
		return
	}
	return *v, true
}

// ClearPromptCachedTokens clears the value of the "prompt_cached_tokens" field.
func (m *UsageLogMutation) ClearPromptCachedTokens() {
	m.prompt_cached_tokens = nil
	m.addprompt_cached_tokens = nil
	m.clearedFields[usagelog.FieldPromptCachedTokens] = struct{}{}
}

// PromptCachedTokensCleared returns if the "prompt_cached_tokens" field was cleared in this mutation.
func (m *UsageLogMutation) PromptCachedTokensCleared() bool {
	_, ok := m.clearedFields[usagelog.FieldPromptCachedTokens]
	return ok
}

// ResetPromptCachedTokens resets all changes to the "prompt_cached_tokens" field.
func (m *UsageLogMutation) ResetPromptCachedTokens() {
	m.prompt_cached_tokens = nil
	m.addprompt_cached_tokens = nil
	delete(m.clearedFields, usagelog.FieldPromptCachedTokens)
}

// SetPromptWriteCachedTokens sets the "prompt_write_cached_tokens" field.
func (m *UsageLogMutation) SetPromptWriteCachedTokens(i int64) {
	m.prompt_write_cached_tokens = &i
	m.addprompt_write_cached_tokens = nil
}

// PromptWriteCachedTokens returns the value of the "prompt_write_cached_tokens" field in the mutation.
func (m *UsageLogMutation) PromptWriteCachedTokens() (r int64, exists bool) {
	v := m.prompt_write_cached_tokens
	if v == nil {
		return
	}
	return *v, true
}

// OldPromptWriteCachedTokens returns the old "prompt_write_cached_tokens" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldPromptWriteCachedTokens(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPromptWriteCachedTokens is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPromptWriteCachedTokens requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPromptWriteCachedTokens: %w", err)
	}
	return oldValue.PromptWriteCachedTokens, nil
}

// AddPromptWriteCachedTokens adds i to the "prompt_write_cached_tokens" field.
func (m *UsageLogMutation) AddPromptWriteCachedTokens(i int64) {
	if m.addprompt_write_cached_tokens != nil {
		*m.addprompt_write_cached_tokens += i
	} else {
		m.addprompt_write_cached_tokens = &i
	}
}

// AddedPromptWriteCachedTokens returns the value that was added to the "prompt_write_cached_tokens" field in this mutation.
func (m *UsageLogMutation) AddedPromptWriteCachedTokens() (r int64, exists bool) {
	v := m.addprompt_write_cached_tokens
	if v == nil {
		return
	}
	return *v, true
}

// ClearPromptWriteCachedTokens clears the value of the "prompt_write_cached_tokens" field.
func (m *UsageLogMutation) ClearPromptWriteCachedTokens() {
	m.prompt_write_cached_tokens = nil
	m.addprompt_write_cached_tokens = nil
	m.clearedFields[usagelog.FieldPromptWriteCachedTokens] = struct{}{}
}

// PromptWriteCachedTokensCleared returns if the "prompt_write_cached_tokens" field was cleared in this mutation.
func (m *UsageLogMutation) PromptWriteCachedTokensCleared() bool {
	_, ok := m.clearedFields[usagelog.FieldPromptWriteCachedTokens]
	return ok
}

// ResetPromptWriteCachedTokens resets all changes to the "prompt_write_cached_tokens" field.
func (m *UsageLogMutation) ResetPromptWriteCachedTokens() {
	m.prompt_write_cached_tokens = nil
	m.addprompt_write_cached_tokens = nil
	delete(m.clearedFields, usagelog.FieldPromptWriteCachedTokens)
}

// SetCompletionAudioTokens sets the "completion_audio_tokens" field.
func (m *UsageLogMutation) SetCompletionAudioTokens(i int64) {
	m.completion_audio_tokens = &i
	m.addcompletion_audio_tokens = nil
}

// CompletionAudioTokens returns the value of the "completion_audio_tokens" field in the mutation.
func (m *UsageLogMutation) CompletionAudioTokens() (r int64, exists bool) {
	v := m.completion_audio_tokens
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletionAudioTokens returns the old "completion_audio_tokens" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldCompletionAudioTokens(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletionAudioTokens is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletionAudioTokens requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletionAudioTokens: %w", err)
	}
	return oldValue.CompletionAudioTokens, nil
}

// AddCompletionAudioTokens adds i to the "completion_audio_tokens" field.
func (m *UsageLogMutation) AddCompletionAudioTokens(i int64) {
	if m.addcompletion_audio_tokens != nil {
		*m.addcompletion_audio_tokens += i
	} else {
		m.addcompletion_audio_tokens = &i
	}
}

// AddedCompletionAudioTokens returns the value that was added to the "completion_audio_tokens" field in this mutation.
func (m *UsageLogMutation) AddedCompletionAudioTokens() (r int64, exists bool) {
	v := m.addcompletion_audio_tokens
	if v == nil {
		return
	}
	return *v, true
}

// ClearCompletionAudioTokens clears the value of the "completion_audio_tokens" field.
func (m *UsageLogMutation) ClearCompletionAudioTokens() {
	m.completion_audio_tokens = nil
	m.addcompletion_audio_tokens = nil
	m.clearedFields[usagelog.FieldCompletionAudioTokens] = struct{}{}
}

// CompletionAudioTokensCleared returns if the "completion_audio_tokens" field was cleared in this mutation.
func (m *UsageLogMutation) CompletionAudioTokensCleared() bool {
	_, ok := m.clearedFields[usagelog.FieldCompletionAudioTokens]
	return ok
}

// ResetCompletionAudioTokens resets all changes to the "completion_audio_tokens" field.
func (m *UsageLogMutation) ResetCompletionAudioTokens() {
	m.completion_audio_tokens = nil
	m.addcompletion_audio_tokens = nil
	delete(m.clearedFields, usagelog.FieldCompletionAudioTokens)
}

// SetCompletionReasoningTokens sets the "completion_reasoning_tokens" field.
func (m *UsageLogMutation) SetCompletionReasoningTokens(i int64) {
	m.completion_reasoning_tokens = &i
	m.addcompletion_reasoning_tokens = nil
}

// CompletionReasoningTokens returns the value of the "completion_reasoning_tokens" field in the mutation.
func (m *UsageLogMutation) CompletionReasoningTokens() (r int64, exists bool) {
	v := m.completion_reasoning_tokens
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletionReasoningTokens returns the old "completion_reasoning_tokens" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldCompletionReasoningTokens(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletionReasoningTokens is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletionReasoningTokens requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletionReasoningTokens: %w", err)
	}
	return oldValue.CompletionReasoningTokens, nil
}

// AddCompletionReasoningTokens adds i to the "completion_reasoning_tokens" field.
func (m *UsageLogMutation) AddCompletionReasoningTokens(i int64) {
	if m.addcompletion_reasoning_tokens != nil {
		*m.addcompletion_reasoning_tokens += i
	} else {
		m.addcompletion_reasoning_tokens = &i
	}
}

// AddedCompletionReasoningTokens returns the value that was added to the "completion_reasoning_tokens" field in this mutation.
func (m *UsageLogMutation) AddedCompletionReasoningTokens() (r int64, exists bool) {
	v := m.addcompletion_reasoning_tokens
	if v == nil {
		return
	}
	return *v, true
}

// ClearCompletionReasoningTokens clears the value of the "completion_reasoning_tokens" field.
func (m *UsageLogMutation) ClearCompletionReasoningTokens() {
	m.completion_reasoning_tokens = nil
	m.addcompletion_reasoning_tokens = nil
	m.clearedFields[usagelog.FieldCompletionReasoningTokens] = struct{}{}
}

// CompletionReasoningTokensCleared returns if the "completion_reasoning_tokens" field was cleared in this mutation.
func (m *UsageLogMutation) CompletionReasoningTokensCleared() bool {
	_, ok := m.clearedFields[usagelog.FieldCompletionReasoningTokens]
	return ok
}

// ResetCompletionReasoningTokens resets all changes to the "completion_reasoning_tokens" field.
func (m *UsageLogMutation) ResetCompletionReasoningTokens() {
	m.completion_reasoning_tokens = nil
	m.addcompletion_reasoning_tokens = nil
	delete(m.clearedFields, usagelog.FieldCompletionReasoningTokens)
}

// SetCompletionAcceptedPredictionTokens sets the "completion_accepted_prediction_tokens" field.
func (m *UsageLogMutation) SetCompletionAcceptedPredictionTokens(i int64) {
	m.completion_accepted_prediction_tokens = &i
	m.addcompletion_accepted_prediction_tokens = nil
}

// CompletionAcceptedPredictionTokens returns the value of the "completion_accepted_prediction_tokens" field in the mutation.
func (m *UsageLogMutation) CompletionAcceptedPredictionTokens() (r int64, exists bool) {
	v := m.completion_accepted_prediction_tokens
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletionAcceptedPredictionTokens returns the old "completion_accepted_prediction_tokens" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldCompletionAcceptedPredictionTokens(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletionAcceptedPredictionTokens is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletionAcceptedPredictionTokens requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletionAcceptedPredictionTokens: %w", err)
	}
	return oldValue.CompletionAcceptedPredictionTokens, nil
}

// AddCompletionAcceptedPredictionTokens adds i to the "completion_accepted_prediction_tokens" field.
func (m *UsageLogMutation) AddCompletionAcceptedPredictionTokens(i int64) {
	if m.addcompletion_accepted_prediction_tokens != nil {
		*m.addcompletion_accepted_prediction_tokens += i
	} else {
		m.addcompletion_accepted_prediction_tokens = &i
	}
}

// AddedCompletionAcceptedPredictionTokens returns the value that was added to the "completion_accepted_prediction_tokens" field in this mutation.
func (m *UsageLogMutation) AddedCompletionAcceptedPredictionTokens() (r int64, exists bool) {
	v := m.addcompletion_accepted_prediction_tokens
	if v == nil {
		return
	}
	return *v, true
}

// ClearCompletionAcceptedPredictionTokens clears the value of the "completion_accepted_prediction_tokens" field.
func (m *UsageLogMutation) ClearCompletionAcceptedPredictionTokens() {
	m.completion_accepted_prediction_tokens = nil
	m.addcompletion_accepted_prediction_tokens = nil
	m.clearedFields[usagelog.FieldCompletionAcceptedPredictionTokens] = struct{}{}
}

// CompletionAcceptedPredictionTokensCleared returns if the "completion_accepted_prediction_tokens" field was cleared in this mutation.
func (m *UsageLogMutation) CompletionAcceptedPredictionTokensCleared() bool {
	_, ok := m.clearedFields[usagelog.FieldCompletionAcceptedPredictionTokens]
	return ok
}

// ResetCompletionAcceptedPredictionTokens resets all changes to the "completion_accepted_prediction_tokens" field.
func (m *UsageLogMutation) ResetCompletionAcceptedPredictionTokens() {
	m.completion_accepted_prediction_tokens = nil
	m.addcompletion_accepted_prediction_tokens = nil
	delete(m.clearedFields, usagelog.FieldCompletionAcceptedPredictionTokens)
}

// SetCompletionRejectedPredictionTokens sets the "completion_rejected_prediction_tokens" field.
func (m *UsageLogMutation) SetCompletionRejectedPredictionTokens(i int64) {
	m.completion_rejected_prediction_tokens = &i
	m.addcompletion_rejected_prediction_tokens = nil
}

// CompletionRejectedPredictionTokens returns the value of the "completion_rejected_prediction_tokens" field in the mutation.
func (m *UsageLogMutation) CompletionRejectedPredictionTokens() (r int64, exists bool) {
	v := m.completion_rejected_prediction_tokens
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletionRejectedPredictionTokens returns the old "completion_rejected_prediction_tokens" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldCompletionRejectedPredictionTokens(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletionRejectedPredictionTokens is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletionRejectedPredictionTokens requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletionRejectedPredictionTokens: %w", err)
	}
	return oldValue.CompletionRejectedPredictionTokens, nil
}

// AddCompletionRejectedPredictionTokens adds i to the "completion_rejected_prediction_tokens" field.
func (m *UsageLogMutation) AddCompletionRejectedPredictionTokens(i int64) {
	if m.addcompletion_rejected_prediction_tokens != nil {
		*m.addcompletion_rejected_prediction_tokens += i
	} else {
		m.addcompletion_rejected_prediction_tokens = &i
	}
}

// AddedCompletionRejectedPredictionTokens returns the value that was added to the "completion_rejected_prediction_tokens" field in this mutation.
func (m *UsageLogMutation) AddedCompletionRejectedPredictionTokens() (r int64, exists bool) {
	v := m.addcompletion_rejected_prediction_tokens
	if v == nil {
		return
	}
	return *v, true
}

// ClearCompletionRejectedPredictionTokens clears the value of the "completion_rejected_prediction_tokens" field.
func (m *UsageLogMutation) ClearCompletionRejectedPredictionTokens() {
	m.completion_rejected_prediction_tokens = nil
	m.addcompletion_rejected_prediction_tokens = nil
	m.clearedFields[usagelog.FieldCompletionRejectedPredictionTokens] = struct{}{}
}

// CompletionRejectedPredictionTokensCleared returns if the "completion_rejected_prediction_tokens" field was cleared in this mutation.
func (m *UsageLogMutation) CompletionRejectedPredictionTokensCleared() bool {
	_, ok := m.clearedFields[usagelog.FieldCompletionRejectedPredictionTokens]
	return ok
}

// ResetCompletionRejectedPredictionTokens resets all changes to the "completion_rejected_prediction_tokens" field.
func (m *UsageLogMutation) ResetCompletionRejectedPredictionTokens() {
	m.completion_rejected_prediction_tokens = nil
	m.addcompletion_rejected_prediction_tokens = nil
	delete(m.clearedFields, usagelog.FieldCompletionRejectedPredictionTokens)
}

// SetSource sets the "source" field.
func (m *UsageLogMutation) SetSource(u usagelog.Source) {
	m.source = &u
}

// Source returns the value of the "source" field in the mutation.
func (m *UsageLogMutation) Source() (r usagelog.Source, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldSource(ctx context.Context) (v usagelog.Source, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *UsageLogMutation) ResetSource() {
	m.source = nil
}

// SetFormat sets the "format" field.
func (m *UsageLogMutation) SetFormat(s string) {
	m.format = &s
}

// Format returns the value of the "format" field in the mutation.
func (m *UsageLogMutation) Format() (r string, exists bool) {
	v := m.format
	if v == nil {
		return
	}
	return *v, true
}

// OldFormat returns the old "format" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldFormat(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFormat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFormat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormat: %w", err)
	}
	return oldValue.Format, nil
}

// ResetFormat resets all changes to the "format" field.
func (m *UsageLogMutation) ResetFormat() {
	m.format = nil
}

// ClearRequest clears the "request" edge to the Request entity.
func (m *UsageLogMutation) ClearRequest() {
	m.clearedrequest = true
	m.clearedFields[usagelog.FieldRequestID] = struct{}{}
}

// RequestCleared reports if the "request" edge to the Request entity was cleared.
func (m *UsageLogMutation) RequestCleared() bool {
	return m.clearedrequest
}

// RequestIDs returns the "request" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RequestID instead. It exists only for internal usage by the builders.
func (m *UsageLogMutation) RequestIDs() (ids []int) {
	if id := m.request; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRequest resets all changes to the "request" edge.
func (m *UsageLogMutation) ResetRequest() {
	m.request = nil
	m.clearedrequest = false
}

// ClearProject clears the "project" edge to the Project entity.
func (m *UsageLogMutation) ClearProject() {
	m.clearedproject = true
	m.clearedFields[usagelog.FieldProjectID] = struct{}{}
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *UsageLogMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *UsageLogMutation) ProjectIDs() (ids []int) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *UsageLogMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// ClearChannel clears the "channel" edge to the Channel entity.
func (m *UsageLogMutation) ClearChannel() {
	m.clearedchannel = true
	m.clearedFields[usagelog.FieldChannelID] = struct{}{}
}

// ChannelCleared reports if the "channel" edge to the Channel entity was cleared.
func (m *UsageLogMutation) ChannelCleared() bool {
	return m.ChannelIDCleared() || m.clearedchannel
}

// ChannelIDs returns the "channel" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChannelID instead. It exists only for internal usage by the builders.
func (m *UsageLogMutation) ChannelIDs() (ids []int) {
	if id := m.channel; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChannel resets all changes to the "channel" edge.
func (m *UsageLogMutation) ResetChannel() {
	m.channel = nil
	m.clearedchannel = false
}

// Where appends a list predicates to the UsageLogMutation builder.
func (m *UsageLogMutation) Where(ps ...predicate.UsageLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UsageLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UsageLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UsageLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UsageLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UsageLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UsageLog).
func (m *UsageLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UsageLogMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.created_at != nil {
		fields = append(fields, usagelog.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, usagelog.FieldUpdatedAt)
	}
	if m.request != nil {
		fields = append(fields, usagelog.FieldRequestID)
	}
	if m.project != nil {
		fields = append(fields, usagelog.FieldProjectID)
	}
	if m.channel != nil {
		fields = append(fields, usagelog.FieldChannelID)
	}
	if m.model_id != nil {
		fields = append(fields, usagelog.FieldModelID)
	}
	if m.prompt_tokens != nil {
		fields = append(fields, usagelog.FieldPromptTokens)
	}
	if m.completion_tokens != nil {
		fields = append(fields, usagelog.FieldCompletionTokens)
	}
	if m.total_tokens != nil {
		fields = append(fields, usagelog.FieldTotalTokens)
	}
	if m.prompt_audio_tokens != nil {
		fields = append(fields, usagelog.FieldPromptAudioTokens)
	}
	if m.prompt_cached_tokens != nil {
		fields = append(fields, usagelog.FieldPromptCachedTokens)
	}
	if m.prompt_write_cached_tokens != nil {
		fields = append(fields, usagelog.FieldPromptWriteCachedTokens)
	}
	if m.completion_audio_tokens != nil {
		fields = append(fields, usagelog.FieldCompletionAudioTokens)
	}
	if m.completion_reasoning_tokens != nil {
		fields = append(fields, usagelog.FieldCompletionReasoningTokens)
	}
	if m.completion_accepted_prediction_tokens != nil {
		fields = append(fields, usagelog.FieldCompletionAcceptedPredictionTokens)
	}
	if m.completion_rejected_prediction_tokens != nil {
		fields = append(fields, usagelog.FieldCompletionRejectedPredictionTokens)
	}
	if m.source != nil {
		fields = append(fields, usagelog.FieldSource)
	}
	if m.format != nil {
		fields = append(fields, usagelog.FieldFormat)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UsageLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usagelog.FieldCreatedAt:
		return m.CreatedAt()
	case usagelog.FieldUpdatedAt:
		return m.UpdatedAt()
	case usagelog.FieldRequestID:
		return m.RequestID()
	case usagelog.FieldProjectID:
		return m.ProjectID()
	case usagelog.FieldChannelID:
		return m.ChannelID()
	case usagelog.FieldModelID:
		return m.ModelID()
	case usagelog.FieldPromptTokens:
		return m.PromptTokens()
	case usagelog.FieldCompletionTokens:
		return m.CompletionTokens()
	case usagelog.FieldTotalTokens:
		return m.TotalTokens()
	case usagelog.FieldPromptAudioTokens:
		return m.PromptAudioTokens()
	case usagelog.FieldPromptCachedTokens:
		return m.PromptCachedTokens()
	case usagelog.FieldPromptWriteCachedTokens:
		return m.PromptWriteCachedTokens()
	case usagelog.FieldCompletionAudioTokens:
		return m.CompletionAudioTokens()
	case usagelog.FieldCompletionReasoningTokens:
		return m.CompletionReasoningTokens()
	case usagelog.FieldCompletionAcceptedPredictionTokens:
		return m.CompletionAcceptedPredictionTokens()
	case usagelog.FieldCompletionRejectedPredictionTokens:
		return m.CompletionRejectedPredictionTokens()
	case usagelog.FieldSource:
		return m.Source()
	case usagelog.FieldFormat:
		return m.Format()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UsageLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usagelog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case usagelog.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case usagelog.FieldRequestID:
		return m.OldRequestID(ctx)
	case usagelog.FieldProjectID:
		return m.OldProjectID(ctx)
	case usagelog.FieldChannelID:
		return m.OldChannelID(ctx)
	case usagelog.FieldModelID:
		return m.OldModelID(ctx)
	case usagelog.FieldPromptTokens:
		return m.OldPromptTokens(ctx)
	case usagelog.FieldCompletionTokens:
		return m.OldCompletionTokens(ctx)
	case usagelog.FieldTotalTokens:
		return m.OldTotalTokens(ctx)
	case usagelog.FieldPromptAudioTokens:
		return m.OldPromptAudioTokens(ctx)
	case usagelog.FieldPromptCachedTokens:
		return m.OldPromptCachedTokens(ctx)
	case usagelog.FieldPromptWriteCachedTokens:
		return m.OldPromptWriteCachedTokens(ctx)
	case usagelog.FieldCompletionAudioTokens:
		return m.OldCompletionAudioTokens(ctx)
	case usagelog.FieldCompletionReasoningTokens:
		return m.OldCompletionReasoningTokens(ctx)
	case usagelog.FieldCompletionAcceptedPredictionTokens:
		return m.OldCompletionAcceptedPredictionTokens(ctx)
	case usagelog.FieldCompletionRejectedPredictionTokens:
		return m.OldCompletionRejectedPredictionTokens(ctx)
	case usagelog.FieldSource:
		return m.OldSource(ctx)
	case usagelog.FieldFormat:
		return m.OldFormat(ctx)
	}
	return nil, fmt.Errorf("unknown UsageLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UsageLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usagelog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case usagelog.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case usagelog.FieldRequestID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestID(v)
		return nil
	case usagelog.FieldProjectID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case usagelog.FieldChannelID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelID(v)
		return nil
	case usagelog.FieldModelID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModelID(v)
		return nil
	case usagelog.FieldPromptTokens:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPromptTokens(v)
		return nil
	case usagelog.FieldCompletionTokens:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletionTokens(v)
		return nil
	case usagelog.FieldTotalTokens:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalTokens(v)
		return nil
	case usagelog.FieldPromptAudioTokens:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPromptAudioTokens(v)
		return nil
	case usagelog.FieldPromptCachedTokens:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPromptCachedTokens(v)
		return nil
	case usagelog.FieldPromptWriteCachedTokens:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPromptWriteCachedTokens(v)
		return nil
	case usagelog.FieldCompletionAudioTokens:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletionAudioTokens(v)
		return nil
	case usagelog.FieldCompletionReasoningTokens:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletionReasoningTokens(v)
		return nil
	case usagelog.FieldCompletionAcceptedPredictionTokens:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletionAcceptedPredictionTokens(v)
		return nil
	case usagelog.FieldCompletionRejectedPredictionTokens:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletionRejectedPredictionTokens(v)
		return nil
	case usagelog.FieldSource:
		v, ok := value.(usagelog.Source)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case usagelog.FieldFormat:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormat(v)
		return nil
	}
	return fmt.Errorf("unknown UsageLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UsageLogMutation) AddedFields() []string {
	var fields []string
	if m.addprompt_tokens != nil {
		fields = append(fields, usagelog.FieldPromptTokens)
	}
	if m.addcompletion_tokens != nil {
		fields = append(fields, usagelog.FieldCompletionTokens)
	}
	if m.addtotal_tokens != nil {
		fields = append(fields, usagelog.FieldTotalTokens)
	}
	if m.addprompt_audio_tokens != nil {
		fields = append(fields, usagelog.FieldPromptAudioTokens)
	}
	if m.addprompt_cached_tokens != nil {
		fields = append(fields, usagelog.FieldPromptCachedTokens)
	}
	if m.addprompt_write_cached_tokens != nil {
		fields = append(fields, usagelog.FieldPromptWriteCachedTokens)
	}
	if m.addcompletion_audio_tokens != nil {
		fields = append(fields, usagelog.FieldCompletionAudioTokens)
	}
	if m.addcompletion_reasoning_tokens != nil {
		fields = append(fields, usagelog.FieldCompletionReasoningTokens)
	}
	if m.addcompletion_accepted_prediction_tokens != nil {
		fields = append(fields, usagelog.FieldCompletionAcceptedPredictionTokens)
	}
	if m.addcompletion_rejected_prediction_tokens != nil {
		fields = append(fields, usagelog.FieldCompletionRejectedPredictionTokens)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UsageLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case usagelog.FieldPromptTokens:
		return m.AddedPromptTokens()
	case usagelog.FieldCompletionTokens:
		return m.AddedCompletionTokens()
	case usagelog.FieldTotalTokens:
		return m.AddedTotalTokens()
	case usagelog.FieldPromptAudioTokens:
		return m.AddedPromptAudioTokens()
	case usagelog.FieldPromptCachedTokens:
		return m.AddedPromptCachedTokens()
	case usagelog.FieldPromptWriteCachedTokens:
		return m.AddedPromptWriteCachedTokens()
	case usagelog.FieldCompletionAudioTokens:
		return m.AddedCompletionAudioTokens()
	case usagelog.FieldCompletionReasoningTokens:
		return m.AddedCompletionReasoningTokens()
	case usagelog.FieldCompletionAcceptedPredictionTokens:
		return m.AddedCompletionAcceptedPredictionTokens()
	case usagelog.FieldCompletionRejectedPredictionTokens:
		return m.AddedCompletionRejectedPredictionTokens()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UsageLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case usagelog.FieldPromptTokens:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPromptTokens(v)
		return nil
	case usagelog.FieldCompletionTokens:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCompletionTokens(v)
		return nil
	case usagelog.FieldTotalTokens:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalTokens(v)
		return nil
	case usagelog.FieldPromptAudioTokens:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPromptAudioTokens(v)
		return nil
	case usagelog.FieldPromptCachedTokens:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPromptCachedTokens(v)
		return nil
	case usagelog.FieldPromptWriteCachedTokens:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPromptWriteCachedTokens(v)
		return nil
	case usagelog.FieldCompletionAudioTokens:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCompletionAudioTokens(v)
		return nil
	case usagelog.FieldCompletionReasoningTokens:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCompletionReasoningTokens(v)
		return nil
	case usagelog.FieldCompletionAcceptedPredictionTokens:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCompletionAcceptedPredictionTokens(v)
		return nil
	case usagelog.FieldCompletionRejectedPredictionTokens:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCompletionRejectedPredictionTokens(v)
		return nil
	}
	return fmt.Errorf("unknown UsageLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UsageLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(usagelog.FieldChannelID) {
		fields = append(fields, usagelog.FieldChannelID)
	}
	if m.FieldCleared(usagelog.FieldPromptAudioTokens) {
		fields = append(fields, usagelog.FieldPromptAudioTokens)
	}
	if m.FieldCleared(usagelog.FieldPromptCachedTokens) {
		fields = append(fields, usagelog.FieldPromptCachedTokens)
	}
	if m.FieldCleared(usagelog.FieldPromptWriteCachedTokens) {
		fields = append(fields, usagelog.FieldPromptWriteCachedTokens)
	}
	if m.FieldCleared(usagelog.FieldCompletionAudioTokens) {
		fields = append(fields, usagelog.FieldCompletionAudioTokens)
	}
	if m.FieldCleared(usagelog.FieldCompletionReasoningTokens) {
		fields = append(fields, usagelog.FieldCompletionReasoningTokens)
	}
	if m.FieldCleared(usagelog.FieldCompletionAcceptedPredictionTokens) {
		fields = append(fields, usagelog.FieldCompletionAcceptedPredictionTokens)
	}
	if m.FieldCleared(usagelog.FieldCompletionRejectedPredictionTokens) {
		fields = append(fields, usagelog.FieldCompletionRejectedPredictionTokens)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UsageLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UsageLogMutation) ClearField(name string) error {
	switch name {
	case usagelog.FieldChannelID:
		m.ClearChannelID()
		return nil
	case usagelog.FieldPromptAudioTokens:
		m.ClearPromptAudioTokens()
		return nil
	case usagelog.FieldPromptCachedTokens:
		m.ClearPromptCachedTokens()
		return nil
	case usagelog.FieldPromptWriteCachedTokens:
		m.ClearPromptWriteCachedTokens()
		return nil
	case usagelog.FieldCompletionAudioTokens:
		m.ClearCompletionAudioTokens()
		return nil
	case usagelog.FieldCompletionReasoningTokens:
		m.ClearCompletionReasoningTokens()
		return nil
	case usagelog.FieldCompletionAcceptedPredictionTokens:
		m.ClearCompletionAcceptedPredictionTokens()
		return nil
	case usagelog.FieldCompletionRejectedPredictionTokens:
		m.ClearCompletionRejectedPredictionTokens()
		return nil
	}
	return fmt.Errorf("unknown UsageLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UsageLogMutation) ResetField(name string) error {
	switch name {
	case usagelog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case usagelog.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case usagelog.FieldRequestID:
		m.ResetRequestID()
		return nil
	case usagelog.FieldProjectID:
		m.ResetProjectID()
		return nil
	case usagelog.FieldChannelID:
		m.ResetChannelID()
		return nil
	case usagelog.FieldModelID:
		m.ResetModelID()
		return nil
	case usagelog.FieldPromptTokens:
		m.ResetPromptTokens()
		return nil
	case usagelog.FieldCompletionTokens:
		m.ResetCompletionTokens()
		return nil
	case usagelog.FieldTotalTokens:
		m.ResetTotalTokens()
		return nil
	case usagelog.FieldPromptAudioTokens:
		m.ResetPromptAudioTokens()
		return nil
	case usagelog.FieldPromptCachedTokens:
		m.ResetPromptCachedTokens()
		return nil
	case usagelog.FieldPromptWriteCachedTokens:
		m.ResetPromptWriteCachedTokens()
		return nil
	case usagelog.FieldCompletionAudioTokens:
		m.ResetCompletionAudioTokens()
		return nil
	case usagelog.FieldCompletionReasoningTokens:
		m.ResetCompletionReasoningTokens()
		return nil
	case usagelog.FieldCompletionAcceptedPredictionTokens:
		m.ResetCompletionAcceptedPredictionTokens()
		return nil
	case usagelog.FieldCompletionRejectedPredictionTokens:
		m.ResetCompletionRejectedPredictionTokens()
		return nil
	case usagelog.FieldSource:
		m.ResetSource()
		return nil
	case usagelog.FieldFormat:
		m.ResetFormat()
		return nil
	}
	return fmt.Errorf("unknown UsageLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UsageLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.request != nil {
		edges = append(edges, usagelog.EdgeRequest)
	}
	if m.project != nil {
		edges = append(edges, usagelog.EdgeProject)
	}
	if m.channel != nil {
		edges = append(edges, usagelog.EdgeChannel)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UsageLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usagelog.EdgeRequest:
		if id := m.request; id != nil {
			return []ent.Value{*id}
		}
	case usagelog.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case usagelog.EdgeChannel:
		if id := m.channel; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UsageLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UsageLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UsageLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedrequest {
		edges = append(edges, usagelog.EdgeRequest)
	}
	if m.clearedproject {
		edges = append(edges, usagelog.EdgeProject)
	}
	if m.clearedchannel {
		edges = append(edges, usagelog.EdgeChannel)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UsageLogMutation) EdgeCleared(name string) bool {
	switch name {
	case usagelog.EdgeRequest:
		return m.clearedrequest
	case usagelog.EdgeProject:
		return m.clearedproject
	case usagelog.EdgeChannel:
		return m.clearedchannel
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UsageLogMutation) ClearEdge(name string) error {
	switch name {
	case usagelog.EdgeRequest:
		m.ClearRequest()
		return nil
	case usagelog.EdgeProject:
		m.ClearProject()
		return nil
	case usagelog.EdgeChannel:
		m.ClearChannel()
		return nil
	}
	return fmt.Errorf("unknown UsageLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UsageLogMutation) ResetEdge(name string) error {
	switch name {
	case usagelog.EdgeRequest:
		m.ResetRequest()
		return nil
	case usagelog.EdgeProject:
		m.ResetProject()
		return nil
	case usagelog.EdgeChannel:
		m.ResetChannel()
		return nil
	}
	return fmt.Errorf("unknown UsageLog edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                                Op
	typ                               string
	id                                *int
	created_at                        *time.Time
	updated_at                        *time.Time
	deleted_at                        *int
	adddeleted_at                     *int
	email                             *string
	status                            *user.Status
	prefer_language                   *string
	password                          *string
	first_name                        *string
	last_name                         *string
	avatar                            *string
	is_owner                          *bool
	scopes                            *[]string
	appendscopes                      []string
	clearedFields                     map[string]struct{}
	projects                          map[int]struct{}
	removedprojects                   map[int]struct{}
	clearedprojects                   bool
	api_keys                          map[int]struct{}
	removedapi_keys                   map[int]struct{}
	clearedapi_keys                   bool
	roles                             map[int]struct{}
	removedroles                      map[int]struct{}
	clearedroles                      bool
	channel_override_templates        map[int]struct{}
	removedchannel_override_templates map[int]struct{}
	clearedchannel_override_templates bool
	project_users                     map[int]struct{}
	removedproject_users              map[int]struct{}
	clearedproject_users              bool
	user_roles                        map[int]struct{}
	removeduser_roles                 map[int]struct{}
	cleareduser_roles                 bool
	done                              bool
	oldValue                          func(context.Context) (*User, error)
	predicates                        []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserMutation) SetDeletedAt(i int) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserMutation) DeletedAt() (r int, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedAt(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *UserMutation) AddDeletedAt(i int) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *UserMutation) AddedDeletedAt() (r int, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetStatus sets the "status" field.
func (m *UserMutation) SetStatus(u user.Status) {
	m.status = &u
}

// Status returns the value of the "status" field in the mutation.
func (m *UserMutation) Status() (r user.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStatus(ctx context.Context) (v user.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *UserMutation) ResetStatus() {
	m.status = nil
}

// SetPreferLanguage sets the "prefer_language" field.
func (m *UserMutation) SetPreferLanguage(s string) {
	m.prefer_language = &s
}

// PreferLanguage returns the value of the "prefer_language" field in the mutation.
func (m *UserMutation) PreferLanguage() (r string, exists bool) {
	v := m.prefer_language
	if v == nil {
		return
	}
	return *v, true
}

// OldPreferLanguage returns the old "prefer_language" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPreferLanguage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPreferLanguage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPreferLanguage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPreferLanguage: %w", err)
	}
	return oldValue.PreferLanguage, nil
}

// ResetPreferLanguage resets all changes to the "prefer_language" field.
func (m *UserMutation) ResetPreferLanguage() {
	m.prefer_language = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetFirstName sets the "first_name" field.
func (m *UserMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *UserMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *UserMutation) ResetFirstName() {
	m.first_name = nil
}

// SetLastName sets the "last_name" field.
func (m *UserMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *UserMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *UserMutation) ResetLastName() {
	m.last_name = nil
}

// SetAvatar sets the "avatar" field.
func (m *UserMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *UserMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ClearAvatar clears the value of the "avatar" field.
func (m *UserMutation) ClearAvatar() {
	m.avatar = nil
	m.clearedFields[user.FieldAvatar] = struct{}{}
}

// AvatarCleared returns if the "avatar" field was cleared in this mutation.
func (m *UserMutation) AvatarCleared() bool {
	_, ok := m.clearedFields[user.FieldAvatar]
	return ok
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *UserMutation) ResetAvatar() {
	m.avatar = nil
	delete(m.clearedFields, user.FieldAvatar)
}

// SetIsOwner sets the "is_owner" field.
func (m *UserMutation) SetIsOwner(b bool) {
	m.is_owner = &b
}

// IsOwner returns the value of the "is_owner" field in the mutation.
func (m *UserMutation) IsOwner() (r bool, exists bool) {
	v := m.is_owner
	if v == nil {
		return
	}
	return *v, true
}

// OldIsOwner returns the old "is_owner" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsOwner(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsOwner is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsOwner requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsOwner: %w", err)
	}
	return oldValue.IsOwner, nil
}

// ResetIsOwner resets all changes to the "is_owner" field.
func (m *UserMutation) ResetIsOwner() {
	m.is_owner = nil
}

// SetScopes sets the "scopes" field.
func (m *UserMutation) SetScopes(s []string) {
	m.scopes = &s
	m.appendscopes = nil
}

// Scopes returns the value of the "scopes" field in the mutation.
func (m *UserMutation) Scopes() (r []string, exists bool) {
	v := m.scopes
	if v == nil {
		return
	}
	return *v, true
}

// OldScopes returns the old "scopes" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldScopes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopes: %w", err)
	}
	return oldValue.Scopes, nil
}

// AppendScopes adds s to the "scopes" field.
func (m *UserMutation) AppendScopes(s []string) {
	m.appendscopes = append(m.appendscopes, s...)
}

// AppendedScopes returns the list of values that were appended to the "scopes" field in this mutation.
func (m *UserMutation) AppendedScopes() ([]string, bool) {
	if len(m.appendscopes) == 0 {
		return nil, false
	}
	return m.appendscopes, true
}

// ClearScopes clears the value of the "scopes" field.
func (m *UserMutation) ClearScopes() {
	m.scopes = nil
	m.appendscopes = nil
	m.clearedFields[user.FieldScopes] = struct{}{}
}

// ScopesCleared returns if the "scopes" field was cleared in this mutation.
func (m *UserMutation) ScopesCleared() bool {
	_, ok := m.clearedFields[user.FieldScopes]
	return ok
}

// ResetScopes resets all changes to the "scopes" field.
func (m *UserMutation) ResetScopes() {
	m.scopes = nil
	m.appendscopes = nil
	delete(m.clearedFields, user.FieldScopes)
}

// AddProjectIDs adds the "projects" edge to the Project entity by ids.
func (m *UserMutation) AddProjectIDs(ids ...int) {
	if m.projects == nil {
		m.projects = make(map[int]struct{})
	}
	for i := range ids {
		m.projects[ids[i]] = struct{}{}
	}
}

// ClearProjects clears the "projects" edge to the Project entity.
func (m *UserMutation) ClearProjects() {
	m.clearedprojects = true
}

// ProjectsCleared reports if the "projects" edge to the Project entity was cleared.
func (m *UserMutation) ProjectsCleared() bool {
	return m.clearedprojects
}

// RemoveProjectIDs removes the "projects" edge to the Project entity by IDs.
func (m *UserMutation) RemoveProjectIDs(ids ...int) {
	if m.removedprojects == nil {
		m.removedprojects = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.projects, ids[i])
		m.removedprojects[ids[i]] = struct{}{}
	}
}

// RemovedProjects returns the removed IDs of the "projects" edge to the Project entity.
func (m *UserMutation) RemovedProjectsIDs() (ids []int) {
	for id := range m.removedprojects {
		ids = append(ids, id)
	}
	return
}

// ProjectsIDs returns the "projects" edge IDs in the mutation.
func (m *UserMutation) ProjectsIDs() (ids []int) {
	for id := range m.projects {
		ids = append(ids, id)
	}
	return
}

// ResetProjects resets all changes to the "projects" edge.
func (m *UserMutation) ResetProjects() {
	m.projects = nil
	m.clearedprojects = false
	m.removedprojects = nil
}

// AddAPIKeyIDs adds the "api_keys" edge to the APIKey entity by ids.
func (m *UserMutation) AddAPIKeyIDs(ids ...int) {
	if m.api_keys == nil {
		m.api_keys = make(map[int]struct{})
	}
	for i := range ids {
		m.api_keys[ids[i]] = struct{}{}
	}
}

// ClearAPIKeys clears the "api_keys" edge to the APIKey entity.
func (m *UserMutation) ClearAPIKeys() {
	m.clearedapi_keys = true
}

// APIKeysCleared reports if the "api_keys" edge to the APIKey entity was cleared.
func (m *UserMutation) APIKeysCleared() bool {
	return m.clearedapi_keys
}

// RemoveAPIKeyIDs removes the "api_keys" edge to the APIKey entity by IDs.
func (m *UserMutation) RemoveAPIKeyIDs(ids ...int) {
	if m.removedapi_keys == nil {
		m.removedapi_keys = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.api_keys, ids[i])
		m.removedapi_keys[ids[i]] = struct{}{}
	}
}

// RemovedAPIKeys returns the removed IDs of the "api_keys" edge to the APIKey entity.
func (m *UserMutation) RemovedAPIKeysIDs() (ids []int) {
	for id := range m.removedapi_keys {
		ids = append(ids, id)
	}
	return
}

// APIKeysIDs returns the "api_keys" edge IDs in the mutation.
func (m *UserMutation) APIKeysIDs() (ids []int) {
	for id := range m.api_keys {
		ids = append(ids, id)
	}
	return
}

// ResetAPIKeys resets all changes to the "api_keys" edge.
func (m *UserMutation) ResetAPIKeys() {
	m.api_keys = nil
	m.clearedapi_keys = false
	m.removedapi_keys = nil
}

// AddRoleIDs adds the "roles" edge to the Role entity by ids.
func (m *UserMutation) AddRoleIDs(ids ...int) {
	if m.roles == nil {
		m.roles = make(map[int]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the Role entity.
func (m *UserMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the Role entity was cleared.
func (m *UserMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the Role entity by IDs.
func (m *UserMutation) RemoveRoleIDs(ids ...int) {
	if m.removedroles == nil {
		m.removedroles = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the Role entity.
func (m *UserMutation) RemovedRolesIDs() (ids []int) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *UserMutation) RolesIDs() (ids []int) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *UserMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// AddChannelOverrideTemplateIDs adds the "channel_override_templates" edge to the ChannelOverrideTemplate entity by ids.
func (m *UserMutation) AddChannelOverrideTemplateIDs(ids ...int) {
	if m.channel_override_templates == nil {
		m.channel_override_templates = make(map[int]struct{})
	}
	for i := range ids {
		m.channel_override_templates[ids[i]] = struct{}{}
	}
}

// ClearChannelOverrideTemplates clears the "channel_override_templates" edge to the ChannelOverrideTemplate entity.
func (m *UserMutation) ClearChannelOverrideTemplates() {
	m.clearedchannel_override_templates = true
}

// ChannelOverrideTemplatesCleared reports if the "channel_override_templates" edge to the ChannelOverrideTemplate entity was cleared.
func (m *UserMutation) ChannelOverrideTemplatesCleared() bool {
	return m.clearedchannel_override_templates
}

// RemoveChannelOverrideTemplateIDs removes the "channel_override_templates" edge to the ChannelOverrideTemplate entity by IDs.
func (m *UserMutation) RemoveChannelOverrideTemplateIDs(ids ...int) {
	if m.removedchannel_override_templates == nil {
		m.removedchannel_override_templates = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.channel_override_templates, ids[i])
		m.removedchannel_override_templates[ids[i]] = struct{}{}
	}
}

// RemovedChannelOverrideTemplates returns the removed IDs of the "channel_override_templates" edge to the ChannelOverrideTemplate entity.
func (m *UserMutation) RemovedChannelOverrideTemplatesIDs() (ids []int) {
	for id := range m.removedchannel_override_templates {
		ids = append(ids, id)
	}
	return
}

// ChannelOverrideTemplatesIDs returns the "channel_override_templates" edge IDs in the mutation.
func (m *UserMutation) ChannelOverrideTemplatesIDs() (ids []int) {
	for id := range m.channel_override_templates {
		ids = append(ids, id)
	}
	return
}

// ResetChannelOverrideTemplates resets all changes to the "channel_override_templates" edge.
func (m *UserMutation) ResetChannelOverrideTemplates() {
	m.channel_override_templates = nil
	m.clearedchannel_override_templates = false
	m.removedchannel_override_templates = nil
}

// AddProjectUserIDs adds the "project_users" edge to the UserProject entity by ids.
func (m *UserMutation) AddProjectUserIDs(ids ...int) {
	if m.project_users == nil {
		m.project_users = make(map[int]struct{})
	}
	for i := range ids {
		m.project_users[ids[i]] = struct{}{}
	}
}

// ClearProjectUsers clears the "project_users" edge to the UserProject entity.
func (m *UserMutation) ClearProjectUsers() {
	m.clearedproject_users = true
}

// ProjectUsersCleared reports if the "project_users" edge to the UserProject entity was cleared.
func (m *UserMutation) ProjectUsersCleared() bool {
	return m.clearedproject_users
}

// RemoveProjectUserIDs removes the "project_users" edge to the UserProject entity by IDs.
func (m *UserMutation) RemoveProjectUserIDs(ids ...int) {
	if m.removedproject_users == nil {
		m.removedproject_users = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.project_users, ids[i])
		m.removedproject_users[ids[i]] = struct{}{}
	}
}

// RemovedProjectUsers returns the removed IDs of the "project_users" edge to the UserProject entity.
func (m *UserMutation) RemovedProjectUsersIDs() (ids []int) {
	for id := range m.removedproject_users {
		ids = append(ids, id)
	}
	return
}

// ProjectUsersIDs returns the "project_users" edge IDs in the mutation.
func (m *UserMutation) ProjectUsersIDs() (ids []int) {
	for id := range m.project_users {
		ids = append(ids, id)
	}
	return
}

// ResetProjectUsers resets all changes to the "project_users" edge.
func (m *UserMutation) ResetProjectUsers() {
	m.project_users = nil
	m.clearedproject_users = false
	m.removedproject_users = nil
}

// AddUserRoleIDs adds the "user_roles" edge to the UserRole entity by ids.
func (m *UserMutation) AddUserRoleIDs(ids ...int) {
	if m.user_roles == nil {
		m.user_roles = make(map[int]struct{})
	}
	for i := range ids {
		m.user_roles[ids[i]] = struct{}{}
	}
}

// ClearUserRoles clears the "user_roles" edge to the UserRole entity.
func (m *UserMutation) ClearUserRoles() {
	m.cleareduser_roles = true
}

// UserRolesCleared reports if the "user_roles" edge to the UserRole entity was cleared.
func (m *UserMutation) UserRolesCleared() bool {
	return m.cleareduser_roles
}

// RemoveUserRoleIDs removes the "user_roles" edge to the UserRole entity by IDs.
func (m *UserMutation) RemoveUserRoleIDs(ids ...int) {
	if m.removeduser_roles == nil {
		m.removeduser_roles = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user_roles, ids[i])
		m.removeduser_roles[ids[i]] = struct{}{}
	}
}

// RemovedUserRoles returns the removed IDs of the "user_roles" edge to the UserRole entity.
func (m *UserMutation) RemovedUserRolesIDs() (ids []int) {
	for id := range m.removeduser_roles {
		ids = append(ids, id)
	}
	return
}

// UserRolesIDs returns the "user_roles" edge IDs in the mutation.
func (m *UserMutation) UserRolesIDs() (ids []int) {
	for id := range m.user_roles {
		ids = append(ids, id)
	}
	return
}

// ResetUserRoles resets all changes to the "user_roles" edge.
func (m *UserMutation) ResetUserRoles() {
	m.user_roles = nil
	m.cleareduser_roles = false
	m.removeduser_roles = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.status != nil {
		fields = append(fields, user.FieldStatus)
	}
	if m.prefer_language != nil {
		fields = append(fields, user.FieldPreferLanguage)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.first_name != nil {
		fields = append(fields, user.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, user.FieldLastName)
	}
	if m.avatar != nil {
		fields = append(fields, user.FieldAvatar)
	}
	if m.is_owner != nil {
		fields = append(fields, user.FieldIsOwner)
	}
	if m.scopes != nil {
		fields = append(fields, user.FieldScopes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldDeletedAt:
		return m.DeletedAt()
	case user.FieldEmail:
		return m.Email()
	case user.FieldStatus:
		return m.Status()
	case user.FieldPreferLanguage:
		return m.PreferLanguage()
	case user.FieldPassword:
		return m.Password()
	case user.FieldFirstName:
		return m.FirstName()
	case user.FieldLastName:
		return m.LastName()
	case user.FieldAvatar:
		return m.Avatar()
	case user.FieldIsOwner:
		return m.IsOwner()
	case user.FieldScopes:
		return m.Scopes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldStatus:
		return m.OldStatus(ctx)
	case user.FieldPreferLanguage:
		return m.OldPreferLanguage(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldFirstName:
		return m.OldFirstName(ctx)
	case user.FieldLastName:
		return m.OldLastName(ctx)
	case user.FieldAvatar:
		return m.OldAvatar(ctx)
	case user.FieldIsOwner:
		return m.OldIsOwner(ctx)
	case user.FieldScopes:
		return m.OldScopes(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(user.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case user.FieldPreferLanguage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPreferLanguage(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case user.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case user.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case user.FieldIsOwner:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsOwner(v)
		return nil
	case user.FieldScopes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopes(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldAvatar) {
		fields = append(fields, user.FieldAvatar)
	}
	if m.FieldCleared(user.FieldScopes) {
		fields = append(fields, user.FieldScopes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldAvatar:
		m.ClearAvatar()
		return nil
	case user.FieldScopes:
		m.ClearScopes()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldStatus:
		m.ResetStatus()
		return nil
	case user.FieldPreferLanguage:
		m.ResetPreferLanguage()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldFirstName:
		m.ResetFirstName()
		return nil
	case user.FieldLastName:
		m.ResetLastName()
		return nil
	case user.FieldAvatar:
		m.ResetAvatar()
		return nil
	case user.FieldIsOwner:
		m.ResetIsOwner()
		return nil
	case user.FieldScopes:
		m.ResetScopes()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.projects != nil {
		edges = append(edges, user.EdgeProjects)
	}
	if m.api_keys != nil {
		edges = append(edges, user.EdgeAPIKeys)
	}
	if m.roles != nil {
		edges = append(edges, user.EdgeRoles)
	}
	if m.channel_override_templates != nil {
		edges = append(edges, user.EdgeChannelOverrideTemplates)
	}
	if m.project_users != nil {
		edges = append(edges, user.EdgeProjectUsers)
	}
	if m.user_roles != nil {
		edges = append(edges, user.EdgeUserRoles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.projects))
		for id := range m.projects {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAPIKeys:
		ids := make([]ent.Value, 0, len(m.api_keys))
		for id := range m.api_keys {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeChannelOverrideTemplates:
		ids := make([]ent.Value, 0, len(m.channel_override_templates))
		for id := range m.channel_override_templates {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeProjectUsers:
		ids := make([]ent.Value, 0, len(m.project_users))
		for id := range m.project_users {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserRoles:
		ids := make([]ent.Value, 0, len(m.user_roles))
		for id := range m.user_roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedprojects != nil {
		edges = append(edges, user.EdgeProjects)
	}
	if m.removedapi_keys != nil {
		edges = append(edges, user.EdgeAPIKeys)
	}
	if m.removedroles != nil {
		edges = append(edges, user.EdgeRoles)
	}
	if m.removedchannel_override_templates != nil {
		edges = append(edges, user.EdgeChannelOverrideTemplates)
	}
	if m.removedproject_users != nil {
		edges = append(edges, user.EdgeProjectUsers)
	}
	if m.removeduser_roles != nil {
		edges = append(edges, user.EdgeUserRoles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.removedprojects))
		for id := range m.removedprojects {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAPIKeys:
		ids := make([]ent.Value, 0, len(m.removedapi_keys))
		for id := range m.removedapi_keys {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeChannelOverrideTemplates:
		ids := make([]ent.Value, 0, len(m.removedchannel_override_templates))
		for id := range m.removedchannel_override_templates {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeProjectUsers:
		ids := make([]ent.Value, 0, len(m.removedproject_users))
		for id := range m.removedproject_users {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserRoles:
		ids := make([]ent.Value, 0, len(m.removeduser_roles))
		for id := range m.removeduser_roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedprojects {
		edges = append(edges, user.EdgeProjects)
	}
	if m.clearedapi_keys {
		edges = append(edges, user.EdgeAPIKeys)
	}
	if m.clearedroles {
		edges = append(edges, user.EdgeRoles)
	}
	if m.clearedchannel_override_templates {
		edges = append(edges, user.EdgeChannelOverrideTemplates)
	}
	if m.clearedproject_users {
		edges = append(edges, user.EdgeProjectUsers)
	}
	if m.cleareduser_roles {
		edges = append(edges, user.EdgeUserRoles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeProjects:
		return m.clearedprojects
	case user.EdgeAPIKeys:
		return m.clearedapi_keys
	case user.EdgeRoles:
		return m.clearedroles
	case user.EdgeChannelOverrideTemplates:
		return m.clearedchannel_override_templates
	case user.EdgeProjectUsers:
		return m.clearedproject_users
	case user.EdgeUserRoles:
		return m.cleareduser_roles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeProjects:
		m.ResetProjects()
		return nil
	case user.EdgeAPIKeys:
		m.ResetAPIKeys()
		return nil
	case user.EdgeRoles:
		m.ResetRoles()
		return nil
	case user.EdgeChannelOverrideTemplates:
		m.ResetChannelOverrideTemplates()
		return nil
	case user.EdgeProjectUsers:
		m.ResetProjectUsers()
		return nil
	case user.EdgeUserRoles:
		m.ResetUserRoles()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserProjectMutation represents an operation that mutates the UserProject nodes in the graph.
type UserProjectMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	updated_at     *time.Time
	deleted_at     *int
	adddeleted_at  *int
	is_owner       *bool
	scopes         *[]string
	appendscopes   []string
	clearedFields  map[string]struct{}
	user           *int
	cleareduser    bool
	project        *int
	clearedproject bool
	done           bool
	oldValue       func(context.Context) (*UserProject, error)
	predicates     []predicate.UserProject
}

var _ ent.Mutation = (*UserProjectMutation)(nil)

// userprojectOption allows management of the mutation configuration using functional options.
type userprojectOption func(*UserProjectMutation)

// newUserProjectMutation creates new mutation for the UserProject entity.
func newUserProjectMutation(c config, op Op, opts ...userprojectOption) *UserProjectMutation {
	m := &UserProjectMutation{
		config:        c,
		op:            op,
		typ:           TypeUserProject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserProjectID sets the ID field of the mutation.
func withUserProjectID(id int) userprojectOption {
	return func(m *UserProjectMutation) {
		var (
			err   error
			once  sync.Once
			value *UserProject
		)
		m.oldValue = func(ctx context.Context) (*UserProject, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserProject.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserProject sets the old UserProject of the mutation.
func withUserProject(node *UserProject) userprojectOption {
	return func(m *UserProjectMutation) {
		m.oldValue = func(context.Context) (*UserProject, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserProjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserProjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserProjectMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserProjectMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserProject.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserProjectMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserProjectMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserProject entity.
// If the UserProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProjectMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserProjectMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserProjectMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserProjectMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserProject entity.
// If the UserProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProjectMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserProjectMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserProjectMutation) SetDeletedAt(i int) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserProjectMutation) DeletedAt() (r int, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the UserProject entity.
// If the UserProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProjectMutation) OldDeletedAt(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *UserProjectMutation) AddDeletedAt(i int) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *UserProjectMutation) AddedDeletedAt() (r int, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserProjectMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetUserID sets the "user_id" field.
func (m *UserProjectMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserProjectMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserProject entity.
// If the UserProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProjectMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserProjectMutation) ResetUserID() {
	m.user = nil
}

// SetProjectID sets the "project_id" field.
func (m *UserProjectMutation) SetProjectID(i int) {
	m.project = &i
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *UserProjectMutation) ProjectID() (r int, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the UserProject entity.
// If the UserProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProjectMutation) OldProjectID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *UserProjectMutation) ResetProjectID() {
	m.project = nil
}

// SetIsOwner sets the "is_owner" field.
func (m *UserProjectMutation) SetIsOwner(b bool) {
	m.is_owner = &b
}

// IsOwner returns the value of the "is_owner" field in the mutation.
func (m *UserProjectMutation) IsOwner() (r bool, exists bool) {
	v := m.is_owner
	if v == nil {
		return
	}
	return *v, true
}

// OldIsOwner returns the old "is_owner" field's value of the UserProject entity.
// If the UserProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProjectMutation) OldIsOwner(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsOwner is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsOwner requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsOwner: %w", err)
	}
	return oldValue.IsOwner, nil
}

// ResetIsOwner resets all changes to the "is_owner" field.
func (m *UserProjectMutation) ResetIsOwner() {
	m.is_owner = nil
}

// SetScopes sets the "scopes" field.
func (m *UserProjectMutation) SetScopes(s []string) {
	m.scopes = &s
	m.appendscopes = nil
}

// Scopes returns the value of the "scopes" field in the mutation.
func (m *UserProjectMutation) Scopes() (r []string, exists bool) {
	v := m.scopes
	if v == nil {
		return
	}
	return *v, true
}

// OldScopes returns the old "scopes" field's value of the UserProject entity.
// If the UserProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProjectMutation) OldScopes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopes: %w", err)
	}
	return oldValue.Scopes, nil
}

// AppendScopes adds s to the "scopes" field.
func (m *UserProjectMutation) AppendScopes(s []string) {
	m.appendscopes = append(m.appendscopes, s...)
}

// AppendedScopes returns the list of values that were appended to the "scopes" field in this mutation.
func (m *UserProjectMutation) AppendedScopes() ([]string, bool) {
	if len(m.appendscopes) == 0 {
		return nil, false
	}
	return m.appendscopes, true
}

// ClearScopes clears the value of the "scopes" field.
func (m *UserProjectMutation) ClearScopes() {
	m.scopes = nil
	m.appendscopes = nil
	m.clearedFields[userproject.FieldScopes] = struct{}{}
}

// ScopesCleared returns if the "scopes" field was cleared in this mutation.
func (m *UserProjectMutation) ScopesCleared() bool {
	_, ok := m.clearedFields[userproject.FieldScopes]
	return ok
}

// ResetScopes resets all changes to the "scopes" field.
func (m *UserProjectMutation) ResetScopes() {
	m.scopes = nil
	m.appendscopes = nil
	delete(m.clearedFields, userproject.FieldScopes)
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserProjectMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[userproject.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserProjectMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserProjectMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserProjectMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearProject clears the "project" edge to the Project entity.
func (m *UserProjectMutation) ClearProject() {
	m.clearedproject = true
	m.clearedFields[userproject.FieldProjectID] = struct{}{}
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *UserProjectMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *UserProjectMutation) ProjectIDs() (ids []int) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *UserProjectMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// Where appends a list predicates to the UserProjectMutation builder.
func (m *UserProjectMutation) Where(ps ...predicate.UserProject) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserProjectMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserProjectMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserProject, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserProjectMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserProjectMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserProject).
func (m *UserProjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserProjectMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, userproject.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userproject.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, userproject.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, userproject.FieldUserID)
	}
	if m.project != nil {
		fields = append(fields, userproject.FieldProjectID)
	}
	if m.is_owner != nil {
		fields = append(fields, userproject.FieldIsOwner)
	}
	if m.scopes != nil {
		fields = append(fields, userproject.FieldScopes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserProjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userproject.FieldCreatedAt:
		return m.CreatedAt()
	case userproject.FieldUpdatedAt:
		return m.UpdatedAt()
	case userproject.FieldDeletedAt:
		return m.DeletedAt()
	case userproject.FieldUserID:
		return m.UserID()
	case userproject.FieldProjectID:
		return m.ProjectID()
	case userproject.FieldIsOwner:
		return m.IsOwner()
	case userproject.FieldScopes:
		return m.Scopes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserProjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userproject.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userproject.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userproject.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case userproject.FieldUserID:
		return m.OldUserID(ctx)
	case userproject.FieldProjectID:
		return m.OldProjectID(ctx)
	case userproject.FieldIsOwner:
		return m.OldIsOwner(ctx)
	case userproject.FieldScopes:
		return m.OldScopes(ctx)
	}
	return nil, fmt.Errorf("unknown UserProject field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserProjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userproject.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userproject.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userproject.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case userproject.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userproject.FieldProjectID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case userproject.FieldIsOwner:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsOwner(v)
		return nil
	case userproject.FieldScopes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopes(v)
		return nil
	}
	return fmt.Errorf("unknown UserProject field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserProjectMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, userproject.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserProjectMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userproject.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserProjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userproject.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserProject numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserProjectMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userproject.FieldScopes) {
		fields = append(fields, userproject.FieldScopes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserProjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserProjectMutation) ClearField(name string) error {
	switch name {
	case userproject.FieldScopes:
		m.ClearScopes()
		return nil
	}
	return fmt.Errorf("unknown UserProject nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserProjectMutation) ResetField(name string) error {
	switch name {
	case userproject.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userproject.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userproject.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case userproject.FieldUserID:
		m.ResetUserID()
		return nil
	case userproject.FieldProjectID:
		m.ResetProjectID()
		return nil
	case userproject.FieldIsOwner:
		m.ResetIsOwner()
		return nil
	case userproject.FieldScopes:
		m.ResetScopes()
		return nil
	}
	return fmt.Errorf("unknown UserProject field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserProjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, userproject.EdgeUser)
	}
	if m.project != nil {
		edges = append(edges, userproject.EdgeProject)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserProjectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userproject.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case userproject.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserProjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserProjectMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserProjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, userproject.EdgeUser)
	}
	if m.clearedproject {
		edges = append(edges, userproject.EdgeProject)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserProjectMutation) EdgeCleared(name string) bool {
	switch name {
	case userproject.EdgeUser:
		return m.cleareduser
	case userproject.EdgeProject:
		return m.clearedproject
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserProjectMutation) ClearEdge(name string) error {
	switch name {
	case userproject.EdgeUser:
		m.ClearUser()
		return nil
	case userproject.EdgeProject:
		m.ClearProject()
		return nil
	}
	return fmt.Errorf("unknown UserProject unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserProjectMutation) ResetEdge(name string) error {
	switch name {
	case userproject.EdgeUser:
		m.ResetUser()
		return nil
	case userproject.EdgeProject:
		m.ResetProject()
		return nil
	}
	return fmt.Errorf("unknown UserProject edge %s", name)
}

// UserRoleMutation represents an operation that mutates the UserRole nodes in the graph.
type UserRoleMutation struct {
	config
	op            Op
	typ           string
	id            *int
	deleted_at    *int
	adddeleted_at *int
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	role          *int
	clearedrole   bool
	done          bool
	oldValue      func(context.Context) (*UserRole, error)
	predicates    []predicate.UserRole
}

var _ ent.Mutation = (*UserRoleMutation)(nil)

// userroleOption allows management of the mutation configuration using functional options.
type userroleOption func(*UserRoleMutation)

// newUserRoleMutation creates new mutation for the UserRole entity.
func newUserRoleMutation(c config, op Op, opts ...userroleOption) *UserRoleMutation {
	m := &UserRoleMutation{
		config:        c,
		op:            op,
		typ:           TypeUserRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserRoleID sets the ID field of the mutation.
func withUserRoleID(id int) userroleOption {
	return func(m *UserRoleMutation) {
		var (
			err   error
			once  sync.Once
			value *UserRole
		)
		m.oldValue = func(ctx context.Context) (*UserRole, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserRole.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserRole sets the old UserRole of the mutation.
func withUserRole(node *UserRole) userroleOption {
	return func(m *UserRoleMutation) {
		m.oldValue = func(context.Context) (*UserRole, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserRoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserRoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserRoleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserRoleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserRole.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserRoleMutation) SetDeletedAt(i int) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserRoleMutation) DeletedAt() (r int, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldDeletedAt(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *UserRoleMutation) AddDeletedAt(i int) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *UserRoleMutation) AddedDeletedAt() (r int, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserRoleMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetUserID sets the "user_id" field.
func (m *UserRoleMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserRoleMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserRoleMutation) ResetUserID() {
	m.user = nil
}

// SetRoleID sets the "role_id" field.
func (m *UserRoleMutation) SetRoleID(i int) {
	m.role = &i
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *UserRoleMutation) RoleID() (r int, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldRoleID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *UserRoleMutation) ResetRoleID() {
	m.role = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserRoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserRoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *UserRoleMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[userrole.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *UserRoleMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[userrole.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserRoleMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, userrole.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserRoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserRoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserRoleMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[userrole.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserRoleMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[userrole.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserRoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, userrole.FieldUpdatedAt)
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserRoleMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[userrole.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserRoleMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserRoleMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserRoleMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearRole clears the "role" edge to the Role entity.
func (m *UserRoleMutation) ClearRole() {
	m.clearedrole = true
	m.clearedFields[userrole.FieldRoleID] = struct{}{}
}

// RoleCleared reports if the "role" edge to the Role entity was cleared.
func (m *UserRoleMutation) RoleCleared() bool {
	return m.clearedrole
}

// RoleIDs returns the "role" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoleID instead. It exists only for internal usage by the builders.
func (m *UserRoleMutation) RoleIDs() (ids []int) {
	if id := m.role; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRole resets all changes to the "role" edge.
func (m *UserRoleMutation) ResetRole() {
	m.role = nil
	m.clearedrole = false
}

// Where appends a list predicates to the UserRoleMutation builder.
func (m *UserRoleMutation) Where(ps ...predicate.UserRole) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserRoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserRoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserRole, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserRoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserRoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserRole).
func (m *UserRoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserRoleMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.deleted_at != nil {
		fields = append(fields, userrole.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, userrole.FieldUserID)
	}
	if m.role != nil {
		fields = append(fields, userrole.FieldRoleID)
	}
	if m.created_at != nil {
		fields = append(fields, userrole.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userrole.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserRoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userrole.FieldDeletedAt:
		return m.DeletedAt()
	case userrole.FieldUserID:
		return m.UserID()
	case userrole.FieldRoleID:
		return m.RoleID()
	case userrole.FieldCreatedAt:
		return m.CreatedAt()
	case userrole.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserRoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userrole.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case userrole.FieldUserID:
		return m.OldUserID(ctx)
	case userrole.FieldRoleID:
		return m.OldRoleID(ctx)
	case userrole.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userrole.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UserRole field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserRoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userrole.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case userrole.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userrole.FieldRoleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	case userrole.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userrole.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserRole field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserRoleMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, userrole.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserRoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userrole.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserRoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userrole.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserRole numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserRoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userrole.FieldCreatedAt) {
		fields = append(fields, userrole.FieldCreatedAt)
	}
	if m.FieldCleared(userrole.FieldUpdatedAt) {
		fields = append(fields, userrole.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserRoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserRoleMutation) ClearField(name string) error {
	switch name {
	case userrole.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case userrole.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown UserRole nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserRoleMutation) ResetField(name string) error {
	switch name {
	case userrole.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case userrole.FieldUserID:
		m.ResetUserID()
		return nil
	case userrole.FieldRoleID:
		m.ResetRoleID()
		return nil
	case userrole.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userrole.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown UserRole field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserRoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, userrole.EdgeUser)
	}
	if m.role != nil {
		edges = append(edges, userrole.EdgeRole)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserRoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userrole.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case userrole.EdgeRole:
		if id := m.role; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserRoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserRoleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserRoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, userrole.EdgeUser)
	}
	if m.clearedrole {
		edges = append(edges, userrole.EdgeRole)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserRoleMutation) EdgeCleared(name string) bool {
	switch name {
	case userrole.EdgeUser:
		return m.cleareduser
	case userrole.EdgeRole:
		return m.clearedrole
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserRoleMutation) ClearEdge(name string) error {
	switch name {
	case userrole.EdgeUser:
		m.ClearUser()
		return nil
	case userrole.EdgeRole:
		m.ClearRole()
		return nil
	}
	return fmt.Errorf("unknown UserRole unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserRoleMutation) ResetEdge(name string) error {
	switch name {
	case userrole.EdgeUser:
		m.ResetUser()
		return nil
	case userrole.EdgeRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown UserRole edge %s", name)
}
