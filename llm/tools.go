package llm

import (
	"encoding/json"
	"errors"
	"slices"
	"strings"
)

// Tool represents a function tool.
type Tool struct {
	// Type is the type of the tool.
	// Any of "function", "image_generation", "web_search", or "google" (for Google-specific tools).
	Type string `json:"type"`

	// Function is the function definition, will be used when Type is "function".
	Function Function `json:"function"`

	// ImageGeneration is the image generation definition, will be used when Type is "image_generation".
	ImageGeneration *ImageGeneration `json:"image_generation,omitempty"`

	// WebSearch is the web search definition, will be used when Type is "web_search".
	WebSearch *WebSearch `json:"web_search,omitempty"`

	// Google contains Google/Gemini-specific grounding tools.
	// This namespace isolates Google's tools from other providers.
	Google *GoogleTools `json:"google,omitempty"`

	// CacheControl is used for provider-specific cache control (e.g., Anthropic).
	// This field is not serialized in JSON.
	CacheControl *CacheControl `json:"cache_control,omitempty"`
}

// Function represents a function definition.
type Function struct {
	Name        string          `json:"name"`
	Description string          `json:"description,omitempty"`
	Parameters  json.RawMessage `json:"parameters,omitempty"`
	// ParametersJsonSchema is the newer Gemini format that supports full JSON Schema Draft 2020-12
	// including const, enum, and other advanced features. This field is mutually exclusive with Parameters.
	ParametersJsonSchema json.RawMessage `json:"parametersJsonSchema,omitempty"`
	Strict               *bool           `json:"strict,omitempty"`
}

// FunctionCall represents a function call (deprecated).
type FunctionCall struct {
	// The name of the function to call.
	Name string `json:"name"`

	// The arguments to call the function with, as generated by the model in JSON
	// format. Note that the model does not always generate valid JSON, and may
	// hallucinate parameters not defined by your function schema. Validate the
	// arguments in your code before calling your function.
	Arguments string `json:"arguments"`
}

// ToolCall represents a tool call in the response.
type ToolCall struct {
	ID string `json:"id,omitempty"`

	// The type of the tool. Currently, only `function` is supported.
	Type string `json:"type,omitempty"`

	Function FunctionCall `json:"function"`

	// Index is the index of the tool call in the list of tool calls.
	// Cannot use omitempty, as an index of 0 would be omitted, which can break consumers.
	Index int `json:"index"`

	// CacheControl is used for provider-specific cache control (e.g., Anthropic).
	CacheControl *CacheControl `json:"cache_control,omitempty"`

	// TransformerMetadata is used for provider-specific metadata (e.g., Gemini).
	TransformerMetadata map[string]any `json:"transformer_metadata,omitempty"`
}

type ToolFunction struct {
	Name string `json:"name"`
}

// ToolChoice represents the tool choice parameter for function calling.
//
// Tool choice can be a string or a struct.
type ToolChoice struct {
	ToolChoice      *string          `json:"tool_choice,omitempty"`
	NamedToolChoice *NamedToolChoice `json:"named_tool_choice,omitempty"`
}

type NamedToolChoice struct {
	Type     string       `json:"type"`
	Function ToolFunction `json:"function"`
}

func (t ToolChoice) MarshalJSON() ([]byte, error) {
	if t.ToolChoice != nil {
		return json.Marshal(t.ToolChoice)
	}

	return json.Marshal(t.NamedToolChoice)
}

func (t *ToolChoice) UnmarshalJSON(data []byte) error {
	var str string

	err := json.Unmarshal(data, &str)
	if err == nil {
		t.ToolChoice = &str
		return nil
	}

	var named NamedToolChoice

	err = json.Unmarshal(data, &named)
	if err == nil {
		t.NamedToolChoice = &named
		return nil
	}

	return errors.New("invalid tool choice type")
}

// ImageGeneration is a permissive structure to carry image generation tool
// parameters. It mirrors the OpenRouter/OpenAI Responses API fields we care
// about, but is intentionally loose to allow forward-compatibility.
type ImageGeneration struct {
	Model string `json:"model,omitempty"`
	// One of opaque, transparent.
	Background     string         `json:"background,omitempty"`
	InputFidelity  string         `json:"input_fidelity,omitempty"`
	InputImageMask map[string]any `json:"input_image_mask,omitempty"`
	// One of low, auto.
	Moderation string `json:"moderation,omitempty"`
	// The compression level (0-100%) for the generated images. Default: 100.
	OutputCompression *int64 `json:"output_compression,omitempty"`
	// One of png, webp, or jpeg. Default: png.
	OutputFormat string `json:"output_format,omitempty"`
	// The number of images to generate. Default: 1.
	PartialImages  *int64 `json:"partial_images,omitempty"`
	N              *int64 `json:"n,omitempty"`
	ResponseFormat string `json:"response_format,omitempty"`
	// The quality of the image that will be generated.
	// auto (default value) will automatically select the best quality for the given model.
	// high, medium and low are supported for gpt-image-1.
	// hd and standard are supported for dall-e-3.
	// standard is the only option for dall-e-2.
	Quality string `json:"quality,omitempty"`
	// One of 256x256, 512x512, or 1024x1024. Default: 1024x1024.
	Size  string `json:"size,omitempty"`
	Style string `json:"style,omitempty"`

	// Whether to add a watermark to the generated image. Default: false.
	// It only works for the models support watermark, it will be ignored otherwise.
	Watermark bool `json:"watermark,omitempty"`
}

// GoogleTools contains Google/Gemini-specific grounding tools.
// This namespace isolates Google's tools from other providers,
// allowing for provider-specific implementations without naming conflicts.
type GoogleTools struct {
	// Search enables Google Search grounding for real-time web searches.
	Search *GoogleSearch `json:"search,omitempty"`
	// CodeExecution enables code execution as part of generation.
	CodeExecution *GoogleCodeExecution `json:"code_execution,omitempty"`
	// UrlContext enables URL context grounding for Gemini 2.0+.
	UrlContext *GoogleUrlContext `json:"url_context,omitempty"`
}

// GoogleSearch represents Google Search grounding tool for Gemini.
// This enables the model to perform real-time web searches.
type GoogleSearch struct{}

// GoogleCodeExecution represents code execution tool for Gemini.
// This enables the model to execute code as part of generation.
type GoogleCodeExecution struct{}

// GoogleUrlContext represents URL context grounding tool for Gemini 2.0+.
// This allows the model to fetch and process content from specified URLs.
type GoogleUrlContext struct{}

// ContainsGoogleNativeTools checks if the tools slice contains any Google native tools.
// Google native tools include GoogleSearch, GoogleCodeExecution, and GoogleUrlContext.
// These tools are only supported by native Gemini API format (gemini/gemini_vertex),
// not by OpenAI-compatible endpoints (gemini_openai).
func ContainsGoogleNativeTools(tools []Tool) bool {
	return slices.ContainsFunc(tools, IsGoogleNativeTool)
}

// IsGoogleNativeTool checks if a single tool is a Google native tool.
// Google native tools follow the naming convention "google_*".
func IsGoogleNativeTool(tool Tool) bool {
	return strings.HasPrefix(tool.Type, "google_")
}

// FilterGoogleNativeTools removes Google native tools from the tools slice.
// This is useful as a fallback when routing to channels that don't support native tools.
func FilterGoogleNativeTools(tools []Tool) []Tool {
	if len(tools) == 0 {
		return tools
	}

	filtered := make([]Tool, 0, len(tools))

	for _, tool := range tools {
		if !IsGoogleNativeTool(tool) {
			filtered = append(filtered, tool)
		}
	}

	return filtered
}

type WebSearch struct {
	MaxUses        *int64                    `json:"max_uses,omitempty"`
	Strict         *bool                     `json:"strict,omitempty"`
	AllowedDomains []string                  `json:"allowed_domains,omitzero"`
	BlockedDomains []string                  `json:"blocked_domains,omitzero"`
	UserLocation   WebSearchToolUserLocation `json:"user_location,omitzero"`
}

type WebSearchToolUserLocation struct {
	// The city of the user.
	City string `json:"city,omitempty"`
	// The two letter
	// [ISO country code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) of the
	// user.
	Country string `json:"country,omitempty"`
	// The region of the user.
	Region string `json:"region,omitempty"`
	// The [IANA timezone](https://nodatime.org/TimeZones) of the user.
	Timezone string `json:"timezone,omitempty"`
	// This field can be elided, and will marshal its zero value as "approximate".
	Type string `json:"type"`
}
