// Code generated by ent, DO NOT EDIT.

package channel

import (
	"fmt"
	"io"
	"strconv"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/looplj/axonhub/internal/objects"
)

const (
	// Label holds the string label denoting the channel type in the database.
	Label = "channel"
	// FieldID holds the string denoting the id field in the database.
	FieldID = "id"
	// FieldCreatedAt holds the string denoting the created_at field in the database.
	FieldCreatedAt = "created_at"
	// FieldUpdatedAt holds the string denoting the updated_at field in the database.
	FieldUpdatedAt = "updated_at"
	// FieldDeletedAt holds the string denoting the deleted_at field in the database.
	FieldDeletedAt = "deleted_at"
	// FieldType holds the string denoting the type field in the database.
	FieldType = "type"
	// FieldBaseURL holds the string denoting the base_url field in the database.
	FieldBaseURL = "base_url"
	// FieldName holds the string denoting the name field in the database.
	FieldName = "name"
	// FieldStatus holds the string denoting the status field in the database.
	FieldStatus = "status"
	// FieldCredentials holds the string denoting the credentials field in the database.
	FieldCredentials = "credentials"
	// FieldSupportedModels holds the string denoting the supported_models field in the database.
	FieldSupportedModels = "supported_models"
	// FieldAutoSyncSupportedModels holds the string denoting the auto_sync_supported_models field in the database.
	FieldAutoSyncSupportedModels = "auto_sync_supported_models"
	// FieldTags holds the string denoting the tags field in the database.
	FieldTags = "tags"
	// FieldDefaultTestModel holds the string denoting the default_test_model field in the database.
	FieldDefaultTestModel = "default_test_model"
	// FieldPolicies holds the string denoting the policies field in the database.
	FieldPolicies = "policies"
	// FieldSettings holds the string denoting the settings field in the database.
	FieldSettings = "settings"
	// FieldOrderingWeight holds the string denoting the ordering_weight field in the database.
	FieldOrderingWeight = "ordering_weight"
	// FieldErrorMessage holds the string denoting the error_message field in the database.
	FieldErrorMessage = "error_message"
	// FieldRemark holds the string denoting the remark field in the database.
	FieldRemark = "remark"
	// EdgeRequests holds the string denoting the requests edge name in mutations.
	EdgeRequests = "requests"
	// EdgeExecutions holds the string denoting the executions edge name in mutations.
	EdgeExecutions = "executions"
	// EdgeUsageLogs holds the string denoting the usage_logs edge name in mutations.
	EdgeUsageLogs = "usage_logs"
	// EdgeChannelPerformance holds the string denoting the channel_performance edge name in mutations.
	EdgeChannelPerformance = "channel_performance"
	// EdgeChannelProbes holds the string denoting the channel_probes edge name in mutations.
	EdgeChannelProbes = "channel_probes"
	// EdgeChannelModelPrices holds the string denoting the channel_model_prices edge name in mutations.
	EdgeChannelModelPrices = "channel_model_prices"
	// EdgeProviderQuotaStatus holds the string denoting the provider_quota_status edge name in mutations.
	EdgeProviderQuotaStatus = "provider_quota_status"
	// Table holds the table name of the channel in the database.
	Table = "channels"
	// RequestsTable is the table that holds the requests relation/edge.
	RequestsTable = "requests"
	// RequestsInverseTable is the table name for the Request entity.
	// It exists in this package in order to avoid circular dependency with the "request" package.
	RequestsInverseTable = "requests"
	// RequestsColumn is the table column denoting the requests relation/edge.
	RequestsColumn = "channel_id"
	// ExecutionsTable is the table that holds the executions relation/edge.
	ExecutionsTable = "request_executions"
	// ExecutionsInverseTable is the table name for the RequestExecution entity.
	// It exists in this package in order to avoid circular dependency with the "requestexecution" package.
	ExecutionsInverseTable = "request_executions"
	// ExecutionsColumn is the table column denoting the executions relation/edge.
	ExecutionsColumn = "channel_id"
	// UsageLogsTable is the table that holds the usage_logs relation/edge.
	UsageLogsTable = "usage_logs"
	// UsageLogsInverseTable is the table name for the UsageLog entity.
	// It exists in this package in order to avoid circular dependency with the "usagelog" package.
	UsageLogsInverseTable = "usage_logs"
	// UsageLogsColumn is the table column denoting the usage_logs relation/edge.
	UsageLogsColumn = "channel_id"
	// ChannelPerformanceTable is the table that holds the channel_performance relation/edge.
	ChannelPerformanceTable = "channel_performances"
	// ChannelPerformanceInverseTable is the table name for the ChannelPerformance entity.
	// It exists in this package in order to avoid circular dependency with the "channelperformance" package.
	ChannelPerformanceInverseTable = "channel_performances"
	// ChannelPerformanceColumn is the table column denoting the channel_performance relation/edge.
	ChannelPerformanceColumn = "channel_id"
	// ChannelProbesTable is the table that holds the channel_probes relation/edge.
	ChannelProbesTable = "channel_probes"
	// ChannelProbesInverseTable is the table name for the ChannelProbe entity.
	// It exists in this package in order to avoid circular dependency with the "channelprobe" package.
	ChannelProbesInverseTable = "channel_probes"
	// ChannelProbesColumn is the table column denoting the channel_probes relation/edge.
	ChannelProbesColumn = "channel_id"
	// ChannelModelPricesTable is the table that holds the channel_model_prices relation/edge.
	ChannelModelPricesTable = "channel_model_prices"
	// ChannelModelPricesInverseTable is the table name for the ChannelModelPrice entity.
	// It exists in this package in order to avoid circular dependency with the "channelmodelprice" package.
	ChannelModelPricesInverseTable = "channel_model_prices"
	// ChannelModelPricesColumn is the table column denoting the channel_model_prices relation/edge.
	ChannelModelPricesColumn = "channel_id"
	// ProviderQuotaStatusTable is the table that holds the provider_quota_status relation/edge.
	ProviderQuotaStatusTable = "provider_quota_status"
	// ProviderQuotaStatusInverseTable is the table name for the ProviderQuotaStatus entity.
	// It exists in this package in order to avoid circular dependency with the "providerquotastatus" package.
	ProviderQuotaStatusInverseTable = "provider_quota_status"
	// ProviderQuotaStatusColumn is the table column denoting the provider_quota_status relation/edge.
	ProviderQuotaStatusColumn = "channel_id"
)

// Columns holds all SQL columns for channel fields.
var Columns = []string{
	FieldID,
	FieldCreatedAt,
	FieldUpdatedAt,
	FieldDeletedAt,
	FieldType,
	FieldBaseURL,
	FieldName,
	FieldStatus,
	FieldCredentials,
	FieldSupportedModels,
	FieldAutoSyncSupportedModels,
	FieldTags,
	FieldDefaultTestModel,
	FieldPolicies,
	FieldSettings,
	FieldOrderingWeight,
	FieldErrorMessage,
	FieldRemark,
}

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool {
	for i := range Columns {
		if column == Columns[i] {
			return true
		}
	}
	return false
}

// Note that the variables below are initialized by the runtime
// package on the initialization of the application. Therefore,
// it should be imported in the main as follows:
//
//	import _ "github.com/looplj/axonhub/internal/ent/runtime"
var (
	Hooks        [2]ent.Hook
	Interceptors [1]ent.Interceptor
	Policy       ent.Policy
	// DefaultCreatedAt holds the default value on creation for the "created_at" field.
	DefaultCreatedAt func() time.Time
	// DefaultUpdatedAt holds the default value on creation for the "updated_at" field.
	DefaultUpdatedAt func() time.Time
	// UpdateDefaultUpdatedAt holds the default value on update for the "updated_at" field.
	UpdateDefaultUpdatedAt func() time.Time
	// DefaultDeletedAt holds the default value on creation for the "deleted_at" field.
	DefaultDeletedAt int
	// DefaultCredentials holds the default value on creation for the "credentials" field.
	DefaultCredentials *objects.ChannelCredentials
	// DefaultAutoSyncSupportedModels holds the default value on creation for the "auto_sync_supported_models" field.
	DefaultAutoSyncSupportedModels bool
	// DefaultTags holds the default value on creation for the "tags" field.
	DefaultTags []string
	// DefaultPolicies holds the default value on creation for the "policies" field.
	DefaultPolicies objects.ChannelPolicies
	// DefaultSettings holds the default value on creation for the "settings" field.
	DefaultSettings *objects.ChannelSettings
	// DefaultOrderingWeight holds the default value on creation for the "ordering_weight" field.
	DefaultOrderingWeight int
)

// Type defines the type for the "type" enum field.
type Type string

// Type values.
const (
	TypeOpenai            Type = "openai"
	TypeOpenaiResponses   Type = "openai_responses"
	TypeCodex             Type = "codex"
	TypeVercel            Type = "vercel"
	TypeAnthropic         Type = "anthropic"
	TypeAnthropicAWS      Type = "anthropic_aws"
	TypeAnthropicGcp      Type = "anthropic_gcp"
	TypeGeminiOpenai      Type = "gemini_openai"
	TypeGemini            Type = "gemini"
	TypeGeminiVertex      Type = "gemini_vertex"
	TypeDeepseek          Type = "deepseek"
	TypeDeepseekAnthropic Type = "deepseek_anthropic"
	TypeDeepinfra         Type = "deepinfra"
	TypeDoubao            Type = "doubao"
	TypeDoubaoAnthropic   Type = "doubao_anthropic"
	TypeMoonshot          Type = "moonshot"
	TypeMoonshotAnthropic Type = "moonshot_anthropic"
	TypeZhipu             Type = "zhipu"
	TypeZai               Type = "zai"
	TypeZhipuAnthropic    Type = "zhipu_anthropic"
	TypeZaiAnthropic      Type = "zai_anthropic"
	TypeAnthropicFake     Type = "anthropic_fake"
	TypeOpenaiFake        Type = "openai_fake"
	TypeOpenrouter        Type = "openrouter"
	TypeXai               Type = "xai"
	TypePpio              Type = "ppio"
	TypeSiliconflow       Type = "siliconflow"
	TypeVolcengine        Type = "volcengine"
	TypeLongcat           Type = "longcat"
	TypeLongcatAnthropic  Type = "longcat_anthropic"
	TypeMinimax           Type = "minimax"
	TypeMinimaxAnthropic  Type = "minimax_anthropic"
	TypeAihubmix          Type = "aihubmix"
	TypeBurncloud         Type = "burncloud"
	TypeModelscope        Type = "modelscope"
	TypeBailian           Type = "bailian"
	TypeJina              Type = "jina"
	TypeGithub            Type = "github"
	TypeClaudecode        Type = "claudecode"
	TypeCerebras          Type = "cerebras"
	TypeAntigravity       Type = "antigravity"
)

func (_type Type) String() string {
	return string(_type)
}

// TypeValidator is a validator for the "type" field enum values. It is called by the builders before save.
func TypeValidator(_type Type) error {
	switch _type {
	case TypeOpenai, TypeOpenaiResponses, TypeCodex, TypeVercel, TypeAnthropic, TypeAnthropicAWS, TypeAnthropicGcp, TypeGeminiOpenai, TypeGemini, TypeGeminiVertex, TypeDeepseek, TypeDeepseekAnthropic, TypeDeepinfra, TypeDoubao, TypeDoubaoAnthropic, TypeMoonshot, TypeMoonshotAnthropic, TypeZhipu, TypeZai, TypeZhipuAnthropic, TypeZaiAnthropic, TypeAnthropicFake, TypeOpenaiFake, TypeOpenrouter, TypeXai, TypePpio, TypeSiliconflow, TypeVolcengine, TypeLongcat, TypeLongcatAnthropic, TypeMinimax, TypeMinimaxAnthropic, TypeAihubmix, TypeBurncloud, TypeModelscope, TypeBailian, TypeJina, TypeGithub, TypeClaudecode, TypeCerebras, TypeAntigravity:
		return nil
	default:
		return fmt.Errorf("channel: invalid enum value for type field: %q", _type)
	}
}

// Status defines the type for the "status" enum field.
type Status string

// StatusDisabled is the default value of the Status enum.
const DefaultStatus = StatusDisabled

// Status values.
const (
	StatusEnabled  Status = "enabled"
	StatusDisabled Status = "disabled"
	StatusArchived Status = "archived"
)

func (s Status) String() string {
	return string(s)
}

// StatusValidator is a validator for the "status" field enum values. It is called by the builders before save.
func StatusValidator(s Status) error {
	switch s {
	case StatusEnabled, StatusDisabled, StatusArchived:
		return nil
	default:
		return fmt.Errorf("channel: invalid enum value for status field: %q", s)
	}
}

// OrderOption defines the ordering options for the Channel queries.
type OrderOption func(*sql.Selector)

// ByID orders the results by the id field.
func ByID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldID, opts...).ToFunc()
}

// ByCreatedAt orders the results by the created_at field.
func ByCreatedAt(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCreatedAt, opts...).ToFunc()
}

// ByUpdatedAt orders the results by the updated_at field.
func ByUpdatedAt(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldUpdatedAt, opts...).ToFunc()
}

// ByDeletedAt orders the results by the deleted_at field.
func ByDeletedAt(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldDeletedAt, opts...).ToFunc()
}

// ByType orders the results by the type field.
func ByType(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldType, opts...).ToFunc()
}

// ByBaseURL orders the results by the base_url field.
func ByBaseURL(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldBaseURL, opts...).ToFunc()
}

// ByName orders the results by the name field.
func ByName(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldName, opts...).ToFunc()
}

// ByStatus orders the results by the status field.
func ByStatus(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldStatus, opts...).ToFunc()
}

// ByAutoSyncSupportedModels orders the results by the auto_sync_supported_models field.
func ByAutoSyncSupportedModels(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldAutoSyncSupportedModels, opts...).ToFunc()
}

// ByDefaultTestModel orders the results by the default_test_model field.
func ByDefaultTestModel(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldDefaultTestModel, opts...).ToFunc()
}

// ByOrderingWeight orders the results by the ordering_weight field.
func ByOrderingWeight(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldOrderingWeight, opts...).ToFunc()
}

// ByErrorMessage orders the results by the error_message field.
func ByErrorMessage(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldErrorMessage, opts...).ToFunc()
}

// ByRemark orders the results by the remark field.
func ByRemark(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldRemark, opts...).ToFunc()
}

// ByRequestsCount orders the results by requests count.
func ByRequestsCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newRequestsStep(), opts...)
	}
}

// ByRequests orders the results by requests terms.
func ByRequests(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newRequestsStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByExecutionsCount orders the results by executions count.
func ByExecutionsCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newExecutionsStep(), opts...)
	}
}

// ByExecutions orders the results by executions terms.
func ByExecutions(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newExecutionsStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByUsageLogsCount orders the results by usage_logs count.
func ByUsageLogsCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newUsageLogsStep(), opts...)
	}
}

// ByUsageLogs orders the results by usage_logs terms.
func ByUsageLogs(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newUsageLogsStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByChannelPerformanceField orders the results by channel_performance field.
func ByChannelPerformanceField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newChannelPerformanceStep(), sql.OrderByField(field, opts...))
	}
}

// ByChannelProbesCount orders the results by channel_probes count.
func ByChannelProbesCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newChannelProbesStep(), opts...)
	}
}

// ByChannelProbes orders the results by channel_probes terms.
func ByChannelProbes(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newChannelProbesStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByChannelModelPricesCount orders the results by channel_model_prices count.
func ByChannelModelPricesCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newChannelModelPricesStep(), opts...)
	}
}

// ByChannelModelPrices orders the results by channel_model_prices terms.
func ByChannelModelPrices(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newChannelModelPricesStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByProviderQuotaStatusField orders the results by provider_quota_status field.
func ByProviderQuotaStatusField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newProviderQuotaStatusStep(), sql.OrderByField(field, opts...))
	}
}
func newRequestsStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(RequestsInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, RequestsTable, RequestsColumn),
	)
}
func newExecutionsStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(ExecutionsInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, ExecutionsTable, ExecutionsColumn),
	)
}
func newUsageLogsStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(UsageLogsInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, UsageLogsTable, UsageLogsColumn),
	)
}
func newChannelPerformanceStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(ChannelPerformanceInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2O, false, ChannelPerformanceTable, ChannelPerformanceColumn),
	)
}
func newChannelProbesStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(ChannelProbesInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, ChannelProbesTable, ChannelProbesColumn),
	)
}
func newChannelModelPricesStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(ChannelModelPricesInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, ChannelModelPricesTable, ChannelModelPricesColumn),
	)
}
func newProviderQuotaStatusStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(ProviderQuotaStatusInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2O, false, ProviderQuotaStatusTable, ProviderQuotaStatusColumn),
	)
}

// MarshalGQL implements graphql.Marshaler interface.
func (e Type) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(e.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (e *Type) UnmarshalGQL(val interface{}) error {
	str, ok := val.(string)
	if !ok {
		return fmt.Errorf("enum %T must be a string", val)
	}
	*e = Type(str)
	if err := TypeValidator(*e); err != nil {
		return fmt.Errorf("%s is not a valid Type", str)
	}
	return nil
}

// MarshalGQL implements graphql.Marshaler interface.
func (e Status) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(e.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (e *Status) UnmarshalGQL(val interface{}) error {
	str, ok := val.(string)
	if !ok {
		return fmt.Errorf("enum %T must be a string", val)
	}
	*e = Status(str)
	if err := StatusValidator(*e); err != nil {
		return fmt.Errorf("%s is not a valid Status", str)
	}
	return nil
}
