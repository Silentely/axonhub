// Code generated by ent, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"
	"time"

	"github.com/looplj/axonhub/internal/ent/apikey"
	"github.com/looplj/axonhub/internal/ent/channel"
	"github.com/looplj/axonhub/internal/ent/channelperformance"
	"github.com/looplj/axonhub/internal/ent/datastorage"
	"github.com/looplj/axonhub/internal/ent/predicate"
	"github.com/looplj/axonhub/internal/ent/project"
	"github.com/looplj/axonhub/internal/ent/request"
	"github.com/looplj/axonhub/internal/ent/requestexecution"
	"github.com/looplj/axonhub/internal/ent/role"
	"github.com/looplj/axonhub/internal/ent/system"
	"github.com/looplj/axonhub/internal/ent/thread"
	"github.com/looplj/axonhub/internal/ent/trace"
	"github.com/looplj/axonhub/internal/ent/usagelog"
	"github.com/looplj/axonhub/internal/ent/user"
	"github.com/looplj/axonhub/internal/ent/userproject"
	"github.com/looplj/axonhub/internal/ent/userrole"
)

// APIKeyWhereInput represents a where input for filtering APIKey queries.
type APIKeyWhereInput struct {
	Predicates []predicate.APIKey  `json:"-"`
	Not        *APIKeyWhereInput   `json:"not,omitempty"`
	Or         []*APIKeyWhereInput `json:"or,omitempty"`
	And        []*APIKeyWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt      *int  `json:"deletedAt,omitempty"`
	DeletedAtNEQ   *int  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn    []int `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn []int `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT    *int  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE   *int  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT    *int  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE   *int  `json:"deletedAtLTE,omitempty"`

	// "user_id" field predicates.
	UserID      *int  `json:"userID,omitempty"`
	UserIDNEQ   *int  `json:"userIDNEQ,omitempty"`
	UserIDIn    []int `json:"userIDIn,omitempty"`
	UserIDNotIn []int `json:"userIDNotIn,omitempty"`

	// "project_id" field predicates.
	ProjectID      *int  `json:"projectID,omitempty"`
	ProjectIDNEQ   *int  `json:"projectIDNEQ,omitempty"`
	ProjectIDIn    []int `json:"projectIDIn,omitempty"`
	ProjectIDNotIn []int `json:"projectIDNotIn,omitempty"`

	// "key" field predicates.
	Key             *string  `json:"key,omitempty"`
	KeyNEQ          *string  `json:"keyNEQ,omitempty"`
	KeyIn           []string `json:"keyIn,omitempty"`
	KeyNotIn        []string `json:"keyNotIn,omitempty"`
	KeyGT           *string  `json:"keyGT,omitempty"`
	KeyGTE          *string  `json:"keyGTE,omitempty"`
	KeyLT           *string  `json:"keyLT,omitempty"`
	KeyLTE          *string  `json:"keyLTE,omitempty"`
	KeyContains     *string  `json:"keyContains,omitempty"`
	KeyHasPrefix    *string  `json:"keyHasPrefix,omitempty"`
	KeyHasSuffix    *string  `json:"keyHasSuffix,omitempty"`
	KeyEqualFold    *string  `json:"keyEqualFold,omitempty"`
	KeyContainsFold *string  `json:"keyContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "status" field predicates.
	Status      *apikey.Status  `json:"status,omitempty"`
	StatusNEQ   *apikey.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []apikey.Status `json:"statusIn,omitempty"`
	StatusNotIn []apikey.Status `json:"statusNotIn,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`

	// "project" edge predicates.
	HasProject     *bool                `json:"hasProject,omitempty"`
	HasProjectWith []*ProjectWhereInput `json:"hasProjectWith,omitempty"`

	// "requests" edge predicates.
	HasRequests     *bool                `json:"hasRequests,omitempty"`
	HasRequestsWith []*RequestWhereInput `json:"hasRequestsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *APIKeyWhereInput) AddPredicates(predicates ...predicate.APIKey) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the APIKeyWhereInput filter on the APIKeyQuery builder.
func (i *APIKeyWhereInput) Filter(q *APIKeyQuery) (*APIKeyQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyAPIKeyWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyAPIKeyWhereInput is returned in case the APIKeyWhereInput is empty.
var ErrEmptyAPIKeyWhereInput = errors.New("ent: empty predicate APIKeyWhereInput")

// P returns a predicate for filtering apikeys.
// An error is returned if the input is empty or invalid.
func (i *APIKeyWhereInput) P() (predicate.APIKey, error) {
	var predicates []predicate.APIKey
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, apikey.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.APIKey, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, apikey.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.APIKey, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, apikey.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, apikey.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, apikey.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, apikey.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, apikey.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, apikey.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, apikey.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, apikey.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, apikey.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, apikey.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, apikey.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, apikey.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, apikey.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, apikey.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, apikey.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, apikey.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, apikey.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, apikey.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, apikey.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, apikey.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, apikey.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, apikey.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, apikey.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, apikey.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, apikey.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, apikey.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, apikey.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, apikey.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, apikey.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, apikey.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, apikey.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, apikey.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, apikey.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.UserID != nil {
		predicates = append(predicates, apikey.UserIDEQ(*i.UserID))
	}
	if i.UserIDNEQ != nil {
		predicates = append(predicates, apikey.UserIDNEQ(*i.UserIDNEQ))
	}
	if len(i.UserIDIn) > 0 {
		predicates = append(predicates, apikey.UserIDIn(i.UserIDIn...))
	}
	if len(i.UserIDNotIn) > 0 {
		predicates = append(predicates, apikey.UserIDNotIn(i.UserIDNotIn...))
	}
	if i.ProjectID != nil {
		predicates = append(predicates, apikey.ProjectIDEQ(*i.ProjectID))
	}
	if i.ProjectIDNEQ != nil {
		predicates = append(predicates, apikey.ProjectIDNEQ(*i.ProjectIDNEQ))
	}
	if len(i.ProjectIDIn) > 0 {
		predicates = append(predicates, apikey.ProjectIDIn(i.ProjectIDIn...))
	}
	if len(i.ProjectIDNotIn) > 0 {
		predicates = append(predicates, apikey.ProjectIDNotIn(i.ProjectIDNotIn...))
	}
	if i.Key != nil {
		predicates = append(predicates, apikey.KeyEQ(*i.Key))
	}
	if i.KeyNEQ != nil {
		predicates = append(predicates, apikey.KeyNEQ(*i.KeyNEQ))
	}
	if len(i.KeyIn) > 0 {
		predicates = append(predicates, apikey.KeyIn(i.KeyIn...))
	}
	if len(i.KeyNotIn) > 0 {
		predicates = append(predicates, apikey.KeyNotIn(i.KeyNotIn...))
	}
	if i.KeyGT != nil {
		predicates = append(predicates, apikey.KeyGT(*i.KeyGT))
	}
	if i.KeyGTE != nil {
		predicates = append(predicates, apikey.KeyGTE(*i.KeyGTE))
	}
	if i.KeyLT != nil {
		predicates = append(predicates, apikey.KeyLT(*i.KeyLT))
	}
	if i.KeyLTE != nil {
		predicates = append(predicates, apikey.KeyLTE(*i.KeyLTE))
	}
	if i.KeyContains != nil {
		predicates = append(predicates, apikey.KeyContains(*i.KeyContains))
	}
	if i.KeyHasPrefix != nil {
		predicates = append(predicates, apikey.KeyHasPrefix(*i.KeyHasPrefix))
	}
	if i.KeyHasSuffix != nil {
		predicates = append(predicates, apikey.KeyHasSuffix(*i.KeyHasSuffix))
	}
	if i.KeyEqualFold != nil {
		predicates = append(predicates, apikey.KeyEqualFold(*i.KeyEqualFold))
	}
	if i.KeyContainsFold != nil {
		predicates = append(predicates, apikey.KeyContainsFold(*i.KeyContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, apikey.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, apikey.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, apikey.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, apikey.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, apikey.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, apikey.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, apikey.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, apikey.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, apikey.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, apikey.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, apikey.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, apikey.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, apikey.NameContainsFold(*i.NameContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, apikey.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, apikey.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, apikey.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, apikey.StatusNotIn(i.StatusNotIn...))
	}

	if i.HasUser != nil {
		p := apikey.HasUser()
		if !*i.HasUser {
			p = apikey.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, apikey.HasUserWith(with...))
	}
	if i.HasProject != nil {
		p := apikey.HasProject()
		if !*i.HasProject {
			p = apikey.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProjectWith) > 0 {
		with := make([]predicate.Project, 0, len(i.HasProjectWith))
		for _, w := range i.HasProjectWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProjectWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, apikey.HasProjectWith(with...))
	}
	if i.HasRequests != nil {
		p := apikey.HasRequests()
		if !*i.HasRequests {
			p = apikey.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRequestsWith) > 0 {
		with := make([]predicate.Request, 0, len(i.HasRequestsWith))
		for _, w := range i.HasRequestsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRequestsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, apikey.HasRequestsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyAPIKeyWhereInput
	case 1:
		return predicates[0], nil
	default:
		return apikey.And(predicates...), nil
	}
}

// ChannelWhereInput represents a where input for filtering Channel queries.
type ChannelWhereInput struct {
	Predicates []predicate.Channel  `json:"-"`
	Not        *ChannelWhereInput   `json:"not,omitempty"`
	Or         []*ChannelWhereInput `json:"or,omitempty"`
	And        []*ChannelWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt      *int  `json:"deletedAt,omitempty"`
	DeletedAtNEQ   *int  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn    []int `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn []int `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT    *int  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE   *int  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT    *int  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE   *int  `json:"deletedAtLTE,omitempty"`

	// "type" field predicates.
	Type      *channel.Type  `json:"type,omitempty"`
	TypeNEQ   *channel.Type  `json:"typeNEQ,omitempty"`
	TypeIn    []channel.Type `json:"typeIn,omitempty"`
	TypeNotIn []channel.Type `json:"typeNotIn,omitempty"`

	// "base_url" field predicates.
	BaseURL             *string  `json:"baseURL,omitempty"`
	BaseURLNEQ          *string  `json:"baseURLNEQ,omitempty"`
	BaseURLIn           []string `json:"baseURLIn,omitempty"`
	BaseURLNotIn        []string `json:"baseURLNotIn,omitempty"`
	BaseURLGT           *string  `json:"baseURLGT,omitempty"`
	BaseURLGTE          *string  `json:"baseURLGTE,omitempty"`
	BaseURLLT           *string  `json:"baseURLLT,omitempty"`
	BaseURLLTE          *string  `json:"baseURLLTE,omitempty"`
	BaseURLContains     *string  `json:"baseURLContains,omitempty"`
	BaseURLHasPrefix    *string  `json:"baseURLHasPrefix,omitempty"`
	BaseURLHasSuffix    *string  `json:"baseURLHasSuffix,omitempty"`
	BaseURLIsNil        bool     `json:"baseURLIsNil,omitempty"`
	BaseURLNotNil       bool     `json:"baseURLNotNil,omitempty"`
	BaseURLEqualFold    *string  `json:"baseURLEqualFold,omitempty"`
	BaseURLContainsFold *string  `json:"baseURLContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "status" field predicates.
	Status      *channel.Status  `json:"status,omitempty"`
	StatusNEQ   *channel.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []channel.Status `json:"statusIn,omitempty"`
	StatusNotIn []channel.Status `json:"statusNotIn,omitempty"`

	// "default_test_model" field predicates.
	DefaultTestModel             *string  `json:"defaultTestModel,omitempty"`
	DefaultTestModelNEQ          *string  `json:"defaultTestModelNEQ,omitempty"`
	DefaultTestModelIn           []string `json:"defaultTestModelIn,omitempty"`
	DefaultTestModelNotIn        []string `json:"defaultTestModelNotIn,omitempty"`
	DefaultTestModelGT           *string  `json:"defaultTestModelGT,omitempty"`
	DefaultTestModelGTE          *string  `json:"defaultTestModelGTE,omitempty"`
	DefaultTestModelLT           *string  `json:"defaultTestModelLT,omitempty"`
	DefaultTestModelLTE          *string  `json:"defaultTestModelLTE,omitempty"`
	DefaultTestModelContains     *string  `json:"defaultTestModelContains,omitempty"`
	DefaultTestModelHasPrefix    *string  `json:"defaultTestModelHasPrefix,omitempty"`
	DefaultTestModelHasSuffix    *string  `json:"defaultTestModelHasSuffix,omitempty"`
	DefaultTestModelEqualFold    *string  `json:"defaultTestModelEqualFold,omitempty"`
	DefaultTestModelContainsFold *string  `json:"defaultTestModelContainsFold,omitempty"`

	// "ordering_weight" field predicates.
	OrderingWeight      *int  `json:"orderingWeight,omitempty"`
	OrderingWeightNEQ   *int  `json:"orderingWeightNEQ,omitempty"`
	OrderingWeightIn    []int `json:"orderingWeightIn,omitempty"`
	OrderingWeightNotIn []int `json:"orderingWeightNotIn,omitempty"`
	OrderingWeightGT    *int  `json:"orderingWeightGT,omitempty"`
	OrderingWeightGTE   *int  `json:"orderingWeightGTE,omitempty"`
	OrderingWeightLT    *int  `json:"orderingWeightLT,omitempty"`
	OrderingWeightLTE   *int  `json:"orderingWeightLTE,omitempty"`

	// "error_message" field predicates.
	ErrorMessage             *string  `json:"errorMessage,omitempty"`
	ErrorMessageNEQ          *string  `json:"errorMessageNEQ,omitempty"`
	ErrorMessageIn           []string `json:"errorMessageIn,omitempty"`
	ErrorMessageNotIn        []string `json:"errorMessageNotIn,omitempty"`
	ErrorMessageGT           *string  `json:"errorMessageGT,omitempty"`
	ErrorMessageGTE          *string  `json:"errorMessageGTE,omitempty"`
	ErrorMessageLT           *string  `json:"errorMessageLT,omitempty"`
	ErrorMessageLTE          *string  `json:"errorMessageLTE,omitempty"`
	ErrorMessageContains     *string  `json:"errorMessageContains,omitempty"`
	ErrorMessageHasPrefix    *string  `json:"errorMessageHasPrefix,omitempty"`
	ErrorMessageHasSuffix    *string  `json:"errorMessageHasSuffix,omitempty"`
	ErrorMessageIsNil        bool     `json:"errorMessageIsNil,omitempty"`
	ErrorMessageNotNil       bool     `json:"errorMessageNotNil,omitempty"`
	ErrorMessageEqualFold    *string  `json:"errorMessageEqualFold,omitempty"`
	ErrorMessageContainsFold *string  `json:"errorMessageContainsFold,omitempty"`

	// "requests" edge predicates.
	HasRequests     *bool                `json:"hasRequests,omitempty"`
	HasRequestsWith []*RequestWhereInput `json:"hasRequestsWith,omitempty"`

	// "executions" edge predicates.
	HasExecutions     *bool                         `json:"hasExecutions,omitempty"`
	HasExecutionsWith []*RequestExecutionWhereInput `json:"hasExecutionsWith,omitempty"`

	// "usage_logs" edge predicates.
	HasUsageLogs     *bool                 `json:"hasUsageLogs,omitempty"`
	HasUsageLogsWith []*UsageLogWhereInput `json:"hasUsageLogsWith,omitempty"`

	// "channel_performance" edge predicates.
	HasChannelPerformance     *bool                           `json:"hasChannelPerformance,omitempty"`
	HasChannelPerformanceWith []*ChannelPerformanceWhereInput `json:"hasChannelPerformanceWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ChannelWhereInput) AddPredicates(predicates ...predicate.Channel) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ChannelWhereInput filter on the ChannelQuery builder.
func (i *ChannelWhereInput) Filter(q *ChannelQuery) (*ChannelQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyChannelWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyChannelWhereInput is returned in case the ChannelWhereInput is empty.
var ErrEmptyChannelWhereInput = errors.New("ent: empty predicate ChannelWhereInput")

// P returns a predicate for filtering channels.
// An error is returned if the input is empty or invalid.
func (i *ChannelWhereInput) P() (predicate.Channel, error) {
	var predicates []predicate.Channel
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, channel.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Channel, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, channel.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Channel, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, channel.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, channel.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, channel.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, channel.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, channel.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, channel.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, channel.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, channel.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, channel.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, channel.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, channel.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, channel.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, channel.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, channel.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, channel.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, channel.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, channel.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, channel.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, channel.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, channel.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, channel.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, channel.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, channel.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, channel.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, channel.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, channel.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, channel.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, channel.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, channel.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, channel.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, channel.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, channel.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, channel.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.Type != nil {
		predicates = append(predicates, channel.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, channel.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, channel.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, channel.TypeNotIn(i.TypeNotIn...))
	}
	if i.BaseURL != nil {
		predicates = append(predicates, channel.BaseURLEQ(*i.BaseURL))
	}
	if i.BaseURLNEQ != nil {
		predicates = append(predicates, channel.BaseURLNEQ(*i.BaseURLNEQ))
	}
	if len(i.BaseURLIn) > 0 {
		predicates = append(predicates, channel.BaseURLIn(i.BaseURLIn...))
	}
	if len(i.BaseURLNotIn) > 0 {
		predicates = append(predicates, channel.BaseURLNotIn(i.BaseURLNotIn...))
	}
	if i.BaseURLGT != nil {
		predicates = append(predicates, channel.BaseURLGT(*i.BaseURLGT))
	}
	if i.BaseURLGTE != nil {
		predicates = append(predicates, channel.BaseURLGTE(*i.BaseURLGTE))
	}
	if i.BaseURLLT != nil {
		predicates = append(predicates, channel.BaseURLLT(*i.BaseURLLT))
	}
	if i.BaseURLLTE != nil {
		predicates = append(predicates, channel.BaseURLLTE(*i.BaseURLLTE))
	}
	if i.BaseURLContains != nil {
		predicates = append(predicates, channel.BaseURLContains(*i.BaseURLContains))
	}
	if i.BaseURLHasPrefix != nil {
		predicates = append(predicates, channel.BaseURLHasPrefix(*i.BaseURLHasPrefix))
	}
	if i.BaseURLHasSuffix != nil {
		predicates = append(predicates, channel.BaseURLHasSuffix(*i.BaseURLHasSuffix))
	}
	if i.BaseURLIsNil {
		predicates = append(predicates, channel.BaseURLIsNil())
	}
	if i.BaseURLNotNil {
		predicates = append(predicates, channel.BaseURLNotNil())
	}
	if i.BaseURLEqualFold != nil {
		predicates = append(predicates, channel.BaseURLEqualFold(*i.BaseURLEqualFold))
	}
	if i.BaseURLContainsFold != nil {
		predicates = append(predicates, channel.BaseURLContainsFold(*i.BaseURLContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, channel.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, channel.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, channel.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, channel.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, channel.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, channel.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, channel.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, channel.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, channel.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, channel.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, channel.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, channel.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, channel.NameContainsFold(*i.NameContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, channel.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, channel.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, channel.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, channel.StatusNotIn(i.StatusNotIn...))
	}
	if i.DefaultTestModel != nil {
		predicates = append(predicates, channel.DefaultTestModelEQ(*i.DefaultTestModel))
	}
	if i.DefaultTestModelNEQ != nil {
		predicates = append(predicates, channel.DefaultTestModelNEQ(*i.DefaultTestModelNEQ))
	}
	if len(i.DefaultTestModelIn) > 0 {
		predicates = append(predicates, channel.DefaultTestModelIn(i.DefaultTestModelIn...))
	}
	if len(i.DefaultTestModelNotIn) > 0 {
		predicates = append(predicates, channel.DefaultTestModelNotIn(i.DefaultTestModelNotIn...))
	}
	if i.DefaultTestModelGT != nil {
		predicates = append(predicates, channel.DefaultTestModelGT(*i.DefaultTestModelGT))
	}
	if i.DefaultTestModelGTE != nil {
		predicates = append(predicates, channel.DefaultTestModelGTE(*i.DefaultTestModelGTE))
	}
	if i.DefaultTestModelLT != nil {
		predicates = append(predicates, channel.DefaultTestModelLT(*i.DefaultTestModelLT))
	}
	if i.DefaultTestModelLTE != nil {
		predicates = append(predicates, channel.DefaultTestModelLTE(*i.DefaultTestModelLTE))
	}
	if i.DefaultTestModelContains != nil {
		predicates = append(predicates, channel.DefaultTestModelContains(*i.DefaultTestModelContains))
	}
	if i.DefaultTestModelHasPrefix != nil {
		predicates = append(predicates, channel.DefaultTestModelHasPrefix(*i.DefaultTestModelHasPrefix))
	}
	if i.DefaultTestModelHasSuffix != nil {
		predicates = append(predicates, channel.DefaultTestModelHasSuffix(*i.DefaultTestModelHasSuffix))
	}
	if i.DefaultTestModelEqualFold != nil {
		predicates = append(predicates, channel.DefaultTestModelEqualFold(*i.DefaultTestModelEqualFold))
	}
	if i.DefaultTestModelContainsFold != nil {
		predicates = append(predicates, channel.DefaultTestModelContainsFold(*i.DefaultTestModelContainsFold))
	}
	if i.OrderingWeight != nil {
		predicates = append(predicates, channel.OrderingWeightEQ(*i.OrderingWeight))
	}
	if i.OrderingWeightNEQ != nil {
		predicates = append(predicates, channel.OrderingWeightNEQ(*i.OrderingWeightNEQ))
	}
	if len(i.OrderingWeightIn) > 0 {
		predicates = append(predicates, channel.OrderingWeightIn(i.OrderingWeightIn...))
	}
	if len(i.OrderingWeightNotIn) > 0 {
		predicates = append(predicates, channel.OrderingWeightNotIn(i.OrderingWeightNotIn...))
	}
	if i.OrderingWeightGT != nil {
		predicates = append(predicates, channel.OrderingWeightGT(*i.OrderingWeightGT))
	}
	if i.OrderingWeightGTE != nil {
		predicates = append(predicates, channel.OrderingWeightGTE(*i.OrderingWeightGTE))
	}
	if i.OrderingWeightLT != nil {
		predicates = append(predicates, channel.OrderingWeightLT(*i.OrderingWeightLT))
	}
	if i.OrderingWeightLTE != nil {
		predicates = append(predicates, channel.OrderingWeightLTE(*i.OrderingWeightLTE))
	}
	if i.ErrorMessage != nil {
		predicates = append(predicates, channel.ErrorMessageEQ(*i.ErrorMessage))
	}
	if i.ErrorMessageNEQ != nil {
		predicates = append(predicates, channel.ErrorMessageNEQ(*i.ErrorMessageNEQ))
	}
	if len(i.ErrorMessageIn) > 0 {
		predicates = append(predicates, channel.ErrorMessageIn(i.ErrorMessageIn...))
	}
	if len(i.ErrorMessageNotIn) > 0 {
		predicates = append(predicates, channel.ErrorMessageNotIn(i.ErrorMessageNotIn...))
	}
	if i.ErrorMessageGT != nil {
		predicates = append(predicates, channel.ErrorMessageGT(*i.ErrorMessageGT))
	}
	if i.ErrorMessageGTE != nil {
		predicates = append(predicates, channel.ErrorMessageGTE(*i.ErrorMessageGTE))
	}
	if i.ErrorMessageLT != nil {
		predicates = append(predicates, channel.ErrorMessageLT(*i.ErrorMessageLT))
	}
	if i.ErrorMessageLTE != nil {
		predicates = append(predicates, channel.ErrorMessageLTE(*i.ErrorMessageLTE))
	}
	if i.ErrorMessageContains != nil {
		predicates = append(predicates, channel.ErrorMessageContains(*i.ErrorMessageContains))
	}
	if i.ErrorMessageHasPrefix != nil {
		predicates = append(predicates, channel.ErrorMessageHasPrefix(*i.ErrorMessageHasPrefix))
	}
	if i.ErrorMessageHasSuffix != nil {
		predicates = append(predicates, channel.ErrorMessageHasSuffix(*i.ErrorMessageHasSuffix))
	}
	if i.ErrorMessageIsNil {
		predicates = append(predicates, channel.ErrorMessageIsNil())
	}
	if i.ErrorMessageNotNil {
		predicates = append(predicates, channel.ErrorMessageNotNil())
	}
	if i.ErrorMessageEqualFold != nil {
		predicates = append(predicates, channel.ErrorMessageEqualFold(*i.ErrorMessageEqualFold))
	}
	if i.ErrorMessageContainsFold != nil {
		predicates = append(predicates, channel.ErrorMessageContainsFold(*i.ErrorMessageContainsFold))
	}

	if i.HasRequests != nil {
		p := channel.HasRequests()
		if !*i.HasRequests {
			p = channel.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRequestsWith) > 0 {
		with := make([]predicate.Request, 0, len(i.HasRequestsWith))
		for _, w := range i.HasRequestsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRequestsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, channel.HasRequestsWith(with...))
	}
	if i.HasExecutions != nil {
		p := channel.HasExecutions()
		if !*i.HasExecutions {
			p = channel.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasExecutionsWith) > 0 {
		with := make([]predicate.RequestExecution, 0, len(i.HasExecutionsWith))
		for _, w := range i.HasExecutionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasExecutionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, channel.HasExecutionsWith(with...))
	}
	if i.HasUsageLogs != nil {
		p := channel.HasUsageLogs()
		if !*i.HasUsageLogs {
			p = channel.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUsageLogsWith) > 0 {
		with := make([]predicate.UsageLog, 0, len(i.HasUsageLogsWith))
		for _, w := range i.HasUsageLogsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUsageLogsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, channel.HasUsageLogsWith(with...))
	}
	if i.HasChannelPerformance != nil {
		p := channel.HasChannelPerformance()
		if !*i.HasChannelPerformance {
			p = channel.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasChannelPerformanceWith) > 0 {
		with := make([]predicate.ChannelPerformance, 0, len(i.HasChannelPerformanceWith))
		for _, w := range i.HasChannelPerformanceWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasChannelPerformanceWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, channel.HasChannelPerformanceWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyChannelWhereInput
	case 1:
		return predicates[0], nil
	default:
		return channel.And(predicates...), nil
	}
}

// ChannelPerformanceWhereInput represents a where input for filtering ChannelPerformance queries.
type ChannelPerformanceWhereInput struct {
	Predicates []predicate.ChannelPerformance  `json:"-"`
	Not        *ChannelPerformanceWhereInput   `json:"not,omitempty"`
	Or         []*ChannelPerformanceWhereInput `json:"or,omitempty"`
	And        []*ChannelPerformanceWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt      *int  `json:"deletedAt,omitempty"`
	DeletedAtNEQ   *int  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn    []int `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn []int `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT    *int  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE   *int  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT    *int  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE   *int  `json:"deletedAtLTE,omitempty"`

	// "channel_id" field predicates.
	ChannelID      *int  `json:"channelID,omitempty"`
	ChannelIDNEQ   *int  `json:"channelIDNEQ,omitempty"`
	ChannelIDIn    []int `json:"channelIDIn,omitempty"`
	ChannelIDNotIn []int `json:"channelIDNotIn,omitempty"`

	// "success_rate" field predicates.
	SuccessRate      *int  `json:"successRate,omitempty"`
	SuccessRateNEQ   *int  `json:"successRateNEQ,omitempty"`
	SuccessRateIn    []int `json:"successRateIn,omitempty"`
	SuccessRateNotIn []int `json:"successRateNotIn,omitempty"`
	SuccessRateGT    *int  `json:"successRateGT,omitempty"`
	SuccessRateGTE   *int  `json:"successRateGTE,omitempty"`
	SuccessRateLT    *int  `json:"successRateLT,omitempty"`
	SuccessRateLTE   *int  `json:"successRateLTE,omitempty"`

	// "avg_latency_ms" field predicates.
	AvgLatencyMs      *int  `json:"avgLatencyMs,omitempty"`
	AvgLatencyMsNEQ   *int  `json:"avgLatencyMsNEQ,omitempty"`
	AvgLatencyMsIn    []int `json:"avgLatencyMsIn,omitempty"`
	AvgLatencyMsNotIn []int `json:"avgLatencyMsNotIn,omitempty"`
	AvgLatencyMsGT    *int  `json:"avgLatencyMsGT,omitempty"`
	AvgLatencyMsGTE   *int  `json:"avgLatencyMsGTE,omitempty"`
	AvgLatencyMsLT    *int  `json:"avgLatencyMsLT,omitempty"`
	AvgLatencyMsLTE   *int  `json:"avgLatencyMsLTE,omitempty"`

	// "avg_token_per_second" field predicates.
	AvgTokenPerSecond      *int  `json:"avgTokenPerSecond,omitempty"`
	AvgTokenPerSecondNEQ   *int  `json:"avgTokenPerSecondNEQ,omitempty"`
	AvgTokenPerSecondIn    []int `json:"avgTokenPerSecondIn,omitempty"`
	AvgTokenPerSecondNotIn []int `json:"avgTokenPerSecondNotIn,omitempty"`
	AvgTokenPerSecondGT    *int  `json:"avgTokenPerSecondGT,omitempty"`
	AvgTokenPerSecondGTE   *int  `json:"avgTokenPerSecondGTE,omitempty"`
	AvgTokenPerSecondLT    *int  `json:"avgTokenPerSecondLT,omitempty"`
	AvgTokenPerSecondLTE   *int  `json:"avgTokenPerSecondLTE,omitempty"`

	// "avg_stream_first_token_latency_ms" field predicates.
	AvgStreamFirstTokenLatencyMs      *int  `json:"avgStreamFirstTokenLatencyMs,omitempty"`
	AvgStreamFirstTokenLatencyMsNEQ   *int  `json:"avgStreamFirstTokenLatencyMsNEQ,omitempty"`
	AvgStreamFirstTokenLatencyMsIn    []int `json:"avgStreamFirstTokenLatencyMsIn,omitempty"`
	AvgStreamFirstTokenLatencyMsNotIn []int `json:"avgStreamFirstTokenLatencyMsNotIn,omitempty"`
	AvgStreamFirstTokenLatencyMsGT    *int  `json:"avgStreamFirstTokenLatencyMsGT,omitempty"`
	AvgStreamFirstTokenLatencyMsGTE   *int  `json:"avgStreamFirstTokenLatencyMsGTE,omitempty"`
	AvgStreamFirstTokenLatencyMsLT    *int  `json:"avgStreamFirstTokenLatencyMsLT,omitempty"`
	AvgStreamFirstTokenLatencyMsLTE   *int  `json:"avgStreamFirstTokenLatencyMsLTE,omitempty"`

	// "avg_stream_token_per_second" field predicates.
	AvgStreamTokenPerSecond      *float64  `json:"avgStreamTokenPerSecond,omitempty"`
	AvgStreamTokenPerSecondNEQ   *float64  `json:"avgStreamTokenPerSecondNEQ,omitempty"`
	AvgStreamTokenPerSecondIn    []float64 `json:"avgStreamTokenPerSecondIn,omitempty"`
	AvgStreamTokenPerSecondNotIn []float64 `json:"avgStreamTokenPerSecondNotIn,omitempty"`
	AvgStreamTokenPerSecondGT    *float64  `json:"avgStreamTokenPerSecondGT,omitempty"`
	AvgStreamTokenPerSecondGTE   *float64  `json:"avgStreamTokenPerSecondGTE,omitempty"`
	AvgStreamTokenPerSecondLT    *float64  `json:"avgStreamTokenPerSecondLT,omitempty"`
	AvgStreamTokenPerSecondLTE   *float64  `json:"avgStreamTokenPerSecondLTE,omitempty"`

	// "last_success_at" field predicates.
	LastSuccessAt       *time.Time  `json:"lastSuccessAt,omitempty"`
	LastSuccessAtNEQ    *time.Time  `json:"lastSuccessAtNEQ,omitempty"`
	LastSuccessAtIn     []time.Time `json:"lastSuccessAtIn,omitempty"`
	LastSuccessAtNotIn  []time.Time `json:"lastSuccessAtNotIn,omitempty"`
	LastSuccessAtGT     *time.Time  `json:"lastSuccessAtGT,omitempty"`
	LastSuccessAtGTE    *time.Time  `json:"lastSuccessAtGTE,omitempty"`
	LastSuccessAtLT     *time.Time  `json:"lastSuccessAtLT,omitempty"`
	LastSuccessAtLTE    *time.Time  `json:"lastSuccessAtLTE,omitempty"`
	LastSuccessAtIsNil  bool        `json:"lastSuccessAtIsNil,omitempty"`
	LastSuccessAtNotNil bool        `json:"lastSuccessAtNotNil,omitempty"`

	// "last_failure_at" field predicates.
	LastFailureAt       *time.Time  `json:"lastFailureAt,omitempty"`
	LastFailureAtNEQ    *time.Time  `json:"lastFailureAtNEQ,omitempty"`
	LastFailureAtIn     []time.Time `json:"lastFailureAtIn,omitempty"`
	LastFailureAtNotIn  []time.Time `json:"lastFailureAtNotIn,omitempty"`
	LastFailureAtGT     *time.Time  `json:"lastFailureAtGT,omitempty"`
	LastFailureAtGTE    *time.Time  `json:"lastFailureAtGTE,omitempty"`
	LastFailureAtLT     *time.Time  `json:"lastFailureAtLT,omitempty"`
	LastFailureAtLTE    *time.Time  `json:"lastFailureAtLTE,omitempty"`
	LastFailureAtIsNil  bool        `json:"lastFailureAtIsNil,omitempty"`
	LastFailureAtNotNil bool        `json:"lastFailureAtNotNil,omitempty"`

	// "channel" edge predicates.
	HasChannel     *bool                `json:"hasChannel,omitempty"`
	HasChannelWith []*ChannelWhereInput `json:"hasChannelWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ChannelPerformanceWhereInput) AddPredicates(predicates ...predicate.ChannelPerformance) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ChannelPerformanceWhereInput filter on the ChannelPerformanceQuery builder.
func (i *ChannelPerformanceWhereInput) Filter(q *ChannelPerformanceQuery) (*ChannelPerformanceQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyChannelPerformanceWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyChannelPerformanceWhereInput is returned in case the ChannelPerformanceWhereInput is empty.
var ErrEmptyChannelPerformanceWhereInput = errors.New("ent: empty predicate ChannelPerformanceWhereInput")

// P returns a predicate for filtering channelperformances.
// An error is returned if the input is empty or invalid.
func (i *ChannelPerformanceWhereInput) P() (predicate.ChannelPerformance, error) {
	var predicates []predicate.ChannelPerformance
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, channelperformance.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ChannelPerformance, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, channelperformance.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ChannelPerformance, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, channelperformance.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, channelperformance.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, channelperformance.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, channelperformance.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, channelperformance.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, channelperformance.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, channelperformance.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, channelperformance.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, channelperformance.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, channelperformance.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, channelperformance.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, channelperformance.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, channelperformance.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, channelperformance.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, channelperformance.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, channelperformance.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, channelperformance.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, channelperformance.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, channelperformance.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, channelperformance.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, channelperformance.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, channelperformance.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, channelperformance.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, channelperformance.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, channelperformance.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, channelperformance.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, channelperformance.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, channelperformance.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, channelperformance.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, channelperformance.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, channelperformance.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, channelperformance.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, channelperformance.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.ChannelID != nil {
		predicates = append(predicates, channelperformance.ChannelIDEQ(*i.ChannelID))
	}
	if i.ChannelIDNEQ != nil {
		predicates = append(predicates, channelperformance.ChannelIDNEQ(*i.ChannelIDNEQ))
	}
	if len(i.ChannelIDIn) > 0 {
		predicates = append(predicates, channelperformance.ChannelIDIn(i.ChannelIDIn...))
	}
	if len(i.ChannelIDNotIn) > 0 {
		predicates = append(predicates, channelperformance.ChannelIDNotIn(i.ChannelIDNotIn...))
	}
	if i.SuccessRate != nil {
		predicates = append(predicates, channelperformance.SuccessRateEQ(*i.SuccessRate))
	}
	if i.SuccessRateNEQ != nil {
		predicates = append(predicates, channelperformance.SuccessRateNEQ(*i.SuccessRateNEQ))
	}
	if len(i.SuccessRateIn) > 0 {
		predicates = append(predicates, channelperformance.SuccessRateIn(i.SuccessRateIn...))
	}
	if len(i.SuccessRateNotIn) > 0 {
		predicates = append(predicates, channelperformance.SuccessRateNotIn(i.SuccessRateNotIn...))
	}
	if i.SuccessRateGT != nil {
		predicates = append(predicates, channelperformance.SuccessRateGT(*i.SuccessRateGT))
	}
	if i.SuccessRateGTE != nil {
		predicates = append(predicates, channelperformance.SuccessRateGTE(*i.SuccessRateGTE))
	}
	if i.SuccessRateLT != nil {
		predicates = append(predicates, channelperformance.SuccessRateLT(*i.SuccessRateLT))
	}
	if i.SuccessRateLTE != nil {
		predicates = append(predicates, channelperformance.SuccessRateLTE(*i.SuccessRateLTE))
	}
	if i.AvgLatencyMs != nil {
		predicates = append(predicates, channelperformance.AvgLatencyMsEQ(*i.AvgLatencyMs))
	}
	if i.AvgLatencyMsNEQ != nil {
		predicates = append(predicates, channelperformance.AvgLatencyMsNEQ(*i.AvgLatencyMsNEQ))
	}
	if len(i.AvgLatencyMsIn) > 0 {
		predicates = append(predicates, channelperformance.AvgLatencyMsIn(i.AvgLatencyMsIn...))
	}
	if len(i.AvgLatencyMsNotIn) > 0 {
		predicates = append(predicates, channelperformance.AvgLatencyMsNotIn(i.AvgLatencyMsNotIn...))
	}
	if i.AvgLatencyMsGT != nil {
		predicates = append(predicates, channelperformance.AvgLatencyMsGT(*i.AvgLatencyMsGT))
	}
	if i.AvgLatencyMsGTE != nil {
		predicates = append(predicates, channelperformance.AvgLatencyMsGTE(*i.AvgLatencyMsGTE))
	}
	if i.AvgLatencyMsLT != nil {
		predicates = append(predicates, channelperformance.AvgLatencyMsLT(*i.AvgLatencyMsLT))
	}
	if i.AvgLatencyMsLTE != nil {
		predicates = append(predicates, channelperformance.AvgLatencyMsLTE(*i.AvgLatencyMsLTE))
	}
	if i.AvgTokenPerSecond != nil {
		predicates = append(predicates, channelperformance.AvgTokenPerSecondEQ(*i.AvgTokenPerSecond))
	}
	if i.AvgTokenPerSecondNEQ != nil {
		predicates = append(predicates, channelperformance.AvgTokenPerSecondNEQ(*i.AvgTokenPerSecondNEQ))
	}
	if len(i.AvgTokenPerSecondIn) > 0 {
		predicates = append(predicates, channelperformance.AvgTokenPerSecondIn(i.AvgTokenPerSecondIn...))
	}
	if len(i.AvgTokenPerSecondNotIn) > 0 {
		predicates = append(predicates, channelperformance.AvgTokenPerSecondNotIn(i.AvgTokenPerSecondNotIn...))
	}
	if i.AvgTokenPerSecondGT != nil {
		predicates = append(predicates, channelperformance.AvgTokenPerSecondGT(*i.AvgTokenPerSecondGT))
	}
	if i.AvgTokenPerSecondGTE != nil {
		predicates = append(predicates, channelperformance.AvgTokenPerSecondGTE(*i.AvgTokenPerSecondGTE))
	}
	if i.AvgTokenPerSecondLT != nil {
		predicates = append(predicates, channelperformance.AvgTokenPerSecondLT(*i.AvgTokenPerSecondLT))
	}
	if i.AvgTokenPerSecondLTE != nil {
		predicates = append(predicates, channelperformance.AvgTokenPerSecondLTE(*i.AvgTokenPerSecondLTE))
	}
	if i.AvgStreamFirstTokenLatencyMs != nil {
		predicates = append(predicates, channelperformance.AvgStreamFirstTokenLatencyMsEQ(*i.AvgStreamFirstTokenLatencyMs))
	}
	if i.AvgStreamFirstTokenLatencyMsNEQ != nil {
		predicates = append(predicates, channelperformance.AvgStreamFirstTokenLatencyMsNEQ(*i.AvgStreamFirstTokenLatencyMsNEQ))
	}
	if len(i.AvgStreamFirstTokenLatencyMsIn) > 0 {
		predicates = append(predicates, channelperformance.AvgStreamFirstTokenLatencyMsIn(i.AvgStreamFirstTokenLatencyMsIn...))
	}
	if len(i.AvgStreamFirstTokenLatencyMsNotIn) > 0 {
		predicates = append(predicates, channelperformance.AvgStreamFirstTokenLatencyMsNotIn(i.AvgStreamFirstTokenLatencyMsNotIn...))
	}
	if i.AvgStreamFirstTokenLatencyMsGT != nil {
		predicates = append(predicates, channelperformance.AvgStreamFirstTokenLatencyMsGT(*i.AvgStreamFirstTokenLatencyMsGT))
	}
	if i.AvgStreamFirstTokenLatencyMsGTE != nil {
		predicates = append(predicates, channelperformance.AvgStreamFirstTokenLatencyMsGTE(*i.AvgStreamFirstTokenLatencyMsGTE))
	}
	if i.AvgStreamFirstTokenLatencyMsLT != nil {
		predicates = append(predicates, channelperformance.AvgStreamFirstTokenLatencyMsLT(*i.AvgStreamFirstTokenLatencyMsLT))
	}
	if i.AvgStreamFirstTokenLatencyMsLTE != nil {
		predicates = append(predicates, channelperformance.AvgStreamFirstTokenLatencyMsLTE(*i.AvgStreamFirstTokenLatencyMsLTE))
	}
	if i.AvgStreamTokenPerSecond != nil {
		predicates = append(predicates, channelperformance.AvgStreamTokenPerSecondEQ(*i.AvgStreamTokenPerSecond))
	}
	if i.AvgStreamTokenPerSecondNEQ != nil {
		predicates = append(predicates, channelperformance.AvgStreamTokenPerSecondNEQ(*i.AvgStreamTokenPerSecondNEQ))
	}
	if len(i.AvgStreamTokenPerSecondIn) > 0 {
		predicates = append(predicates, channelperformance.AvgStreamTokenPerSecondIn(i.AvgStreamTokenPerSecondIn...))
	}
	if len(i.AvgStreamTokenPerSecondNotIn) > 0 {
		predicates = append(predicates, channelperformance.AvgStreamTokenPerSecondNotIn(i.AvgStreamTokenPerSecondNotIn...))
	}
	if i.AvgStreamTokenPerSecondGT != nil {
		predicates = append(predicates, channelperformance.AvgStreamTokenPerSecondGT(*i.AvgStreamTokenPerSecondGT))
	}
	if i.AvgStreamTokenPerSecondGTE != nil {
		predicates = append(predicates, channelperformance.AvgStreamTokenPerSecondGTE(*i.AvgStreamTokenPerSecondGTE))
	}
	if i.AvgStreamTokenPerSecondLT != nil {
		predicates = append(predicates, channelperformance.AvgStreamTokenPerSecondLT(*i.AvgStreamTokenPerSecondLT))
	}
	if i.AvgStreamTokenPerSecondLTE != nil {
		predicates = append(predicates, channelperformance.AvgStreamTokenPerSecondLTE(*i.AvgStreamTokenPerSecondLTE))
	}
	if i.LastSuccessAt != nil {
		predicates = append(predicates, channelperformance.LastSuccessAtEQ(*i.LastSuccessAt))
	}
	if i.LastSuccessAtNEQ != nil {
		predicates = append(predicates, channelperformance.LastSuccessAtNEQ(*i.LastSuccessAtNEQ))
	}
	if len(i.LastSuccessAtIn) > 0 {
		predicates = append(predicates, channelperformance.LastSuccessAtIn(i.LastSuccessAtIn...))
	}
	if len(i.LastSuccessAtNotIn) > 0 {
		predicates = append(predicates, channelperformance.LastSuccessAtNotIn(i.LastSuccessAtNotIn...))
	}
	if i.LastSuccessAtGT != nil {
		predicates = append(predicates, channelperformance.LastSuccessAtGT(*i.LastSuccessAtGT))
	}
	if i.LastSuccessAtGTE != nil {
		predicates = append(predicates, channelperformance.LastSuccessAtGTE(*i.LastSuccessAtGTE))
	}
	if i.LastSuccessAtLT != nil {
		predicates = append(predicates, channelperformance.LastSuccessAtLT(*i.LastSuccessAtLT))
	}
	if i.LastSuccessAtLTE != nil {
		predicates = append(predicates, channelperformance.LastSuccessAtLTE(*i.LastSuccessAtLTE))
	}
	if i.LastSuccessAtIsNil {
		predicates = append(predicates, channelperformance.LastSuccessAtIsNil())
	}
	if i.LastSuccessAtNotNil {
		predicates = append(predicates, channelperformance.LastSuccessAtNotNil())
	}
	if i.LastFailureAt != nil {
		predicates = append(predicates, channelperformance.LastFailureAtEQ(*i.LastFailureAt))
	}
	if i.LastFailureAtNEQ != nil {
		predicates = append(predicates, channelperformance.LastFailureAtNEQ(*i.LastFailureAtNEQ))
	}
	if len(i.LastFailureAtIn) > 0 {
		predicates = append(predicates, channelperformance.LastFailureAtIn(i.LastFailureAtIn...))
	}
	if len(i.LastFailureAtNotIn) > 0 {
		predicates = append(predicates, channelperformance.LastFailureAtNotIn(i.LastFailureAtNotIn...))
	}
	if i.LastFailureAtGT != nil {
		predicates = append(predicates, channelperformance.LastFailureAtGT(*i.LastFailureAtGT))
	}
	if i.LastFailureAtGTE != nil {
		predicates = append(predicates, channelperformance.LastFailureAtGTE(*i.LastFailureAtGTE))
	}
	if i.LastFailureAtLT != nil {
		predicates = append(predicates, channelperformance.LastFailureAtLT(*i.LastFailureAtLT))
	}
	if i.LastFailureAtLTE != nil {
		predicates = append(predicates, channelperformance.LastFailureAtLTE(*i.LastFailureAtLTE))
	}
	if i.LastFailureAtIsNil {
		predicates = append(predicates, channelperformance.LastFailureAtIsNil())
	}
	if i.LastFailureAtNotNil {
		predicates = append(predicates, channelperformance.LastFailureAtNotNil())
	}

	if i.HasChannel != nil {
		p := channelperformance.HasChannel()
		if !*i.HasChannel {
			p = channelperformance.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasChannelWith) > 0 {
		with := make([]predicate.Channel, 0, len(i.HasChannelWith))
		for _, w := range i.HasChannelWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasChannelWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, channelperformance.HasChannelWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyChannelPerformanceWhereInput
	case 1:
		return predicates[0], nil
	default:
		return channelperformance.And(predicates...), nil
	}
}

// DataStorageWhereInput represents a where input for filtering DataStorage queries.
type DataStorageWhereInput struct {
	Predicates []predicate.DataStorage  `json:"-"`
	Not        *DataStorageWhereInput   `json:"not,omitempty"`
	Or         []*DataStorageWhereInput `json:"or,omitempty"`
	And        []*DataStorageWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt      *int  `json:"deletedAt,omitempty"`
	DeletedAtNEQ   *int  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn    []int `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn []int `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT    *int  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE   *int  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT    *int  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE   *int  `json:"deletedAtLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "primary" field predicates.
	Primary    *bool `json:"primary,omitempty"`
	PrimaryNEQ *bool `json:"primaryNEQ,omitempty"`

	// "type" field predicates.
	Type      *datastorage.Type  `json:"type,omitempty"`
	TypeNEQ   *datastorage.Type  `json:"typeNEQ,omitempty"`
	TypeIn    []datastorage.Type `json:"typeIn,omitempty"`
	TypeNotIn []datastorage.Type `json:"typeNotIn,omitempty"`

	// "status" field predicates.
	Status      *datastorage.Status  `json:"status,omitempty"`
	StatusNEQ   *datastorage.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []datastorage.Status `json:"statusIn,omitempty"`
	StatusNotIn []datastorage.Status `json:"statusNotIn,omitempty"`

	// "requests" edge predicates.
	HasRequests     *bool                `json:"hasRequests,omitempty"`
	HasRequestsWith []*RequestWhereInput `json:"hasRequestsWith,omitempty"`

	// "executions" edge predicates.
	HasExecutions     *bool                         `json:"hasExecutions,omitempty"`
	HasExecutionsWith []*RequestExecutionWhereInput `json:"hasExecutionsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *DataStorageWhereInput) AddPredicates(predicates ...predicate.DataStorage) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the DataStorageWhereInput filter on the DataStorageQuery builder.
func (i *DataStorageWhereInput) Filter(q *DataStorageQuery) (*DataStorageQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyDataStorageWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyDataStorageWhereInput is returned in case the DataStorageWhereInput is empty.
var ErrEmptyDataStorageWhereInput = errors.New("ent: empty predicate DataStorageWhereInput")

// P returns a predicate for filtering datastorages.
// An error is returned if the input is empty or invalid.
func (i *DataStorageWhereInput) P() (predicate.DataStorage, error) {
	var predicates []predicate.DataStorage
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, datastorage.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.DataStorage, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, datastorage.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.DataStorage, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, datastorage.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, datastorage.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, datastorage.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, datastorage.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, datastorage.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, datastorage.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, datastorage.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, datastorage.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, datastorage.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, datastorage.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, datastorage.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, datastorage.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, datastorage.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, datastorage.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, datastorage.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, datastorage.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, datastorage.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, datastorage.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, datastorage.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, datastorage.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, datastorage.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, datastorage.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, datastorage.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, datastorage.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, datastorage.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, datastorage.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, datastorage.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, datastorage.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, datastorage.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, datastorage.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, datastorage.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, datastorage.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, datastorage.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, datastorage.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, datastorage.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, datastorage.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, datastorage.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, datastorage.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, datastorage.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, datastorage.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, datastorage.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, datastorage.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, datastorage.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, datastorage.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, datastorage.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, datastorage.NameContainsFold(*i.NameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, datastorage.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, datastorage.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, datastorage.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, datastorage.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, datastorage.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, datastorage.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, datastorage.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, datastorage.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, datastorage.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, datastorage.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, datastorage.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, datastorage.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, datastorage.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.Primary != nil {
		predicates = append(predicates, datastorage.PrimaryEQ(*i.Primary))
	}
	if i.PrimaryNEQ != nil {
		predicates = append(predicates, datastorage.PrimaryNEQ(*i.PrimaryNEQ))
	}
	if i.Type != nil {
		predicates = append(predicates, datastorage.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, datastorage.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, datastorage.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, datastorage.TypeNotIn(i.TypeNotIn...))
	}
	if i.Status != nil {
		predicates = append(predicates, datastorage.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, datastorage.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, datastorage.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, datastorage.StatusNotIn(i.StatusNotIn...))
	}

	if i.HasRequests != nil {
		p := datastorage.HasRequests()
		if !*i.HasRequests {
			p = datastorage.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRequestsWith) > 0 {
		with := make([]predicate.Request, 0, len(i.HasRequestsWith))
		for _, w := range i.HasRequestsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRequestsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, datastorage.HasRequestsWith(with...))
	}
	if i.HasExecutions != nil {
		p := datastorage.HasExecutions()
		if !*i.HasExecutions {
			p = datastorage.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasExecutionsWith) > 0 {
		with := make([]predicate.RequestExecution, 0, len(i.HasExecutionsWith))
		for _, w := range i.HasExecutionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasExecutionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, datastorage.HasExecutionsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyDataStorageWhereInput
	case 1:
		return predicates[0], nil
	default:
		return datastorage.And(predicates...), nil
	}
}

// ProjectWhereInput represents a where input for filtering Project queries.
type ProjectWhereInput struct {
	Predicates []predicate.Project  `json:"-"`
	Not        *ProjectWhereInput   `json:"not,omitempty"`
	Or         []*ProjectWhereInput `json:"or,omitempty"`
	And        []*ProjectWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt      *int  `json:"deletedAt,omitempty"`
	DeletedAtNEQ   *int  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn    []int `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn []int `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT    *int  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE   *int  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT    *int  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE   *int  `json:"deletedAtLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "status" field predicates.
	Status      *project.Status  `json:"status,omitempty"`
	StatusNEQ   *project.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []project.Status `json:"statusIn,omitempty"`
	StatusNotIn []project.Status `json:"statusNotIn,omitempty"`

	// "users" edge predicates.
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`

	// "roles" edge predicates.
	HasRoles     *bool             `json:"hasRoles,omitempty"`
	HasRolesWith []*RoleWhereInput `json:"hasRolesWith,omitempty"`

	// "api_keys" edge predicates.
	HasAPIKeys     *bool               `json:"hasAPIKeys,omitempty"`
	HasAPIKeysWith []*APIKeyWhereInput `json:"hasAPIKeysWith,omitempty"`

	// "requests" edge predicates.
	HasRequests     *bool                `json:"hasRequests,omitempty"`
	HasRequestsWith []*RequestWhereInput `json:"hasRequestsWith,omitempty"`

	// "usage_logs" edge predicates.
	HasUsageLogs     *bool                 `json:"hasUsageLogs,omitempty"`
	HasUsageLogsWith []*UsageLogWhereInput `json:"hasUsageLogsWith,omitempty"`

	// "threads" edge predicates.
	HasThreads     *bool               `json:"hasThreads,omitempty"`
	HasThreadsWith []*ThreadWhereInput `json:"hasThreadsWith,omitempty"`

	// "traces" edge predicates.
	HasTraces     *bool              `json:"hasTraces,omitempty"`
	HasTracesWith []*TraceWhereInput `json:"hasTracesWith,omitempty"`

	// "project_users" edge predicates.
	HasProjectUsers     *bool                    `json:"hasProjectUsers,omitempty"`
	HasProjectUsersWith []*UserProjectWhereInput `json:"hasProjectUsersWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ProjectWhereInput) AddPredicates(predicates ...predicate.Project) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ProjectWhereInput filter on the ProjectQuery builder.
func (i *ProjectWhereInput) Filter(q *ProjectQuery) (*ProjectQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyProjectWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyProjectWhereInput is returned in case the ProjectWhereInput is empty.
var ErrEmptyProjectWhereInput = errors.New("ent: empty predicate ProjectWhereInput")

// P returns a predicate for filtering projects.
// An error is returned if the input is empty or invalid.
func (i *ProjectWhereInput) P() (predicate.Project, error) {
	var predicates []predicate.Project
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, project.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Project, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, project.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Project, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, project.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, project.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, project.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, project.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, project.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, project.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, project.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, project.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, project.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, project.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, project.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, project.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, project.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, project.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, project.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, project.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, project.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, project.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, project.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, project.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, project.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, project.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, project.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, project.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, project.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, project.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, project.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, project.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, project.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, project.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, project.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, project.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, project.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, project.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, project.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, project.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, project.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, project.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, project.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, project.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, project.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, project.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, project.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, project.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, project.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, project.NameContainsFold(*i.NameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, project.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, project.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, project.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, project.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, project.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, project.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, project.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, project.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, project.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, project.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, project.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, project.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, project.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, project.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, project.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, project.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, project.StatusNotIn(i.StatusNotIn...))
	}

	if i.HasUsers != nil {
		p := project.HasUsers()
		if !*i.HasUsers {
			p = project.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUsersWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUsersWith))
		for _, w := range i.HasUsersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUsersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, project.HasUsersWith(with...))
	}
	if i.HasRoles != nil {
		p := project.HasRoles()
		if !*i.HasRoles {
			p = project.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRolesWith) > 0 {
		with := make([]predicate.Role, 0, len(i.HasRolesWith))
		for _, w := range i.HasRolesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRolesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, project.HasRolesWith(with...))
	}
	if i.HasAPIKeys != nil {
		p := project.HasAPIKeys()
		if !*i.HasAPIKeys {
			p = project.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAPIKeysWith) > 0 {
		with := make([]predicate.APIKey, 0, len(i.HasAPIKeysWith))
		for _, w := range i.HasAPIKeysWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAPIKeysWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, project.HasAPIKeysWith(with...))
	}
	if i.HasRequests != nil {
		p := project.HasRequests()
		if !*i.HasRequests {
			p = project.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRequestsWith) > 0 {
		with := make([]predicate.Request, 0, len(i.HasRequestsWith))
		for _, w := range i.HasRequestsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRequestsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, project.HasRequestsWith(with...))
	}
	if i.HasUsageLogs != nil {
		p := project.HasUsageLogs()
		if !*i.HasUsageLogs {
			p = project.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUsageLogsWith) > 0 {
		with := make([]predicate.UsageLog, 0, len(i.HasUsageLogsWith))
		for _, w := range i.HasUsageLogsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUsageLogsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, project.HasUsageLogsWith(with...))
	}
	if i.HasThreads != nil {
		p := project.HasThreads()
		if !*i.HasThreads {
			p = project.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasThreadsWith) > 0 {
		with := make([]predicate.Thread, 0, len(i.HasThreadsWith))
		for _, w := range i.HasThreadsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasThreadsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, project.HasThreadsWith(with...))
	}
	if i.HasTraces != nil {
		p := project.HasTraces()
		if !*i.HasTraces {
			p = project.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTracesWith) > 0 {
		with := make([]predicate.Trace, 0, len(i.HasTracesWith))
		for _, w := range i.HasTracesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTracesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, project.HasTracesWith(with...))
	}
	if i.HasProjectUsers != nil {
		p := project.HasProjectUsers()
		if !*i.HasProjectUsers {
			p = project.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProjectUsersWith) > 0 {
		with := make([]predicate.UserProject, 0, len(i.HasProjectUsersWith))
		for _, w := range i.HasProjectUsersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProjectUsersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, project.HasProjectUsersWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyProjectWhereInput
	case 1:
		return predicates[0], nil
	default:
		return project.And(predicates...), nil
	}
}

// RequestWhereInput represents a where input for filtering Request queries.
type RequestWhereInput struct {
	Predicates []predicate.Request  `json:"-"`
	Not        *RequestWhereInput   `json:"not,omitempty"`
	Or         []*RequestWhereInput `json:"or,omitempty"`
	And        []*RequestWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "api_key_id" field predicates.
	APIKeyID       *int  `json:"apiKeyID,omitempty"`
	APIKeyIDNEQ    *int  `json:"apiKeyIDNEQ,omitempty"`
	APIKeyIDIn     []int `json:"apiKeyIDIn,omitempty"`
	APIKeyIDNotIn  []int `json:"apiKeyIDNotIn,omitempty"`
	APIKeyIDIsNil  bool  `json:"apiKeyIDIsNil,omitempty"`
	APIKeyIDNotNil bool  `json:"apiKeyIDNotNil,omitempty"`

	// "project_id" field predicates.
	ProjectID      *int  `json:"projectID,omitempty"`
	ProjectIDNEQ   *int  `json:"projectIDNEQ,omitempty"`
	ProjectIDIn    []int `json:"projectIDIn,omitempty"`
	ProjectIDNotIn []int `json:"projectIDNotIn,omitempty"`

	// "trace_id" field predicates.
	TraceID       *int  `json:"traceID,omitempty"`
	TraceIDNEQ    *int  `json:"traceIDNEQ,omitempty"`
	TraceIDIn     []int `json:"traceIDIn,omitempty"`
	TraceIDNotIn  []int `json:"traceIDNotIn,omitempty"`
	TraceIDIsNil  bool  `json:"traceIDIsNil,omitempty"`
	TraceIDNotNil bool  `json:"traceIDNotNil,omitempty"`

	// "data_storage_id" field predicates.
	DataStorageID       *int  `json:"dataStorageID,omitempty"`
	DataStorageIDNEQ    *int  `json:"dataStorageIDNEQ,omitempty"`
	DataStorageIDIn     []int `json:"dataStorageIDIn,omitempty"`
	DataStorageIDNotIn  []int `json:"dataStorageIDNotIn,omitempty"`
	DataStorageIDIsNil  bool  `json:"dataStorageIDIsNil,omitempty"`
	DataStorageIDNotNil bool  `json:"dataStorageIDNotNil,omitempty"`

	// "source" field predicates.
	Source      *request.Source  `json:"source,omitempty"`
	SourceNEQ   *request.Source  `json:"sourceNEQ,omitempty"`
	SourceIn    []request.Source `json:"sourceIn,omitempty"`
	SourceNotIn []request.Source `json:"sourceNotIn,omitempty"`

	// "model_id" field predicates.
	ModelID             *string  `json:"modelID,omitempty"`
	ModelIDNEQ          *string  `json:"modelIDNEQ,omitempty"`
	ModelIDIn           []string `json:"modelIDIn,omitempty"`
	ModelIDNotIn        []string `json:"modelIDNotIn,omitempty"`
	ModelIDGT           *string  `json:"modelIDGT,omitempty"`
	ModelIDGTE          *string  `json:"modelIDGTE,omitempty"`
	ModelIDLT           *string  `json:"modelIDLT,omitempty"`
	ModelIDLTE          *string  `json:"modelIDLTE,omitempty"`
	ModelIDContains     *string  `json:"modelIDContains,omitempty"`
	ModelIDHasPrefix    *string  `json:"modelIDHasPrefix,omitempty"`
	ModelIDHasSuffix    *string  `json:"modelIDHasSuffix,omitempty"`
	ModelIDEqualFold    *string  `json:"modelIDEqualFold,omitempty"`
	ModelIDContainsFold *string  `json:"modelIDContainsFold,omitempty"`

	// "format" field predicates.
	Format             *string  `json:"format,omitempty"`
	FormatNEQ          *string  `json:"formatNEQ,omitempty"`
	FormatIn           []string `json:"formatIn,omitempty"`
	FormatNotIn        []string `json:"formatNotIn,omitempty"`
	FormatGT           *string  `json:"formatGT,omitempty"`
	FormatGTE          *string  `json:"formatGTE,omitempty"`
	FormatLT           *string  `json:"formatLT,omitempty"`
	FormatLTE          *string  `json:"formatLTE,omitempty"`
	FormatContains     *string  `json:"formatContains,omitempty"`
	FormatHasPrefix    *string  `json:"formatHasPrefix,omitempty"`
	FormatHasSuffix    *string  `json:"formatHasSuffix,omitempty"`
	FormatEqualFold    *string  `json:"formatEqualFold,omitempty"`
	FormatContainsFold *string  `json:"formatContainsFold,omitempty"`

	// "channel_id" field predicates.
	ChannelID       *int  `json:"channelID,omitempty"`
	ChannelIDNEQ    *int  `json:"channelIDNEQ,omitempty"`
	ChannelIDIn     []int `json:"channelIDIn,omitempty"`
	ChannelIDNotIn  []int `json:"channelIDNotIn,omitempty"`
	ChannelIDIsNil  bool  `json:"channelIDIsNil,omitempty"`
	ChannelIDNotNil bool  `json:"channelIDNotNil,omitempty"`

	// "external_id" field predicates.
	ExternalID             *string  `json:"externalID,omitempty"`
	ExternalIDNEQ          *string  `json:"externalIDNEQ,omitempty"`
	ExternalIDIn           []string `json:"externalIDIn,omitempty"`
	ExternalIDNotIn        []string `json:"externalIDNotIn,omitempty"`
	ExternalIDGT           *string  `json:"externalIDGT,omitempty"`
	ExternalIDGTE          *string  `json:"externalIDGTE,omitempty"`
	ExternalIDLT           *string  `json:"externalIDLT,omitempty"`
	ExternalIDLTE          *string  `json:"externalIDLTE,omitempty"`
	ExternalIDContains     *string  `json:"externalIDContains,omitempty"`
	ExternalIDHasPrefix    *string  `json:"externalIDHasPrefix,omitempty"`
	ExternalIDHasSuffix    *string  `json:"externalIDHasSuffix,omitempty"`
	ExternalIDIsNil        bool     `json:"externalIDIsNil,omitempty"`
	ExternalIDNotNil       bool     `json:"externalIDNotNil,omitempty"`
	ExternalIDEqualFold    *string  `json:"externalIDEqualFold,omitempty"`
	ExternalIDContainsFold *string  `json:"externalIDContainsFold,omitempty"`

	// "status" field predicates.
	Status      *request.Status  `json:"status,omitempty"`
	StatusNEQ   *request.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []request.Status `json:"statusIn,omitempty"`
	StatusNotIn []request.Status `json:"statusNotIn,omitempty"`

	// "stream" field predicates.
	Stream    *bool `json:"stream,omitempty"`
	StreamNEQ *bool `json:"streamNEQ,omitempty"`

	// "api_key" edge predicates.
	HasAPIKey     *bool               `json:"hasAPIKey,omitempty"`
	HasAPIKeyWith []*APIKeyWhereInput `json:"hasAPIKeyWith,omitempty"`

	// "project" edge predicates.
	HasProject     *bool                `json:"hasProject,omitempty"`
	HasProjectWith []*ProjectWhereInput `json:"hasProjectWith,omitempty"`

	// "trace" edge predicates.
	HasTrace     *bool              `json:"hasTrace,omitempty"`
	HasTraceWith []*TraceWhereInput `json:"hasTraceWith,omitempty"`

	// "data_storage" edge predicates.
	HasDataStorage     *bool                    `json:"hasDataStorage,omitempty"`
	HasDataStorageWith []*DataStorageWhereInput `json:"hasDataStorageWith,omitempty"`

	// "executions" edge predicates.
	HasExecutions     *bool                         `json:"hasExecutions,omitempty"`
	HasExecutionsWith []*RequestExecutionWhereInput `json:"hasExecutionsWith,omitempty"`

	// "channel" edge predicates.
	HasChannel     *bool                `json:"hasChannel,omitempty"`
	HasChannelWith []*ChannelWhereInput `json:"hasChannelWith,omitempty"`

	// "usage_logs" edge predicates.
	HasUsageLogs     *bool                 `json:"hasUsageLogs,omitempty"`
	HasUsageLogsWith []*UsageLogWhereInput `json:"hasUsageLogsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *RequestWhereInput) AddPredicates(predicates ...predicate.Request) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the RequestWhereInput filter on the RequestQuery builder.
func (i *RequestWhereInput) Filter(q *RequestQuery) (*RequestQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyRequestWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyRequestWhereInput is returned in case the RequestWhereInput is empty.
var ErrEmptyRequestWhereInput = errors.New("ent: empty predicate RequestWhereInput")

// P returns a predicate for filtering requests.
// An error is returned if the input is empty or invalid.
func (i *RequestWhereInput) P() (predicate.Request, error) {
	var predicates []predicate.Request
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, request.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Request, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, request.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Request, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, request.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, request.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, request.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, request.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, request.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, request.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, request.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, request.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, request.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, request.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, request.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, request.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, request.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, request.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, request.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, request.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, request.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, request.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, request.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, request.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, request.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, request.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, request.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, request.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, request.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.APIKeyID != nil {
		predicates = append(predicates, request.APIKeyIDEQ(*i.APIKeyID))
	}
	if i.APIKeyIDNEQ != nil {
		predicates = append(predicates, request.APIKeyIDNEQ(*i.APIKeyIDNEQ))
	}
	if len(i.APIKeyIDIn) > 0 {
		predicates = append(predicates, request.APIKeyIDIn(i.APIKeyIDIn...))
	}
	if len(i.APIKeyIDNotIn) > 0 {
		predicates = append(predicates, request.APIKeyIDNotIn(i.APIKeyIDNotIn...))
	}
	if i.APIKeyIDIsNil {
		predicates = append(predicates, request.APIKeyIDIsNil())
	}
	if i.APIKeyIDNotNil {
		predicates = append(predicates, request.APIKeyIDNotNil())
	}
	if i.ProjectID != nil {
		predicates = append(predicates, request.ProjectIDEQ(*i.ProjectID))
	}
	if i.ProjectIDNEQ != nil {
		predicates = append(predicates, request.ProjectIDNEQ(*i.ProjectIDNEQ))
	}
	if len(i.ProjectIDIn) > 0 {
		predicates = append(predicates, request.ProjectIDIn(i.ProjectIDIn...))
	}
	if len(i.ProjectIDNotIn) > 0 {
		predicates = append(predicates, request.ProjectIDNotIn(i.ProjectIDNotIn...))
	}
	if i.TraceID != nil {
		predicates = append(predicates, request.TraceIDEQ(*i.TraceID))
	}
	if i.TraceIDNEQ != nil {
		predicates = append(predicates, request.TraceIDNEQ(*i.TraceIDNEQ))
	}
	if len(i.TraceIDIn) > 0 {
		predicates = append(predicates, request.TraceIDIn(i.TraceIDIn...))
	}
	if len(i.TraceIDNotIn) > 0 {
		predicates = append(predicates, request.TraceIDNotIn(i.TraceIDNotIn...))
	}
	if i.TraceIDIsNil {
		predicates = append(predicates, request.TraceIDIsNil())
	}
	if i.TraceIDNotNil {
		predicates = append(predicates, request.TraceIDNotNil())
	}
	if i.DataStorageID != nil {
		predicates = append(predicates, request.DataStorageIDEQ(*i.DataStorageID))
	}
	if i.DataStorageIDNEQ != nil {
		predicates = append(predicates, request.DataStorageIDNEQ(*i.DataStorageIDNEQ))
	}
	if len(i.DataStorageIDIn) > 0 {
		predicates = append(predicates, request.DataStorageIDIn(i.DataStorageIDIn...))
	}
	if len(i.DataStorageIDNotIn) > 0 {
		predicates = append(predicates, request.DataStorageIDNotIn(i.DataStorageIDNotIn...))
	}
	if i.DataStorageIDIsNil {
		predicates = append(predicates, request.DataStorageIDIsNil())
	}
	if i.DataStorageIDNotNil {
		predicates = append(predicates, request.DataStorageIDNotNil())
	}
	if i.Source != nil {
		predicates = append(predicates, request.SourceEQ(*i.Source))
	}
	if i.SourceNEQ != nil {
		predicates = append(predicates, request.SourceNEQ(*i.SourceNEQ))
	}
	if len(i.SourceIn) > 0 {
		predicates = append(predicates, request.SourceIn(i.SourceIn...))
	}
	if len(i.SourceNotIn) > 0 {
		predicates = append(predicates, request.SourceNotIn(i.SourceNotIn...))
	}
	if i.ModelID != nil {
		predicates = append(predicates, request.ModelIDEQ(*i.ModelID))
	}
	if i.ModelIDNEQ != nil {
		predicates = append(predicates, request.ModelIDNEQ(*i.ModelIDNEQ))
	}
	if len(i.ModelIDIn) > 0 {
		predicates = append(predicates, request.ModelIDIn(i.ModelIDIn...))
	}
	if len(i.ModelIDNotIn) > 0 {
		predicates = append(predicates, request.ModelIDNotIn(i.ModelIDNotIn...))
	}
	if i.ModelIDGT != nil {
		predicates = append(predicates, request.ModelIDGT(*i.ModelIDGT))
	}
	if i.ModelIDGTE != nil {
		predicates = append(predicates, request.ModelIDGTE(*i.ModelIDGTE))
	}
	if i.ModelIDLT != nil {
		predicates = append(predicates, request.ModelIDLT(*i.ModelIDLT))
	}
	if i.ModelIDLTE != nil {
		predicates = append(predicates, request.ModelIDLTE(*i.ModelIDLTE))
	}
	if i.ModelIDContains != nil {
		predicates = append(predicates, request.ModelIDContains(*i.ModelIDContains))
	}
	if i.ModelIDHasPrefix != nil {
		predicates = append(predicates, request.ModelIDHasPrefix(*i.ModelIDHasPrefix))
	}
	if i.ModelIDHasSuffix != nil {
		predicates = append(predicates, request.ModelIDHasSuffix(*i.ModelIDHasSuffix))
	}
	if i.ModelIDEqualFold != nil {
		predicates = append(predicates, request.ModelIDEqualFold(*i.ModelIDEqualFold))
	}
	if i.ModelIDContainsFold != nil {
		predicates = append(predicates, request.ModelIDContainsFold(*i.ModelIDContainsFold))
	}
	if i.Format != nil {
		predicates = append(predicates, request.FormatEQ(*i.Format))
	}
	if i.FormatNEQ != nil {
		predicates = append(predicates, request.FormatNEQ(*i.FormatNEQ))
	}
	if len(i.FormatIn) > 0 {
		predicates = append(predicates, request.FormatIn(i.FormatIn...))
	}
	if len(i.FormatNotIn) > 0 {
		predicates = append(predicates, request.FormatNotIn(i.FormatNotIn...))
	}
	if i.FormatGT != nil {
		predicates = append(predicates, request.FormatGT(*i.FormatGT))
	}
	if i.FormatGTE != nil {
		predicates = append(predicates, request.FormatGTE(*i.FormatGTE))
	}
	if i.FormatLT != nil {
		predicates = append(predicates, request.FormatLT(*i.FormatLT))
	}
	if i.FormatLTE != nil {
		predicates = append(predicates, request.FormatLTE(*i.FormatLTE))
	}
	if i.FormatContains != nil {
		predicates = append(predicates, request.FormatContains(*i.FormatContains))
	}
	if i.FormatHasPrefix != nil {
		predicates = append(predicates, request.FormatHasPrefix(*i.FormatHasPrefix))
	}
	if i.FormatHasSuffix != nil {
		predicates = append(predicates, request.FormatHasSuffix(*i.FormatHasSuffix))
	}
	if i.FormatEqualFold != nil {
		predicates = append(predicates, request.FormatEqualFold(*i.FormatEqualFold))
	}
	if i.FormatContainsFold != nil {
		predicates = append(predicates, request.FormatContainsFold(*i.FormatContainsFold))
	}
	if i.ChannelID != nil {
		predicates = append(predicates, request.ChannelIDEQ(*i.ChannelID))
	}
	if i.ChannelIDNEQ != nil {
		predicates = append(predicates, request.ChannelIDNEQ(*i.ChannelIDNEQ))
	}
	if len(i.ChannelIDIn) > 0 {
		predicates = append(predicates, request.ChannelIDIn(i.ChannelIDIn...))
	}
	if len(i.ChannelIDNotIn) > 0 {
		predicates = append(predicates, request.ChannelIDNotIn(i.ChannelIDNotIn...))
	}
	if i.ChannelIDIsNil {
		predicates = append(predicates, request.ChannelIDIsNil())
	}
	if i.ChannelIDNotNil {
		predicates = append(predicates, request.ChannelIDNotNil())
	}
	if i.ExternalID != nil {
		predicates = append(predicates, request.ExternalIDEQ(*i.ExternalID))
	}
	if i.ExternalIDNEQ != nil {
		predicates = append(predicates, request.ExternalIDNEQ(*i.ExternalIDNEQ))
	}
	if len(i.ExternalIDIn) > 0 {
		predicates = append(predicates, request.ExternalIDIn(i.ExternalIDIn...))
	}
	if len(i.ExternalIDNotIn) > 0 {
		predicates = append(predicates, request.ExternalIDNotIn(i.ExternalIDNotIn...))
	}
	if i.ExternalIDGT != nil {
		predicates = append(predicates, request.ExternalIDGT(*i.ExternalIDGT))
	}
	if i.ExternalIDGTE != nil {
		predicates = append(predicates, request.ExternalIDGTE(*i.ExternalIDGTE))
	}
	if i.ExternalIDLT != nil {
		predicates = append(predicates, request.ExternalIDLT(*i.ExternalIDLT))
	}
	if i.ExternalIDLTE != nil {
		predicates = append(predicates, request.ExternalIDLTE(*i.ExternalIDLTE))
	}
	if i.ExternalIDContains != nil {
		predicates = append(predicates, request.ExternalIDContains(*i.ExternalIDContains))
	}
	if i.ExternalIDHasPrefix != nil {
		predicates = append(predicates, request.ExternalIDHasPrefix(*i.ExternalIDHasPrefix))
	}
	if i.ExternalIDHasSuffix != nil {
		predicates = append(predicates, request.ExternalIDHasSuffix(*i.ExternalIDHasSuffix))
	}
	if i.ExternalIDIsNil {
		predicates = append(predicates, request.ExternalIDIsNil())
	}
	if i.ExternalIDNotNil {
		predicates = append(predicates, request.ExternalIDNotNil())
	}
	if i.ExternalIDEqualFold != nil {
		predicates = append(predicates, request.ExternalIDEqualFold(*i.ExternalIDEqualFold))
	}
	if i.ExternalIDContainsFold != nil {
		predicates = append(predicates, request.ExternalIDContainsFold(*i.ExternalIDContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, request.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, request.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, request.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, request.StatusNotIn(i.StatusNotIn...))
	}
	if i.Stream != nil {
		predicates = append(predicates, request.StreamEQ(*i.Stream))
	}
	if i.StreamNEQ != nil {
		predicates = append(predicates, request.StreamNEQ(*i.StreamNEQ))
	}

	if i.HasAPIKey != nil {
		p := request.HasAPIKey()
		if !*i.HasAPIKey {
			p = request.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAPIKeyWith) > 0 {
		with := make([]predicate.APIKey, 0, len(i.HasAPIKeyWith))
		for _, w := range i.HasAPIKeyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAPIKeyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, request.HasAPIKeyWith(with...))
	}
	if i.HasProject != nil {
		p := request.HasProject()
		if !*i.HasProject {
			p = request.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProjectWith) > 0 {
		with := make([]predicate.Project, 0, len(i.HasProjectWith))
		for _, w := range i.HasProjectWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProjectWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, request.HasProjectWith(with...))
	}
	if i.HasTrace != nil {
		p := request.HasTrace()
		if !*i.HasTrace {
			p = request.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTraceWith) > 0 {
		with := make([]predicate.Trace, 0, len(i.HasTraceWith))
		for _, w := range i.HasTraceWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTraceWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, request.HasTraceWith(with...))
	}
	if i.HasDataStorage != nil {
		p := request.HasDataStorage()
		if !*i.HasDataStorage {
			p = request.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDataStorageWith) > 0 {
		with := make([]predicate.DataStorage, 0, len(i.HasDataStorageWith))
		for _, w := range i.HasDataStorageWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDataStorageWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, request.HasDataStorageWith(with...))
	}
	if i.HasExecutions != nil {
		p := request.HasExecutions()
		if !*i.HasExecutions {
			p = request.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasExecutionsWith) > 0 {
		with := make([]predicate.RequestExecution, 0, len(i.HasExecutionsWith))
		for _, w := range i.HasExecutionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasExecutionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, request.HasExecutionsWith(with...))
	}
	if i.HasChannel != nil {
		p := request.HasChannel()
		if !*i.HasChannel {
			p = request.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasChannelWith) > 0 {
		with := make([]predicate.Channel, 0, len(i.HasChannelWith))
		for _, w := range i.HasChannelWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasChannelWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, request.HasChannelWith(with...))
	}
	if i.HasUsageLogs != nil {
		p := request.HasUsageLogs()
		if !*i.HasUsageLogs {
			p = request.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUsageLogsWith) > 0 {
		with := make([]predicate.UsageLog, 0, len(i.HasUsageLogsWith))
		for _, w := range i.HasUsageLogsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUsageLogsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, request.HasUsageLogsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyRequestWhereInput
	case 1:
		return predicates[0], nil
	default:
		return request.And(predicates...), nil
	}
}

// RequestExecutionWhereInput represents a where input for filtering RequestExecution queries.
type RequestExecutionWhereInput struct {
	Predicates []predicate.RequestExecution  `json:"-"`
	Not        *RequestExecutionWhereInput   `json:"not,omitempty"`
	Or         []*RequestExecutionWhereInput `json:"or,omitempty"`
	And        []*RequestExecutionWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "project_id" field predicates.
	ProjectID      *int  `json:"projectID,omitempty"`
	ProjectIDNEQ   *int  `json:"projectIDNEQ,omitempty"`
	ProjectIDIn    []int `json:"projectIDIn,omitempty"`
	ProjectIDNotIn []int `json:"projectIDNotIn,omitempty"`
	ProjectIDGT    *int  `json:"projectIDGT,omitempty"`
	ProjectIDGTE   *int  `json:"projectIDGTE,omitempty"`
	ProjectIDLT    *int  `json:"projectIDLT,omitempty"`
	ProjectIDLTE   *int  `json:"projectIDLTE,omitempty"`

	// "request_id" field predicates.
	RequestID      *int  `json:"requestID,omitempty"`
	RequestIDNEQ   *int  `json:"requestIDNEQ,omitempty"`
	RequestIDIn    []int `json:"requestIDIn,omitempty"`
	RequestIDNotIn []int `json:"requestIDNotIn,omitempty"`

	// "channel_id" field predicates.
	ChannelID       *int  `json:"channelID,omitempty"`
	ChannelIDNEQ    *int  `json:"channelIDNEQ,omitempty"`
	ChannelIDIn     []int `json:"channelIDIn,omitempty"`
	ChannelIDNotIn  []int `json:"channelIDNotIn,omitempty"`
	ChannelIDIsNil  bool  `json:"channelIDIsNil,omitempty"`
	ChannelIDNotNil bool  `json:"channelIDNotNil,omitempty"`

	// "data_storage_id" field predicates.
	DataStorageID       *int  `json:"dataStorageID,omitempty"`
	DataStorageIDNEQ    *int  `json:"dataStorageIDNEQ,omitempty"`
	DataStorageIDIn     []int `json:"dataStorageIDIn,omitempty"`
	DataStorageIDNotIn  []int `json:"dataStorageIDNotIn,omitempty"`
	DataStorageIDIsNil  bool  `json:"dataStorageIDIsNil,omitempty"`
	DataStorageIDNotNil bool  `json:"dataStorageIDNotNil,omitempty"`

	// "external_id" field predicates.
	ExternalID             *string  `json:"externalID,omitempty"`
	ExternalIDNEQ          *string  `json:"externalIDNEQ,omitempty"`
	ExternalIDIn           []string `json:"externalIDIn,omitempty"`
	ExternalIDNotIn        []string `json:"externalIDNotIn,omitempty"`
	ExternalIDGT           *string  `json:"externalIDGT,omitempty"`
	ExternalIDGTE          *string  `json:"externalIDGTE,omitempty"`
	ExternalIDLT           *string  `json:"externalIDLT,omitempty"`
	ExternalIDLTE          *string  `json:"externalIDLTE,omitempty"`
	ExternalIDContains     *string  `json:"externalIDContains,omitempty"`
	ExternalIDHasPrefix    *string  `json:"externalIDHasPrefix,omitempty"`
	ExternalIDHasSuffix    *string  `json:"externalIDHasSuffix,omitempty"`
	ExternalIDIsNil        bool     `json:"externalIDIsNil,omitempty"`
	ExternalIDNotNil       bool     `json:"externalIDNotNil,omitempty"`
	ExternalIDEqualFold    *string  `json:"externalIDEqualFold,omitempty"`
	ExternalIDContainsFold *string  `json:"externalIDContainsFold,omitempty"`

	// "model_id" field predicates.
	ModelID             *string  `json:"modelID,omitempty"`
	ModelIDNEQ          *string  `json:"modelIDNEQ,omitempty"`
	ModelIDIn           []string `json:"modelIDIn,omitempty"`
	ModelIDNotIn        []string `json:"modelIDNotIn,omitempty"`
	ModelIDGT           *string  `json:"modelIDGT,omitempty"`
	ModelIDGTE          *string  `json:"modelIDGTE,omitempty"`
	ModelIDLT           *string  `json:"modelIDLT,omitempty"`
	ModelIDLTE          *string  `json:"modelIDLTE,omitempty"`
	ModelIDContains     *string  `json:"modelIDContains,omitempty"`
	ModelIDHasPrefix    *string  `json:"modelIDHasPrefix,omitempty"`
	ModelIDHasSuffix    *string  `json:"modelIDHasSuffix,omitempty"`
	ModelIDEqualFold    *string  `json:"modelIDEqualFold,omitempty"`
	ModelIDContainsFold *string  `json:"modelIDContainsFold,omitempty"`

	// "format" field predicates.
	Format             *string  `json:"format,omitempty"`
	FormatNEQ          *string  `json:"formatNEQ,omitempty"`
	FormatIn           []string `json:"formatIn,omitempty"`
	FormatNotIn        []string `json:"formatNotIn,omitempty"`
	FormatGT           *string  `json:"formatGT,omitempty"`
	FormatGTE          *string  `json:"formatGTE,omitempty"`
	FormatLT           *string  `json:"formatLT,omitempty"`
	FormatLTE          *string  `json:"formatLTE,omitempty"`
	FormatContains     *string  `json:"formatContains,omitempty"`
	FormatHasPrefix    *string  `json:"formatHasPrefix,omitempty"`
	FormatHasSuffix    *string  `json:"formatHasSuffix,omitempty"`
	FormatEqualFold    *string  `json:"formatEqualFold,omitempty"`
	FormatContainsFold *string  `json:"formatContainsFold,omitempty"`

	// "error_message" field predicates.
	ErrorMessage             *string  `json:"errorMessage,omitempty"`
	ErrorMessageNEQ          *string  `json:"errorMessageNEQ,omitempty"`
	ErrorMessageIn           []string `json:"errorMessageIn,omitempty"`
	ErrorMessageNotIn        []string `json:"errorMessageNotIn,omitempty"`
	ErrorMessageGT           *string  `json:"errorMessageGT,omitempty"`
	ErrorMessageGTE          *string  `json:"errorMessageGTE,omitempty"`
	ErrorMessageLT           *string  `json:"errorMessageLT,omitempty"`
	ErrorMessageLTE          *string  `json:"errorMessageLTE,omitempty"`
	ErrorMessageContains     *string  `json:"errorMessageContains,omitempty"`
	ErrorMessageHasPrefix    *string  `json:"errorMessageHasPrefix,omitempty"`
	ErrorMessageHasSuffix    *string  `json:"errorMessageHasSuffix,omitempty"`
	ErrorMessageIsNil        bool     `json:"errorMessageIsNil,omitempty"`
	ErrorMessageNotNil       bool     `json:"errorMessageNotNil,omitempty"`
	ErrorMessageEqualFold    *string  `json:"errorMessageEqualFold,omitempty"`
	ErrorMessageContainsFold *string  `json:"errorMessageContainsFold,omitempty"`

	// "status" field predicates.
	Status      *requestexecution.Status  `json:"status,omitempty"`
	StatusNEQ   *requestexecution.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []requestexecution.Status `json:"statusIn,omitempty"`
	StatusNotIn []requestexecution.Status `json:"statusNotIn,omitempty"`

	// "request" edge predicates.
	HasRequest     *bool                `json:"hasRequest,omitempty"`
	HasRequestWith []*RequestWhereInput `json:"hasRequestWith,omitempty"`

	// "channel" edge predicates.
	HasChannel     *bool                `json:"hasChannel,omitempty"`
	HasChannelWith []*ChannelWhereInput `json:"hasChannelWith,omitempty"`

	// "data_storage" edge predicates.
	HasDataStorage     *bool                    `json:"hasDataStorage,omitempty"`
	HasDataStorageWith []*DataStorageWhereInput `json:"hasDataStorageWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *RequestExecutionWhereInput) AddPredicates(predicates ...predicate.RequestExecution) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the RequestExecutionWhereInput filter on the RequestExecutionQuery builder.
func (i *RequestExecutionWhereInput) Filter(q *RequestExecutionQuery) (*RequestExecutionQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyRequestExecutionWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyRequestExecutionWhereInput is returned in case the RequestExecutionWhereInput is empty.
var ErrEmptyRequestExecutionWhereInput = errors.New("ent: empty predicate RequestExecutionWhereInput")

// P returns a predicate for filtering requestexecutions.
// An error is returned if the input is empty or invalid.
func (i *RequestExecutionWhereInput) P() (predicate.RequestExecution, error) {
	var predicates []predicate.RequestExecution
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, requestexecution.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.RequestExecution, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, requestexecution.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.RequestExecution, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, requestexecution.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, requestexecution.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, requestexecution.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, requestexecution.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, requestexecution.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, requestexecution.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, requestexecution.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, requestexecution.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, requestexecution.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, requestexecution.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, requestexecution.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, requestexecution.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, requestexecution.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, requestexecution.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, requestexecution.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, requestexecution.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, requestexecution.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, requestexecution.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, requestexecution.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, requestexecution.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, requestexecution.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, requestexecution.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, requestexecution.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, requestexecution.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, requestexecution.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.ProjectID != nil {
		predicates = append(predicates, requestexecution.ProjectIDEQ(*i.ProjectID))
	}
	if i.ProjectIDNEQ != nil {
		predicates = append(predicates, requestexecution.ProjectIDNEQ(*i.ProjectIDNEQ))
	}
	if len(i.ProjectIDIn) > 0 {
		predicates = append(predicates, requestexecution.ProjectIDIn(i.ProjectIDIn...))
	}
	if len(i.ProjectIDNotIn) > 0 {
		predicates = append(predicates, requestexecution.ProjectIDNotIn(i.ProjectIDNotIn...))
	}
	if i.ProjectIDGT != nil {
		predicates = append(predicates, requestexecution.ProjectIDGT(*i.ProjectIDGT))
	}
	if i.ProjectIDGTE != nil {
		predicates = append(predicates, requestexecution.ProjectIDGTE(*i.ProjectIDGTE))
	}
	if i.ProjectIDLT != nil {
		predicates = append(predicates, requestexecution.ProjectIDLT(*i.ProjectIDLT))
	}
	if i.ProjectIDLTE != nil {
		predicates = append(predicates, requestexecution.ProjectIDLTE(*i.ProjectIDLTE))
	}
	if i.RequestID != nil {
		predicates = append(predicates, requestexecution.RequestIDEQ(*i.RequestID))
	}
	if i.RequestIDNEQ != nil {
		predicates = append(predicates, requestexecution.RequestIDNEQ(*i.RequestIDNEQ))
	}
	if len(i.RequestIDIn) > 0 {
		predicates = append(predicates, requestexecution.RequestIDIn(i.RequestIDIn...))
	}
	if len(i.RequestIDNotIn) > 0 {
		predicates = append(predicates, requestexecution.RequestIDNotIn(i.RequestIDNotIn...))
	}
	if i.ChannelID != nil {
		predicates = append(predicates, requestexecution.ChannelIDEQ(*i.ChannelID))
	}
	if i.ChannelIDNEQ != nil {
		predicates = append(predicates, requestexecution.ChannelIDNEQ(*i.ChannelIDNEQ))
	}
	if len(i.ChannelIDIn) > 0 {
		predicates = append(predicates, requestexecution.ChannelIDIn(i.ChannelIDIn...))
	}
	if len(i.ChannelIDNotIn) > 0 {
		predicates = append(predicates, requestexecution.ChannelIDNotIn(i.ChannelIDNotIn...))
	}
	if i.ChannelIDIsNil {
		predicates = append(predicates, requestexecution.ChannelIDIsNil())
	}
	if i.ChannelIDNotNil {
		predicates = append(predicates, requestexecution.ChannelIDNotNil())
	}
	if i.DataStorageID != nil {
		predicates = append(predicates, requestexecution.DataStorageIDEQ(*i.DataStorageID))
	}
	if i.DataStorageIDNEQ != nil {
		predicates = append(predicates, requestexecution.DataStorageIDNEQ(*i.DataStorageIDNEQ))
	}
	if len(i.DataStorageIDIn) > 0 {
		predicates = append(predicates, requestexecution.DataStorageIDIn(i.DataStorageIDIn...))
	}
	if len(i.DataStorageIDNotIn) > 0 {
		predicates = append(predicates, requestexecution.DataStorageIDNotIn(i.DataStorageIDNotIn...))
	}
	if i.DataStorageIDIsNil {
		predicates = append(predicates, requestexecution.DataStorageIDIsNil())
	}
	if i.DataStorageIDNotNil {
		predicates = append(predicates, requestexecution.DataStorageIDNotNil())
	}
	if i.ExternalID != nil {
		predicates = append(predicates, requestexecution.ExternalIDEQ(*i.ExternalID))
	}
	if i.ExternalIDNEQ != nil {
		predicates = append(predicates, requestexecution.ExternalIDNEQ(*i.ExternalIDNEQ))
	}
	if len(i.ExternalIDIn) > 0 {
		predicates = append(predicates, requestexecution.ExternalIDIn(i.ExternalIDIn...))
	}
	if len(i.ExternalIDNotIn) > 0 {
		predicates = append(predicates, requestexecution.ExternalIDNotIn(i.ExternalIDNotIn...))
	}
	if i.ExternalIDGT != nil {
		predicates = append(predicates, requestexecution.ExternalIDGT(*i.ExternalIDGT))
	}
	if i.ExternalIDGTE != nil {
		predicates = append(predicates, requestexecution.ExternalIDGTE(*i.ExternalIDGTE))
	}
	if i.ExternalIDLT != nil {
		predicates = append(predicates, requestexecution.ExternalIDLT(*i.ExternalIDLT))
	}
	if i.ExternalIDLTE != nil {
		predicates = append(predicates, requestexecution.ExternalIDLTE(*i.ExternalIDLTE))
	}
	if i.ExternalIDContains != nil {
		predicates = append(predicates, requestexecution.ExternalIDContains(*i.ExternalIDContains))
	}
	if i.ExternalIDHasPrefix != nil {
		predicates = append(predicates, requestexecution.ExternalIDHasPrefix(*i.ExternalIDHasPrefix))
	}
	if i.ExternalIDHasSuffix != nil {
		predicates = append(predicates, requestexecution.ExternalIDHasSuffix(*i.ExternalIDHasSuffix))
	}
	if i.ExternalIDIsNil {
		predicates = append(predicates, requestexecution.ExternalIDIsNil())
	}
	if i.ExternalIDNotNil {
		predicates = append(predicates, requestexecution.ExternalIDNotNil())
	}
	if i.ExternalIDEqualFold != nil {
		predicates = append(predicates, requestexecution.ExternalIDEqualFold(*i.ExternalIDEqualFold))
	}
	if i.ExternalIDContainsFold != nil {
		predicates = append(predicates, requestexecution.ExternalIDContainsFold(*i.ExternalIDContainsFold))
	}
	if i.ModelID != nil {
		predicates = append(predicates, requestexecution.ModelIDEQ(*i.ModelID))
	}
	if i.ModelIDNEQ != nil {
		predicates = append(predicates, requestexecution.ModelIDNEQ(*i.ModelIDNEQ))
	}
	if len(i.ModelIDIn) > 0 {
		predicates = append(predicates, requestexecution.ModelIDIn(i.ModelIDIn...))
	}
	if len(i.ModelIDNotIn) > 0 {
		predicates = append(predicates, requestexecution.ModelIDNotIn(i.ModelIDNotIn...))
	}
	if i.ModelIDGT != nil {
		predicates = append(predicates, requestexecution.ModelIDGT(*i.ModelIDGT))
	}
	if i.ModelIDGTE != nil {
		predicates = append(predicates, requestexecution.ModelIDGTE(*i.ModelIDGTE))
	}
	if i.ModelIDLT != nil {
		predicates = append(predicates, requestexecution.ModelIDLT(*i.ModelIDLT))
	}
	if i.ModelIDLTE != nil {
		predicates = append(predicates, requestexecution.ModelIDLTE(*i.ModelIDLTE))
	}
	if i.ModelIDContains != nil {
		predicates = append(predicates, requestexecution.ModelIDContains(*i.ModelIDContains))
	}
	if i.ModelIDHasPrefix != nil {
		predicates = append(predicates, requestexecution.ModelIDHasPrefix(*i.ModelIDHasPrefix))
	}
	if i.ModelIDHasSuffix != nil {
		predicates = append(predicates, requestexecution.ModelIDHasSuffix(*i.ModelIDHasSuffix))
	}
	if i.ModelIDEqualFold != nil {
		predicates = append(predicates, requestexecution.ModelIDEqualFold(*i.ModelIDEqualFold))
	}
	if i.ModelIDContainsFold != nil {
		predicates = append(predicates, requestexecution.ModelIDContainsFold(*i.ModelIDContainsFold))
	}
	if i.Format != nil {
		predicates = append(predicates, requestexecution.FormatEQ(*i.Format))
	}
	if i.FormatNEQ != nil {
		predicates = append(predicates, requestexecution.FormatNEQ(*i.FormatNEQ))
	}
	if len(i.FormatIn) > 0 {
		predicates = append(predicates, requestexecution.FormatIn(i.FormatIn...))
	}
	if len(i.FormatNotIn) > 0 {
		predicates = append(predicates, requestexecution.FormatNotIn(i.FormatNotIn...))
	}
	if i.FormatGT != nil {
		predicates = append(predicates, requestexecution.FormatGT(*i.FormatGT))
	}
	if i.FormatGTE != nil {
		predicates = append(predicates, requestexecution.FormatGTE(*i.FormatGTE))
	}
	if i.FormatLT != nil {
		predicates = append(predicates, requestexecution.FormatLT(*i.FormatLT))
	}
	if i.FormatLTE != nil {
		predicates = append(predicates, requestexecution.FormatLTE(*i.FormatLTE))
	}
	if i.FormatContains != nil {
		predicates = append(predicates, requestexecution.FormatContains(*i.FormatContains))
	}
	if i.FormatHasPrefix != nil {
		predicates = append(predicates, requestexecution.FormatHasPrefix(*i.FormatHasPrefix))
	}
	if i.FormatHasSuffix != nil {
		predicates = append(predicates, requestexecution.FormatHasSuffix(*i.FormatHasSuffix))
	}
	if i.FormatEqualFold != nil {
		predicates = append(predicates, requestexecution.FormatEqualFold(*i.FormatEqualFold))
	}
	if i.FormatContainsFold != nil {
		predicates = append(predicates, requestexecution.FormatContainsFold(*i.FormatContainsFold))
	}
	if i.ErrorMessage != nil {
		predicates = append(predicates, requestexecution.ErrorMessageEQ(*i.ErrorMessage))
	}
	if i.ErrorMessageNEQ != nil {
		predicates = append(predicates, requestexecution.ErrorMessageNEQ(*i.ErrorMessageNEQ))
	}
	if len(i.ErrorMessageIn) > 0 {
		predicates = append(predicates, requestexecution.ErrorMessageIn(i.ErrorMessageIn...))
	}
	if len(i.ErrorMessageNotIn) > 0 {
		predicates = append(predicates, requestexecution.ErrorMessageNotIn(i.ErrorMessageNotIn...))
	}
	if i.ErrorMessageGT != nil {
		predicates = append(predicates, requestexecution.ErrorMessageGT(*i.ErrorMessageGT))
	}
	if i.ErrorMessageGTE != nil {
		predicates = append(predicates, requestexecution.ErrorMessageGTE(*i.ErrorMessageGTE))
	}
	if i.ErrorMessageLT != nil {
		predicates = append(predicates, requestexecution.ErrorMessageLT(*i.ErrorMessageLT))
	}
	if i.ErrorMessageLTE != nil {
		predicates = append(predicates, requestexecution.ErrorMessageLTE(*i.ErrorMessageLTE))
	}
	if i.ErrorMessageContains != nil {
		predicates = append(predicates, requestexecution.ErrorMessageContains(*i.ErrorMessageContains))
	}
	if i.ErrorMessageHasPrefix != nil {
		predicates = append(predicates, requestexecution.ErrorMessageHasPrefix(*i.ErrorMessageHasPrefix))
	}
	if i.ErrorMessageHasSuffix != nil {
		predicates = append(predicates, requestexecution.ErrorMessageHasSuffix(*i.ErrorMessageHasSuffix))
	}
	if i.ErrorMessageIsNil {
		predicates = append(predicates, requestexecution.ErrorMessageIsNil())
	}
	if i.ErrorMessageNotNil {
		predicates = append(predicates, requestexecution.ErrorMessageNotNil())
	}
	if i.ErrorMessageEqualFold != nil {
		predicates = append(predicates, requestexecution.ErrorMessageEqualFold(*i.ErrorMessageEqualFold))
	}
	if i.ErrorMessageContainsFold != nil {
		predicates = append(predicates, requestexecution.ErrorMessageContainsFold(*i.ErrorMessageContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, requestexecution.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, requestexecution.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, requestexecution.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, requestexecution.StatusNotIn(i.StatusNotIn...))
	}

	if i.HasRequest != nil {
		p := requestexecution.HasRequest()
		if !*i.HasRequest {
			p = requestexecution.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRequestWith) > 0 {
		with := make([]predicate.Request, 0, len(i.HasRequestWith))
		for _, w := range i.HasRequestWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRequestWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, requestexecution.HasRequestWith(with...))
	}
	if i.HasChannel != nil {
		p := requestexecution.HasChannel()
		if !*i.HasChannel {
			p = requestexecution.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasChannelWith) > 0 {
		with := make([]predicate.Channel, 0, len(i.HasChannelWith))
		for _, w := range i.HasChannelWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasChannelWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, requestexecution.HasChannelWith(with...))
	}
	if i.HasDataStorage != nil {
		p := requestexecution.HasDataStorage()
		if !*i.HasDataStorage {
			p = requestexecution.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDataStorageWith) > 0 {
		with := make([]predicate.DataStorage, 0, len(i.HasDataStorageWith))
		for _, w := range i.HasDataStorageWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDataStorageWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, requestexecution.HasDataStorageWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyRequestExecutionWhereInput
	case 1:
		return predicates[0], nil
	default:
		return requestexecution.And(predicates...), nil
	}
}

// RoleWhereInput represents a where input for filtering Role queries.
type RoleWhereInput struct {
	Predicates []predicate.Role  `json:"-"`
	Not        *RoleWhereInput   `json:"not,omitempty"`
	Or         []*RoleWhereInput `json:"or,omitempty"`
	And        []*RoleWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt      *int  `json:"deletedAt,omitempty"`
	DeletedAtNEQ   *int  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn    []int `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn []int `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT    *int  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE   *int  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT    *int  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE   *int  `json:"deletedAtLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "level" field predicates.
	Level      *role.Level  `json:"level,omitempty"`
	LevelNEQ   *role.Level  `json:"levelNEQ,omitempty"`
	LevelIn    []role.Level `json:"levelIn,omitempty"`
	LevelNotIn []role.Level `json:"levelNotIn,omitempty"`

	// "project_id" field predicates.
	ProjectID       *int  `json:"projectID,omitempty"`
	ProjectIDNEQ    *int  `json:"projectIDNEQ,omitempty"`
	ProjectIDIn     []int `json:"projectIDIn,omitempty"`
	ProjectIDNotIn  []int `json:"projectIDNotIn,omitempty"`
	ProjectIDIsNil  bool  `json:"projectIDIsNil,omitempty"`
	ProjectIDNotNil bool  `json:"projectIDNotNil,omitempty"`

	// "users" edge predicates.
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`

	// "project" edge predicates.
	HasProject     *bool                `json:"hasProject,omitempty"`
	HasProjectWith []*ProjectWhereInput `json:"hasProjectWith,omitempty"`

	// "user_roles" edge predicates.
	HasUserRoles     *bool                 `json:"hasUserRoles,omitempty"`
	HasUserRolesWith []*UserRoleWhereInput `json:"hasUserRolesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *RoleWhereInput) AddPredicates(predicates ...predicate.Role) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the RoleWhereInput filter on the RoleQuery builder.
func (i *RoleWhereInput) Filter(q *RoleQuery) (*RoleQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyRoleWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyRoleWhereInput is returned in case the RoleWhereInput is empty.
var ErrEmptyRoleWhereInput = errors.New("ent: empty predicate RoleWhereInput")

// P returns a predicate for filtering roles.
// An error is returned if the input is empty or invalid.
func (i *RoleWhereInput) P() (predicate.Role, error) {
	var predicates []predicate.Role
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, role.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Role, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, role.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Role, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, role.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, role.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, role.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, role.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, role.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, role.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, role.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, role.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, role.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, role.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, role.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, role.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, role.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, role.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, role.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, role.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, role.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, role.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, role.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, role.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, role.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, role.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, role.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, role.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, role.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, role.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, role.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, role.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, role.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, role.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, role.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, role.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, role.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, role.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, role.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, role.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, role.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, role.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, role.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, role.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, role.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, role.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, role.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, role.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, role.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, role.NameContainsFold(*i.NameContainsFold))
	}
	if i.Level != nil {
		predicates = append(predicates, role.LevelEQ(*i.Level))
	}
	if i.LevelNEQ != nil {
		predicates = append(predicates, role.LevelNEQ(*i.LevelNEQ))
	}
	if len(i.LevelIn) > 0 {
		predicates = append(predicates, role.LevelIn(i.LevelIn...))
	}
	if len(i.LevelNotIn) > 0 {
		predicates = append(predicates, role.LevelNotIn(i.LevelNotIn...))
	}
	if i.ProjectID != nil {
		predicates = append(predicates, role.ProjectIDEQ(*i.ProjectID))
	}
	if i.ProjectIDNEQ != nil {
		predicates = append(predicates, role.ProjectIDNEQ(*i.ProjectIDNEQ))
	}
	if len(i.ProjectIDIn) > 0 {
		predicates = append(predicates, role.ProjectIDIn(i.ProjectIDIn...))
	}
	if len(i.ProjectIDNotIn) > 0 {
		predicates = append(predicates, role.ProjectIDNotIn(i.ProjectIDNotIn...))
	}
	if i.ProjectIDIsNil {
		predicates = append(predicates, role.ProjectIDIsNil())
	}
	if i.ProjectIDNotNil {
		predicates = append(predicates, role.ProjectIDNotNil())
	}

	if i.HasUsers != nil {
		p := role.HasUsers()
		if !*i.HasUsers {
			p = role.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUsersWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUsersWith))
		for _, w := range i.HasUsersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUsersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, role.HasUsersWith(with...))
	}
	if i.HasProject != nil {
		p := role.HasProject()
		if !*i.HasProject {
			p = role.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProjectWith) > 0 {
		with := make([]predicate.Project, 0, len(i.HasProjectWith))
		for _, w := range i.HasProjectWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProjectWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, role.HasProjectWith(with...))
	}
	if i.HasUserRoles != nil {
		p := role.HasUserRoles()
		if !*i.HasUserRoles {
			p = role.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserRolesWith) > 0 {
		with := make([]predicate.UserRole, 0, len(i.HasUserRolesWith))
		for _, w := range i.HasUserRolesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserRolesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, role.HasUserRolesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyRoleWhereInput
	case 1:
		return predicates[0], nil
	default:
		return role.And(predicates...), nil
	}
}

// SystemWhereInput represents a where input for filtering System queries.
type SystemWhereInput struct {
	Predicates []predicate.System  `json:"-"`
	Not        *SystemWhereInput   `json:"not,omitempty"`
	Or         []*SystemWhereInput `json:"or,omitempty"`
	And        []*SystemWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt      *int  `json:"deletedAt,omitempty"`
	DeletedAtNEQ   *int  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn    []int `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn []int `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT    *int  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE   *int  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT    *int  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE   *int  `json:"deletedAtLTE,omitempty"`

	// "key" field predicates.
	Key             *string  `json:"key,omitempty"`
	KeyNEQ          *string  `json:"keyNEQ,omitempty"`
	KeyIn           []string `json:"keyIn,omitempty"`
	KeyNotIn        []string `json:"keyNotIn,omitempty"`
	KeyGT           *string  `json:"keyGT,omitempty"`
	KeyGTE          *string  `json:"keyGTE,omitempty"`
	KeyLT           *string  `json:"keyLT,omitempty"`
	KeyLTE          *string  `json:"keyLTE,omitempty"`
	KeyContains     *string  `json:"keyContains,omitempty"`
	KeyHasPrefix    *string  `json:"keyHasPrefix,omitempty"`
	KeyHasSuffix    *string  `json:"keyHasSuffix,omitempty"`
	KeyEqualFold    *string  `json:"keyEqualFold,omitempty"`
	KeyContainsFold *string  `json:"keyContainsFold,omitempty"`

	// "value" field predicates.
	Value             *string  `json:"value,omitempty"`
	ValueNEQ          *string  `json:"valueNEQ,omitempty"`
	ValueIn           []string `json:"valueIn,omitempty"`
	ValueNotIn        []string `json:"valueNotIn,omitempty"`
	ValueGT           *string  `json:"valueGT,omitempty"`
	ValueGTE          *string  `json:"valueGTE,omitempty"`
	ValueLT           *string  `json:"valueLT,omitempty"`
	ValueLTE          *string  `json:"valueLTE,omitempty"`
	ValueContains     *string  `json:"valueContains,omitempty"`
	ValueHasPrefix    *string  `json:"valueHasPrefix,omitempty"`
	ValueHasSuffix    *string  `json:"valueHasSuffix,omitempty"`
	ValueEqualFold    *string  `json:"valueEqualFold,omitempty"`
	ValueContainsFold *string  `json:"valueContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *SystemWhereInput) AddPredicates(predicates ...predicate.System) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the SystemWhereInput filter on the SystemQuery builder.
func (i *SystemWhereInput) Filter(q *SystemQuery) (*SystemQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptySystemWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptySystemWhereInput is returned in case the SystemWhereInput is empty.
var ErrEmptySystemWhereInput = errors.New("ent: empty predicate SystemWhereInput")

// P returns a predicate for filtering systems.
// An error is returned if the input is empty or invalid.
func (i *SystemWhereInput) P() (predicate.System, error) {
	var predicates []predicate.System
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, system.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.System, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, system.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.System, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, system.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, system.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, system.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, system.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, system.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, system.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, system.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, system.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, system.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, system.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, system.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, system.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, system.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, system.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, system.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, system.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, system.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, system.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, system.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, system.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, system.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, system.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, system.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, system.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, system.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, system.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, system.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, system.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, system.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, system.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, system.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, system.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, system.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.Key != nil {
		predicates = append(predicates, system.KeyEQ(*i.Key))
	}
	if i.KeyNEQ != nil {
		predicates = append(predicates, system.KeyNEQ(*i.KeyNEQ))
	}
	if len(i.KeyIn) > 0 {
		predicates = append(predicates, system.KeyIn(i.KeyIn...))
	}
	if len(i.KeyNotIn) > 0 {
		predicates = append(predicates, system.KeyNotIn(i.KeyNotIn...))
	}
	if i.KeyGT != nil {
		predicates = append(predicates, system.KeyGT(*i.KeyGT))
	}
	if i.KeyGTE != nil {
		predicates = append(predicates, system.KeyGTE(*i.KeyGTE))
	}
	if i.KeyLT != nil {
		predicates = append(predicates, system.KeyLT(*i.KeyLT))
	}
	if i.KeyLTE != nil {
		predicates = append(predicates, system.KeyLTE(*i.KeyLTE))
	}
	if i.KeyContains != nil {
		predicates = append(predicates, system.KeyContains(*i.KeyContains))
	}
	if i.KeyHasPrefix != nil {
		predicates = append(predicates, system.KeyHasPrefix(*i.KeyHasPrefix))
	}
	if i.KeyHasSuffix != nil {
		predicates = append(predicates, system.KeyHasSuffix(*i.KeyHasSuffix))
	}
	if i.KeyEqualFold != nil {
		predicates = append(predicates, system.KeyEqualFold(*i.KeyEqualFold))
	}
	if i.KeyContainsFold != nil {
		predicates = append(predicates, system.KeyContainsFold(*i.KeyContainsFold))
	}
	if i.Value != nil {
		predicates = append(predicates, system.ValueEQ(*i.Value))
	}
	if i.ValueNEQ != nil {
		predicates = append(predicates, system.ValueNEQ(*i.ValueNEQ))
	}
	if len(i.ValueIn) > 0 {
		predicates = append(predicates, system.ValueIn(i.ValueIn...))
	}
	if len(i.ValueNotIn) > 0 {
		predicates = append(predicates, system.ValueNotIn(i.ValueNotIn...))
	}
	if i.ValueGT != nil {
		predicates = append(predicates, system.ValueGT(*i.ValueGT))
	}
	if i.ValueGTE != nil {
		predicates = append(predicates, system.ValueGTE(*i.ValueGTE))
	}
	if i.ValueLT != nil {
		predicates = append(predicates, system.ValueLT(*i.ValueLT))
	}
	if i.ValueLTE != nil {
		predicates = append(predicates, system.ValueLTE(*i.ValueLTE))
	}
	if i.ValueContains != nil {
		predicates = append(predicates, system.ValueContains(*i.ValueContains))
	}
	if i.ValueHasPrefix != nil {
		predicates = append(predicates, system.ValueHasPrefix(*i.ValueHasPrefix))
	}
	if i.ValueHasSuffix != nil {
		predicates = append(predicates, system.ValueHasSuffix(*i.ValueHasSuffix))
	}
	if i.ValueEqualFold != nil {
		predicates = append(predicates, system.ValueEqualFold(*i.ValueEqualFold))
	}
	if i.ValueContainsFold != nil {
		predicates = append(predicates, system.ValueContainsFold(*i.ValueContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptySystemWhereInput
	case 1:
		return predicates[0], nil
	default:
		return system.And(predicates...), nil
	}
}

// ThreadWhereInput represents a where input for filtering Thread queries.
type ThreadWhereInput struct {
	Predicates []predicate.Thread  `json:"-"`
	Not        *ThreadWhereInput   `json:"not,omitempty"`
	Or         []*ThreadWhereInput `json:"or,omitempty"`
	And        []*ThreadWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "project_id" field predicates.
	ProjectID      *int  `json:"projectID,omitempty"`
	ProjectIDNEQ   *int  `json:"projectIDNEQ,omitempty"`
	ProjectIDIn    []int `json:"projectIDIn,omitempty"`
	ProjectIDNotIn []int `json:"projectIDNotIn,omitempty"`

	// "thread_id" field predicates.
	ThreadID             *string  `json:"threadID,omitempty"`
	ThreadIDNEQ          *string  `json:"threadIDNEQ,omitempty"`
	ThreadIDIn           []string `json:"threadIDIn,omitempty"`
	ThreadIDNotIn        []string `json:"threadIDNotIn,omitempty"`
	ThreadIDGT           *string  `json:"threadIDGT,omitempty"`
	ThreadIDGTE          *string  `json:"threadIDGTE,omitempty"`
	ThreadIDLT           *string  `json:"threadIDLT,omitempty"`
	ThreadIDLTE          *string  `json:"threadIDLTE,omitempty"`
	ThreadIDContains     *string  `json:"threadIDContains,omitempty"`
	ThreadIDHasPrefix    *string  `json:"threadIDHasPrefix,omitempty"`
	ThreadIDHasSuffix    *string  `json:"threadIDHasSuffix,omitempty"`
	ThreadIDEqualFold    *string  `json:"threadIDEqualFold,omitempty"`
	ThreadIDContainsFold *string  `json:"threadIDContainsFold,omitempty"`

	// "project" edge predicates.
	HasProject     *bool                `json:"hasProject,omitempty"`
	HasProjectWith []*ProjectWhereInput `json:"hasProjectWith,omitempty"`

	// "traces" edge predicates.
	HasTraces     *bool              `json:"hasTraces,omitempty"`
	HasTracesWith []*TraceWhereInput `json:"hasTracesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ThreadWhereInput) AddPredicates(predicates ...predicate.Thread) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ThreadWhereInput filter on the ThreadQuery builder.
func (i *ThreadWhereInput) Filter(q *ThreadQuery) (*ThreadQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyThreadWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyThreadWhereInput is returned in case the ThreadWhereInput is empty.
var ErrEmptyThreadWhereInput = errors.New("ent: empty predicate ThreadWhereInput")

// P returns a predicate for filtering threads.
// An error is returned if the input is empty or invalid.
func (i *ThreadWhereInput) P() (predicate.Thread, error) {
	var predicates []predicate.Thread
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, thread.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Thread, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, thread.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Thread, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, thread.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, thread.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, thread.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, thread.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, thread.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, thread.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, thread.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, thread.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, thread.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, thread.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, thread.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, thread.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, thread.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, thread.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, thread.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, thread.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, thread.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, thread.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, thread.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, thread.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, thread.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, thread.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, thread.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, thread.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, thread.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.ProjectID != nil {
		predicates = append(predicates, thread.ProjectIDEQ(*i.ProjectID))
	}
	if i.ProjectIDNEQ != nil {
		predicates = append(predicates, thread.ProjectIDNEQ(*i.ProjectIDNEQ))
	}
	if len(i.ProjectIDIn) > 0 {
		predicates = append(predicates, thread.ProjectIDIn(i.ProjectIDIn...))
	}
	if len(i.ProjectIDNotIn) > 0 {
		predicates = append(predicates, thread.ProjectIDNotIn(i.ProjectIDNotIn...))
	}
	if i.ThreadID != nil {
		predicates = append(predicates, thread.ThreadIDEQ(*i.ThreadID))
	}
	if i.ThreadIDNEQ != nil {
		predicates = append(predicates, thread.ThreadIDNEQ(*i.ThreadIDNEQ))
	}
	if len(i.ThreadIDIn) > 0 {
		predicates = append(predicates, thread.ThreadIDIn(i.ThreadIDIn...))
	}
	if len(i.ThreadIDNotIn) > 0 {
		predicates = append(predicates, thread.ThreadIDNotIn(i.ThreadIDNotIn...))
	}
	if i.ThreadIDGT != nil {
		predicates = append(predicates, thread.ThreadIDGT(*i.ThreadIDGT))
	}
	if i.ThreadIDGTE != nil {
		predicates = append(predicates, thread.ThreadIDGTE(*i.ThreadIDGTE))
	}
	if i.ThreadIDLT != nil {
		predicates = append(predicates, thread.ThreadIDLT(*i.ThreadIDLT))
	}
	if i.ThreadIDLTE != nil {
		predicates = append(predicates, thread.ThreadIDLTE(*i.ThreadIDLTE))
	}
	if i.ThreadIDContains != nil {
		predicates = append(predicates, thread.ThreadIDContains(*i.ThreadIDContains))
	}
	if i.ThreadIDHasPrefix != nil {
		predicates = append(predicates, thread.ThreadIDHasPrefix(*i.ThreadIDHasPrefix))
	}
	if i.ThreadIDHasSuffix != nil {
		predicates = append(predicates, thread.ThreadIDHasSuffix(*i.ThreadIDHasSuffix))
	}
	if i.ThreadIDEqualFold != nil {
		predicates = append(predicates, thread.ThreadIDEqualFold(*i.ThreadIDEqualFold))
	}
	if i.ThreadIDContainsFold != nil {
		predicates = append(predicates, thread.ThreadIDContainsFold(*i.ThreadIDContainsFold))
	}

	if i.HasProject != nil {
		p := thread.HasProject()
		if !*i.HasProject {
			p = thread.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProjectWith) > 0 {
		with := make([]predicate.Project, 0, len(i.HasProjectWith))
		for _, w := range i.HasProjectWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProjectWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, thread.HasProjectWith(with...))
	}
	if i.HasTraces != nil {
		p := thread.HasTraces()
		if !*i.HasTraces {
			p = thread.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTracesWith) > 0 {
		with := make([]predicate.Trace, 0, len(i.HasTracesWith))
		for _, w := range i.HasTracesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTracesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, thread.HasTracesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyThreadWhereInput
	case 1:
		return predicates[0], nil
	default:
		return thread.And(predicates...), nil
	}
}

// TraceWhereInput represents a where input for filtering Trace queries.
type TraceWhereInput struct {
	Predicates []predicate.Trace  `json:"-"`
	Not        *TraceWhereInput   `json:"not,omitempty"`
	Or         []*TraceWhereInput `json:"or,omitempty"`
	And        []*TraceWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "project_id" field predicates.
	ProjectID      *int  `json:"projectID,omitempty"`
	ProjectIDNEQ   *int  `json:"projectIDNEQ,omitempty"`
	ProjectIDIn    []int `json:"projectIDIn,omitempty"`
	ProjectIDNotIn []int `json:"projectIDNotIn,omitempty"`

	// "trace_id" field predicates.
	TraceID             *string  `json:"traceID,omitempty"`
	TraceIDNEQ          *string  `json:"traceIDNEQ,omitempty"`
	TraceIDIn           []string `json:"traceIDIn,omitempty"`
	TraceIDNotIn        []string `json:"traceIDNotIn,omitempty"`
	TraceIDGT           *string  `json:"traceIDGT,omitempty"`
	TraceIDGTE          *string  `json:"traceIDGTE,omitempty"`
	TraceIDLT           *string  `json:"traceIDLT,omitempty"`
	TraceIDLTE          *string  `json:"traceIDLTE,omitempty"`
	TraceIDContains     *string  `json:"traceIDContains,omitempty"`
	TraceIDHasPrefix    *string  `json:"traceIDHasPrefix,omitempty"`
	TraceIDHasSuffix    *string  `json:"traceIDHasSuffix,omitempty"`
	TraceIDEqualFold    *string  `json:"traceIDEqualFold,omitempty"`
	TraceIDContainsFold *string  `json:"traceIDContainsFold,omitempty"`

	// "thread_id" field predicates.
	ThreadID       *int  `json:"threadID,omitempty"`
	ThreadIDNEQ    *int  `json:"threadIDNEQ,omitempty"`
	ThreadIDIn     []int `json:"threadIDIn,omitempty"`
	ThreadIDNotIn  []int `json:"threadIDNotIn,omitempty"`
	ThreadIDIsNil  bool  `json:"threadIDIsNil,omitempty"`
	ThreadIDNotNil bool  `json:"threadIDNotNil,omitempty"`

	// "project" edge predicates.
	HasProject     *bool                `json:"hasProject,omitempty"`
	HasProjectWith []*ProjectWhereInput `json:"hasProjectWith,omitempty"`

	// "thread" edge predicates.
	HasThread     *bool               `json:"hasThread,omitempty"`
	HasThreadWith []*ThreadWhereInput `json:"hasThreadWith,omitempty"`

	// "requests" edge predicates.
	HasRequests     *bool                `json:"hasRequests,omitempty"`
	HasRequestsWith []*RequestWhereInput `json:"hasRequestsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *TraceWhereInput) AddPredicates(predicates ...predicate.Trace) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the TraceWhereInput filter on the TraceQuery builder.
func (i *TraceWhereInput) Filter(q *TraceQuery) (*TraceQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyTraceWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyTraceWhereInput is returned in case the TraceWhereInput is empty.
var ErrEmptyTraceWhereInput = errors.New("ent: empty predicate TraceWhereInput")

// P returns a predicate for filtering traces.
// An error is returned if the input is empty or invalid.
func (i *TraceWhereInput) P() (predicate.Trace, error) {
	var predicates []predicate.Trace
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, trace.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Trace, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, trace.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Trace, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, trace.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, trace.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, trace.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, trace.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, trace.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, trace.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, trace.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, trace.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, trace.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, trace.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, trace.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, trace.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, trace.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, trace.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, trace.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, trace.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, trace.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, trace.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, trace.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, trace.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, trace.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, trace.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, trace.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, trace.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, trace.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.ProjectID != nil {
		predicates = append(predicates, trace.ProjectIDEQ(*i.ProjectID))
	}
	if i.ProjectIDNEQ != nil {
		predicates = append(predicates, trace.ProjectIDNEQ(*i.ProjectIDNEQ))
	}
	if len(i.ProjectIDIn) > 0 {
		predicates = append(predicates, trace.ProjectIDIn(i.ProjectIDIn...))
	}
	if len(i.ProjectIDNotIn) > 0 {
		predicates = append(predicates, trace.ProjectIDNotIn(i.ProjectIDNotIn...))
	}
	if i.TraceID != nil {
		predicates = append(predicates, trace.TraceIDEQ(*i.TraceID))
	}
	if i.TraceIDNEQ != nil {
		predicates = append(predicates, trace.TraceIDNEQ(*i.TraceIDNEQ))
	}
	if len(i.TraceIDIn) > 0 {
		predicates = append(predicates, trace.TraceIDIn(i.TraceIDIn...))
	}
	if len(i.TraceIDNotIn) > 0 {
		predicates = append(predicates, trace.TraceIDNotIn(i.TraceIDNotIn...))
	}
	if i.TraceIDGT != nil {
		predicates = append(predicates, trace.TraceIDGT(*i.TraceIDGT))
	}
	if i.TraceIDGTE != nil {
		predicates = append(predicates, trace.TraceIDGTE(*i.TraceIDGTE))
	}
	if i.TraceIDLT != nil {
		predicates = append(predicates, trace.TraceIDLT(*i.TraceIDLT))
	}
	if i.TraceIDLTE != nil {
		predicates = append(predicates, trace.TraceIDLTE(*i.TraceIDLTE))
	}
	if i.TraceIDContains != nil {
		predicates = append(predicates, trace.TraceIDContains(*i.TraceIDContains))
	}
	if i.TraceIDHasPrefix != nil {
		predicates = append(predicates, trace.TraceIDHasPrefix(*i.TraceIDHasPrefix))
	}
	if i.TraceIDHasSuffix != nil {
		predicates = append(predicates, trace.TraceIDHasSuffix(*i.TraceIDHasSuffix))
	}
	if i.TraceIDEqualFold != nil {
		predicates = append(predicates, trace.TraceIDEqualFold(*i.TraceIDEqualFold))
	}
	if i.TraceIDContainsFold != nil {
		predicates = append(predicates, trace.TraceIDContainsFold(*i.TraceIDContainsFold))
	}
	if i.ThreadID != nil {
		predicates = append(predicates, trace.ThreadIDEQ(*i.ThreadID))
	}
	if i.ThreadIDNEQ != nil {
		predicates = append(predicates, trace.ThreadIDNEQ(*i.ThreadIDNEQ))
	}
	if len(i.ThreadIDIn) > 0 {
		predicates = append(predicates, trace.ThreadIDIn(i.ThreadIDIn...))
	}
	if len(i.ThreadIDNotIn) > 0 {
		predicates = append(predicates, trace.ThreadIDNotIn(i.ThreadIDNotIn...))
	}
	if i.ThreadIDIsNil {
		predicates = append(predicates, trace.ThreadIDIsNil())
	}
	if i.ThreadIDNotNil {
		predicates = append(predicates, trace.ThreadIDNotNil())
	}

	if i.HasProject != nil {
		p := trace.HasProject()
		if !*i.HasProject {
			p = trace.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProjectWith) > 0 {
		with := make([]predicate.Project, 0, len(i.HasProjectWith))
		for _, w := range i.HasProjectWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProjectWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, trace.HasProjectWith(with...))
	}
	if i.HasThread != nil {
		p := trace.HasThread()
		if !*i.HasThread {
			p = trace.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasThreadWith) > 0 {
		with := make([]predicate.Thread, 0, len(i.HasThreadWith))
		for _, w := range i.HasThreadWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasThreadWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, trace.HasThreadWith(with...))
	}
	if i.HasRequests != nil {
		p := trace.HasRequests()
		if !*i.HasRequests {
			p = trace.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRequestsWith) > 0 {
		with := make([]predicate.Request, 0, len(i.HasRequestsWith))
		for _, w := range i.HasRequestsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRequestsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, trace.HasRequestsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyTraceWhereInput
	case 1:
		return predicates[0], nil
	default:
		return trace.And(predicates...), nil
	}
}

// UsageLogWhereInput represents a where input for filtering UsageLog queries.
type UsageLogWhereInput struct {
	Predicates []predicate.UsageLog  `json:"-"`
	Not        *UsageLogWhereInput   `json:"not,omitempty"`
	Or         []*UsageLogWhereInput `json:"or,omitempty"`
	And        []*UsageLogWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "request_id" field predicates.
	RequestID      *int  `json:"requestID,omitempty"`
	RequestIDNEQ   *int  `json:"requestIDNEQ,omitempty"`
	RequestIDIn    []int `json:"requestIDIn,omitempty"`
	RequestIDNotIn []int `json:"requestIDNotIn,omitempty"`

	// "project_id" field predicates.
	ProjectID      *int  `json:"projectID,omitempty"`
	ProjectIDNEQ   *int  `json:"projectIDNEQ,omitempty"`
	ProjectIDIn    []int `json:"projectIDIn,omitempty"`
	ProjectIDNotIn []int `json:"projectIDNotIn,omitempty"`

	// "channel_id" field predicates.
	ChannelID       *int  `json:"channelID,omitempty"`
	ChannelIDNEQ    *int  `json:"channelIDNEQ,omitempty"`
	ChannelIDIn     []int `json:"channelIDIn,omitempty"`
	ChannelIDNotIn  []int `json:"channelIDNotIn,omitempty"`
	ChannelIDIsNil  bool  `json:"channelIDIsNil,omitempty"`
	ChannelIDNotNil bool  `json:"channelIDNotNil,omitempty"`

	// "model_id" field predicates.
	ModelID             *string  `json:"modelID,omitempty"`
	ModelIDNEQ          *string  `json:"modelIDNEQ,omitempty"`
	ModelIDIn           []string `json:"modelIDIn,omitempty"`
	ModelIDNotIn        []string `json:"modelIDNotIn,omitempty"`
	ModelIDGT           *string  `json:"modelIDGT,omitempty"`
	ModelIDGTE          *string  `json:"modelIDGTE,omitempty"`
	ModelIDLT           *string  `json:"modelIDLT,omitempty"`
	ModelIDLTE          *string  `json:"modelIDLTE,omitempty"`
	ModelIDContains     *string  `json:"modelIDContains,omitempty"`
	ModelIDHasPrefix    *string  `json:"modelIDHasPrefix,omitempty"`
	ModelIDHasSuffix    *string  `json:"modelIDHasSuffix,omitempty"`
	ModelIDEqualFold    *string  `json:"modelIDEqualFold,omitempty"`
	ModelIDContainsFold *string  `json:"modelIDContainsFold,omitempty"`

	// "prompt_tokens" field predicates.
	PromptTokens      *int64  `json:"promptTokens,omitempty"`
	PromptTokensNEQ   *int64  `json:"promptTokensNEQ,omitempty"`
	PromptTokensIn    []int64 `json:"promptTokensIn,omitempty"`
	PromptTokensNotIn []int64 `json:"promptTokensNotIn,omitempty"`
	PromptTokensGT    *int64  `json:"promptTokensGT,omitempty"`
	PromptTokensGTE   *int64  `json:"promptTokensGTE,omitempty"`
	PromptTokensLT    *int64  `json:"promptTokensLT,omitempty"`
	PromptTokensLTE   *int64  `json:"promptTokensLTE,omitempty"`

	// "completion_tokens" field predicates.
	CompletionTokens      *int64  `json:"completionTokens,omitempty"`
	CompletionTokensNEQ   *int64  `json:"completionTokensNEQ,omitempty"`
	CompletionTokensIn    []int64 `json:"completionTokensIn,omitempty"`
	CompletionTokensNotIn []int64 `json:"completionTokensNotIn,omitempty"`
	CompletionTokensGT    *int64  `json:"completionTokensGT,omitempty"`
	CompletionTokensGTE   *int64  `json:"completionTokensGTE,omitempty"`
	CompletionTokensLT    *int64  `json:"completionTokensLT,omitempty"`
	CompletionTokensLTE   *int64  `json:"completionTokensLTE,omitempty"`

	// "total_tokens" field predicates.
	TotalTokens      *int64  `json:"totalTokens,omitempty"`
	TotalTokensNEQ   *int64  `json:"totalTokensNEQ,omitempty"`
	TotalTokensIn    []int64 `json:"totalTokensIn,omitempty"`
	TotalTokensNotIn []int64 `json:"totalTokensNotIn,omitempty"`
	TotalTokensGT    *int64  `json:"totalTokensGT,omitempty"`
	TotalTokensGTE   *int64  `json:"totalTokensGTE,omitempty"`
	TotalTokensLT    *int64  `json:"totalTokensLT,omitempty"`
	TotalTokensLTE   *int64  `json:"totalTokensLTE,omitempty"`

	// "prompt_audio_tokens" field predicates.
	PromptAudioTokens       *int64  `json:"promptAudioTokens,omitempty"`
	PromptAudioTokensNEQ    *int64  `json:"promptAudioTokensNEQ,omitempty"`
	PromptAudioTokensIn     []int64 `json:"promptAudioTokensIn,omitempty"`
	PromptAudioTokensNotIn  []int64 `json:"promptAudioTokensNotIn,omitempty"`
	PromptAudioTokensGT     *int64  `json:"promptAudioTokensGT,omitempty"`
	PromptAudioTokensGTE    *int64  `json:"promptAudioTokensGTE,omitempty"`
	PromptAudioTokensLT     *int64  `json:"promptAudioTokensLT,omitempty"`
	PromptAudioTokensLTE    *int64  `json:"promptAudioTokensLTE,omitempty"`
	PromptAudioTokensIsNil  bool    `json:"promptAudioTokensIsNil,omitempty"`
	PromptAudioTokensNotNil bool    `json:"promptAudioTokensNotNil,omitempty"`

	// "prompt_cached_tokens" field predicates.
	PromptCachedTokens       *int64  `json:"promptCachedTokens,omitempty"`
	PromptCachedTokensNEQ    *int64  `json:"promptCachedTokensNEQ,omitempty"`
	PromptCachedTokensIn     []int64 `json:"promptCachedTokensIn,omitempty"`
	PromptCachedTokensNotIn  []int64 `json:"promptCachedTokensNotIn,omitempty"`
	PromptCachedTokensGT     *int64  `json:"promptCachedTokensGT,omitempty"`
	PromptCachedTokensGTE    *int64  `json:"promptCachedTokensGTE,omitempty"`
	PromptCachedTokensLT     *int64  `json:"promptCachedTokensLT,omitempty"`
	PromptCachedTokensLTE    *int64  `json:"promptCachedTokensLTE,omitempty"`
	PromptCachedTokensIsNil  bool    `json:"promptCachedTokensIsNil,omitempty"`
	PromptCachedTokensNotNil bool    `json:"promptCachedTokensNotNil,omitempty"`

	// "completion_audio_tokens" field predicates.
	CompletionAudioTokens       *int64  `json:"completionAudioTokens,omitempty"`
	CompletionAudioTokensNEQ    *int64  `json:"completionAudioTokensNEQ,omitempty"`
	CompletionAudioTokensIn     []int64 `json:"completionAudioTokensIn,omitempty"`
	CompletionAudioTokensNotIn  []int64 `json:"completionAudioTokensNotIn,omitempty"`
	CompletionAudioTokensGT     *int64  `json:"completionAudioTokensGT,omitempty"`
	CompletionAudioTokensGTE    *int64  `json:"completionAudioTokensGTE,omitempty"`
	CompletionAudioTokensLT     *int64  `json:"completionAudioTokensLT,omitempty"`
	CompletionAudioTokensLTE    *int64  `json:"completionAudioTokensLTE,omitempty"`
	CompletionAudioTokensIsNil  bool    `json:"completionAudioTokensIsNil,omitempty"`
	CompletionAudioTokensNotNil bool    `json:"completionAudioTokensNotNil,omitempty"`

	// "completion_reasoning_tokens" field predicates.
	CompletionReasoningTokens       *int64  `json:"completionReasoningTokens,omitempty"`
	CompletionReasoningTokensNEQ    *int64  `json:"completionReasoningTokensNEQ,omitempty"`
	CompletionReasoningTokensIn     []int64 `json:"completionReasoningTokensIn,omitempty"`
	CompletionReasoningTokensNotIn  []int64 `json:"completionReasoningTokensNotIn,omitempty"`
	CompletionReasoningTokensGT     *int64  `json:"completionReasoningTokensGT,omitempty"`
	CompletionReasoningTokensGTE    *int64  `json:"completionReasoningTokensGTE,omitempty"`
	CompletionReasoningTokensLT     *int64  `json:"completionReasoningTokensLT,omitempty"`
	CompletionReasoningTokensLTE    *int64  `json:"completionReasoningTokensLTE,omitempty"`
	CompletionReasoningTokensIsNil  bool    `json:"completionReasoningTokensIsNil,omitempty"`
	CompletionReasoningTokensNotNil bool    `json:"completionReasoningTokensNotNil,omitempty"`

	// "completion_accepted_prediction_tokens" field predicates.
	CompletionAcceptedPredictionTokens       *int64  `json:"completionAcceptedPredictionTokens,omitempty"`
	CompletionAcceptedPredictionTokensNEQ    *int64  `json:"completionAcceptedPredictionTokensNEQ,omitempty"`
	CompletionAcceptedPredictionTokensIn     []int64 `json:"completionAcceptedPredictionTokensIn,omitempty"`
	CompletionAcceptedPredictionTokensNotIn  []int64 `json:"completionAcceptedPredictionTokensNotIn,omitempty"`
	CompletionAcceptedPredictionTokensGT     *int64  `json:"completionAcceptedPredictionTokensGT,omitempty"`
	CompletionAcceptedPredictionTokensGTE    *int64  `json:"completionAcceptedPredictionTokensGTE,omitempty"`
	CompletionAcceptedPredictionTokensLT     *int64  `json:"completionAcceptedPredictionTokensLT,omitempty"`
	CompletionAcceptedPredictionTokensLTE    *int64  `json:"completionAcceptedPredictionTokensLTE,omitempty"`
	CompletionAcceptedPredictionTokensIsNil  bool    `json:"completionAcceptedPredictionTokensIsNil,omitempty"`
	CompletionAcceptedPredictionTokensNotNil bool    `json:"completionAcceptedPredictionTokensNotNil,omitempty"`

	// "completion_rejected_prediction_tokens" field predicates.
	CompletionRejectedPredictionTokens       *int64  `json:"completionRejectedPredictionTokens,omitempty"`
	CompletionRejectedPredictionTokensNEQ    *int64  `json:"completionRejectedPredictionTokensNEQ,omitempty"`
	CompletionRejectedPredictionTokensIn     []int64 `json:"completionRejectedPredictionTokensIn,omitempty"`
	CompletionRejectedPredictionTokensNotIn  []int64 `json:"completionRejectedPredictionTokensNotIn,omitempty"`
	CompletionRejectedPredictionTokensGT     *int64  `json:"completionRejectedPredictionTokensGT,omitempty"`
	CompletionRejectedPredictionTokensGTE    *int64  `json:"completionRejectedPredictionTokensGTE,omitempty"`
	CompletionRejectedPredictionTokensLT     *int64  `json:"completionRejectedPredictionTokensLT,omitempty"`
	CompletionRejectedPredictionTokensLTE    *int64  `json:"completionRejectedPredictionTokensLTE,omitempty"`
	CompletionRejectedPredictionTokensIsNil  bool    `json:"completionRejectedPredictionTokensIsNil,omitempty"`
	CompletionRejectedPredictionTokensNotNil bool    `json:"completionRejectedPredictionTokensNotNil,omitempty"`

	// "source" field predicates.
	Source      *usagelog.Source  `json:"source,omitempty"`
	SourceNEQ   *usagelog.Source  `json:"sourceNEQ,omitempty"`
	SourceIn    []usagelog.Source `json:"sourceIn,omitempty"`
	SourceNotIn []usagelog.Source `json:"sourceNotIn,omitempty"`

	// "format" field predicates.
	Format             *string  `json:"format,omitempty"`
	FormatNEQ          *string  `json:"formatNEQ,omitempty"`
	FormatIn           []string `json:"formatIn,omitempty"`
	FormatNotIn        []string `json:"formatNotIn,omitempty"`
	FormatGT           *string  `json:"formatGT,omitempty"`
	FormatGTE          *string  `json:"formatGTE,omitempty"`
	FormatLT           *string  `json:"formatLT,omitempty"`
	FormatLTE          *string  `json:"formatLTE,omitempty"`
	FormatContains     *string  `json:"formatContains,omitempty"`
	FormatHasPrefix    *string  `json:"formatHasPrefix,omitempty"`
	FormatHasSuffix    *string  `json:"formatHasSuffix,omitempty"`
	FormatEqualFold    *string  `json:"formatEqualFold,omitempty"`
	FormatContainsFold *string  `json:"formatContainsFold,omitempty"`

	// "request" edge predicates.
	HasRequest     *bool                `json:"hasRequest,omitempty"`
	HasRequestWith []*RequestWhereInput `json:"hasRequestWith,omitempty"`

	// "project" edge predicates.
	HasProject     *bool                `json:"hasProject,omitempty"`
	HasProjectWith []*ProjectWhereInput `json:"hasProjectWith,omitempty"`

	// "channel" edge predicates.
	HasChannel     *bool                `json:"hasChannel,omitempty"`
	HasChannelWith []*ChannelWhereInput `json:"hasChannelWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UsageLogWhereInput) AddPredicates(predicates ...predicate.UsageLog) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UsageLogWhereInput filter on the UsageLogQuery builder.
func (i *UsageLogWhereInput) Filter(q *UsageLogQuery) (*UsageLogQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUsageLogWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUsageLogWhereInput is returned in case the UsageLogWhereInput is empty.
var ErrEmptyUsageLogWhereInput = errors.New("ent: empty predicate UsageLogWhereInput")

// P returns a predicate for filtering usagelogs.
// An error is returned if the input is empty or invalid.
func (i *UsageLogWhereInput) P() (predicate.UsageLog, error) {
	var predicates []predicate.UsageLog
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, usagelog.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.UsageLog, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, usagelog.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.UsageLog, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, usagelog.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, usagelog.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, usagelog.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, usagelog.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, usagelog.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, usagelog.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, usagelog.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, usagelog.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, usagelog.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, usagelog.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, usagelog.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, usagelog.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, usagelog.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, usagelog.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, usagelog.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, usagelog.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, usagelog.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, usagelog.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, usagelog.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, usagelog.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, usagelog.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, usagelog.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, usagelog.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, usagelog.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, usagelog.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.RequestID != nil {
		predicates = append(predicates, usagelog.RequestIDEQ(*i.RequestID))
	}
	if i.RequestIDNEQ != nil {
		predicates = append(predicates, usagelog.RequestIDNEQ(*i.RequestIDNEQ))
	}
	if len(i.RequestIDIn) > 0 {
		predicates = append(predicates, usagelog.RequestIDIn(i.RequestIDIn...))
	}
	if len(i.RequestIDNotIn) > 0 {
		predicates = append(predicates, usagelog.RequestIDNotIn(i.RequestIDNotIn...))
	}
	if i.ProjectID != nil {
		predicates = append(predicates, usagelog.ProjectIDEQ(*i.ProjectID))
	}
	if i.ProjectIDNEQ != nil {
		predicates = append(predicates, usagelog.ProjectIDNEQ(*i.ProjectIDNEQ))
	}
	if len(i.ProjectIDIn) > 0 {
		predicates = append(predicates, usagelog.ProjectIDIn(i.ProjectIDIn...))
	}
	if len(i.ProjectIDNotIn) > 0 {
		predicates = append(predicates, usagelog.ProjectIDNotIn(i.ProjectIDNotIn...))
	}
	if i.ChannelID != nil {
		predicates = append(predicates, usagelog.ChannelIDEQ(*i.ChannelID))
	}
	if i.ChannelIDNEQ != nil {
		predicates = append(predicates, usagelog.ChannelIDNEQ(*i.ChannelIDNEQ))
	}
	if len(i.ChannelIDIn) > 0 {
		predicates = append(predicates, usagelog.ChannelIDIn(i.ChannelIDIn...))
	}
	if len(i.ChannelIDNotIn) > 0 {
		predicates = append(predicates, usagelog.ChannelIDNotIn(i.ChannelIDNotIn...))
	}
	if i.ChannelIDIsNil {
		predicates = append(predicates, usagelog.ChannelIDIsNil())
	}
	if i.ChannelIDNotNil {
		predicates = append(predicates, usagelog.ChannelIDNotNil())
	}
	if i.ModelID != nil {
		predicates = append(predicates, usagelog.ModelIDEQ(*i.ModelID))
	}
	if i.ModelIDNEQ != nil {
		predicates = append(predicates, usagelog.ModelIDNEQ(*i.ModelIDNEQ))
	}
	if len(i.ModelIDIn) > 0 {
		predicates = append(predicates, usagelog.ModelIDIn(i.ModelIDIn...))
	}
	if len(i.ModelIDNotIn) > 0 {
		predicates = append(predicates, usagelog.ModelIDNotIn(i.ModelIDNotIn...))
	}
	if i.ModelIDGT != nil {
		predicates = append(predicates, usagelog.ModelIDGT(*i.ModelIDGT))
	}
	if i.ModelIDGTE != nil {
		predicates = append(predicates, usagelog.ModelIDGTE(*i.ModelIDGTE))
	}
	if i.ModelIDLT != nil {
		predicates = append(predicates, usagelog.ModelIDLT(*i.ModelIDLT))
	}
	if i.ModelIDLTE != nil {
		predicates = append(predicates, usagelog.ModelIDLTE(*i.ModelIDLTE))
	}
	if i.ModelIDContains != nil {
		predicates = append(predicates, usagelog.ModelIDContains(*i.ModelIDContains))
	}
	if i.ModelIDHasPrefix != nil {
		predicates = append(predicates, usagelog.ModelIDHasPrefix(*i.ModelIDHasPrefix))
	}
	if i.ModelIDHasSuffix != nil {
		predicates = append(predicates, usagelog.ModelIDHasSuffix(*i.ModelIDHasSuffix))
	}
	if i.ModelIDEqualFold != nil {
		predicates = append(predicates, usagelog.ModelIDEqualFold(*i.ModelIDEqualFold))
	}
	if i.ModelIDContainsFold != nil {
		predicates = append(predicates, usagelog.ModelIDContainsFold(*i.ModelIDContainsFold))
	}
	if i.PromptTokens != nil {
		predicates = append(predicates, usagelog.PromptTokensEQ(*i.PromptTokens))
	}
	if i.PromptTokensNEQ != nil {
		predicates = append(predicates, usagelog.PromptTokensNEQ(*i.PromptTokensNEQ))
	}
	if len(i.PromptTokensIn) > 0 {
		predicates = append(predicates, usagelog.PromptTokensIn(i.PromptTokensIn...))
	}
	if len(i.PromptTokensNotIn) > 0 {
		predicates = append(predicates, usagelog.PromptTokensNotIn(i.PromptTokensNotIn...))
	}
	if i.PromptTokensGT != nil {
		predicates = append(predicates, usagelog.PromptTokensGT(*i.PromptTokensGT))
	}
	if i.PromptTokensGTE != nil {
		predicates = append(predicates, usagelog.PromptTokensGTE(*i.PromptTokensGTE))
	}
	if i.PromptTokensLT != nil {
		predicates = append(predicates, usagelog.PromptTokensLT(*i.PromptTokensLT))
	}
	if i.PromptTokensLTE != nil {
		predicates = append(predicates, usagelog.PromptTokensLTE(*i.PromptTokensLTE))
	}
	if i.CompletionTokens != nil {
		predicates = append(predicates, usagelog.CompletionTokensEQ(*i.CompletionTokens))
	}
	if i.CompletionTokensNEQ != nil {
		predicates = append(predicates, usagelog.CompletionTokensNEQ(*i.CompletionTokensNEQ))
	}
	if len(i.CompletionTokensIn) > 0 {
		predicates = append(predicates, usagelog.CompletionTokensIn(i.CompletionTokensIn...))
	}
	if len(i.CompletionTokensNotIn) > 0 {
		predicates = append(predicates, usagelog.CompletionTokensNotIn(i.CompletionTokensNotIn...))
	}
	if i.CompletionTokensGT != nil {
		predicates = append(predicates, usagelog.CompletionTokensGT(*i.CompletionTokensGT))
	}
	if i.CompletionTokensGTE != nil {
		predicates = append(predicates, usagelog.CompletionTokensGTE(*i.CompletionTokensGTE))
	}
	if i.CompletionTokensLT != nil {
		predicates = append(predicates, usagelog.CompletionTokensLT(*i.CompletionTokensLT))
	}
	if i.CompletionTokensLTE != nil {
		predicates = append(predicates, usagelog.CompletionTokensLTE(*i.CompletionTokensLTE))
	}
	if i.TotalTokens != nil {
		predicates = append(predicates, usagelog.TotalTokensEQ(*i.TotalTokens))
	}
	if i.TotalTokensNEQ != nil {
		predicates = append(predicates, usagelog.TotalTokensNEQ(*i.TotalTokensNEQ))
	}
	if len(i.TotalTokensIn) > 0 {
		predicates = append(predicates, usagelog.TotalTokensIn(i.TotalTokensIn...))
	}
	if len(i.TotalTokensNotIn) > 0 {
		predicates = append(predicates, usagelog.TotalTokensNotIn(i.TotalTokensNotIn...))
	}
	if i.TotalTokensGT != nil {
		predicates = append(predicates, usagelog.TotalTokensGT(*i.TotalTokensGT))
	}
	if i.TotalTokensGTE != nil {
		predicates = append(predicates, usagelog.TotalTokensGTE(*i.TotalTokensGTE))
	}
	if i.TotalTokensLT != nil {
		predicates = append(predicates, usagelog.TotalTokensLT(*i.TotalTokensLT))
	}
	if i.TotalTokensLTE != nil {
		predicates = append(predicates, usagelog.TotalTokensLTE(*i.TotalTokensLTE))
	}
	if i.PromptAudioTokens != nil {
		predicates = append(predicates, usagelog.PromptAudioTokensEQ(*i.PromptAudioTokens))
	}
	if i.PromptAudioTokensNEQ != nil {
		predicates = append(predicates, usagelog.PromptAudioTokensNEQ(*i.PromptAudioTokensNEQ))
	}
	if len(i.PromptAudioTokensIn) > 0 {
		predicates = append(predicates, usagelog.PromptAudioTokensIn(i.PromptAudioTokensIn...))
	}
	if len(i.PromptAudioTokensNotIn) > 0 {
		predicates = append(predicates, usagelog.PromptAudioTokensNotIn(i.PromptAudioTokensNotIn...))
	}
	if i.PromptAudioTokensGT != nil {
		predicates = append(predicates, usagelog.PromptAudioTokensGT(*i.PromptAudioTokensGT))
	}
	if i.PromptAudioTokensGTE != nil {
		predicates = append(predicates, usagelog.PromptAudioTokensGTE(*i.PromptAudioTokensGTE))
	}
	if i.PromptAudioTokensLT != nil {
		predicates = append(predicates, usagelog.PromptAudioTokensLT(*i.PromptAudioTokensLT))
	}
	if i.PromptAudioTokensLTE != nil {
		predicates = append(predicates, usagelog.PromptAudioTokensLTE(*i.PromptAudioTokensLTE))
	}
	if i.PromptAudioTokensIsNil {
		predicates = append(predicates, usagelog.PromptAudioTokensIsNil())
	}
	if i.PromptAudioTokensNotNil {
		predicates = append(predicates, usagelog.PromptAudioTokensNotNil())
	}
	if i.PromptCachedTokens != nil {
		predicates = append(predicates, usagelog.PromptCachedTokensEQ(*i.PromptCachedTokens))
	}
	if i.PromptCachedTokensNEQ != nil {
		predicates = append(predicates, usagelog.PromptCachedTokensNEQ(*i.PromptCachedTokensNEQ))
	}
	if len(i.PromptCachedTokensIn) > 0 {
		predicates = append(predicates, usagelog.PromptCachedTokensIn(i.PromptCachedTokensIn...))
	}
	if len(i.PromptCachedTokensNotIn) > 0 {
		predicates = append(predicates, usagelog.PromptCachedTokensNotIn(i.PromptCachedTokensNotIn...))
	}
	if i.PromptCachedTokensGT != nil {
		predicates = append(predicates, usagelog.PromptCachedTokensGT(*i.PromptCachedTokensGT))
	}
	if i.PromptCachedTokensGTE != nil {
		predicates = append(predicates, usagelog.PromptCachedTokensGTE(*i.PromptCachedTokensGTE))
	}
	if i.PromptCachedTokensLT != nil {
		predicates = append(predicates, usagelog.PromptCachedTokensLT(*i.PromptCachedTokensLT))
	}
	if i.PromptCachedTokensLTE != nil {
		predicates = append(predicates, usagelog.PromptCachedTokensLTE(*i.PromptCachedTokensLTE))
	}
	if i.PromptCachedTokensIsNil {
		predicates = append(predicates, usagelog.PromptCachedTokensIsNil())
	}
	if i.PromptCachedTokensNotNil {
		predicates = append(predicates, usagelog.PromptCachedTokensNotNil())
	}
	if i.CompletionAudioTokens != nil {
		predicates = append(predicates, usagelog.CompletionAudioTokensEQ(*i.CompletionAudioTokens))
	}
	if i.CompletionAudioTokensNEQ != nil {
		predicates = append(predicates, usagelog.CompletionAudioTokensNEQ(*i.CompletionAudioTokensNEQ))
	}
	if len(i.CompletionAudioTokensIn) > 0 {
		predicates = append(predicates, usagelog.CompletionAudioTokensIn(i.CompletionAudioTokensIn...))
	}
	if len(i.CompletionAudioTokensNotIn) > 0 {
		predicates = append(predicates, usagelog.CompletionAudioTokensNotIn(i.CompletionAudioTokensNotIn...))
	}
	if i.CompletionAudioTokensGT != nil {
		predicates = append(predicates, usagelog.CompletionAudioTokensGT(*i.CompletionAudioTokensGT))
	}
	if i.CompletionAudioTokensGTE != nil {
		predicates = append(predicates, usagelog.CompletionAudioTokensGTE(*i.CompletionAudioTokensGTE))
	}
	if i.CompletionAudioTokensLT != nil {
		predicates = append(predicates, usagelog.CompletionAudioTokensLT(*i.CompletionAudioTokensLT))
	}
	if i.CompletionAudioTokensLTE != nil {
		predicates = append(predicates, usagelog.CompletionAudioTokensLTE(*i.CompletionAudioTokensLTE))
	}
	if i.CompletionAudioTokensIsNil {
		predicates = append(predicates, usagelog.CompletionAudioTokensIsNil())
	}
	if i.CompletionAudioTokensNotNil {
		predicates = append(predicates, usagelog.CompletionAudioTokensNotNil())
	}
	if i.CompletionReasoningTokens != nil {
		predicates = append(predicates, usagelog.CompletionReasoningTokensEQ(*i.CompletionReasoningTokens))
	}
	if i.CompletionReasoningTokensNEQ != nil {
		predicates = append(predicates, usagelog.CompletionReasoningTokensNEQ(*i.CompletionReasoningTokensNEQ))
	}
	if len(i.CompletionReasoningTokensIn) > 0 {
		predicates = append(predicates, usagelog.CompletionReasoningTokensIn(i.CompletionReasoningTokensIn...))
	}
	if len(i.CompletionReasoningTokensNotIn) > 0 {
		predicates = append(predicates, usagelog.CompletionReasoningTokensNotIn(i.CompletionReasoningTokensNotIn...))
	}
	if i.CompletionReasoningTokensGT != nil {
		predicates = append(predicates, usagelog.CompletionReasoningTokensGT(*i.CompletionReasoningTokensGT))
	}
	if i.CompletionReasoningTokensGTE != nil {
		predicates = append(predicates, usagelog.CompletionReasoningTokensGTE(*i.CompletionReasoningTokensGTE))
	}
	if i.CompletionReasoningTokensLT != nil {
		predicates = append(predicates, usagelog.CompletionReasoningTokensLT(*i.CompletionReasoningTokensLT))
	}
	if i.CompletionReasoningTokensLTE != nil {
		predicates = append(predicates, usagelog.CompletionReasoningTokensLTE(*i.CompletionReasoningTokensLTE))
	}
	if i.CompletionReasoningTokensIsNil {
		predicates = append(predicates, usagelog.CompletionReasoningTokensIsNil())
	}
	if i.CompletionReasoningTokensNotNil {
		predicates = append(predicates, usagelog.CompletionReasoningTokensNotNil())
	}
	if i.CompletionAcceptedPredictionTokens != nil {
		predicates = append(predicates, usagelog.CompletionAcceptedPredictionTokensEQ(*i.CompletionAcceptedPredictionTokens))
	}
	if i.CompletionAcceptedPredictionTokensNEQ != nil {
		predicates = append(predicates, usagelog.CompletionAcceptedPredictionTokensNEQ(*i.CompletionAcceptedPredictionTokensNEQ))
	}
	if len(i.CompletionAcceptedPredictionTokensIn) > 0 {
		predicates = append(predicates, usagelog.CompletionAcceptedPredictionTokensIn(i.CompletionAcceptedPredictionTokensIn...))
	}
	if len(i.CompletionAcceptedPredictionTokensNotIn) > 0 {
		predicates = append(predicates, usagelog.CompletionAcceptedPredictionTokensNotIn(i.CompletionAcceptedPredictionTokensNotIn...))
	}
	if i.CompletionAcceptedPredictionTokensGT != nil {
		predicates = append(predicates, usagelog.CompletionAcceptedPredictionTokensGT(*i.CompletionAcceptedPredictionTokensGT))
	}
	if i.CompletionAcceptedPredictionTokensGTE != nil {
		predicates = append(predicates, usagelog.CompletionAcceptedPredictionTokensGTE(*i.CompletionAcceptedPredictionTokensGTE))
	}
	if i.CompletionAcceptedPredictionTokensLT != nil {
		predicates = append(predicates, usagelog.CompletionAcceptedPredictionTokensLT(*i.CompletionAcceptedPredictionTokensLT))
	}
	if i.CompletionAcceptedPredictionTokensLTE != nil {
		predicates = append(predicates, usagelog.CompletionAcceptedPredictionTokensLTE(*i.CompletionAcceptedPredictionTokensLTE))
	}
	if i.CompletionAcceptedPredictionTokensIsNil {
		predicates = append(predicates, usagelog.CompletionAcceptedPredictionTokensIsNil())
	}
	if i.CompletionAcceptedPredictionTokensNotNil {
		predicates = append(predicates, usagelog.CompletionAcceptedPredictionTokensNotNil())
	}
	if i.CompletionRejectedPredictionTokens != nil {
		predicates = append(predicates, usagelog.CompletionRejectedPredictionTokensEQ(*i.CompletionRejectedPredictionTokens))
	}
	if i.CompletionRejectedPredictionTokensNEQ != nil {
		predicates = append(predicates, usagelog.CompletionRejectedPredictionTokensNEQ(*i.CompletionRejectedPredictionTokensNEQ))
	}
	if len(i.CompletionRejectedPredictionTokensIn) > 0 {
		predicates = append(predicates, usagelog.CompletionRejectedPredictionTokensIn(i.CompletionRejectedPredictionTokensIn...))
	}
	if len(i.CompletionRejectedPredictionTokensNotIn) > 0 {
		predicates = append(predicates, usagelog.CompletionRejectedPredictionTokensNotIn(i.CompletionRejectedPredictionTokensNotIn...))
	}
	if i.CompletionRejectedPredictionTokensGT != nil {
		predicates = append(predicates, usagelog.CompletionRejectedPredictionTokensGT(*i.CompletionRejectedPredictionTokensGT))
	}
	if i.CompletionRejectedPredictionTokensGTE != nil {
		predicates = append(predicates, usagelog.CompletionRejectedPredictionTokensGTE(*i.CompletionRejectedPredictionTokensGTE))
	}
	if i.CompletionRejectedPredictionTokensLT != nil {
		predicates = append(predicates, usagelog.CompletionRejectedPredictionTokensLT(*i.CompletionRejectedPredictionTokensLT))
	}
	if i.CompletionRejectedPredictionTokensLTE != nil {
		predicates = append(predicates, usagelog.CompletionRejectedPredictionTokensLTE(*i.CompletionRejectedPredictionTokensLTE))
	}
	if i.CompletionRejectedPredictionTokensIsNil {
		predicates = append(predicates, usagelog.CompletionRejectedPredictionTokensIsNil())
	}
	if i.CompletionRejectedPredictionTokensNotNil {
		predicates = append(predicates, usagelog.CompletionRejectedPredictionTokensNotNil())
	}
	if i.Source != nil {
		predicates = append(predicates, usagelog.SourceEQ(*i.Source))
	}
	if i.SourceNEQ != nil {
		predicates = append(predicates, usagelog.SourceNEQ(*i.SourceNEQ))
	}
	if len(i.SourceIn) > 0 {
		predicates = append(predicates, usagelog.SourceIn(i.SourceIn...))
	}
	if len(i.SourceNotIn) > 0 {
		predicates = append(predicates, usagelog.SourceNotIn(i.SourceNotIn...))
	}
	if i.Format != nil {
		predicates = append(predicates, usagelog.FormatEQ(*i.Format))
	}
	if i.FormatNEQ != nil {
		predicates = append(predicates, usagelog.FormatNEQ(*i.FormatNEQ))
	}
	if len(i.FormatIn) > 0 {
		predicates = append(predicates, usagelog.FormatIn(i.FormatIn...))
	}
	if len(i.FormatNotIn) > 0 {
		predicates = append(predicates, usagelog.FormatNotIn(i.FormatNotIn...))
	}
	if i.FormatGT != nil {
		predicates = append(predicates, usagelog.FormatGT(*i.FormatGT))
	}
	if i.FormatGTE != nil {
		predicates = append(predicates, usagelog.FormatGTE(*i.FormatGTE))
	}
	if i.FormatLT != nil {
		predicates = append(predicates, usagelog.FormatLT(*i.FormatLT))
	}
	if i.FormatLTE != nil {
		predicates = append(predicates, usagelog.FormatLTE(*i.FormatLTE))
	}
	if i.FormatContains != nil {
		predicates = append(predicates, usagelog.FormatContains(*i.FormatContains))
	}
	if i.FormatHasPrefix != nil {
		predicates = append(predicates, usagelog.FormatHasPrefix(*i.FormatHasPrefix))
	}
	if i.FormatHasSuffix != nil {
		predicates = append(predicates, usagelog.FormatHasSuffix(*i.FormatHasSuffix))
	}
	if i.FormatEqualFold != nil {
		predicates = append(predicates, usagelog.FormatEqualFold(*i.FormatEqualFold))
	}
	if i.FormatContainsFold != nil {
		predicates = append(predicates, usagelog.FormatContainsFold(*i.FormatContainsFold))
	}

	if i.HasRequest != nil {
		p := usagelog.HasRequest()
		if !*i.HasRequest {
			p = usagelog.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRequestWith) > 0 {
		with := make([]predicate.Request, 0, len(i.HasRequestWith))
		for _, w := range i.HasRequestWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRequestWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, usagelog.HasRequestWith(with...))
	}
	if i.HasProject != nil {
		p := usagelog.HasProject()
		if !*i.HasProject {
			p = usagelog.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProjectWith) > 0 {
		with := make([]predicate.Project, 0, len(i.HasProjectWith))
		for _, w := range i.HasProjectWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProjectWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, usagelog.HasProjectWith(with...))
	}
	if i.HasChannel != nil {
		p := usagelog.HasChannel()
		if !*i.HasChannel {
			p = usagelog.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasChannelWith) > 0 {
		with := make([]predicate.Channel, 0, len(i.HasChannelWith))
		for _, w := range i.HasChannelWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasChannelWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, usagelog.HasChannelWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUsageLogWhereInput
	case 1:
		return predicates[0], nil
	default:
		return usagelog.And(predicates...), nil
	}
}

// UserWhereInput represents a where input for filtering User queries.
type UserWhereInput struct {
	Predicates []predicate.User  `json:"-"`
	Not        *UserWhereInput   `json:"not,omitempty"`
	Or         []*UserWhereInput `json:"or,omitempty"`
	And        []*UserWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt      *int  `json:"deletedAt,omitempty"`
	DeletedAtNEQ   *int  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn    []int `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn []int `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT    *int  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE   *int  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT    *int  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE   *int  `json:"deletedAtLTE,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "status" field predicates.
	Status      *user.Status  `json:"status,omitempty"`
	StatusNEQ   *user.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []user.Status `json:"statusIn,omitempty"`
	StatusNotIn []user.Status `json:"statusNotIn,omitempty"`

	// "prefer_language" field predicates.
	PreferLanguage             *string  `json:"preferLanguage,omitempty"`
	PreferLanguageNEQ          *string  `json:"preferLanguageNEQ,omitempty"`
	PreferLanguageIn           []string `json:"preferLanguageIn,omitempty"`
	PreferLanguageNotIn        []string `json:"preferLanguageNotIn,omitempty"`
	PreferLanguageGT           *string  `json:"preferLanguageGT,omitempty"`
	PreferLanguageGTE          *string  `json:"preferLanguageGTE,omitempty"`
	PreferLanguageLT           *string  `json:"preferLanguageLT,omitempty"`
	PreferLanguageLTE          *string  `json:"preferLanguageLTE,omitempty"`
	PreferLanguageContains     *string  `json:"preferLanguageContains,omitempty"`
	PreferLanguageHasPrefix    *string  `json:"preferLanguageHasPrefix,omitempty"`
	PreferLanguageHasSuffix    *string  `json:"preferLanguageHasSuffix,omitempty"`
	PreferLanguageEqualFold    *string  `json:"preferLanguageEqualFold,omitempty"`
	PreferLanguageContainsFold *string  `json:"preferLanguageContainsFold,omitempty"`

	// "password" field predicates.
	Password             *string  `json:"password,omitempty"`
	PasswordNEQ          *string  `json:"passwordNEQ,omitempty"`
	PasswordIn           []string `json:"passwordIn,omitempty"`
	PasswordNotIn        []string `json:"passwordNotIn,omitempty"`
	PasswordGT           *string  `json:"passwordGT,omitempty"`
	PasswordGTE          *string  `json:"passwordGTE,omitempty"`
	PasswordLT           *string  `json:"passwordLT,omitempty"`
	PasswordLTE          *string  `json:"passwordLTE,omitempty"`
	PasswordContains     *string  `json:"passwordContains,omitempty"`
	PasswordHasPrefix    *string  `json:"passwordHasPrefix,omitempty"`
	PasswordHasSuffix    *string  `json:"passwordHasSuffix,omitempty"`
	PasswordEqualFold    *string  `json:"passwordEqualFold,omitempty"`
	PasswordContainsFold *string  `json:"passwordContainsFold,omitempty"`

	// "first_name" field predicates.
	FirstName             *string  `json:"firstName,omitempty"`
	FirstNameNEQ          *string  `json:"firstNameNEQ,omitempty"`
	FirstNameIn           []string `json:"firstNameIn,omitempty"`
	FirstNameNotIn        []string `json:"firstNameNotIn,omitempty"`
	FirstNameGT           *string  `json:"firstNameGT,omitempty"`
	FirstNameGTE          *string  `json:"firstNameGTE,omitempty"`
	FirstNameLT           *string  `json:"firstNameLT,omitempty"`
	FirstNameLTE          *string  `json:"firstNameLTE,omitempty"`
	FirstNameContains     *string  `json:"firstNameContains,omitempty"`
	FirstNameHasPrefix    *string  `json:"firstNameHasPrefix,omitempty"`
	FirstNameHasSuffix    *string  `json:"firstNameHasSuffix,omitempty"`
	FirstNameEqualFold    *string  `json:"firstNameEqualFold,omitempty"`
	FirstNameContainsFold *string  `json:"firstNameContainsFold,omitempty"`

	// "last_name" field predicates.
	LastName             *string  `json:"lastName,omitempty"`
	LastNameNEQ          *string  `json:"lastNameNEQ,omitempty"`
	LastNameIn           []string `json:"lastNameIn,omitempty"`
	LastNameNotIn        []string `json:"lastNameNotIn,omitempty"`
	LastNameGT           *string  `json:"lastNameGT,omitempty"`
	LastNameGTE          *string  `json:"lastNameGTE,omitempty"`
	LastNameLT           *string  `json:"lastNameLT,omitempty"`
	LastNameLTE          *string  `json:"lastNameLTE,omitempty"`
	LastNameContains     *string  `json:"lastNameContains,omitempty"`
	LastNameHasPrefix    *string  `json:"lastNameHasPrefix,omitempty"`
	LastNameHasSuffix    *string  `json:"lastNameHasSuffix,omitempty"`
	LastNameEqualFold    *string  `json:"lastNameEqualFold,omitempty"`
	LastNameContainsFold *string  `json:"lastNameContainsFold,omitempty"`

	// "avatar" field predicates.
	Avatar             *string  `json:"avatar,omitempty"`
	AvatarNEQ          *string  `json:"avatarNEQ,omitempty"`
	AvatarIn           []string `json:"avatarIn,omitempty"`
	AvatarNotIn        []string `json:"avatarNotIn,omitempty"`
	AvatarGT           *string  `json:"avatarGT,omitempty"`
	AvatarGTE          *string  `json:"avatarGTE,omitempty"`
	AvatarLT           *string  `json:"avatarLT,omitempty"`
	AvatarLTE          *string  `json:"avatarLTE,omitempty"`
	AvatarContains     *string  `json:"avatarContains,omitempty"`
	AvatarHasPrefix    *string  `json:"avatarHasPrefix,omitempty"`
	AvatarHasSuffix    *string  `json:"avatarHasSuffix,omitempty"`
	AvatarIsNil        bool     `json:"avatarIsNil,omitempty"`
	AvatarNotNil       bool     `json:"avatarNotNil,omitempty"`
	AvatarEqualFold    *string  `json:"avatarEqualFold,omitempty"`
	AvatarContainsFold *string  `json:"avatarContainsFold,omitempty"`

	// "is_owner" field predicates.
	IsOwner    *bool `json:"isOwner,omitempty"`
	IsOwnerNEQ *bool `json:"isOwnerNEQ,omitempty"`

	// "projects" edge predicates.
	HasProjects     *bool                `json:"hasProjects,omitempty"`
	HasProjectsWith []*ProjectWhereInput `json:"hasProjectsWith,omitempty"`

	// "api_keys" edge predicates.
	HasAPIKeys     *bool               `json:"hasAPIKeys,omitempty"`
	HasAPIKeysWith []*APIKeyWhereInput `json:"hasAPIKeysWith,omitempty"`

	// "roles" edge predicates.
	HasRoles     *bool             `json:"hasRoles,omitempty"`
	HasRolesWith []*RoleWhereInput `json:"hasRolesWith,omitempty"`

	// "project_users" edge predicates.
	HasProjectUsers     *bool                    `json:"hasProjectUsers,omitempty"`
	HasProjectUsersWith []*UserProjectWhereInput `json:"hasProjectUsersWith,omitempty"`

	// "user_roles" edge predicates.
	HasUserRoles     *bool                 `json:"hasUserRoles,omitempty"`
	HasUserRolesWith []*UserRoleWhereInput `json:"hasUserRolesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserWhereInput) AddPredicates(predicates ...predicate.User) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserWhereInput filter on the UserQuery builder.
func (i *UserWhereInput) Filter(q *UserQuery) (*UserQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserWhereInput is returned in case the UserWhereInput is empty.
var ErrEmptyUserWhereInput = errors.New("ent: empty predicate UserWhereInput")

// P returns a predicate for filtering users.
// An error is returned if the input is empty or invalid.
func (i *UserWhereInput) P() (predicate.User, error) {
	var predicates []predicate.User
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, user.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.User, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, user.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.User, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, user.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, user.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, user.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, user.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, user.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, user.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, user.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, user.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, user.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, user.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, user.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, user.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, user.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, user.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, user.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, user.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, user.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, user.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, user.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, user.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, user.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, user.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, user.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, user.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, user.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, user.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, user.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, user.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, user.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, user.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, user.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, user.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, user.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.Email != nil {
		predicates = append(predicates, user.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, user.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, user.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, user.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, user.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, user.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, user.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, user.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, user.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, user.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, user.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, user.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, user.EmailContainsFold(*i.EmailContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, user.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, user.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, user.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, user.StatusNotIn(i.StatusNotIn...))
	}
	if i.PreferLanguage != nil {
		predicates = append(predicates, user.PreferLanguageEQ(*i.PreferLanguage))
	}
	if i.PreferLanguageNEQ != nil {
		predicates = append(predicates, user.PreferLanguageNEQ(*i.PreferLanguageNEQ))
	}
	if len(i.PreferLanguageIn) > 0 {
		predicates = append(predicates, user.PreferLanguageIn(i.PreferLanguageIn...))
	}
	if len(i.PreferLanguageNotIn) > 0 {
		predicates = append(predicates, user.PreferLanguageNotIn(i.PreferLanguageNotIn...))
	}
	if i.PreferLanguageGT != nil {
		predicates = append(predicates, user.PreferLanguageGT(*i.PreferLanguageGT))
	}
	if i.PreferLanguageGTE != nil {
		predicates = append(predicates, user.PreferLanguageGTE(*i.PreferLanguageGTE))
	}
	if i.PreferLanguageLT != nil {
		predicates = append(predicates, user.PreferLanguageLT(*i.PreferLanguageLT))
	}
	if i.PreferLanguageLTE != nil {
		predicates = append(predicates, user.PreferLanguageLTE(*i.PreferLanguageLTE))
	}
	if i.PreferLanguageContains != nil {
		predicates = append(predicates, user.PreferLanguageContains(*i.PreferLanguageContains))
	}
	if i.PreferLanguageHasPrefix != nil {
		predicates = append(predicates, user.PreferLanguageHasPrefix(*i.PreferLanguageHasPrefix))
	}
	if i.PreferLanguageHasSuffix != nil {
		predicates = append(predicates, user.PreferLanguageHasSuffix(*i.PreferLanguageHasSuffix))
	}
	if i.PreferLanguageEqualFold != nil {
		predicates = append(predicates, user.PreferLanguageEqualFold(*i.PreferLanguageEqualFold))
	}
	if i.PreferLanguageContainsFold != nil {
		predicates = append(predicates, user.PreferLanguageContainsFold(*i.PreferLanguageContainsFold))
	}
	if i.Password != nil {
		predicates = append(predicates, user.PasswordEQ(*i.Password))
	}
	if i.PasswordNEQ != nil {
		predicates = append(predicates, user.PasswordNEQ(*i.PasswordNEQ))
	}
	if len(i.PasswordIn) > 0 {
		predicates = append(predicates, user.PasswordIn(i.PasswordIn...))
	}
	if len(i.PasswordNotIn) > 0 {
		predicates = append(predicates, user.PasswordNotIn(i.PasswordNotIn...))
	}
	if i.PasswordGT != nil {
		predicates = append(predicates, user.PasswordGT(*i.PasswordGT))
	}
	if i.PasswordGTE != nil {
		predicates = append(predicates, user.PasswordGTE(*i.PasswordGTE))
	}
	if i.PasswordLT != nil {
		predicates = append(predicates, user.PasswordLT(*i.PasswordLT))
	}
	if i.PasswordLTE != nil {
		predicates = append(predicates, user.PasswordLTE(*i.PasswordLTE))
	}
	if i.PasswordContains != nil {
		predicates = append(predicates, user.PasswordContains(*i.PasswordContains))
	}
	if i.PasswordHasPrefix != nil {
		predicates = append(predicates, user.PasswordHasPrefix(*i.PasswordHasPrefix))
	}
	if i.PasswordHasSuffix != nil {
		predicates = append(predicates, user.PasswordHasSuffix(*i.PasswordHasSuffix))
	}
	if i.PasswordEqualFold != nil {
		predicates = append(predicates, user.PasswordEqualFold(*i.PasswordEqualFold))
	}
	if i.PasswordContainsFold != nil {
		predicates = append(predicates, user.PasswordContainsFold(*i.PasswordContainsFold))
	}
	if i.FirstName != nil {
		predicates = append(predicates, user.FirstNameEQ(*i.FirstName))
	}
	if i.FirstNameNEQ != nil {
		predicates = append(predicates, user.FirstNameNEQ(*i.FirstNameNEQ))
	}
	if len(i.FirstNameIn) > 0 {
		predicates = append(predicates, user.FirstNameIn(i.FirstNameIn...))
	}
	if len(i.FirstNameNotIn) > 0 {
		predicates = append(predicates, user.FirstNameNotIn(i.FirstNameNotIn...))
	}
	if i.FirstNameGT != nil {
		predicates = append(predicates, user.FirstNameGT(*i.FirstNameGT))
	}
	if i.FirstNameGTE != nil {
		predicates = append(predicates, user.FirstNameGTE(*i.FirstNameGTE))
	}
	if i.FirstNameLT != nil {
		predicates = append(predicates, user.FirstNameLT(*i.FirstNameLT))
	}
	if i.FirstNameLTE != nil {
		predicates = append(predicates, user.FirstNameLTE(*i.FirstNameLTE))
	}
	if i.FirstNameContains != nil {
		predicates = append(predicates, user.FirstNameContains(*i.FirstNameContains))
	}
	if i.FirstNameHasPrefix != nil {
		predicates = append(predicates, user.FirstNameHasPrefix(*i.FirstNameHasPrefix))
	}
	if i.FirstNameHasSuffix != nil {
		predicates = append(predicates, user.FirstNameHasSuffix(*i.FirstNameHasSuffix))
	}
	if i.FirstNameEqualFold != nil {
		predicates = append(predicates, user.FirstNameEqualFold(*i.FirstNameEqualFold))
	}
	if i.FirstNameContainsFold != nil {
		predicates = append(predicates, user.FirstNameContainsFold(*i.FirstNameContainsFold))
	}
	if i.LastName != nil {
		predicates = append(predicates, user.LastNameEQ(*i.LastName))
	}
	if i.LastNameNEQ != nil {
		predicates = append(predicates, user.LastNameNEQ(*i.LastNameNEQ))
	}
	if len(i.LastNameIn) > 0 {
		predicates = append(predicates, user.LastNameIn(i.LastNameIn...))
	}
	if len(i.LastNameNotIn) > 0 {
		predicates = append(predicates, user.LastNameNotIn(i.LastNameNotIn...))
	}
	if i.LastNameGT != nil {
		predicates = append(predicates, user.LastNameGT(*i.LastNameGT))
	}
	if i.LastNameGTE != nil {
		predicates = append(predicates, user.LastNameGTE(*i.LastNameGTE))
	}
	if i.LastNameLT != nil {
		predicates = append(predicates, user.LastNameLT(*i.LastNameLT))
	}
	if i.LastNameLTE != nil {
		predicates = append(predicates, user.LastNameLTE(*i.LastNameLTE))
	}
	if i.LastNameContains != nil {
		predicates = append(predicates, user.LastNameContains(*i.LastNameContains))
	}
	if i.LastNameHasPrefix != nil {
		predicates = append(predicates, user.LastNameHasPrefix(*i.LastNameHasPrefix))
	}
	if i.LastNameHasSuffix != nil {
		predicates = append(predicates, user.LastNameHasSuffix(*i.LastNameHasSuffix))
	}
	if i.LastNameEqualFold != nil {
		predicates = append(predicates, user.LastNameEqualFold(*i.LastNameEqualFold))
	}
	if i.LastNameContainsFold != nil {
		predicates = append(predicates, user.LastNameContainsFold(*i.LastNameContainsFold))
	}
	if i.Avatar != nil {
		predicates = append(predicates, user.AvatarEQ(*i.Avatar))
	}
	if i.AvatarNEQ != nil {
		predicates = append(predicates, user.AvatarNEQ(*i.AvatarNEQ))
	}
	if len(i.AvatarIn) > 0 {
		predicates = append(predicates, user.AvatarIn(i.AvatarIn...))
	}
	if len(i.AvatarNotIn) > 0 {
		predicates = append(predicates, user.AvatarNotIn(i.AvatarNotIn...))
	}
	if i.AvatarGT != nil {
		predicates = append(predicates, user.AvatarGT(*i.AvatarGT))
	}
	if i.AvatarGTE != nil {
		predicates = append(predicates, user.AvatarGTE(*i.AvatarGTE))
	}
	if i.AvatarLT != nil {
		predicates = append(predicates, user.AvatarLT(*i.AvatarLT))
	}
	if i.AvatarLTE != nil {
		predicates = append(predicates, user.AvatarLTE(*i.AvatarLTE))
	}
	if i.AvatarContains != nil {
		predicates = append(predicates, user.AvatarContains(*i.AvatarContains))
	}
	if i.AvatarHasPrefix != nil {
		predicates = append(predicates, user.AvatarHasPrefix(*i.AvatarHasPrefix))
	}
	if i.AvatarHasSuffix != nil {
		predicates = append(predicates, user.AvatarHasSuffix(*i.AvatarHasSuffix))
	}
	if i.AvatarIsNil {
		predicates = append(predicates, user.AvatarIsNil())
	}
	if i.AvatarNotNil {
		predicates = append(predicates, user.AvatarNotNil())
	}
	if i.AvatarEqualFold != nil {
		predicates = append(predicates, user.AvatarEqualFold(*i.AvatarEqualFold))
	}
	if i.AvatarContainsFold != nil {
		predicates = append(predicates, user.AvatarContainsFold(*i.AvatarContainsFold))
	}
	if i.IsOwner != nil {
		predicates = append(predicates, user.IsOwnerEQ(*i.IsOwner))
	}
	if i.IsOwnerNEQ != nil {
		predicates = append(predicates, user.IsOwnerNEQ(*i.IsOwnerNEQ))
	}

	if i.HasProjects != nil {
		p := user.HasProjects()
		if !*i.HasProjects {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProjectsWith) > 0 {
		with := make([]predicate.Project, 0, len(i.HasProjectsWith))
		for _, w := range i.HasProjectsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProjectsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasProjectsWith(with...))
	}
	if i.HasAPIKeys != nil {
		p := user.HasAPIKeys()
		if !*i.HasAPIKeys {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAPIKeysWith) > 0 {
		with := make([]predicate.APIKey, 0, len(i.HasAPIKeysWith))
		for _, w := range i.HasAPIKeysWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAPIKeysWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasAPIKeysWith(with...))
	}
	if i.HasRoles != nil {
		p := user.HasRoles()
		if !*i.HasRoles {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRolesWith) > 0 {
		with := make([]predicate.Role, 0, len(i.HasRolesWith))
		for _, w := range i.HasRolesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRolesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasRolesWith(with...))
	}
	if i.HasProjectUsers != nil {
		p := user.HasProjectUsers()
		if !*i.HasProjectUsers {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProjectUsersWith) > 0 {
		with := make([]predicate.UserProject, 0, len(i.HasProjectUsersWith))
		for _, w := range i.HasProjectUsersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProjectUsersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasProjectUsersWith(with...))
	}
	if i.HasUserRoles != nil {
		p := user.HasUserRoles()
		if !*i.HasUserRoles {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserRolesWith) > 0 {
		with := make([]predicate.UserRole, 0, len(i.HasUserRolesWith))
		for _, w := range i.HasUserRolesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserRolesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasUserRolesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserWhereInput
	case 1:
		return predicates[0], nil
	default:
		return user.And(predicates...), nil
	}
}

// UserProjectWhereInput represents a where input for filtering UserProject queries.
type UserProjectWhereInput struct {
	Predicates []predicate.UserProject  `json:"-"`
	Not        *UserProjectWhereInput   `json:"not,omitempty"`
	Or         []*UserProjectWhereInput `json:"or,omitempty"`
	And        []*UserProjectWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt      *int  `json:"deletedAt,omitempty"`
	DeletedAtNEQ   *int  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn    []int `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn []int `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT    *int  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE   *int  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT    *int  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE   *int  `json:"deletedAtLTE,omitempty"`

	// "user_id" field predicates.
	UserID      *int  `json:"userID,omitempty"`
	UserIDNEQ   *int  `json:"userIDNEQ,omitempty"`
	UserIDIn    []int `json:"userIDIn,omitempty"`
	UserIDNotIn []int `json:"userIDNotIn,omitempty"`

	// "project_id" field predicates.
	ProjectID      *int  `json:"projectID,omitempty"`
	ProjectIDNEQ   *int  `json:"projectIDNEQ,omitempty"`
	ProjectIDIn    []int `json:"projectIDIn,omitempty"`
	ProjectIDNotIn []int `json:"projectIDNotIn,omitempty"`

	// "is_owner" field predicates.
	IsOwner    *bool `json:"isOwner,omitempty"`
	IsOwnerNEQ *bool `json:"isOwnerNEQ,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`

	// "project" edge predicates.
	HasProject     *bool                `json:"hasProject,omitempty"`
	HasProjectWith []*ProjectWhereInput `json:"hasProjectWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserProjectWhereInput) AddPredicates(predicates ...predicate.UserProject) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserProjectWhereInput filter on the UserProjectQuery builder.
func (i *UserProjectWhereInput) Filter(q *UserProjectQuery) (*UserProjectQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserProjectWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserProjectWhereInput is returned in case the UserProjectWhereInput is empty.
var ErrEmptyUserProjectWhereInput = errors.New("ent: empty predicate UserProjectWhereInput")

// P returns a predicate for filtering userprojects.
// An error is returned if the input is empty or invalid.
func (i *UserProjectWhereInput) P() (predicate.UserProject, error) {
	var predicates []predicate.UserProject
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, userproject.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.UserProject, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, userproject.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.UserProject, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, userproject.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, userproject.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, userproject.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, userproject.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, userproject.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, userproject.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, userproject.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, userproject.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, userproject.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, userproject.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, userproject.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, userproject.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, userproject.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, userproject.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, userproject.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, userproject.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, userproject.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, userproject.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, userproject.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, userproject.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, userproject.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, userproject.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, userproject.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, userproject.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, userproject.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, userproject.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, userproject.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, userproject.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, userproject.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, userproject.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, userproject.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, userproject.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, userproject.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.UserID != nil {
		predicates = append(predicates, userproject.UserIDEQ(*i.UserID))
	}
	if i.UserIDNEQ != nil {
		predicates = append(predicates, userproject.UserIDNEQ(*i.UserIDNEQ))
	}
	if len(i.UserIDIn) > 0 {
		predicates = append(predicates, userproject.UserIDIn(i.UserIDIn...))
	}
	if len(i.UserIDNotIn) > 0 {
		predicates = append(predicates, userproject.UserIDNotIn(i.UserIDNotIn...))
	}
	if i.ProjectID != nil {
		predicates = append(predicates, userproject.ProjectIDEQ(*i.ProjectID))
	}
	if i.ProjectIDNEQ != nil {
		predicates = append(predicates, userproject.ProjectIDNEQ(*i.ProjectIDNEQ))
	}
	if len(i.ProjectIDIn) > 0 {
		predicates = append(predicates, userproject.ProjectIDIn(i.ProjectIDIn...))
	}
	if len(i.ProjectIDNotIn) > 0 {
		predicates = append(predicates, userproject.ProjectIDNotIn(i.ProjectIDNotIn...))
	}
	if i.IsOwner != nil {
		predicates = append(predicates, userproject.IsOwnerEQ(*i.IsOwner))
	}
	if i.IsOwnerNEQ != nil {
		predicates = append(predicates, userproject.IsOwnerNEQ(*i.IsOwnerNEQ))
	}

	if i.HasUser != nil {
		p := userproject.HasUser()
		if !*i.HasUser {
			p = userproject.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, userproject.HasUserWith(with...))
	}
	if i.HasProject != nil {
		p := userproject.HasProject()
		if !*i.HasProject {
			p = userproject.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProjectWith) > 0 {
		with := make([]predicate.Project, 0, len(i.HasProjectWith))
		for _, w := range i.HasProjectWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProjectWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, userproject.HasProjectWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserProjectWhereInput
	case 1:
		return predicates[0], nil
	default:
		return userproject.And(predicates...), nil
	}
}

// UserRoleWhereInput represents a where input for filtering UserRole queries.
type UserRoleWhereInput struct {
	Predicates []predicate.UserRole  `json:"-"`
	Not        *UserRoleWhereInput   `json:"not,omitempty"`
	Or         []*UserRoleWhereInput `json:"or,omitempty"`
	And        []*UserRoleWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt      *int  `json:"deletedAt,omitempty"`
	DeletedAtNEQ   *int  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn    []int `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn []int `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT    *int  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE   *int  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT    *int  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE   *int  `json:"deletedAtLTE,omitempty"`

	// "user_id" field predicates.
	UserID      *int  `json:"userID,omitempty"`
	UserIDNEQ   *int  `json:"userIDNEQ,omitempty"`
	UserIDIn    []int `json:"userIDIn,omitempty"`
	UserIDNotIn []int `json:"userIDNotIn,omitempty"`

	// "role_id" field predicates.
	RoleID      *int  `json:"roleID,omitempty"`
	RoleIDNEQ   *int  `json:"roleIDNEQ,omitempty"`
	RoleIDIn    []int `json:"roleIDIn,omitempty"`
	RoleIDNotIn []int `json:"roleIDNotIn,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`

	// "role" edge predicates.
	HasRole     *bool             `json:"hasRole,omitempty"`
	HasRoleWith []*RoleWhereInput `json:"hasRoleWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserRoleWhereInput) AddPredicates(predicates ...predicate.UserRole) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserRoleWhereInput filter on the UserRoleQuery builder.
func (i *UserRoleWhereInput) Filter(q *UserRoleQuery) (*UserRoleQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserRoleWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserRoleWhereInput is returned in case the UserRoleWhereInput is empty.
var ErrEmptyUserRoleWhereInput = errors.New("ent: empty predicate UserRoleWhereInput")

// P returns a predicate for filtering userroles.
// An error is returned if the input is empty or invalid.
func (i *UserRoleWhereInput) P() (predicate.UserRole, error) {
	var predicates []predicate.UserRole
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, userrole.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.UserRole, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, userrole.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.UserRole, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, userrole.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, userrole.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, userrole.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, userrole.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, userrole.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, userrole.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, userrole.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, userrole.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, userrole.IDLTE(*i.IDLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, userrole.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, userrole.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, userrole.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, userrole.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, userrole.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, userrole.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, userrole.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, userrole.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.UserID != nil {
		predicates = append(predicates, userrole.UserIDEQ(*i.UserID))
	}
	if i.UserIDNEQ != nil {
		predicates = append(predicates, userrole.UserIDNEQ(*i.UserIDNEQ))
	}
	if len(i.UserIDIn) > 0 {
		predicates = append(predicates, userrole.UserIDIn(i.UserIDIn...))
	}
	if len(i.UserIDNotIn) > 0 {
		predicates = append(predicates, userrole.UserIDNotIn(i.UserIDNotIn...))
	}
	if i.RoleID != nil {
		predicates = append(predicates, userrole.RoleIDEQ(*i.RoleID))
	}
	if i.RoleIDNEQ != nil {
		predicates = append(predicates, userrole.RoleIDNEQ(*i.RoleIDNEQ))
	}
	if len(i.RoleIDIn) > 0 {
		predicates = append(predicates, userrole.RoleIDIn(i.RoleIDIn...))
	}
	if len(i.RoleIDNotIn) > 0 {
		predicates = append(predicates, userrole.RoleIDNotIn(i.RoleIDNotIn...))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, userrole.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, userrole.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, userrole.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, userrole.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, userrole.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, userrole.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, userrole.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, userrole.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, userrole.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, userrole.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, userrole.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, userrole.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, userrole.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, userrole.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, userrole.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, userrole.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, userrole.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, userrole.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, userrole.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, userrole.UpdatedAtNotNil())
	}

	if i.HasUser != nil {
		p := userrole.HasUser()
		if !*i.HasUser {
			p = userrole.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, userrole.HasUserWith(with...))
	}
	if i.HasRole != nil {
		p := userrole.HasRole()
		if !*i.HasRole {
			p = userrole.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRoleWith) > 0 {
		with := make([]predicate.Role, 0, len(i.HasRoleWith))
		for _, w := range i.HasRoleWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRoleWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, userrole.HasRoleWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserRoleWhereInput
	case 1:
		return predicates[0], nil
	default:
		return userrole.And(predicates...), nil
	}
}
