// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/looplj/axonhub/internal/ent/apikey"
	"github.com/looplj/axonhub/internal/ent/channel"
	"github.com/looplj/axonhub/internal/ent/predicate"
	"github.com/looplj/axonhub/internal/ent/project"
	"github.com/looplj/axonhub/internal/ent/request"
	"github.com/looplj/axonhub/internal/ent/requestexecution"
	"github.com/looplj/axonhub/internal/ent/role"
	"github.com/looplj/axonhub/internal/ent/system"
	"github.com/looplj/axonhub/internal/ent/thread"
	"github.com/looplj/axonhub/internal/ent/trace"
	"github.com/looplj/axonhub/internal/ent/usagelog"
	"github.com/looplj/axonhub/internal/ent/user"
	"github.com/looplj/axonhub/internal/ent/userproject"
	"github.com/looplj/axonhub/internal/ent/userrole"
	"github.com/looplj/axonhub/internal/objects"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAPIKey           = "APIKey"
	TypeChannel          = "Channel"
	TypeProject          = "Project"
	TypeRequest          = "Request"
	TypeRequestExecution = "RequestExecution"
	TypeRole             = "Role"
	TypeSystem           = "System"
	TypeThread           = "Thread"
	TypeTrace            = "Trace"
	TypeUsageLog         = "UsageLog"
	TypeUser             = "User"
	TypeUserProject      = "UserProject"
	TypeUserRole         = "UserRole"
)

// APIKeyMutation represents an operation that mutates the APIKey nodes in the graph.
type APIKeyMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *int
	adddeleted_at   *int
	key             *string
	name            *string
	status          *apikey.Status
	scopes          *[]string
	appendscopes    []string
	profiles        **objects.APIKeyProfiles
	clearedFields   map[string]struct{}
	user            *int
	cleareduser     bool
	project         *int
	clearedproject  bool
	requests        map[int]struct{}
	removedrequests map[int]struct{}
	clearedrequests bool
	done            bool
	oldValue        func(context.Context) (*APIKey, error)
	predicates      []predicate.APIKey
}

var _ ent.Mutation = (*APIKeyMutation)(nil)

// apikeyOption allows management of the mutation configuration using functional options.
type apikeyOption func(*APIKeyMutation)

// newAPIKeyMutation creates new mutation for the APIKey entity.
func newAPIKeyMutation(c config, op Op, opts ...apikeyOption) *APIKeyMutation {
	m := &APIKeyMutation{
		config:        c,
		op:            op,
		typ:           TypeAPIKey,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAPIKeyID sets the ID field of the mutation.
func withAPIKeyID(id int) apikeyOption {
	return func(m *APIKeyMutation) {
		var (
			err   error
			once  sync.Once
			value *APIKey
		)
		m.oldValue = func(ctx context.Context) (*APIKey, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().APIKey.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAPIKey sets the old APIKey of the mutation.
func withAPIKey(node *APIKey) apikeyOption {
	return func(m *APIKeyMutation) {
		m.oldValue = func(context.Context) (*APIKey, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m APIKeyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m APIKeyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *APIKeyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *APIKeyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().APIKey.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *APIKeyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *APIKeyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *APIKeyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *APIKeyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *APIKeyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *APIKeyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *APIKeyMutation) SetDeletedAt(i int) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *APIKeyMutation) DeletedAt() (r int, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldDeletedAt(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *APIKeyMutation) AddDeletedAt(i int) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *APIKeyMutation) AddedDeletedAt() (r int, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *APIKeyMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetUserID sets the "user_id" field.
func (m *APIKeyMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *APIKeyMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *APIKeyMutation) ResetUserID() {
	m.user = nil
}

// SetProjectID sets the "project_id" field.
func (m *APIKeyMutation) SetProjectID(i int) {
	m.project = &i
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *APIKeyMutation) ProjectID() (r int, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldProjectID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *APIKeyMutation) ResetProjectID() {
	m.project = nil
}

// SetKey sets the "key" field.
func (m *APIKeyMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *APIKeyMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *APIKeyMutation) ResetKey() {
	m.key = nil
}

// SetName sets the "name" field.
func (m *APIKeyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *APIKeyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *APIKeyMutation) ResetName() {
	m.name = nil
}

// SetStatus sets the "status" field.
func (m *APIKeyMutation) SetStatus(a apikey.Status) {
	m.status = &a
}

// Status returns the value of the "status" field in the mutation.
func (m *APIKeyMutation) Status() (r apikey.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldStatus(ctx context.Context) (v apikey.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *APIKeyMutation) ResetStatus() {
	m.status = nil
}

// SetScopes sets the "scopes" field.
func (m *APIKeyMutation) SetScopes(s []string) {
	m.scopes = &s
	m.appendscopes = nil
}

// Scopes returns the value of the "scopes" field in the mutation.
func (m *APIKeyMutation) Scopes() (r []string, exists bool) {
	v := m.scopes
	if v == nil {
		return
	}
	return *v, true
}

// OldScopes returns the old "scopes" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldScopes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopes: %w", err)
	}
	return oldValue.Scopes, nil
}

// AppendScopes adds s to the "scopes" field.
func (m *APIKeyMutation) AppendScopes(s []string) {
	m.appendscopes = append(m.appendscopes, s...)
}

// AppendedScopes returns the list of values that were appended to the "scopes" field in this mutation.
func (m *APIKeyMutation) AppendedScopes() ([]string, bool) {
	if len(m.appendscopes) == 0 {
		return nil, false
	}
	return m.appendscopes, true
}

// ClearScopes clears the value of the "scopes" field.
func (m *APIKeyMutation) ClearScopes() {
	m.scopes = nil
	m.appendscopes = nil
	m.clearedFields[apikey.FieldScopes] = struct{}{}
}

// ScopesCleared returns if the "scopes" field was cleared in this mutation.
func (m *APIKeyMutation) ScopesCleared() bool {
	_, ok := m.clearedFields[apikey.FieldScopes]
	return ok
}

// ResetScopes resets all changes to the "scopes" field.
func (m *APIKeyMutation) ResetScopes() {
	m.scopes = nil
	m.appendscopes = nil
	delete(m.clearedFields, apikey.FieldScopes)
}

// SetProfiles sets the "profiles" field.
func (m *APIKeyMutation) SetProfiles(okp *objects.APIKeyProfiles) {
	m.profiles = &okp
}

// Profiles returns the value of the "profiles" field in the mutation.
func (m *APIKeyMutation) Profiles() (r *objects.APIKeyProfiles, exists bool) {
	v := m.profiles
	if v == nil {
		return
	}
	return *v, true
}

// OldProfiles returns the old "profiles" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldProfiles(ctx context.Context) (v *objects.APIKeyProfiles, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfiles is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfiles requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfiles: %w", err)
	}
	return oldValue.Profiles, nil
}

// ClearProfiles clears the value of the "profiles" field.
func (m *APIKeyMutation) ClearProfiles() {
	m.profiles = nil
	m.clearedFields[apikey.FieldProfiles] = struct{}{}
}

// ProfilesCleared returns if the "profiles" field was cleared in this mutation.
func (m *APIKeyMutation) ProfilesCleared() bool {
	_, ok := m.clearedFields[apikey.FieldProfiles]
	return ok
}

// ResetProfiles resets all changes to the "profiles" field.
func (m *APIKeyMutation) ResetProfiles() {
	m.profiles = nil
	delete(m.clearedFields, apikey.FieldProfiles)
}

// ClearUser clears the "user" edge to the User entity.
func (m *APIKeyMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[apikey.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *APIKeyMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *APIKeyMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *APIKeyMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearProject clears the "project" edge to the Project entity.
func (m *APIKeyMutation) ClearProject() {
	m.clearedproject = true
	m.clearedFields[apikey.FieldProjectID] = struct{}{}
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *APIKeyMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *APIKeyMutation) ProjectIDs() (ids []int) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *APIKeyMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// AddRequestIDs adds the "requests" edge to the Request entity by ids.
func (m *APIKeyMutation) AddRequestIDs(ids ...int) {
	if m.requests == nil {
		m.requests = make(map[int]struct{})
	}
	for i := range ids {
		m.requests[ids[i]] = struct{}{}
	}
}

// ClearRequests clears the "requests" edge to the Request entity.
func (m *APIKeyMutation) ClearRequests() {
	m.clearedrequests = true
}

// RequestsCleared reports if the "requests" edge to the Request entity was cleared.
func (m *APIKeyMutation) RequestsCleared() bool {
	return m.clearedrequests
}

// RemoveRequestIDs removes the "requests" edge to the Request entity by IDs.
func (m *APIKeyMutation) RemoveRequestIDs(ids ...int) {
	if m.removedrequests == nil {
		m.removedrequests = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.requests, ids[i])
		m.removedrequests[ids[i]] = struct{}{}
	}
}

// RemovedRequests returns the removed IDs of the "requests" edge to the Request entity.
func (m *APIKeyMutation) RemovedRequestsIDs() (ids []int) {
	for id := range m.removedrequests {
		ids = append(ids, id)
	}
	return
}

// RequestsIDs returns the "requests" edge IDs in the mutation.
func (m *APIKeyMutation) RequestsIDs() (ids []int) {
	for id := range m.requests {
		ids = append(ids, id)
	}
	return
}

// ResetRequests resets all changes to the "requests" edge.
func (m *APIKeyMutation) ResetRequests() {
	m.requests = nil
	m.clearedrequests = false
	m.removedrequests = nil
}

// Where appends a list predicates to the APIKeyMutation builder.
func (m *APIKeyMutation) Where(ps ...predicate.APIKey) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the APIKeyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *APIKeyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.APIKey, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *APIKeyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *APIKeyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (APIKey).
func (m *APIKeyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *APIKeyMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, apikey.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, apikey.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, apikey.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, apikey.FieldUserID)
	}
	if m.project != nil {
		fields = append(fields, apikey.FieldProjectID)
	}
	if m.key != nil {
		fields = append(fields, apikey.FieldKey)
	}
	if m.name != nil {
		fields = append(fields, apikey.FieldName)
	}
	if m.status != nil {
		fields = append(fields, apikey.FieldStatus)
	}
	if m.scopes != nil {
		fields = append(fields, apikey.FieldScopes)
	}
	if m.profiles != nil {
		fields = append(fields, apikey.FieldProfiles)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *APIKeyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case apikey.FieldCreatedAt:
		return m.CreatedAt()
	case apikey.FieldUpdatedAt:
		return m.UpdatedAt()
	case apikey.FieldDeletedAt:
		return m.DeletedAt()
	case apikey.FieldUserID:
		return m.UserID()
	case apikey.FieldProjectID:
		return m.ProjectID()
	case apikey.FieldKey:
		return m.Key()
	case apikey.FieldName:
		return m.Name()
	case apikey.FieldStatus:
		return m.Status()
	case apikey.FieldScopes:
		return m.Scopes()
	case apikey.FieldProfiles:
		return m.Profiles()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *APIKeyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case apikey.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case apikey.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case apikey.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case apikey.FieldUserID:
		return m.OldUserID(ctx)
	case apikey.FieldProjectID:
		return m.OldProjectID(ctx)
	case apikey.FieldKey:
		return m.OldKey(ctx)
	case apikey.FieldName:
		return m.OldName(ctx)
	case apikey.FieldStatus:
		return m.OldStatus(ctx)
	case apikey.FieldScopes:
		return m.OldScopes(ctx)
	case apikey.FieldProfiles:
		return m.OldProfiles(ctx)
	}
	return nil, fmt.Errorf("unknown APIKey field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *APIKeyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case apikey.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case apikey.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case apikey.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case apikey.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case apikey.FieldProjectID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case apikey.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case apikey.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case apikey.FieldStatus:
		v, ok := value.(apikey.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case apikey.FieldScopes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopes(v)
		return nil
	case apikey.FieldProfiles:
		v, ok := value.(*objects.APIKeyProfiles)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfiles(v)
		return nil
	}
	return fmt.Errorf("unknown APIKey field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *APIKeyMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, apikey.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *APIKeyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case apikey.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *APIKeyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case apikey.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown APIKey numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *APIKeyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(apikey.FieldScopes) {
		fields = append(fields, apikey.FieldScopes)
	}
	if m.FieldCleared(apikey.FieldProfiles) {
		fields = append(fields, apikey.FieldProfiles)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *APIKeyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *APIKeyMutation) ClearField(name string) error {
	switch name {
	case apikey.FieldScopes:
		m.ClearScopes()
		return nil
	case apikey.FieldProfiles:
		m.ClearProfiles()
		return nil
	}
	return fmt.Errorf("unknown APIKey nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *APIKeyMutation) ResetField(name string) error {
	switch name {
	case apikey.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case apikey.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case apikey.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case apikey.FieldUserID:
		m.ResetUserID()
		return nil
	case apikey.FieldProjectID:
		m.ResetProjectID()
		return nil
	case apikey.FieldKey:
		m.ResetKey()
		return nil
	case apikey.FieldName:
		m.ResetName()
		return nil
	case apikey.FieldStatus:
		m.ResetStatus()
		return nil
	case apikey.FieldScopes:
		m.ResetScopes()
		return nil
	case apikey.FieldProfiles:
		m.ResetProfiles()
		return nil
	}
	return fmt.Errorf("unknown APIKey field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *APIKeyMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user != nil {
		edges = append(edges, apikey.EdgeUser)
	}
	if m.project != nil {
		edges = append(edges, apikey.EdgeProject)
	}
	if m.requests != nil {
		edges = append(edges, apikey.EdgeRequests)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *APIKeyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case apikey.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case apikey.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case apikey.EdgeRequests:
		ids := make([]ent.Value, 0, len(m.requests))
		for id := range m.requests {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *APIKeyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedrequests != nil {
		edges = append(edges, apikey.EdgeRequests)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *APIKeyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case apikey.EdgeRequests:
		ids := make([]ent.Value, 0, len(m.removedrequests))
		for id := range m.removedrequests {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *APIKeyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, apikey.EdgeUser)
	}
	if m.clearedproject {
		edges = append(edges, apikey.EdgeProject)
	}
	if m.clearedrequests {
		edges = append(edges, apikey.EdgeRequests)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *APIKeyMutation) EdgeCleared(name string) bool {
	switch name {
	case apikey.EdgeUser:
		return m.cleareduser
	case apikey.EdgeProject:
		return m.clearedproject
	case apikey.EdgeRequests:
		return m.clearedrequests
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *APIKeyMutation) ClearEdge(name string) error {
	switch name {
	case apikey.EdgeUser:
		m.ClearUser()
		return nil
	case apikey.EdgeProject:
		m.ClearProject()
		return nil
	}
	return fmt.Errorf("unknown APIKey unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *APIKeyMutation) ResetEdge(name string) error {
	switch name {
	case apikey.EdgeUser:
		m.ResetUser()
		return nil
	case apikey.EdgeProject:
		m.ResetProject()
		return nil
	case apikey.EdgeRequests:
		m.ResetRequests()
		return nil
	}
	return fmt.Errorf("unknown APIKey edge %s", name)
}

// ChannelMutation represents an operation that mutates the Channel nodes in the graph.
type ChannelMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	created_at             *time.Time
	updated_at             *time.Time
	deleted_at             *int
	adddeleted_at          *int
	_type                  *channel.Type
	base_url               *string
	name                   *string
	status                 *channel.Status
	credentials            **objects.ChannelCredentials
	supported_models       *[]string
	appendsupported_models []string
	default_test_model     *string
	settings               **objects.ChannelSettings
	ordering_weight        *int
	addordering_weight     *int
	clearedFields          map[string]struct{}
	requests               map[int]struct{}
	removedrequests        map[int]struct{}
	clearedrequests        bool
	executions             map[int]struct{}
	removedexecutions      map[int]struct{}
	clearedexecutions      bool
	usage_logs             map[int]struct{}
	removedusage_logs      map[int]struct{}
	clearedusage_logs      bool
	done                   bool
	oldValue               func(context.Context) (*Channel, error)
	predicates             []predicate.Channel
}

var _ ent.Mutation = (*ChannelMutation)(nil)

// channelOption allows management of the mutation configuration using functional options.
type channelOption func(*ChannelMutation)

// newChannelMutation creates new mutation for the Channel entity.
func newChannelMutation(c config, op Op, opts ...channelOption) *ChannelMutation {
	m := &ChannelMutation{
		config:        c,
		op:            op,
		typ:           TypeChannel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChannelID sets the ID field of the mutation.
func withChannelID(id int) channelOption {
	return func(m *ChannelMutation) {
		var (
			err   error
			once  sync.Once
			value *Channel
		)
		m.oldValue = func(ctx context.Context) (*Channel, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Channel.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChannel sets the old Channel of the mutation.
func withChannel(node *Channel) channelOption {
	return func(m *ChannelMutation) {
		m.oldValue = func(context.Context) (*Channel, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChannelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChannelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChannelMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChannelMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Channel.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ChannelMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ChannelMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ChannelMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ChannelMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ChannelMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ChannelMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ChannelMutation) SetDeletedAt(i int) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ChannelMutation) DeletedAt() (r int, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldDeletedAt(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *ChannelMutation) AddDeletedAt(i int) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *ChannelMutation) AddedDeletedAt() (r int, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ChannelMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetType sets the "type" field.
func (m *ChannelMutation) SetType(c channel.Type) {
	m._type = &c
}

// GetType returns the value of the "type" field in the mutation.
func (m *ChannelMutation) GetType() (r channel.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldType(ctx context.Context) (v channel.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ChannelMutation) ResetType() {
	m._type = nil
}

// SetBaseURL sets the "base_url" field.
func (m *ChannelMutation) SetBaseURL(s string) {
	m.base_url = &s
}

// BaseURL returns the value of the "base_url" field in the mutation.
func (m *ChannelMutation) BaseURL() (r string, exists bool) {
	v := m.base_url
	if v == nil {
		return
	}
	return *v, true
}

// OldBaseURL returns the old "base_url" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldBaseURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaseURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaseURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaseURL: %w", err)
	}
	return oldValue.BaseURL, nil
}

// ClearBaseURL clears the value of the "base_url" field.
func (m *ChannelMutation) ClearBaseURL() {
	m.base_url = nil
	m.clearedFields[channel.FieldBaseURL] = struct{}{}
}

// BaseURLCleared returns if the "base_url" field was cleared in this mutation.
func (m *ChannelMutation) BaseURLCleared() bool {
	_, ok := m.clearedFields[channel.FieldBaseURL]
	return ok
}

// ResetBaseURL resets all changes to the "base_url" field.
func (m *ChannelMutation) ResetBaseURL() {
	m.base_url = nil
	delete(m.clearedFields, channel.FieldBaseURL)
}

// SetName sets the "name" field.
func (m *ChannelMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ChannelMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ChannelMutation) ResetName() {
	m.name = nil
}

// SetStatus sets the "status" field.
func (m *ChannelMutation) SetStatus(c channel.Status) {
	m.status = &c
}

// Status returns the value of the "status" field in the mutation.
func (m *ChannelMutation) Status() (r channel.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldStatus(ctx context.Context) (v channel.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ChannelMutation) ResetStatus() {
	m.status = nil
}

// SetCredentials sets the "credentials" field.
func (m *ChannelMutation) SetCredentials(oc *objects.ChannelCredentials) {
	m.credentials = &oc
}

// Credentials returns the value of the "credentials" field in the mutation.
func (m *ChannelMutation) Credentials() (r *objects.ChannelCredentials, exists bool) {
	v := m.credentials
	if v == nil {
		return
	}
	return *v, true
}

// OldCredentials returns the old "credentials" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldCredentials(ctx context.Context) (v *objects.ChannelCredentials, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCredentials is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCredentials requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCredentials: %w", err)
	}
	return oldValue.Credentials, nil
}

// ResetCredentials resets all changes to the "credentials" field.
func (m *ChannelMutation) ResetCredentials() {
	m.credentials = nil
}

// SetSupportedModels sets the "supported_models" field.
func (m *ChannelMutation) SetSupportedModels(s []string) {
	m.supported_models = &s
	m.appendsupported_models = nil
}

// SupportedModels returns the value of the "supported_models" field in the mutation.
func (m *ChannelMutation) SupportedModels() (r []string, exists bool) {
	v := m.supported_models
	if v == nil {
		return
	}
	return *v, true
}

// OldSupportedModels returns the old "supported_models" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldSupportedModels(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupportedModels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupportedModels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupportedModels: %w", err)
	}
	return oldValue.SupportedModels, nil
}

// AppendSupportedModels adds s to the "supported_models" field.
func (m *ChannelMutation) AppendSupportedModels(s []string) {
	m.appendsupported_models = append(m.appendsupported_models, s...)
}

// AppendedSupportedModels returns the list of values that were appended to the "supported_models" field in this mutation.
func (m *ChannelMutation) AppendedSupportedModels() ([]string, bool) {
	if len(m.appendsupported_models) == 0 {
		return nil, false
	}
	return m.appendsupported_models, true
}

// ResetSupportedModels resets all changes to the "supported_models" field.
func (m *ChannelMutation) ResetSupportedModels() {
	m.supported_models = nil
	m.appendsupported_models = nil
}

// SetDefaultTestModel sets the "default_test_model" field.
func (m *ChannelMutation) SetDefaultTestModel(s string) {
	m.default_test_model = &s
}

// DefaultTestModel returns the value of the "default_test_model" field in the mutation.
func (m *ChannelMutation) DefaultTestModel() (r string, exists bool) {
	v := m.default_test_model
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultTestModel returns the old "default_test_model" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldDefaultTestModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultTestModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultTestModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultTestModel: %w", err)
	}
	return oldValue.DefaultTestModel, nil
}

// ResetDefaultTestModel resets all changes to the "default_test_model" field.
func (m *ChannelMutation) ResetDefaultTestModel() {
	m.default_test_model = nil
}

// SetSettings sets the "settings" field.
func (m *ChannelMutation) SetSettings(os *objects.ChannelSettings) {
	m.settings = &os
}

// Settings returns the value of the "settings" field in the mutation.
func (m *ChannelMutation) Settings() (r *objects.ChannelSettings, exists bool) {
	v := m.settings
	if v == nil {
		return
	}
	return *v, true
}

// OldSettings returns the old "settings" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldSettings(ctx context.Context) (v *objects.ChannelSettings, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettings: %w", err)
	}
	return oldValue.Settings, nil
}

// ClearSettings clears the value of the "settings" field.
func (m *ChannelMutation) ClearSettings() {
	m.settings = nil
	m.clearedFields[channel.FieldSettings] = struct{}{}
}

// SettingsCleared returns if the "settings" field was cleared in this mutation.
func (m *ChannelMutation) SettingsCleared() bool {
	_, ok := m.clearedFields[channel.FieldSettings]
	return ok
}

// ResetSettings resets all changes to the "settings" field.
func (m *ChannelMutation) ResetSettings() {
	m.settings = nil
	delete(m.clearedFields, channel.FieldSettings)
}

// SetOrderingWeight sets the "ordering_weight" field.
func (m *ChannelMutation) SetOrderingWeight(i int) {
	m.ordering_weight = &i
	m.addordering_weight = nil
}

// OrderingWeight returns the value of the "ordering_weight" field in the mutation.
func (m *ChannelMutation) OrderingWeight() (r int, exists bool) {
	v := m.ordering_weight
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderingWeight returns the old "ordering_weight" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldOrderingWeight(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderingWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderingWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderingWeight: %w", err)
	}
	return oldValue.OrderingWeight, nil
}

// AddOrderingWeight adds i to the "ordering_weight" field.
func (m *ChannelMutation) AddOrderingWeight(i int) {
	if m.addordering_weight != nil {
		*m.addordering_weight += i
	} else {
		m.addordering_weight = &i
	}
}

// AddedOrderingWeight returns the value that was added to the "ordering_weight" field in this mutation.
func (m *ChannelMutation) AddedOrderingWeight() (r int, exists bool) {
	v := m.addordering_weight
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderingWeight resets all changes to the "ordering_weight" field.
func (m *ChannelMutation) ResetOrderingWeight() {
	m.ordering_weight = nil
	m.addordering_weight = nil
}

// AddRequestIDs adds the "requests" edge to the Request entity by ids.
func (m *ChannelMutation) AddRequestIDs(ids ...int) {
	if m.requests == nil {
		m.requests = make(map[int]struct{})
	}
	for i := range ids {
		m.requests[ids[i]] = struct{}{}
	}
}

// ClearRequests clears the "requests" edge to the Request entity.
func (m *ChannelMutation) ClearRequests() {
	m.clearedrequests = true
}

// RequestsCleared reports if the "requests" edge to the Request entity was cleared.
func (m *ChannelMutation) RequestsCleared() bool {
	return m.clearedrequests
}

// RemoveRequestIDs removes the "requests" edge to the Request entity by IDs.
func (m *ChannelMutation) RemoveRequestIDs(ids ...int) {
	if m.removedrequests == nil {
		m.removedrequests = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.requests, ids[i])
		m.removedrequests[ids[i]] = struct{}{}
	}
}

// RemovedRequests returns the removed IDs of the "requests" edge to the Request entity.
func (m *ChannelMutation) RemovedRequestsIDs() (ids []int) {
	for id := range m.removedrequests {
		ids = append(ids, id)
	}
	return
}

// RequestsIDs returns the "requests" edge IDs in the mutation.
func (m *ChannelMutation) RequestsIDs() (ids []int) {
	for id := range m.requests {
		ids = append(ids, id)
	}
	return
}

// ResetRequests resets all changes to the "requests" edge.
func (m *ChannelMutation) ResetRequests() {
	m.requests = nil
	m.clearedrequests = false
	m.removedrequests = nil
}

// AddExecutionIDs adds the "executions" edge to the RequestExecution entity by ids.
func (m *ChannelMutation) AddExecutionIDs(ids ...int) {
	if m.executions == nil {
		m.executions = make(map[int]struct{})
	}
	for i := range ids {
		m.executions[ids[i]] = struct{}{}
	}
}

// ClearExecutions clears the "executions" edge to the RequestExecution entity.
func (m *ChannelMutation) ClearExecutions() {
	m.clearedexecutions = true
}

// ExecutionsCleared reports if the "executions" edge to the RequestExecution entity was cleared.
func (m *ChannelMutation) ExecutionsCleared() bool {
	return m.clearedexecutions
}

// RemoveExecutionIDs removes the "executions" edge to the RequestExecution entity by IDs.
func (m *ChannelMutation) RemoveExecutionIDs(ids ...int) {
	if m.removedexecutions == nil {
		m.removedexecutions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.executions, ids[i])
		m.removedexecutions[ids[i]] = struct{}{}
	}
}

// RemovedExecutions returns the removed IDs of the "executions" edge to the RequestExecution entity.
func (m *ChannelMutation) RemovedExecutionsIDs() (ids []int) {
	for id := range m.removedexecutions {
		ids = append(ids, id)
	}
	return
}

// ExecutionsIDs returns the "executions" edge IDs in the mutation.
func (m *ChannelMutation) ExecutionsIDs() (ids []int) {
	for id := range m.executions {
		ids = append(ids, id)
	}
	return
}

// ResetExecutions resets all changes to the "executions" edge.
func (m *ChannelMutation) ResetExecutions() {
	m.executions = nil
	m.clearedexecutions = false
	m.removedexecutions = nil
}

// AddUsageLogIDs adds the "usage_logs" edge to the UsageLog entity by ids.
func (m *ChannelMutation) AddUsageLogIDs(ids ...int) {
	if m.usage_logs == nil {
		m.usage_logs = make(map[int]struct{})
	}
	for i := range ids {
		m.usage_logs[ids[i]] = struct{}{}
	}
}

// ClearUsageLogs clears the "usage_logs" edge to the UsageLog entity.
func (m *ChannelMutation) ClearUsageLogs() {
	m.clearedusage_logs = true
}

// UsageLogsCleared reports if the "usage_logs" edge to the UsageLog entity was cleared.
func (m *ChannelMutation) UsageLogsCleared() bool {
	return m.clearedusage_logs
}

// RemoveUsageLogIDs removes the "usage_logs" edge to the UsageLog entity by IDs.
func (m *ChannelMutation) RemoveUsageLogIDs(ids ...int) {
	if m.removedusage_logs == nil {
		m.removedusage_logs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.usage_logs, ids[i])
		m.removedusage_logs[ids[i]] = struct{}{}
	}
}

// RemovedUsageLogs returns the removed IDs of the "usage_logs" edge to the UsageLog entity.
func (m *ChannelMutation) RemovedUsageLogsIDs() (ids []int) {
	for id := range m.removedusage_logs {
		ids = append(ids, id)
	}
	return
}

// UsageLogsIDs returns the "usage_logs" edge IDs in the mutation.
func (m *ChannelMutation) UsageLogsIDs() (ids []int) {
	for id := range m.usage_logs {
		ids = append(ids, id)
	}
	return
}

// ResetUsageLogs resets all changes to the "usage_logs" edge.
func (m *ChannelMutation) ResetUsageLogs() {
	m.usage_logs = nil
	m.clearedusage_logs = false
	m.removedusage_logs = nil
}

// Where appends a list predicates to the ChannelMutation builder.
func (m *ChannelMutation) Where(ps ...predicate.Channel) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ChannelMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ChannelMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Channel, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ChannelMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ChannelMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Channel).
func (m *ChannelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChannelMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, channel.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, channel.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, channel.FieldDeletedAt)
	}
	if m._type != nil {
		fields = append(fields, channel.FieldType)
	}
	if m.base_url != nil {
		fields = append(fields, channel.FieldBaseURL)
	}
	if m.name != nil {
		fields = append(fields, channel.FieldName)
	}
	if m.status != nil {
		fields = append(fields, channel.FieldStatus)
	}
	if m.credentials != nil {
		fields = append(fields, channel.FieldCredentials)
	}
	if m.supported_models != nil {
		fields = append(fields, channel.FieldSupportedModels)
	}
	if m.default_test_model != nil {
		fields = append(fields, channel.FieldDefaultTestModel)
	}
	if m.settings != nil {
		fields = append(fields, channel.FieldSettings)
	}
	if m.ordering_weight != nil {
		fields = append(fields, channel.FieldOrderingWeight)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChannelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case channel.FieldCreatedAt:
		return m.CreatedAt()
	case channel.FieldUpdatedAt:
		return m.UpdatedAt()
	case channel.FieldDeletedAt:
		return m.DeletedAt()
	case channel.FieldType:
		return m.GetType()
	case channel.FieldBaseURL:
		return m.BaseURL()
	case channel.FieldName:
		return m.Name()
	case channel.FieldStatus:
		return m.Status()
	case channel.FieldCredentials:
		return m.Credentials()
	case channel.FieldSupportedModels:
		return m.SupportedModels()
	case channel.FieldDefaultTestModel:
		return m.DefaultTestModel()
	case channel.FieldSettings:
		return m.Settings()
	case channel.FieldOrderingWeight:
		return m.OrderingWeight()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChannelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case channel.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case channel.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case channel.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case channel.FieldType:
		return m.OldType(ctx)
	case channel.FieldBaseURL:
		return m.OldBaseURL(ctx)
	case channel.FieldName:
		return m.OldName(ctx)
	case channel.FieldStatus:
		return m.OldStatus(ctx)
	case channel.FieldCredentials:
		return m.OldCredentials(ctx)
	case channel.FieldSupportedModels:
		return m.OldSupportedModels(ctx)
	case channel.FieldDefaultTestModel:
		return m.OldDefaultTestModel(ctx)
	case channel.FieldSettings:
		return m.OldSettings(ctx)
	case channel.FieldOrderingWeight:
		return m.OldOrderingWeight(ctx)
	}
	return nil, fmt.Errorf("unknown Channel field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChannelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case channel.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case channel.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case channel.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case channel.FieldType:
		v, ok := value.(channel.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case channel.FieldBaseURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaseURL(v)
		return nil
	case channel.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case channel.FieldStatus:
		v, ok := value.(channel.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case channel.FieldCredentials:
		v, ok := value.(*objects.ChannelCredentials)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCredentials(v)
		return nil
	case channel.FieldSupportedModels:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupportedModels(v)
		return nil
	case channel.FieldDefaultTestModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultTestModel(v)
		return nil
	case channel.FieldSettings:
		v, ok := value.(*objects.ChannelSettings)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettings(v)
		return nil
	case channel.FieldOrderingWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderingWeight(v)
		return nil
	}
	return fmt.Errorf("unknown Channel field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChannelMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, channel.FieldDeletedAt)
	}
	if m.addordering_weight != nil {
		fields = append(fields, channel.FieldOrderingWeight)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChannelMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case channel.FieldDeletedAt:
		return m.AddedDeletedAt()
	case channel.FieldOrderingWeight:
		return m.AddedOrderingWeight()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChannelMutation) AddField(name string, value ent.Value) error {
	switch name {
	case channel.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case channel.FieldOrderingWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderingWeight(v)
		return nil
	}
	return fmt.Errorf("unknown Channel numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChannelMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(channel.FieldBaseURL) {
		fields = append(fields, channel.FieldBaseURL)
	}
	if m.FieldCleared(channel.FieldSettings) {
		fields = append(fields, channel.FieldSettings)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChannelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChannelMutation) ClearField(name string) error {
	switch name {
	case channel.FieldBaseURL:
		m.ClearBaseURL()
		return nil
	case channel.FieldSettings:
		m.ClearSettings()
		return nil
	}
	return fmt.Errorf("unknown Channel nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChannelMutation) ResetField(name string) error {
	switch name {
	case channel.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case channel.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case channel.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case channel.FieldType:
		m.ResetType()
		return nil
	case channel.FieldBaseURL:
		m.ResetBaseURL()
		return nil
	case channel.FieldName:
		m.ResetName()
		return nil
	case channel.FieldStatus:
		m.ResetStatus()
		return nil
	case channel.FieldCredentials:
		m.ResetCredentials()
		return nil
	case channel.FieldSupportedModels:
		m.ResetSupportedModels()
		return nil
	case channel.FieldDefaultTestModel:
		m.ResetDefaultTestModel()
		return nil
	case channel.FieldSettings:
		m.ResetSettings()
		return nil
	case channel.FieldOrderingWeight:
		m.ResetOrderingWeight()
		return nil
	}
	return fmt.Errorf("unknown Channel field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChannelMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.requests != nil {
		edges = append(edges, channel.EdgeRequests)
	}
	if m.executions != nil {
		edges = append(edges, channel.EdgeExecutions)
	}
	if m.usage_logs != nil {
		edges = append(edges, channel.EdgeUsageLogs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChannelMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case channel.EdgeRequests:
		ids := make([]ent.Value, 0, len(m.requests))
		for id := range m.requests {
			ids = append(ids, id)
		}
		return ids
	case channel.EdgeExecutions:
		ids := make([]ent.Value, 0, len(m.executions))
		for id := range m.executions {
			ids = append(ids, id)
		}
		return ids
	case channel.EdgeUsageLogs:
		ids := make([]ent.Value, 0, len(m.usage_logs))
		for id := range m.usage_logs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChannelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedrequests != nil {
		edges = append(edges, channel.EdgeRequests)
	}
	if m.removedexecutions != nil {
		edges = append(edges, channel.EdgeExecutions)
	}
	if m.removedusage_logs != nil {
		edges = append(edges, channel.EdgeUsageLogs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChannelMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case channel.EdgeRequests:
		ids := make([]ent.Value, 0, len(m.removedrequests))
		for id := range m.removedrequests {
			ids = append(ids, id)
		}
		return ids
	case channel.EdgeExecutions:
		ids := make([]ent.Value, 0, len(m.removedexecutions))
		for id := range m.removedexecutions {
			ids = append(ids, id)
		}
		return ids
	case channel.EdgeUsageLogs:
		ids := make([]ent.Value, 0, len(m.removedusage_logs))
		for id := range m.removedusage_logs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChannelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedrequests {
		edges = append(edges, channel.EdgeRequests)
	}
	if m.clearedexecutions {
		edges = append(edges, channel.EdgeExecutions)
	}
	if m.clearedusage_logs {
		edges = append(edges, channel.EdgeUsageLogs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChannelMutation) EdgeCleared(name string) bool {
	switch name {
	case channel.EdgeRequests:
		return m.clearedrequests
	case channel.EdgeExecutions:
		return m.clearedexecutions
	case channel.EdgeUsageLogs:
		return m.clearedusage_logs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChannelMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Channel unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChannelMutation) ResetEdge(name string) error {
	switch name {
	case channel.EdgeRequests:
		m.ResetRequests()
		return nil
	case channel.EdgeExecutions:
		m.ResetExecutions()
		return nil
	case channel.EdgeUsageLogs:
		m.ResetUsageLogs()
		return nil
	}
	return fmt.Errorf("unknown Channel edge %s", name)
}

// ProjectMutation represents an operation that mutates the Project nodes in the graph.
type ProjectMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	created_at           *time.Time
	updated_at           *time.Time
	deleted_at           *int
	adddeleted_at        *int
	name                 *string
	description          *string
	status               *project.Status
	clearedFields        map[string]struct{}
	users                map[int]struct{}
	removedusers         map[int]struct{}
	clearedusers         bool
	roles                map[int]struct{}
	removedroles         map[int]struct{}
	clearedroles         bool
	api_keys             map[int]struct{}
	removedapi_keys      map[int]struct{}
	clearedapi_keys      bool
	requests             map[int]struct{}
	removedrequests      map[int]struct{}
	clearedrequests      bool
	usage_logs           map[int]struct{}
	removedusage_logs    map[int]struct{}
	clearedusage_logs    bool
	threads              map[int]struct{}
	removedthreads       map[int]struct{}
	clearedthreads       bool
	traces               map[int]struct{}
	removedtraces        map[int]struct{}
	clearedtraces        bool
	project_users        map[int]struct{}
	removedproject_users map[int]struct{}
	clearedproject_users bool
	done                 bool
	oldValue             func(context.Context) (*Project, error)
	predicates           []predicate.Project
}

var _ ent.Mutation = (*ProjectMutation)(nil)

// projectOption allows management of the mutation configuration using functional options.
type projectOption func(*ProjectMutation)

// newProjectMutation creates new mutation for the Project entity.
func newProjectMutation(c config, op Op, opts ...projectOption) *ProjectMutation {
	m := &ProjectMutation{
		config:        c,
		op:            op,
		typ:           TypeProject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectID sets the ID field of the mutation.
func withProjectID(id int) projectOption {
	return func(m *ProjectMutation) {
		var (
			err   error
			once  sync.Once
			value *Project
		)
		m.oldValue = func(ctx context.Context) (*Project, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Project.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProject sets the old Project of the mutation.
func withProject(node *Project) projectOption {
	return func(m *ProjectMutation) {
		m.oldValue = func(context.Context) (*Project, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProjectMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Project.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProjectMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProjectMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProjectMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProjectMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProjectMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProjectMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ProjectMutation) SetDeletedAt(i int) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ProjectMutation) DeletedAt() (r int, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldDeletedAt(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *ProjectMutation) AddDeletedAt(i int) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *ProjectMutation) AddedDeletedAt() (r int, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ProjectMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetName sets the "name" field.
func (m *ProjectMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProjectMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProjectMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ProjectMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProjectMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ProjectMutation) ResetDescription() {
	m.description = nil
}

// SetStatus sets the "status" field.
func (m *ProjectMutation) SetStatus(pr project.Status) {
	m.status = &pr
}

// Status returns the value of the "status" field in the mutation.
func (m *ProjectMutation) Status() (r project.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldStatus(ctx context.Context) (v project.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ProjectMutation) ResetStatus() {
	m.status = nil
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *ProjectMutation) AddUserIDs(ids ...int) {
	if m.users == nil {
		m.users = make(map[int]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *ProjectMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *ProjectMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *ProjectMutation) RemoveUserIDs(ids ...int) {
	if m.removedusers == nil {
		m.removedusers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *ProjectMutation) RemovedUsersIDs() (ids []int) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *ProjectMutation) UsersIDs() (ids []int) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *ProjectMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddRoleIDs adds the "roles" edge to the Role entity by ids.
func (m *ProjectMutation) AddRoleIDs(ids ...int) {
	if m.roles == nil {
		m.roles = make(map[int]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the Role entity.
func (m *ProjectMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the Role entity was cleared.
func (m *ProjectMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the Role entity by IDs.
func (m *ProjectMutation) RemoveRoleIDs(ids ...int) {
	if m.removedroles == nil {
		m.removedroles = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the Role entity.
func (m *ProjectMutation) RemovedRolesIDs() (ids []int) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *ProjectMutation) RolesIDs() (ids []int) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *ProjectMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// AddAPIKeyIDs adds the "api_keys" edge to the APIKey entity by ids.
func (m *ProjectMutation) AddAPIKeyIDs(ids ...int) {
	if m.api_keys == nil {
		m.api_keys = make(map[int]struct{})
	}
	for i := range ids {
		m.api_keys[ids[i]] = struct{}{}
	}
}

// ClearAPIKeys clears the "api_keys" edge to the APIKey entity.
func (m *ProjectMutation) ClearAPIKeys() {
	m.clearedapi_keys = true
}

// APIKeysCleared reports if the "api_keys" edge to the APIKey entity was cleared.
func (m *ProjectMutation) APIKeysCleared() bool {
	return m.clearedapi_keys
}

// RemoveAPIKeyIDs removes the "api_keys" edge to the APIKey entity by IDs.
func (m *ProjectMutation) RemoveAPIKeyIDs(ids ...int) {
	if m.removedapi_keys == nil {
		m.removedapi_keys = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.api_keys, ids[i])
		m.removedapi_keys[ids[i]] = struct{}{}
	}
}

// RemovedAPIKeys returns the removed IDs of the "api_keys" edge to the APIKey entity.
func (m *ProjectMutation) RemovedAPIKeysIDs() (ids []int) {
	for id := range m.removedapi_keys {
		ids = append(ids, id)
	}
	return
}

// APIKeysIDs returns the "api_keys" edge IDs in the mutation.
func (m *ProjectMutation) APIKeysIDs() (ids []int) {
	for id := range m.api_keys {
		ids = append(ids, id)
	}
	return
}

// ResetAPIKeys resets all changes to the "api_keys" edge.
func (m *ProjectMutation) ResetAPIKeys() {
	m.api_keys = nil
	m.clearedapi_keys = false
	m.removedapi_keys = nil
}

// AddRequestIDs adds the "requests" edge to the Request entity by ids.
func (m *ProjectMutation) AddRequestIDs(ids ...int) {
	if m.requests == nil {
		m.requests = make(map[int]struct{})
	}
	for i := range ids {
		m.requests[ids[i]] = struct{}{}
	}
}

// ClearRequests clears the "requests" edge to the Request entity.
func (m *ProjectMutation) ClearRequests() {
	m.clearedrequests = true
}

// RequestsCleared reports if the "requests" edge to the Request entity was cleared.
func (m *ProjectMutation) RequestsCleared() bool {
	return m.clearedrequests
}

// RemoveRequestIDs removes the "requests" edge to the Request entity by IDs.
func (m *ProjectMutation) RemoveRequestIDs(ids ...int) {
	if m.removedrequests == nil {
		m.removedrequests = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.requests, ids[i])
		m.removedrequests[ids[i]] = struct{}{}
	}
}

// RemovedRequests returns the removed IDs of the "requests" edge to the Request entity.
func (m *ProjectMutation) RemovedRequestsIDs() (ids []int) {
	for id := range m.removedrequests {
		ids = append(ids, id)
	}
	return
}

// RequestsIDs returns the "requests" edge IDs in the mutation.
func (m *ProjectMutation) RequestsIDs() (ids []int) {
	for id := range m.requests {
		ids = append(ids, id)
	}
	return
}

// ResetRequests resets all changes to the "requests" edge.
func (m *ProjectMutation) ResetRequests() {
	m.requests = nil
	m.clearedrequests = false
	m.removedrequests = nil
}

// AddUsageLogIDs adds the "usage_logs" edge to the UsageLog entity by ids.
func (m *ProjectMutation) AddUsageLogIDs(ids ...int) {
	if m.usage_logs == nil {
		m.usage_logs = make(map[int]struct{})
	}
	for i := range ids {
		m.usage_logs[ids[i]] = struct{}{}
	}
}

// ClearUsageLogs clears the "usage_logs" edge to the UsageLog entity.
func (m *ProjectMutation) ClearUsageLogs() {
	m.clearedusage_logs = true
}

// UsageLogsCleared reports if the "usage_logs" edge to the UsageLog entity was cleared.
func (m *ProjectMutation) UsageLogsCleared() bool {
	return m.clearedusage_logs
}

// RemoveUsageLogIDs removes the "usage_logs" edge to the UsageLog entity by IDs.
func (m *ProjectMutation) RemoveUsageLogIDs(ids ...int) {
	if m.removedusage_logs == nil {
		m.removedusage_logs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.usage_logs, ids[i])
		m.removedusage_logs[ids[i]] = struct{}{}
	}
}

// RemovedUsageLogs returns the removed IDs of the "usage_logs" edge to the UsageLog entity.
func (m *ProjectMutation) RemovedUsageLogsIDs() (ids []int) {
	for id := range m.removedusage_logs {
		ids = append(ids, id)
	}
	return
}

// UsageLogsIDs returns the "usage_logs" edge IDs in the mutation.
func (m *ProjectMutation) UsageLogsIDs() (ids []int) {
	for id := range m.usage_logs {
		ids = append(ids, id)
	}
	return
}

// ResetUsageLogs resets all changes to the "usage_logs" edge.
func (m *ProjectMutation) ResetUsageLogs() {
	m.usage_logs = nil
	m.clearedusage_logs = false
	m.removedusage_logs = nil
}

// AddThreadIDs adds the "threads" edge to the Thread entity by ids.
func (m *ProjectMutation) AddThreadIDs(ids ...int) {
	if m.threads == nil {
		m.threads = make(map[int]struct{})
	}
	for i := range ids {
		m.threads[ids[i]] = struct{}{}
	}
}

// ClearThreads clears the "threads" edge to the Thread entity.
func (m *ProjectMutation) ClearThreads() {
	m.clearedthreads = true
}

// ThreadsCleared reports if the "threads" edge to the Thread entity was cleared.
func (m *ProjectMutation) ThreadsCleared() bool {
	return m.clearedthreads
}

// RemoveThreadIDs removes the "threads" edge to the Thread entity by IDs.
func (m *ProjectMutation) RemoveThreadIDs(ids ...int) {
	if m.removedthreads == nil {
		m.removedthreads = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.threads, ids[i])
		m.removedthreads[ids[i]] = struct{}{}
	}
}

// RemovedThreads returns the removed IDs of the "threads" edge to the Thread entity.
func (m *ProjectMutation) RemovedThreadsIDs() (ids []int) {
	for id := range m.removedthreads {
		ids = append(ids, id)
	}
	return
}

// ThreadsIDs returns the "threads" edge IDs in the mutation.
func (m *ProjectMutation) ThreadsIDs() (ids []int) {
	for id := range m.threads {
		ids = append(ids, id)
	}
	return
}

// ResetThreads resets all changes to the "threads" edge.
func (m *ProjectMutation) ResetThreads() {
	m.threads = nil
	m.clearedthreads = false
	m.removedthreads = nil
}

// AddTraceIDs adds the "traces" edge to the Trace entity by ids.
func (m *ProjectMutation) AddTraceIDs(ids ...int) {
	if m.traces == nil {
		m.traces = make(map[int]struct{})
	}
	for i := range ids {
		m.traces[ids[i]] = struct{}{}
	}
}

// ClearTraces clears the "traces" edge to the Trace entity.
func (m *ProjectMutation) ClearTraces() {
	m.clearedtraces = true
}

// TracesCleared reports if the "traces" edge to the Trace entity was cleared.
func (m *ProjectMutation) TracesCleared() bool {
	return m.clearedtraces
}

// RemoveTraceIDs removes the "traces" edge to the Trace entity by IDs.
func (m *ProjectMutation) RemoveTraceIDs(ids ...int) {
	if m.removedtraces == nil {
		m.removedtraces = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.traces, ids[i])
		m.removedtraces[ids[i]] = struct{}{}
	}
}

// RemovedTraces returns the removed IDs of the "traces" edge to the Trace entity.
func (m *ProjectMutation) RemovedTracesIDs() (ids []int) {
	for id := range m.removedtraces {
		ids = append(ids, id)
	}
	return
}

// TracesIDs returns the "traces" edge IDs in the mutation.
func (m *ProjectMutation) TracesIDs() (ids []int) {
	for id := range m.traces {
		ids = append(ids, id)
	}
	return
}

// ResetTraces resets all changes to the "traces" edge.
func (m *ProjectMutation) ResetTraces() {
	m.traces = nil
	m.clearedtraces = false
	m.removedtraces = nil
}

// AddProjectUserIDs adds the "project_users" edge to the UserProject entity by ids.
func (m *ProjectMutation) AddProjectUserIDs(ids ...int) {
	if m.project_users == nil {
		m.project_users = make(map[int]struct{})
	}
	for i := range ids {
		m.project_users[ids[i]] = struct{}{}
	}
}

// ClearProjectUsers clears the "project_users" edge to the UserProject entity.
func (m *ProjectMutation) ClearProjectUsers() {
	m.clearedproject_users = true
}

// ProjectUsersCleared reports if the "project_users" edge to the UserProject entity was cleared.
func (m *ProjectMutation) ProjectUsersCleared() bool {
	return m.clearedproject_users
}

// RemoveProjectUserIDs removes the "project_users" edge to the UserProject entity by IDs.
func (m *ProjectMutation) RemoveProjectUserIDs(ids ...int) {
	if m.removedproject_users == nil {
		m.removedproject_users = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.project_users, ids[i])
		m.removedproject_users[ids[i]] = struct{}{}
	}
}

// RemovedProjectUsers returns the removed IDs of the "project_users" edge to the UserProject entity.
func (m *ProjectMutation) RemovedProjectUsersIDs() (ids []int) {
	for id := range m.removedproject_users {
		ids = append(ids, id)
	}
	return
}

// ProjectUsersIDs returns the "project_users" edge IDs in the mutation.
func (m *ProjectMutation) ProjectUsersIDs() (ids []int) {
	for id := range m.project_users {
		ids = append(ids, id)
	}
	return
}

// ResetProjectUsers resets all changes to the "project_users" edge.
func (m *ProjectMutation) ResetProjectUsers() {
	m.project_users = nil
	m.clearedproject_users = false
	m.removedproject_users = nil
}

// Where appends a list predicates to the ProjectMutation builder.
func (m *ProjectMutation) Where(ps ...predicate.Project) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProjectMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProjectMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Project, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProjectMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProjectMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Project).
func (m *ProjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, project.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, project.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, project.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, project.FieldName)
	}
	if m.description != nil {
		fields = append(fields, project.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, project.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case project.FieldCreatedAt:
		return m.CreatedAt()
	case project.FieldUpdatedAt:
		return m.UpdatedAt()
	case project.FieldDeletedAt:
		return m.DeletedAt()
	case project.FieldName:
		return m.Name()
	case project.FieldDescription:
		return m.Description()
	case project.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case project.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case project.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case project.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case project.FieldName:
		return m.OldName(ctx)
	case project.FieldDescription:
		return m.OldDescription(ctx)
	case project.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Project field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case project.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case project.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case project.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case project.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case project.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case project.FieldStatus:
		v, ok := value.(project.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, project.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case project.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	case project.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Project numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Project nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectMutation) ResetField(name string) error {
	switch name {
	case project.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case project.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case project.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case project.FieldName:
		m.ResetName()
		return nil
	case project.FieldDescription:
		m.ResetDescription()
		return nil
	case project.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.users != nil {
		edges = append(edges, project.EdgeUsers)
	}
	if m.roles != nil {
		edges = append(edges, project.EdgeRoles)
	}
	if m.api_keys != nil {
		edges = append(edges, project.EdgeAPIKeys)
	}
	if m.requests != nil {
		edges = append(edges, project.EdgeRequests)
	}
	if m.usage_logs != nil {
		edges = append(edges, project.EdgeUsageLogs)
	}
	if m.threads != nil {
		edges = append(edges, project.EdgeThreads)
	}
	if m.traces != nil {
		edges = append(edges, project.EdgeTraces)
	}
	if m.project_users != nil {
		edges = append(edges, project.EdgeProjectUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeAPIKeys:
		ids := make([]ent.Value, 0, len(m.api_keys))
		for id := range m.api_keys {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeRequests:
		ids := make([]ent.Value, 0, len(m.requests))
		for id := range m.requests {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeUsageLogs:
		ids := make([]ent.Value, 0, len(m.usage_logs))
		for id := range m.usage_logs {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeThreads:
		ids := make([]ent.Value, 0, len(m.threads))
		for id := range m.threads {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeTraces:
		ids := make([]ent.Value, 0, len(m.traces))
		for id := range m.traces {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeProjectUsers:
		ids := make([]ent.Value, 0, len(m.project_users))
		for id := range m.project_users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedusers != nil {
		edges = append(edges, project.EdgeUsers)
	}
	if m.removedroles != nil {
		edges = append(edges, project.EdgeRoles)
	}
	if m.removedapi_keys != nil {
		edges = append(edges, project.EdgeAPIKeys)
	}
	if m.removedrequests != nil {
		edges = append(edges, project.EdgeRequests)
	}
	if m.removedusage_logs != nil {
		edges = append(edges, project.EdgeUsageLogs)
	}
	if m.removedthreads != nil {
		edges = append(edges, project.EdgeThreads)
	}
	if m.removedtraces != nil {
		edges = append(edges, project.EdgeTraces)
	}
	if m.removedproject_users != nil {
		edges = append(edges, project.EdgeProjectUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeAPIKeys:
		ids := make([]ent.Value, 0, len(m.removedapi_keys))
		for id := range m.removedapi_keys {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeRequests:
		ids := make([]ent.Value, 0, len(m.removedrequests))
		for id := range m.removedrequests {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeUsageLogs:
		ids := make([]ent.Value, 0, len(m.removedusage_logs))
		for id := range m.removedusage_logs {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeThreads:
		ids := make([]ent.Value, 0, len(m.removedthreads))
		for id := range m.removedthreads {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeTraces:
		ids := make([]ent.Value, 0, len(m.removedtraces))
		for id := range m.removedtraces {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeProjectUsers:
		ids := make([]ent.Value, 0, len(m.removedproject_users))
		for id := range m.removedproject_users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedusers {
		edges = append(edges, project.EdgeUsers)
	}
	if m.clearedroles {
		edges = append(edges, project.EdgeRoles)
	}
	if m.clearedapi_keys {
		edges = append(edges, project.EdgeAPIKeys)
	}
	if m.clearedrequests {
		edges = append(edges, project.EdgeRequests)
	}
	if m.clearedusage_logs {
		edges = append(edges, project.EdgeUsageLogs)
	}
	if m.clearedthreads {
		edges = append(edges, project.EdgeThreads)
	}
	if m.clearedtraces {
		edges = append(edges, project.EdgeTraces)
	}
	if m.clearedproject_users {
		edges = append(edges, project.EdgeProjectUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectMutation) EdgeCleared(name string) bool {
	switch name {
	case project.EdgeUsers:
		return m.clearedusers
	case project.EdgeRoles:
		return m.clearedroles
	case project.EdgeAPIKeys:
		return m.clearedapi_keys
	case project.EdgeRequests:
		return m.clearedrequests
	case project.EdgeUsageLogs:
		return m.clearedusage_logs
	case project.EdgeThreads:
		return m.clearedthreads
	case project.EdgeTraces:
		return m.clearedtraces
	case project.EdgeProjectUsers:
		return m.clearedproject_users
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Project unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectMutation) ResetEdge(name string) error {
	switch name {
	case project.EdgeUsers:
		m.ResetUsers()
		return nil
	case project.EdgeRoles:
		m.ResetRoles()
		return nil
	case project.EdgeAPIKeys:
		m.ResetAPIKeys()
		return nil
	case project.EdgeRequests:
		m.ResetRequests()
		return nil
	case project.EdgeUsageLogs:
		m.ResetUsageLogs()
		return nil
	case project.EdgeThreads:
		m.ResetThreads()
		return nil
	case project.EdgeTraces:
		m.ResetTraces()
		return nil
	case project.EdgeProjectUsers:
		m.ResetProjectUsers()
		return nil
	}
	return fmt.Errorf("unknown Project edge %s", name)
}

// RequestMutation represents an operation that mutates the Request nodes in the graph.
type RequestMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *int
	adddeleted_at         *int
	source                *request.Source
	model_id              *string
	format                *string
	request_body          *objects.JSONRawMessage
	appendrequest_body    objects.JSONRawMessage
	response_body         *objects.JSONRawMessage
	appendresponse_body   objects.JSONRawMessage
	response_chunks       *[]objects.JSONRawMessage
	appendresponse_chunks []objects.JSONRawMessage
	external_id           *string
	status                *request.Status
	stream                *bool
	clearedFields         map[string]struct{}
	api_key               *int
	clearedapi_key        bool
	project               *int
	clearedproject        bool
	trace                 *int
	clearedtrace          bool
	executions            map[int]struct{}
	removedexecutions     map[int]struct{}
	clearedexecutions     bool
	channel               *int
	clearedchannel        bool
	usage_logs            map[int]struct{}
	removedusage_logs     map[int]struct{}
	clearedusage_logs     bool
	done                  bool
	oldValue              func(context.Context) (*Request, error)
	predicates            []predicate.Request
}

var _ ent.Mutation = (*RequestMutation)(nil)

// requestOption allows management of the mutation configuration using functional options.
type requestOption func(*RequestMutation)

// newRequestMutation creates new mutation for the Request entity.
func newRequestMutation(c config, op Op, opts ...requestOption) *RequestMutation {
	m := &RequestMutation{
		config:        c,
		op:            op,
		typ:           TypeRequest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRequestID sets the ID field of the mutation.
func withRequestID(id int) requestOption {
	return func(m *RequestMutation) {
		var (
			err   error
			once  sync.Once
			value *Request
		)
		m.oldValue = func(ctx context.Context) (*Request, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Request.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRequest sets the old Request of the mutation.
func withRequest(node *Request) requestOption {
	return func(m *RequestMutation) {
		m.oldValue = func(context.Context) (*Request, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RequestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RequestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RequestMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RequestMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Request.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RequestMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RequestMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RequestMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RequestMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RequestMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RequestMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RequestMutation) SetDeletedAt(i int) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RequestMutation) DeletedAt() (r int, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldDeletedAt(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *RequestMutation) AddDeletedAt(i int) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *RequestMutation) AddedDeletedAt() (r int, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RequestMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAPIKeyID sets the "api_key_id" field.
func (m *RequestMutation) SetAPIKeyID(i int) {
	m.api_key = &i
}

// APIKeyID returns the value of the "api_key_id" field in the mutation.
func (m *RequestMutation) APIKeyID() (r int, exists bool) {
	v := m.api_key
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIKeyID returns the old "api_key_id" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldAPIKeyID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPIKeyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPIKeyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIKeyID: %w", err)
	}
	return oldValue.APIKeyID, nil
}

// ClearAPIKeyID clears the value of the "api_key_id" field.
func (m *RequestMutation) ClearAPIKeyID() {
	m.api_key = nil
	m.clearedFields[request.FieldAPIKeyID] = struct{}{}
}

// APIKeyIDCleared returns if the "api_key_id" field was cleared in this mutation.
func (m *RequestMutation) APIKeyIDCleared() bool {
	_, ok := m.clearedFields[request.FieldAPIKeyID]
	return ok
}

// ResetAPIKeyID resets all changes to the "api_key_id" field.
func (m *RequestMutation) ResetAPIKeyID() {
	m.api_key = nil
	delete(m.clearedFields, request.FieldAPIKeyID)
}

// SetProjectID sets the "project_id" field.
func (m *RequestMutation) SetProjectID(i int) {
	m.project = &i
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *RequestMutation) ProjectID() (r int, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldProjectID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *RequestMutation) ResetProjectID() {
	m.project = nil
}

// SetTraceID sets the "trace_id" field.
func (m *RequestMutation) SetTraceID(i int) {
	m.trace = &i
}

// TraceID returns the value of the "trace_id" field in the mutation.
func (m *RequestMutation) TraceID() (r int, exists bool) {
	v := m.trace
	if v == nil {
		return
	}
	return *v, true
}

// OldTraceID returns the old "trace_id" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldTraceID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTraceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTraceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTraceID: %w", err)
	}
	return oldValue.TraceID, nil
}

// ClearTraceID clears the value of the "trace_id" field.
func (m *RequestMutation) ClearTraceID() {
	m.trace = nil
	m.clearedFields[request.FieldTraceID] = struct{}{}
}

// TraceIDCleared returns if the "trace_id" field was cleared in this mutation.
func (m *RequestMutation) TraceIDCleared() bool {
	_, ok := m.clearedFields[request.FieldTraceID]
	return ok
}

// ResetTraceID resets all changes to the "trace_id" field.
func (m *RequestMutation) ResetTraceID() {
	m.trace = nil
	delete(m.clearedFields, request.FieldTraceID)
}

// SetSource sets the "source" field.
func (m *RequestMutation) SetSource(r request.Source) {
	m.source = &r
}

// Source returns the value of the "source" field in the mutation.
func (m *RequestMutation) Source() (r request.Source, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldSource(ctx context.Context) (v request.Source, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *RequestMutation) ResetSource() {
	m.source = nil
}

// SetModelID sets the "model_id" field.
func (m *RequestMutation) SetModelID(s string) {
	m.model_id = &s
}

// ModelID returns the value of the "model_id" field in the mutation.
func (m *RequestMutation) ModelID() (r string, exists bool) {
	v := m.model_id
	if v == nil {
		return
	}
	return *v, true
}

// OldModelID returns the old "model_id" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldModelID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModelID: %w", err)
	}
	return oldValue.ModelID, nil
}

// ResetModelID resets all changes to the "model_id" field.
func (m *RequestMutation) ResetModelID() {
	m.model_id = nil
}

// SetFormat sets the "format" field.
func (m *RequestMutation) SetFormat(s string) {
	m.format = &s
}

// Format returns the value of the "format" field in the mutation.
func (m *RequestMutation) Format() (r string, exists bool) {
	v := m.format
	if v == nil {
		return
	}
	return *v, true
}

// OldFormat returns the old "format" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldFormat(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFormat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFormat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormat: %w", err)
	}
	return oldValue.Format, nil
}

// ResetFormat resets all changes to the "format" field.
func (m *RequestMutation) ResetFormat() {
	m.format = nil
}

// SetRequestBody sets the "request_body" field.
func (m *RequestMutation) SetRequestBody(orm objects.JSONRawMessage) {
	m.request_body = &orm
	m.appendrequest_body = nil
}

// RequestBody returns the value of the "request_body" field in the mutation.
func (m *RequestMutation) RequestBody() (r objects.JSONRawMessage, exists bool) {
	v := m.request_body
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestBody returns the old "request_body" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldRequestBody(ctx context.Context) (v objects.JSONRawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestBody: %w", err)
	}
	return oldValue.RequestBody, nil
}

// AppendRequestBody adds orm to the "request_body" field.
func (m *RequestMutation) AppendRequestBody(orm objects.JSONRawMessage) {
	m.appendrequest_body = append(m.appendrequest_body, orm...)
}

// AppendedRequestBody returns the list of values that were appended to the "request_body" field in this mutation.
func (m *RequestMutation) AppendedRequestBody() (objects.JSONRawMessage, bool) {
	if len(m.appendrequest_body) == 0 {
		return nil, false
	}
	return m.appendrequest_body, true
}

// ResetRequestBody resets all changes to the "request_body" field.
func (m *RequestMutation) ResetRequestBody() {
	m.request_body = nil
	m.appendrequest_body = nil
}

// SetResponseBody sets the "response_body" field.
func (m *RequestMutation) SetResponseBody(orm objects.JSONRawMessage) {
	m.response_body = &orm
	m.appendresponse_body = nil
}

// ResponseBody returns the value of the "response_body" field in the mutation.
func (m *RequestMutation) ResponseBody() (r objects.JSONRawMessage, exists bool) {
	v := m.response_body
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseBody returns the old "response_body" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldResponseBody(ctx context.Context) (v objects.JSONRawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseBody: %w", err)
	}
	return oldValue.ResponseBody, nil
}

// AppendResponseBody adds orm to the "response_body" field.
func (m *RequestMutation) AppendResponseBody(orm objects.JSONRawMessage) {
	m.appendresponse_body = append(m.appendresponse_body, orm...)
}

// AppendedResponseBody returns the list of values that were appended to the "response_body" field in this mutation.
func (m *RequestMutation) AppendedResponseBody() (objects.JSONRawMessage, bool) {
	if len(m.appendresponse_body) == 0 {
		return nil, false
	}
	return m.appendresponse_body, true
}

// ClearResponseBody clears the value of the "response_body" field.
func (m *RequestMutation) ClearResponseBody() {
	m.response_body = nil
	m.appendresponse_body = nil
	m.clearedFields[request.FieldResponseBody] = struct{}{}
}

// ResponseBodyCleared returns if the "response_body" field was cleared in this mutation.
func (m *RequestMutation) ResponseBodyCleared() bool {
	_, ok := m.clearedFields[request.FieldResponseBody]
	return ok
}

// ResetResponseBody resets all changes to the "response_body" field.
func (m *RequestMutation) ResetResponseBody() {
	m.response_body = nil
	m.appendresponse_body = nil
	delete(m.clearedFields, request.FieldResponseBody)
}

// SetResponseChunks sets the "response_chunks" field.
func (m *RequestMutation) SetResponseChunks(orm []objects.JSONRawMessage) {
	m.response_chunks = &orm
	m.appendresponse_chunks = nil
}

// ResponseChunks returns the value of the "response_chunks" field in the mutation.
func (m *RequestMutation) ResponseChunks() (r []objects.JSONRawMessage, exists bool) {
	v := m.response_chunks
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseChunks returns the old "response_chunks" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldResponseChunks(ctx context.Context) (v []objects.JSONRawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseChunks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseChunks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseChunks: %w", err)
	}
	return oldValue.ResponseChunks, nil
}

// AppendResponseChunks adds orm to the "response_chunks" field.
func (m *RequestMutation) AppendResponseChunks(orm []objects.JSONRawMessage) {
	m.appendresponse_chunks = append(m.appendresponse_chunks, orm...)
}

// AppendedResponseChunks returns the list of values that were appended to the "response_chunks" field in this mutation.
func (m *RequestMutation) AppendedResponseChunks() ([]objects.JSONRawMessage, bool) {
	if len(m.appendresponse_chunks) == 0 {
		return nil, false
	}
	return m.appendresponse_chunks, true
}

// ClearResponseChunks clears the value of the "response_chunks" field.
func (m *RequestMutation) ClearResponseChunks() {
	m.response_chunks = nil
	m.appendresponse_chunks = nil
	m.clearedFields[request.FieldResponseChunks] = struct{}{}
}

// ResponseChunksCleared returns if the "response_chunks" field was cleared in this mutation.
func (m *RequestMutation) ResponseChunksCleared() bool {
	_, ok := m.clearedFields[request.FieldResponseChunks]
	return ok
}

// ResetResponseChunks resets all changes to the "response_chunks" field.
func (m *RequestMutation) ResetResponseChunks() {
	m.response_chunks = nil
	m.appendresponse_chunks = nil
	delete(m.clearedFields, request.FieldResponseChunks)
}

// SetChannelID sets the "channel_id" field.
func (m *RequestMutation) SetChannelID(i int) {
	m.channel = &i
}

// ChannelID returns the value of the "channel_id" field in the mutation.
func (m *RequestMutation) ChannelID() (r int, exists bool) {
	v := m.channel
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelID returns the old "channel_id" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldChannelID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelID: %w", err)
	}
	return oldValue.ChannelID, nil
}

// ClearChannelID clears the value of the "channel_id" field.
func (m *RequestMutation) ClearChannelID() {
	m.channel = nil
	m.clearedFields[request.FieldChannelID] = struct{}{}
}

// ChannelIDCleared returns if the "channel_id" field was cleared in this mutation.
func (m *RequestMutation) ChannelIDCleared() bool {
	_, ok := m.clearedFields[request.FieldChannelID]
	return ok
}

// ResetChannelID resets all changes to the "channel_id" field.
func (m *RequestMutation) ResetChannelID() {
	m.channel = nil
	delete(m.clearedFields, request.FieldChannelID)
}

// SetExternalID sets the "external_id" field.
func (m *RequestMutation) SetExternalID(s string) {
	m.external_id = &s
}

// ExternalID returns the value of the "external_id" field in the mutation.
func (m *RequestMutation) ExternalID() (r string, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old "external_id" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldExternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// ClearExternalID clears the value of the "external_id" field.
func (m *RequestMutation) ClearExternalID() {
	m.external_id = nil
	m.clearedFields[request.FieldExternalID] = struct{}{}
}

// ExternalIDCleared returns if the "external_id" field was cleared in this mutation.
func (m *RequestMutation) ExternalIDCleared() bool {
	_, ok := m.clearedFields[request.FieldExternalID]
	return ok
}

// ResetExternalID resets all changes to the "external_id" field.
func (m *RequestMutation) ResetExternalID() {
	m.external_id = nil
	delete(m.clearedFields, request.FieldExternalID)
}

// SetStatus sets the "status" field.
func (m *RequestMutation) SetStatus(r request.Status) {
	m.status = &r
}

// Status returns the value of the "status" field in the mutation.
func (m *RequestMutation) Status() (r request.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldStatus(ctx context.Context) (v request.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *RequestMutation) ResetStatus() {
	m.status = nil
}

// SetStream sets the "stream" field.
func (m *RequestMutation) SetStream(b bool) {
	m.stream = &b
}

// Stream returns the value of the "stream" field in the mutation.
func (m *RequestMutation) Stream() (r bool, exists bool) {
	v := m.stream
	if v == nil {
		return
	}
	return *v, true
}

// OldStream returns the old "stream" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldStream(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStream is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStream requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStream: %w", err)
	}
	return oldValue.Stream, nil
}

// ResetStream resets all changes to the "stream" field.
func (m *RequestMutation) ResetStream() {
	m.stream = nil
}

// ClearAPIKey clears the "api_key" edge to the APIKey entity.
func (m *RequestMutation) ClearAPIKey() {
	m.clearedapi_key = true
	m.clearedFields[request.FieldAPIKeyID] = struct{}{}
}

// APIKeyCleared reports if the "api_key" edge to the APIKey entity was cleared.
func (m *RequestMutation) APIKeyCleared() bool {
	return m.APIKeyIDCleared() || m.clearedapi_key
}

// APIKeyIDs returns the "api_key" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// APIKeyID instead. It exists only for internal usage by the builders.
func (m *RequestMutation) APIKeyIDs() (ids []int) {
	if id := m.api_key; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAPIKey resets all changes to the "api_key" edge.
func (m *RequestMutation) ResetAPIKey() {
	m.api_key = nil
	m.clearedapi_key = false
}

// ClearProject clears the "project" edge to the Project entity.
func (m *RequestMutation) ClearProject() {
	m.clearedproject = true
	m.clearedFields[request.FieldProjectID] = struct{}{}
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *RequestMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *RequestMutation) ProjectIDs() (ids []int) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *RequestMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// ClearTrace clears the "trace" edge to the Trace entity.
func (m *RequestMutation) ClearTrace() {
	m.clearedtrace = true
	m.clearedFields[request.FieldTraceID] = struct{}{}
}

// TraceCleared reports if the "trace" edge to the Trace entity was cleared.
func (m *RequestMutation) TraceCleared() bool {
	return m.TraceIDCleared() || m.clearedtrace
}

// TraceIDs returns the "trace" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TraceID instead. It exists only for internal usage by the builders.
func (m *RequestMutation) TraceIDs() (ids []int) {
	if id := m.trace; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTrace resets all changes to the "trace" edge.
func (m *RequestMutation) ResetTrace() {
	m.trace = nil
	m.clearedtrace = false
}

// AddExecutionIDs adds the "executions" edge to the RequestExecution entity by ids.
func (m *RequestMutation) AddExecutionIDs(ids ...int) {
	if m.executions == nil {
		m.executions = make(map[int]struct{})
	}
	for i := range ids {
		m.executions[ids[i]] = struct{}{}
	}
}

// ClearExecutions clears the "executions" edge to the RequestExecution entity.
func (m *RequestMutation) ClearExecutions() {
	m.clearedexecutions = true
}

// ExecutionsCleared reports if the "executions" edge to the RequestExecution entity was cleared.
func (m *RequestMutation) ExecutionsCleared() bool {
	return m.clearedexecutions
}

// RemoveExecutionIDs removes the "executions" edge to the RequestExecution entity by IDs.
func (m *RequestMutation) RemoveExecutionIDs(ids ...int) {
	if m.removedexecutions == nil {
		m.removedexecutions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.executions, ids[i])
		m.removedexecutions[ids[i]] = struct{}{}
	}
}

// RemovedExecutions returns the removed IDs of the "executions" edge to the RequestExecution entity.
func (m *RequestMutation) RemovedExecutionsIDs() (ids []int) {
	for id := range m.removedexecutions {
		ids = append(ids, id)
	}
	return
}

// ExecutionsIDs returns the "executions" edge IDs in the mutation.
func (m *RequestMutation) ExecutionsIDs() (ids []int) {
	for id := range m.executions {
		ids = append(ids, id)
	}
	return
}

// ResetExecutions resets all changes to the "executions" edge.
func (m *RequestMutation) ResetExecutions() {
	m.executions = nil
	m.clearedexecutions = false
	m.removedexecutions = nil
}

// ClearChannel clears the "channel" edge to the Channel entity.
func (m *RequestMutation) ClearChannel() {
	m.clearedchannel = true
	m.clearedFields[request.FieldChannelID] = struct{}{}
}

// ChannelCleared reports if the "channel" edge to the Channel entity was cleared.
func (m *RequestMutation) ChannelCleared() bool {
	return m.ChannelIDCleared() || m.clearedchannel
}

// ChannelIDs returns the "channel" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChannelID instead. It exists only for internal usage by the builders.
func (m *RequestMutation) ChannelIDs() (ids []int) {
	if id := m.channel; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChannel resets all changes to the "channel" edge.
func (m *RequestMutation) ResetChannel() {
	m.channel = nil
	m.clearedchannel = false
}

// AddUsageLogIDs adds the "usage_logs" edge to the UsageLog entity by ids.
func (m *RequestMutation) AddUsageLogIDs(ids ...int) {
	if m.usage_logs == nil {
		m.usage_logs = make(map[int]struct{})
	}
	for i := range ids {
		m.usage_logs[ids[i]] = struct{}{}
	}
}

// ClearUsageLogs clears the "usage_logs" edge to the UsageLog entity.
func (m *RequestMutation) ClearUsageLogs() {
	m.clearedusage_logs = true
}

// UsageLogsCleared reports if the "usage_logs" edge to the UsageLog entity was cleared.
func (m *RequestMutation) UsageLogsCleared() bool {
	return m.clearedusage_logs
}

// RemoveUsageLogIDs removes the "usage_logs" edge to the UsageLog entity by IDs.
func (m *RequestMutation) RemoveUsageLogIDs(ids ...int) {
	if m.removedusage_logs == nil {
		m.removedusage_logs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.usage_logs, ids[i])
		m.removedusage_logs[ids[i]] = struct{}{}
	}
}

// RemovedUsageLogs returns the removed IDs of the "usage_logs" edge to the UsageLog entity.
func (m *RequestMutation) RemovedUsageLogsIDs() (ids []int) {
	for id := range m.removedusage_logs {
		ids = append(ids, id)
	}
	return
}

// UsageLogsIDs returns the "usage_logs" edge IDs in the mutation.
func (m *RequestMutation) UsageLogsIDs() (ids []int) {
	for id := range m.usage_logs {
		ids = append(ids, id)
	}
	return
}

// ResetUsageLogs resets all changes to the "usage_logs" edge.
func (m *RequestMutation) ResetUsageLogs() {
	m.usage_logs = nil
	m.clearedusage_logs = false
	m.removedusage_logs = nil
}

// Where appends a list predicates to the RequestMutation builder.
func (m *RequestMutation) Where(ps ...predicate.Request) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RequestMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RequestMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Request, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RequestMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RequestMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Request).
func (m *RequestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RequestMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_at != nil {
		fields = append(fields, request.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, request.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, request.FieldDeletedAt)
	}
	if m.api_key != nil {
		fields = append(fields, request.FieldAPIKeyID)
	}
	if m.project != nil {
		fields = append(fields, request.FieldProjectID)
	}
	if m.trace != nil {
		fields = append(fields, request.FieldTraceID)
	}
	if m.source != nil {
		fields = append(fields, request.FieldSource)
	}
	if m.model_id != nil {
		fields = append(fields, request.FieldModelID)
	}
	if m.format != nil {
		fields = append(fields, request.FieldFormat)
	}
	if m.request_body != nil {
		fields = append(fields, request.FieldRequestBody)
	}
	if m.response_body != nil {
		fields = append(fields, request.FieldResponseBody)
	}
	if m.response_chunks != nil {
		fields = append(fields, request.FieldResponseChunks)
	}
	if m.channel != nil {
		fields = append(fields, request.FieldChannelID)
	}
	if m.external_id != nil {
		fields = append(fields, request.FieldExternalID)
	}
	if m.status != nil {
		fields = append(fields, request.FieldStatus)
	}
	if m.stream != nil {
		fields = append(fields, request.FieldStream)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RequestMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case request.FieldCreatedAt:
		return m.CreatedAt()
	case request.FieldUpdatedAt:
		return m.UpdatedAt()
	case request.FieldDeletedAt:
		return m.DeletedAt()
	case request.FieldAPIKeyID:
		return m.APIKeyID()
	case request.FieldProjectID:
		return m.ProjectID()
	case request.FieldTraceID:
		return m.TraceID()
	case request.FieldSource:
		return m.Source()
	case request.FieldModelID:
		return m.ModelID()
	case request.FieldFormat:
		return m.Format()
	case request.FieldRequestBody:
		return m.RequestBody()
	case request.FieldResponseBody:
		return m.ResponseBody()
	case request.FieldResponseChunks:
		return m.ResponseChunks()
	case request.FieldChannelID:
		return m.ChannelID()
	case request.FieldExternalID:
		return m.ExternalID()
	case request.FieldStatus:
		return m.Status()
	case request.FieldStream:
		return m.Stream()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RequestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case request.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case request.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case request.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case request.FieldAPIKeyID:
		return m.OldAPIKeyID(ctx)
	case request.FieldProjectID:
		return m.OldProjectID(ctx)
	case request.FieldTraceID:
		return m.OldTraceID(ctx)
	case request.FieldSource:
		return m.OldSource(ctx)
	case request.FieldModelID:
		return m.OldModelID(ctx)
	case request.FieldFormat:
		return m.OldFormat(ctx)
	case request.FieldRequestBody:
		return m.OldRequestBody(ctx)
	case request.FieldResponseBody:
		return m.OldResponseBody(ctx)
	case request.FieldResponseChunks:
		return m.OldResponseChunks(ctx)
	case request.FieldChannelID:
		return m.OldChannelID(ctx)
	case request.FieldExternalID:
		return m.OldExternalID(ctx)
	case request.FieldStatus:
		return m.OldStatus(ctx)
	case request.FieldStream:
		return m.OldStream(ctx)
	}
	return nil, fmt.Errorf("unknown Request field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RequestMutation) SetField(name string, value ent.Value) error {
	switch name {
	case request.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case request.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case request.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case request.FieldAPIKeyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIKeyID(v)
		return nil
	case request.FieldProjectID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case request.FieldTraceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTraceID(v)
		return nil
	case request.FieldSource:
		v, ok := value.(request.Source)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case request.FieldModelID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModelID(v)
		return nil
	case request.FieldFormat:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormat(v)
		return nil
	case request.FieldRequestBody:
		v, ok := value.(objects.JSONRawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestBody(v)
		return nil
	case request.FieldResponseBody:
		v, ok := value.(objects.JSONRawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseBody(v)
		return nil
	case request.FieldResponseChunks:
		v, ok := value.([]objects.JSONRawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseChunks(v)
		return nil
	case request.FieldChannelID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelID(v)
		return nil
	case request.FieldExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	case request.FieldStatus:
		v, ok := value.(request.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case request.FieldStream:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStream(v)
		return nil
	}
	return fmt.Errorf("unknown Request field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RequestMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, request.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RequestMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case request.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RequestMutation) AddField(name string, value ent.Value) error {
	switch name {
	case request.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Request numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RequestMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(request.FieldAPIKeyID) {
		fields = append(fields, request.FieldAPIKeyID)
	}
	if m.FieldCleared(request.FieldTraceID) {
		fields = append(fields, request.FieldTraceID)
	}
	if m.FieldCleared(request.FieldResponseBody) {
		fields = append(fields, request.FieldResponseBody)
	}
	if m.FieldCleared(request.FieldResponseChunks) {
		fields = append(fields, request.FieldResponseChunks)
	}
	if m.FieldCleared(request.FieldChannelID) {
		fields = append(fields, request.FieldChannelID)
	}
	if m.FieldCleared(request.FieldExternalID) {
		fields = append(fields, request.FieldExternalID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RequestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RequestMutation) ClearField(name string) error {
	switch name {
	case request.FieldAPIKeyID:
		m.ClearAPIKeyID()
		return nil
	case request.FieldTraceID:
		m.ClearTraceID()
		return nil
	case request.FieldResponseBody:
		m.ClearResponseBody()
		return nil
	case request.FieldResponseChunks:
		m.ClearResponseChunks()
		return nil
	case request.FieldChannelID:
		m.ClearChannelID()
		return nil
	case request.FieldExternalID:
		m.ClearExternalID()
		return nil
	}
	return fmt.Errorf("unknown Request nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RequestMutation) ResetField(name string) error {
	switch name {
	case request.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case request.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case request.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case request.FieldAPIKeyID:
		m.ResetAPIKeyID()
		return nil
	case request.FieldProjectID:
		m.ResetProjectID()
		return nil
	case request.FieldTraceID:
		m.ResetTraceID()
		return nil
	case request.FieldSource:
		m.ResetSource()
		return nil
	case request.FieldModelID:
		m.ResetModelID()
		return nil
	case request.FieldFormat:
		m.ResetFormat()
		return nil
	case request.FieldRequestBody:
		m.ResetRequestBody()
		return nil
	case request.FieldResponseBody:
		m.ResetResponseBody()
		return nil
	case request.FieldResponseChunks:
		m.ResetResponseChunks()
		return nil
	case request.FieldChannelID:
		m.ResetChannelID()
		return nil
	case request.FieldExternalID:
		m.ResetExternalID()
		return nil
	case request.FieldStatus:
		m.ResetStatus()
		return nil
	case request.FieldStream:
		m.ResetStream()
		return nil
	}
	return fmt.Errorf("unknown Request field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RequestMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.api_key != nil {
		edges = append(edges, request.EdgeAPIKey)
	}
	if m.project != nil {
		edges = append(edges, request.EdgeProject)
	}
	if m.trace != nil {
		edges = append(edges, request.EdgeTrace)
	}
	if m.executions != nil {
		edges = append(edges, request.EdgeExecutions)
	}
	if m.channel != nil {
		edges = append(edges, request.EdgeChannel)
	}
	if m.usage_logs != nil {
		edges = append(edges, request.EdgeUsageLogs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RequestMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case request.EdgeAPIKey:
		if id := m.api_key; id != nil {
			return []ent.Value{*id}
		}
	case request.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case request.EdgeTrace:
		if id := m.trace; id != nil {
			return []ent.Value{*id}
		}
	case request.EdgeExecutions:
		ids := make([]ent.Value, 0, len(m.executions))
		for id := range m.executions {
			ids = append(ids, id)
		}
		return ids
	case request.EdgeChannel:
		if id := m.channel; id != nil {
			return []ent.Value{*id}
		}
	case request.EdgeUsageLogs:
		ids := make([]ent.Value, 0, len(m.usage_logs))
		for id := range m.usage_logs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RequestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedexecutions != nil {
		edges = append(edges, request.EdgeExecutions)
	}
	if m.removedusage_logs != nil {
		edges = append(edges, request.EdgeUsageLogs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RequestMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case request.EdgeExecutions:
		ids := make([]ent.Value, 0, len(m.removedexecutions))
		for id := range m.removedexecutions {
			ids = append(ids, id)
		}
		return ids
	case request.EdgeUsageLogs:
		ids := make([]ent.Value, 0, len(m.removedusage_logs))
		for id := range m.removedusage_logs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RequestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedapi_key {
		edges = append(edges, request.EdgeAPIKey)
	}
	if m.clearedproject {
		edges = append(edges, request.EdgeProject)
	}
	if m.clearedtrace {
		edges = append(edges, request.EdgeTrace)
	}
	if m.clearedexecutions {
		edges = append(edges, request.EdgeExecutions)
	}
	if m.clearedchannel {
		edges = append(edges, request.EdgeChannel)
	}
	if m.clearedusage_logs {
		edges = append(edges, request.EdgeUsageLogs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RequestMutation) EdgeCleared(name string) bool {
	switch name {
	case request.EdgeAPIKey:
		return m.clearedapi_key
	case request.EdgeProject:
		return m.clearedproject
	case request.EdgeTrace:
		return m.clearedtrace
	case request.EdgeExecutions:
		return m.clearedexecutions
	case request.EdgeChannel:
		return m.clearedchannel
	case request.EdgeUsageLogs:
		return m.clearedusage_logs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RequestMutation) ClearEdge(name string) error {
	switch name {
	case request.EdgeAPIKey:
		m.ClearAPIKey()
		return nil
	case request.EdgeProject:
		m.ClearProject()
		return nil
	case request.EdgeTrace:
		m.ClearTrace()
		return nil
	case request.EdgeChannel:
		m.ClearChannel()
		return nil
	}
	return fmt.Errorf("unknown Request unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RequestMutation) ResetEdge(name string) error {
	switch name {
	case request.EdgeAPIKey:
		m.ResetAPIKey()
		return nil
	case request.EdgeProject:
		m.ResetProject()
		return nil
	case request.EdgeTrace:
		m.ResetTrace()
		return nil
	case request.EdgeExecutions:
		m.ResetExecutions()
		return nil
	case request.EdgeChannel:
		m.ResetChannel()
		return nil
	case request.EdgeUsageLogs:
		m.ResetUsageLogs()
		return nil
	}
	return fmt.Errorf("unknown Request edge %s", name)
}

// RequestExecutionMutation represents an operation that mutates the RequestExecution nodes in the graph.
type RequestExecutionMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	created_at            *time.Time
	updated_at            *time.Time
	project_id            *int
	addproject_id         *int
	external_id           *string
	model_id              *string
	format                *string
	request_body          *objects.JSONRawMessage
	appendrequest_body    objects.JSONRawMessage
	response_body         *objects.JSONRawMessage
	appendresponse_body   objects.JSONRawMessage
	response_chunks       *[]objects.JSONRawMessage
	appendresponse_chunks []objects.JSONRawMessage
	error_message         *string
	status                *requestexecution.Status
	clearedFields         map[string]struct{}
	request               *int
	clearedrequest        bool
	channel               *int
	clearedchannel        bool
	done                  bool
	oldValue              func(context.Context) (*RequestExecution, error)
	predicates            []predicate.RequestExecution
}

var _ ent.Mutation = (*RequestExecutionMutation)(nil)

// requestexecutionOption allows management of the mutation configuration using functional options.
type requestexecutionOption func(*RequestExecutionMutation)

// newRequestExecutionMutation creates new mutation for the RequestExecution entity.
func newRequestExecutionMutation(c config, op Op, opts ...requestexecutionOption) *RequestExecutionMutation {
	m := &RequestExecutionMutation{
		config:        c,
		op:            op,
		typ:           TypeRequestExecution,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRequestExecutionID sets the ID field of the mutation.
func withRequestExecutionID(id int) requestexecutionOption {
	return func(m *RequestExecutionMutation) {
		var (
			err   error
			once  sync.Once
			value *RequestExecution
		)
		m.oldValue = func(ctx context.Context) (*RequestExecution, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RequestExecution.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRequestExecution sets the old RequestExecution of the mutation.
func withRequestExecution(node *RequestExecution) requestexecutionOption {
	return func(m *RequestExecutionMutation) {
		m.oldValue = func(context.Context) (*RequestExecution, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RequestExecutionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RequestExecutionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RequestExecutionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RequestExecutionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RequestExecution.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RequestExecutionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RequestExecutionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RequestExecution entity.
// If the RequestExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestExecutionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RequestExecutionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RequestExecutionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RequestExecutionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RequestExecution entity.
// If the RequestExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestExecutionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RequestExecutionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetProjectID sets the "project_id" field.
func (m *RequestExecutionMutation) SetProjectID(i int) {
	m.project_id = &i
	m.addproject_id = nil
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *RequestExecutionMutation) ProjectID() (r int, exists bool) {
	v := m.project_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the RequestExecution entity.
// If the RequestExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestExecutionMutation) OldProjectID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// AddProjectID adds i to the "project_id" field.
func (m *RequestExecutionMutation) AddProjectID(i int) {
	if m.addproject_id != nil {
		*m.addproject_id += i
	} else {
		m.addproject_id = &i
	}
}

// AddedProjectID returns the value that was added to the "project_id" field in this mutation.
func (m *RequestExecutionMutation) AddedProjectID() (r int, exists bool) {
	v := m.addproject_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *RequestExecutionMutation) ResetProjectID() {
	m.project_id = nil
	m.addproject_id = nil
}

// SetRequestID sets the "request_id" field.
func (m *RequestExecutionMutation) SetRequestID(i int) {
	m.request = &i
}

// RequestID returns the value of the "request_id" field in the mutation.
func (m *RequestExecutionMutation) RequestID() (r int, exists bool) {
	v := m.request
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestID returns the old "request_id" field's value of the RequestExecution entity.
// If the RequestExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestExecutionMutation) OldRequestID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestID: %w", err)
	}
	return oldValue.RequestID, nil
}

// ResetRequestID resets all changes to the "request_id" field.
func (m *RequestExecutionMutation) ResetRequestID() {
	m.request = nil
}

// SetChannelID sets the "channel_id" field.
func (m *RequestExecutionMutation) SetChannelID(i int) {
	m.channel = &i
}

// ChannelID returns the value of the "channel_id" field in the mutation.
func (m *RequestExecutionMutation) ChannelID() (r int, exists bool) {
	v := m.channel
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelID returns the old "channel_id" field's value of the RequestExecution entity.
// If the RequestExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestExecutionMutation) OldChannelID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelID: %w", err)
	}
	return oldValue.ChannelID, nil
}

// ResetChannelID resets all changes to the "channel_id" field.
func (m *RequestExecutionMutation) ResetChannelID() {
	m.channel = nil
}

// SetExternalID sets the "external_id" field.
func (m *RequestExecutionMutation) SetExternalID(s string) {
	m.external_id = &s
}

// ExternalID returns the value of the "external_id" field in the mutation.
func (m *RequestExecutionMutation) ExternalID() (r string, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old "external_id" field's value of the RequestExecution entity.
// If the RequestExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestExecutionMutation) OldExternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// ClearExternalID clears the value of the "external_id" field.
func (m *RequestExecutionMutation) ClearExternalID() {
	m.external_id = nil
	m.clearedFields[requestexecution.FieldExternalID] = struct{}{}
}

// ExternalIDCleared returns if the "external_id" field was cleared in this mutation.
func (m *RequestExecutionMutation) ExternalIDCleared() bool {
	_, ok := m.clearedFields[requestexecution.FieldExternalID]
	return ok
}

// ResetExternalID resets all changes to the "external_id" field.
func (m *RequestExecutionMutation) ResetExternalID() {
	m.external_id = nil
	delete(m.clearedFields, requestexecution.FieldExternalID)
}

// SetModelID sets the "model_id" field.
func (m *RequestExecutionMutation) SetModelID(s string) {
	m.model_id = &s
}

// ModelID returns the value of the "model_id" field in the mutation.
func (m *RequestExecutionMutation) ModelID() (r string, exists bool) {
	v := m.model_id
	if v == nil {
		return
	}
	return *v, true
}

// OldModelID returns the old "model_id" field's value of the RequestExecution entity.
// If the RequestExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestExecutionMutation) OldModelID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModelID: %w", err)
	}
	return oldValue.ModelID, nil
}

// ResetModelID resets all changes to the "model_id" field.
func (m *RequestExecutionMutation) ResetModelID() {
	m.model_id = nil
}

// SetFormat sets the "format" field.
func (m *RequestExecutionMutation) SetFormat(s string) {
	m.format = &s
}

// Format returns the value of the "format" field in the mutation.
func (m *RequestExecutionMutation) Format() (r string, exists bool) {
	v := m.format
	if v == nil {
		return
	}
	return *v, true
}

// OldFormat returns the old "format" field's value of the RequestExecution entity.
// If the RequestExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestExecutionMutation) OldFormat(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFormat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFormat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormat: %w", err)
	}
	return oldValue.Format, nil
}

// ResetFormat resets all changes to the "format" field.
func (m *RequestExecutionMutation) ResetFormat() {
	m.format = nil
}

// SetRequestBody sets the "request_body" field.
func (m *RequestExecutionMutation) SetRequestBody(orm objects.JSONRawMessage) {
	m.request_body = &orm
	m.appendrequest_body = nil
}

// RequestBody returns the value of the "request_body" field in the mutation.
func (m *RequestExecutionMutation) RequestBody() (r objects.JSONRawMessage, exists bool) {
	v := m.request_body
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestBody returns the old "request_body" field's value of the RequestExecution entity.
// If the RequestExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestExecutionMutation) OldRequestBody(ctx context.Context) (v objects.JSONRawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestBody: %w", err)
	}
	return oldValue.RequestBody, nil
}

// AppendRequestBody adds orm to the "request_body" field.
func (m *RequestExecutionMutation) AppendRequestBody(orm objects.JSONRawMessage) {
	m.appendrequest_body = append(m.appendrequest_body, orm...)
}

// AppendedRequestBody returns the list of values that were appended to the "request_body" field in this mutation.
func (m *RequestExecutionMutation) AppendedRequestBody() (objects.JSONRawMessage, bool) {
	if len(m.appendrequest_body) == 0 {
		return nil, false
	}
	return m.appendrequest_body, true
}

// ResetRequestBody resets all changes to the "request_body" field.
func (m *RequestExecutionMutation) ResetRequestBody() {
	m.request_body = nil
	m.appendrequest_body = nil
}

// SetResponseBody sets the "response_body" field.
func (m *RequestExecutionMutation) SetResponseBody(orm objects.JSONRawMessage) {
	m.response_body = &orm
	m.appendresponse_body = nil
}

// ResponseBody returns the value of the "response_body" field in the mutation.
func (m *RequestExecutionMutation) ResponseBody() (r objects.JSONRawMessage, exists bool) {
	v := m.response_body
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseBody returns the old "response_body" field's value of the RequestExecution entity.
// If the RequestExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestExecutionMutation) OldResponseBody(ctx context.Context) (v objects.JSONRawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseBody: %w", err)
	}
	return oldValue.ResponseBody, nil
}

// AppendResponseBody adds orm to the "response_body" field.
func (m *RequestExecutionMutation) AppendResponseBody(orm objects.JSONRawMessage) {
	m.appendresponse_body = append(m.appendresponse_body, orm...)
}

// AppendedResponseBody returns the list of values that were appended to the "response_body" field in this mutation.
func (m *RequestExecutionMutation) AppendedResponseBody() (objects.JSONRawMessage, bool) {
	if len(m.appendresponse_body) == 0 {
		return nil, false
	}
	return m.appendresponse_body, true
}

// ClearResponseBody clears the value of the "response_body" field.
func (m *RequestExecutionMutation) ClearResponseBody() {
	m.response_body = nil
	m.appendresponse_body = nil
	m.clearedFields[requestexecution.FieldResponseBody] = struct{}{}
}

// ResponseBodyCleared returns if the "response_body" field was cleared in this mutation.
func (m *RequestExecutionMutation) ResponseBodyCleared() bool {
	_, ok := m.clearedFields[requestexecution.FieldResponseBody]
	return ok
}

// ResetResponseBody resets all changes to the "response_body" field.
func (m *RequestExecutionMutation) ResetResponseBody() {
	m.response_body = nil
	m.appendresponse_body = nil
	delete(m.clearedFields, requestexecution.FieldResponseBody)
}

// SetResponseChunks sets the "response_chunks" field.
func (m *RequestExecutionMutation) SetResponseChunks(orm []objects.JSONRawMessage) {
	m.response_chunks = &orm
	m.appendresponse_chunks = nil
}

// ResponseChunks returns the value of the "response_chunks" field in the mutation.
func (m *RequestExecutionMutation) ResponseChunks() (r []objects.JSONRawMessage, exists bool) {
	v := m.response_chunks
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseChunks returns the old "response_chunks" field's value of the RequestExecution entity.
// If the RequestExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestExecutionMutation) OldResponseChunks(ctx context.Context) (v []objects.JSONRawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseChunks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseChunks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseChunks: %w", err)
	}
	return oldValue.ResponseChunks, nil
}

// AppendResponseChunks adds orm to the "response_chunks" field.
func (m *RequestExecutionMutation) AppendResponseChunks(orm []objects.JSONRawMessage) {
	m.appendresponse_chunks = append(m.appendresponse_chunks, orm...)
}

// AppendedResponseChunks returns the list of values that were appended to the "response_chunks" field in this mutation.
func (m *RequestExecutionMutation) AppendedResponseChunks() ([]objects.JSONRawMessage, bool) {
	if len(m.appendresponse_chunks) == 0 {
		return nil, false
	}
	return m.appendresponse_chunks, true
}

// ClearResponseChunks clears the value of the "response_chunks" field.
func (m *RequestExecutionMutation) ClearResponseChunks() {
	m.response_chunks = nil
	m.appendresponse_chunks = nil
	m.clearedFields[requestexecution.FieldResponseChunks] = struct{}{}
}

// ResponseChunksCleared returns if the "response_chunks" field was cleared in this mutation.
func (m *RequestExecutionMutation) ResponseChunksCleared() bool {
	_, ok := m.clearedFields[requestexecution.FieldResponseChunks]
	return ok
}

// ResetResponseChunks resets all changes to the "response_chunks" field.
func (m *RequestExecutionMutation) ResetResponseChunks() {
	m.response_chunks = nil
	m.appendresponse_chunks = nil
	delete(m.clearedFields, requestexecution.FieldResponseChunks)
}

// SetErrorMessage sets the "error_message" field.
func (m *RequestExecutionMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *RequestExecutionMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the RequestExecution entity.
// If the RequestExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestExecutionMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *RequestExecutionMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[requestexecution.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *RequestExecutionMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[requestexecution.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *RequestExecutionMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, requestexecution.FieldErrorMessage)
}

// SetStatus sets the "status" field.
func (m *RequestExecutionMutation) SetStatus(r requestexecution.Status) {
	m.status = &r
}

// Status returns the value of the "status" field in the mutation.
func (m *RequestExecutionMutation) Status() (r requestexecution.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the RequestExecution entity.
// If the RequestExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestExecutionMutation) OldStatus(ctx context.Context) (v requestexecution.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *RequestExecutionMutation) ResetStatus() {
	m.status = nil
}

// ClearRequest clears the "request" edge to the Request entity.
func (m *RequestExecutionMutation) ClearRequest() {
	m.clearedrequest = true
	m.clearedFields[requestexecution.FieldRequestID] = struct{}{}
}

// RequestCleared reports if the "request" edge to the Request entity was cleared.
func (m *RequestExecutionMutation) RequestCleared() bool {
	return m.clearedrequest
}

// RequestIDs returns the "request" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RequestID instead. It exists only for internal usage by the builders.
func (m *RequestExecutionMutation) RequestIDs() (ids []int) {
	if id := m.request; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRequest resets all changes to the "request" edge.
func (m *RequestExecutionMutation) ResetRequest() {
	m.request = nil
	m.clearedrequest = false
}

// ClearChannel clears the "channel" edge to the Channel entity.
func (m *RequestExecutionMutation) ClearChannel() {
	m.clearedchannel = true
	m.clearedFields[requestexecution.FieldChannelID] = struct{}{}
}

// ChannelCleared reports if the "channel" edge to the Channel entity was cleared.
func (m *RequestExecutionMutation) ChannelCleared() bool {
	return m.clearedchannel
}

// ChannelIDs returns the "channel" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChannelID instead. It exists only for internal usage by the builders.
func (m *RequestExecutionMutation) ChannelIDs() (ids []int) {
	if id := m.channel; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChannel resets all changes to the "channel" edge.
func (m *RequestExecutionMutation) ResetChannel() {
	m.channel = nil
	m.clearedchannel = false
}

// Where appends a list predicates to the RequestExecutionMutation builder.
func (m *RequestExecutionMutation) Where(ps ...predicate.RequestExecution) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RequestExecutionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RequestExecutionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RequestExecution, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RequestExecutionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RequestExecutionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RequestExecution).
func (m *RequestExecutionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RequestExecutionMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, requestexecution.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, requestexecution.FieldUpdatedAt)
	}
	if m.project_id != nil {
		fields = append(fields, requestexecution.FieldProjectID)
	}
	if m.request != nil {
		fields = append(fields, requestexecution.FieldRequestID)
	}
	if m.channel != nil {
		fields = append(fields, requestexecution.FieldChannelID)
	}
	if m.external_id != nil {
		fields = append(fields, requestexecution.FieldExternalID)
	}
	if m.model_id != nil {
		fields = append(fields, requestexecution.FieldModelID)
	}
	if m.format != nil {
		fields = append(fields, requestexecution.FieldFormat)
	}
	if m.request_body != nil {
		fields = append(fields, requestexecution.FieldRequestBody)
	}
	if m.response_body != nil {
		fields = append(fields, requestexecution.FieldResponseBody)
	}
	if m.response_chunks != nil {
		fields = append(fields, requestexecution.FieldResponseChunks)
	}
	if m.error_message != nil {
		fields = append(fields, requestexecution.FieldErrorMessage)
	}
	if m.status != nil {
		fields = append(fields, requestexecution.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RequestExecutionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case requestexecution.FieldCreatedAt:
		return m.CreatedAt()
	case requestexecution.FieldUpdatedAt:
		return m.UpdatedAt()
	case requestexecution.FieldProjectID:
		return m.ProjectID()
	case requestexecution.FieldRequestID:
		return m.RequestID()
	case requestexecution.FieldChannelID:
		return m.ChannelID()
	case requestexecution.FieldExternalID:
		return m.ExternalID()
	case requestexecution.FieldModelID:
		return m.ModelID()
	case requestexecution.FieldFormat:
		return m.Format()
	case requestexecution.FieldRequestBody:
		return m.RequestBody()
	case requestexecution.FieldResponseBody:
		return m.ResponseBody()
	case requestexecution.FieldResponseChunks:
		return m.ResponseChunks()
	case requestexecution.FieldErrorMessage:
		return m.ErrorMessage()
	case requestexecution.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RequestExecutionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case requestexecution.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case requestexecution.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case requestexecution.FieldProjectID:
		return m.OldProjectID(ctx)
	case requestexecution.FieldRequestID:
		return m.OldRequestID(ctx)
	case requestexecution.FieldChannelID:
		return m.OldChannelID(ctx)
	case requestexecution.FieldExternalID:
		return m.OldExternalID(ctx)
	case requestexecution.FieldModelID:
		return m.OldModelID(ctx)
	case requestexecution.FieldFormat:
		return m.OldFormat(ctx)
	case requestexecution.FieldRequestBody:
		return m.OldRequestBody(ctx)
	case requestexecution.FieldResponseBody:
		return m.OldResponseBody(ctx)
	case requestexecution.FieldResponseChunks:
		return m.OldResponseChunks(ctx)
	case requestexecution.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case requestexecution.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown RequestExecution field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RequestExecutionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case requestexecution.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case requestexecution.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case requestexecution.FieldProjectID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case requestexecution.FieldRequestID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestID(v)
		return nil
	case requestexecution.FieldChannelID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelID(v)
		return nil
	case requestexecution.FieldExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	case requestexecution.FieldModelID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModelID(v)
		return nil
	case requestexecution.FieldFormat:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormat(v)
		return nil
	case requestexecution.FieldRequestBody:
		v, ok := value.(objects.JSONRawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestBody(v)
		return nil
	case requestexecution.FieldResponseBody:
		v, ok := value.(objects.JSONRawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseBody(v)
		return nil
	case requestexecution.FieldResponseChunks:
		v, ok := value.([]objects.JSONRawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseChunks(v)
		return nil
	case requestexecution.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case requestexecution.FieldStatus:
		v, ok := value.(requestexecution.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown RequestExecution field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RequestExecutionMutation) AddedFields() []string {
	var fields []string
	if m.addproject_id != nil {
		fields = append(fields, requestexecution.FieldProjectID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RequestExecutionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case requestexecution.FieldProjectID:
		return m.AddedProjectID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RequestExecutionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case requestexecution.FieldProjectID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProjectID(v)
		return nil
	}
	return fmt.Errorf("unknown RequestExecution numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RequestExecutionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(requestexecution.FieldExternalID) {
		fields = append(fields, requestexecution.FieldExternalID)
	}
	if m.FieldCleared(requestexecution.FieldResponseBody) {
		fields = append(fields, requestexecution.FieldResponseBody)
	}
	if m.FieldCleared(requestexecution.FieldResponseChunks) {
		fields = append(fields, requestexecution.FieldResponseChunks)
	}
	if m.FieldCleared(requestexecution.FieldErrorMessage) {
		fields = append(fields, requestexecution.FieldErrorMessage)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RequestExecutionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RequestExecutionMutation) ClearField(name string) error {
	switch name {
	case requestexecution.FieldExternalID:
		m.ClearExternalID()
		return nil
	case requestexecution.FieldResponseBody:
		m.ClearResponseBody()
		return nil
	case requestexecution.FieldResponseChunks:
		m.ClearResponseChunks()
		return nil
	case requestexecution.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	}
	return fmt.Errorf("unknown RequestExecution nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RequestExecutionMutation) ResetField(name string) error {
	switch name {
	case requestexecution.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case requestexecution.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case requestexecution.FieldProjectID:
		m.ResetProjectID()
		return nil
	case requestexecution.FieldRequestID:
		m.ResetRequestID()
		return nil
	case requestexecution.FieldChannelID:
		m.ResetChannelID()
		return nil
	case requestexecution.FieldExternalID:
		m.ResetExternalID()
		return nil
	case requestexecution.FieldModelID:
		m.ResetModelID()
		return nil
	case requestexecution.FieldFormat:
		m.ResetFormat()
		return nil
	case requestexecution.FieldRequestBody:
		m.ResetRequestBody()
		return nil
	case requestexecution.FieldResponseBody:
		m.ResetResponseBody()
		return nil
	case requestexecution.FieldResponseChunks:
		m.ResetResponseChunks()
		return nil
	case requestexecution.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case requestexecution.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown RequestExecution field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RequestExecutionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.request != nil {
		edges = append(edges, requestexecution.EdgeRequest)
	}
	if m.channel != nil {
		edges = append(edges, requestexecution.EdgeChannel)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RequestExecutionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case requestexecution.EdgeRequest:
		if id := m.request; id != nil {
			return []ent.Value{*id}
		}
	case requestexecution.EdgeChannel:
		if id := m.channel; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RequestExecutionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RequestExecutionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RequestExecutionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedrequest {
		edges = append(edges, requestexecution.EdgeRequest)
	}
	if m.clearedchannel {
		edges = append(edges, requestexecution.EdgeChannel)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RequestExecutionMutation) EdgeCleared(name string) bool {
	switch name {
	case requestexecution.EdgeRequest:
		return m.clearedrequest
	case requestexecution.EdgeChannel:
		return m.clearedchannel
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RequestExecutionMutation) ClearEdge(name string) error {
	switch name {
	case requestexecution.EdgeRequest:
		m.ClearRequest()
		return nil
	case requestexecution.EdgeChannel:
		m.ClearChannel()
		return nil
	}
	return fmt.Errorf("unknown RequestExecution unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RequestExecutionMutation) ResetEdge(name string) error {
	switch name {
	case requestexecution.EdgeRequest:
		m.ResetRequest()
		return nil
	case requestexecution.EdgeChannel:
		m.ResetChannel()
		return nil
	}
	return fmt.Errorf("unknown RequestExecution edge %s", name)
}

// RoleMutation represents an operation that mutates the Role nodes in the graph.
type RoleMutation struct {
	config
	op                Op
	typ               string
	id                *int
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *int
	adddeleted_at     *int
	name              *string
	level             *role.Level
	scopes            *[]string
	appendscopes      []string
	clearedFields     map[string]struct{}
	users             map[int]struct{}
	removedusers      map[int]struct{}
	clearedusers      bool
	project           *int
	clearedproject    bool
	user_roles        map[int]struct{}
	removeduser_roles map[int]struct{}
	cleareduser_roles bool
	done              bool
	oldValue          func(context.Context) (*Role, error)
	predicates        []predicate.Role
}

var _ ent.Mutation = (*RoleMutation)(nil)

// roleOption allows management of the mutation configuration using functional options.
type roleOption func(*RoleMutation)

// newRoleMutation creates new mutation for the Role entity.
func newRoleMutation(c config, op Op, opts ...roleOption) *RoleMutation {
	m := &RoleMutation{
		config:        c,
		op:            op,
		typ:           TypeRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleID sets the ID field of the mutation.
func withRoleID(id int) roleOption {
	return func(m *RoleMutation) {
		var (
			err   error
			once  sync.Once
			value *Role
		)
		m.oldValue = func(ctx context.Context) (*Role, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Role.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRole sets the old Role of the mutation.
func withRole(node *Role) roleOption {
	return func(m *RoleMutation) {
		m.oldValue = func(context.Context) (*Role, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Role.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RoleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RoleMutation) SetDeletedAt(i int) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RoleMutation) DeletedAt() (r int, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldDeletedAt(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *RoleMutation) AddDeletedAt(i int) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *RoleMutation) AddedDeletedAt() (r int, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RoleMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetName sets the "name" field.
func (m *RoleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RoleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RoleMutation) ResetName() {
	m.name = nil
}

// SetLevel sets the "level" field.
func (m *RoleMutation) SetLevel(r role.Level) {
	m.level = &r
}

// Level returns the value of the "level" field in the mutation.
func (m *RoleMutation) Level() (r role.Level, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldLevel(ctx context.Context) (v role.Level, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// ResetLevel resets all changes to the "level" field.
func (m *RoleMutation) ResetLevel() {
	m.level = nil
}

// SetProjectID sets the "project_id" field.
func (m *RoleMutation) SetProjectID(i int) {
	m.project = &i
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *RoleMutation) ProjectID() (r int, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldProjectID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ClearProjectID clears the value of the "project_id" field.
func (m *RoleMutation) ClearProjectID() {
	m.project = nil
	m.clearedFields[role.FieldProjectID] = struct{}{}
}

// ProjectIDCleared returns if the "project_id" field was cleared in this mutation.
func (m *RoleMutation) ProjectIDCleared() bool {
	_, ok := m.clearedFields[role.FieldProjectID]
	return ok
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *RoleMutation) ResetProjectID() {
	m.project = nil
	delete(m.clearedFields, role.FieldProjectID)
}

// SetScopes sets the "scopes" field.
func (m *RoleMutation) SetScopes(s []string) {
	m.scopes = &s
	m.appendscopes = nil
}

// Scopes returns the value of the "scopes" field in the mutation.
func (m *RoleMutation) Scopes() (r []string, exists bool) {
	v := m.scopes
	if v == nil {
		return
	}
	return *v, true
}

// OldScopes returns the old "scopes" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldScopes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopes: %w", err)
	}
	return oldValue.Scopes, nil
}

// AppendScopes adds s to the "scopes" field.
func (m *RoleMutation) AppendScopes(s []string) {
	m.appendscopes = append(m.appendscopes, s...)
}

// AppendedScopes returns the list of values that were appended to the "scopes" field in this mutation.
func (m *RoleMutation) AppendedScopes() ([]string, bool) {
	if len(m.appendscopes) == 0 {
		return nil, false
	}
	return m.appendscopes, true
}

// ClearScopes clears the value of the "scopes" field.
func (m *RoleMutation) ClearScopes() {
	m.scopes = nil
	m.appendscopes = nil
	m.clearedFields[role.FieldScopes] = struct{}{}
}

// ScopesCleared returns if the "scopes" field was cleared in this mutation.
func (m *RoleMutation) ScopesCleared() bool {
	_, ok := m.clearedFields[role.FieldScopes]
	return ok
}

// ResetScopes resets all changes to the "scopes" field.
func (m *RoleMutation) ResetScopes() {
	m.scopes = nil
	m.appendscopes = nil
	delete(m.clearedFields, role.FieldScopes)
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *RoleMutation) AddUserIDs(ids ...int) {
	if m.users == nil {
		m.users = make(map[int]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *RoleMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *RoleMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *RoleMutation) RemoveUserIDs(ids ...int) {
	if m.removedusers == nil {
		m.removedusers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *RoleMutation) RemovedUsersIDs() (ids []int) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *RoleMutation) UsersIDs() (ids []int) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *RoleMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// ClearProject clears the "project" edge to the Project entity.
func (m *RoleMutation) ClearProject() {
	m.clearedproject = true
	m.clearedFields[role.FieldProjectID] = struct{}{}
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *RoleMutation) ProjectCleared() bool {
	return m.ProjectIDCleared() || m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *RoleMutation) ProjectIDs() (ids []int) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *RoleMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// AddUserRoleIDs adds the "user_roles" edge to the UserRole entity by ids.
func (m *RoleMutation) AddUserRoleIDs(ids ...int) {
	if m.user_roles == nil {
		m.user_roles = make(map[int]struct{})
	}
	for i := range ids {
		m.user_roles[ids[i]] = struct{}{}
	}
}

// ClearUserRoles clears the "user_roles" edge to the UserRole entity.
func (m *RoleMutation) ClearUserRoles() {
	m.cleareduser_roles = true
}

// UserRolesCleared reports if the "user_roles" edge to the UserRole entity was cleared.
func (m *RoleMutation) UserRolesCleared() bool {
	return m.cleareduser_roles
}

// RemoveUserRoleIDs removes the "user_roles" edge to the UserRole entity by IDs.
func (m *RoleMutation) RemoveUserRoleIDs(ids ...int) {
	if m.removeduser_roles == nil {
		m.removeduser_roles = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user_roles, ids[i])
		m.removeduser_roles[ids[i]] = struct{}{}
	}
}

// RemovedUserRoles returns the removed IDs of the "user_roles" edge to the UserRole entity.
func (m *RoleMutation) RemovedUserRolesIDs() (ids []int) {
	for id := range m.removeduser_roles {
		ids = append(ids, id)
	}
	return
}

// UserRolesIDs returns the "user_roles" edge IDs in the mutation.
func (m *RoleMutation) UserRolesIDs() (ids []int) {
	for id := range m.user_roles {
		ids = append(ids, id)
	}
	return
}

// ResetUserRoles resets all changes to the "user_roles" edge.
func (m *RoleMutation) ResetUserRoles() {
	m.user_roles = nil
	m.cleareduser_roles = false
	m.removeduser_roles = nil
}

// Where appends a list predicates to the RoleMutation builder.
func (m *RoleMutation) Where(ps ...predicate.Role) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Role, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Role).
func (m *RoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, role.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, role.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, role.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, role.FieldName)
	}
	if m.level != nil {
		fields = append(fields, role.FieldLevel)
	}
	if m.project != nil {
		fields = append(fields, role.FieldProjectID)
	}
	if m.scopes != nil {
		fields = append(fields, role.FieldScopes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case role.FieldCreatedAt:
		return m.CreatedAt()
	case role.FieldUpdatedAt:
		return m.UpdatedAt()
	case role.FieldDeletedAt:
		return m.DeletedAt()
	case role.FieldName:
		return m.Name()
	case role.FieldLevel:
		return m.Level()
	case role.FieldProjectID:
		return m.ProjectID()
	case role.FieldScopes:
		return m.Scopes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case role.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case role.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case role.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case role.FieldName:
		return m.OldName(ctx)
	case role.FieldLevel:
		return m.OldLevel(ctx)
	case role.FieldProjectID:
		return m.OldProjectID(ctx)
	case role.FieldScopes:
		return m.OldScopes(ctx)
	}
	return nil, fmt.Errorf("unknown Role field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case role.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case role.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case role.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case role.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case role.FieldLevel:
		v, ok := value.(role.Level)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case role.FieldProjectID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case role.FieldScopes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopes(v)
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, role.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case role.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case role.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Role numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(role.FieldProjectID) {
		fields = append(fields, role.FieldProjectID)
	}
	if m.FieldCleared(role.FieldScopes) {
		fields = append(fields, role.FieldScopes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleMutation) ClearField(name string) error {
	switch name {
	case role.FieldProjectID:
		m.ClearProjectID()
		return nil
	case role.FieldScopes:
		m.ClearScopes()
		return nil
	}
	return fmt.Errorf("unknown Role nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleMutation) ResetField(name string) error {
	switch name {
	case role.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case role.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case role.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case role.FieldName:
		m.ResetName()
		return nil
	case role.FieldLevel:
		m.ResetLevel()
		return nil
	case role.FieldProjectID:
		m.ResetProjectID()
		return nil
	case role.FieldScopes:
		m.ResetScopes()
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.users != nil {
		edges = append(edges, role.EdgeUsers)
	}
	if m.project != nil {
		edges = append(edges, role.EdgeProject)
	}
	if m.user_roles != nil {
		edges = append(edges, role.EdgeUserRoles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case role.EdgeUserRoles:
		ids := make([]ent.Value, 0, len(m.user_roles))
		for id := range m.user_roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedusers != nil {
		edges = append(edges, role.EdgeUsers)
	}
	if m.removeduser_roles != nil {
		edges = append(edges, role.EdgeUserRoles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeUserRoles:
		ids := make([]ent.Value, 0, len(m.removeduser_roles))
		for id := range m.removeduser_roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedusers {
		edges = append(edges, role.EdgeUsers)
	}
	if m.clearedproject {
		edges = append(edges, role.EdgeProject)
	}
	if m.cleareduser_roles {
		edges = append(edges, role.EdgeUserRoles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleMutation) EdgeCleared(name string) bool {
	switch name {
	case role.EdgeUsers:
		return m.clearedusers
	case role.EdgeProject:
		return m.clearedproject
	case role.EdgeUserRoles:
		return m.cleareduser_roles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleMutation) ClearEdge(name string) error {
	switch name {
	case role.EdgeProject:
		m.ClearProject()
		return nil
	}
	return fmt.Errorf("unknown Role unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleMutation) ResetEdge(name string) error {
	switch name {
	case role.EdgeUsers:
		m.ResetUsers()
		return nil
	case role.EdgeProject:
		m.ResetProject()
		return nil
	case role.EdgeUserRoles:
		m.ResetUserRoles()
		return nil
	}
	return fmt.Errorf("unknown Role edge %s", name)
}

// SystemMutation represents an operation that mutates the System nodes in the graph.
type SystemMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *int
	adddeleted_at *int
	key           *string
	value         *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*System, error)
	predicates    []predicate.System
}

var _ ent.Mutation = (*SystemMutation)(nil)

// systemOption allows management of the mutation configuration using functional options.
type systemOption func(*SystemMutation)

// newSystemMutation creates new mutation for the System entity.
func newSystemMutation(c config, op Op, opts ...systemOption) *SystemMutation {
	m := &SystemMutation{
		config:        c,
		op:            op,
		typ:           TypeSystem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSystemID sets the ID field of the mutation.
func withSystemID(id int) systemOption {
	return func(m *SystemMutation) {
		var (
			err   error
			once  sync.Once
			value *System
		)
		m.oldValue = func(ctx context.Context) (*System, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().System.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSystem sets the old System of the mutation.
func withSystem(node *System) systemOption {
	return func(m *SystemMutation) {
		m.oldValue = func(context.Context) (*System, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SystemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SystemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SystemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SystemMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().System.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SystemMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SystemMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the System entity.
// If the System object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SystemMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SystemMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SystemMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the System entity.
// If the System object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SystemMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SystemMutation) SetDeletedAt(i int) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SystemMutation) DeletedAt() (r int, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the System entity.
// If the System object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemMutation) OldDeletedAt(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *SystemMutation) AddDeletedAt(i int) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *SystemMutation) AddedDeletedAt() (r int, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SystemMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetKey sets the "key" field.
func (m *SystemMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *SystemMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the System entity.
// If the System object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *SystemMutation) ResetKey() {
	m.key = nil
}

// SetValue sets the "value" field.
func (m *SystemMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *SystemMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the System entity.
// If the System object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *SystemMutation) ResetValue() {
	m.value = nil
}

// Where appends a list predicates to the SystemMutation builder.
func (m *SystemMutation) Where(ps ...predicate.System) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SystemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SystemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.System, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SystemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SystemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (System).
func (m *SystemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SystemMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, system.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, system.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, system.FieldDeletedAt)
	}
	if m.key != nil {
		fields = append(fields, system.FieldKey)
	}
	if m.value != nil {
		fields = append(fields, system.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SystemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case system.FieldCreatedAt:
		return m.CreatedAt()
	case system.FieldUpdatedAt:
		return m.UpdatedAt()
	case system.FieldDeletedAt:
		return m.DeletedAt()
	case system.FieldKey:
		return m.Key()
	case system.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SystemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case system.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case system.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case system.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case system.FieldKey:
		return m.OldKey(ctx)
	case system.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown System field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case system.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case system.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case system.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case system.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case system.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown System field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SystemMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, system.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SystemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case system.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case system.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown System numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SystemMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SystemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SystemMutation) ClearField(name string) error {
	return fmt.Errorf("unknown System nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SystemMutation) ResetField(name string) error {
	switch name {
	case system.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case system.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case system.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case system.FieldKey:
		m.ResetKey()
		return nil
	case system.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown System field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SystemMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SystemMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SystemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SystemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SystemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SystemMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SystemMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown System unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SystemMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown System edge %s", name)
}

// ThreadMutation represents an operation that mutates the Thread nodes in the graph.
type ThreadMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	updated_at     *time.Time
	deleted_at     *int
	adddeleted_at  *int
	thread_id      *string
	clearedFields  map[string]struct{}
	project        *int
	clearedproject bool
	traces         map[int]struct{}
	removedtraces  map[int]struct{}
	clearedtraces  bool
	done           bool
	oldValue       func(context.Context) (*Thread, error)
	predicates     []predicate.Thread
}

var _ ent.Mutation = (*ThreadMutation)(nil)

// threadOption allows management of the mutation configuration using functional options.
type threadOption func(*ThreadMutation)

// newThreadMutation creates new mutation for the Thread entity.
func newThreadMutation(c config, op Op, opts ...threadOption) *ThreadMutation {
	m := &ThreadMutation{
		config:        c,
		op:            op,
		typ:           TypeThread,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withThreadID sets the ID field of the mutation.
func withThreadID(id int) threadOption {
	return func(m *ThreadMutation) {
		var (
			err   error
			once  sync.Once
			value *Thread
		)
		m.oldValue = func(ctx context.Context) (*Thread, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Thread.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withThread sets the old Thread of the mutation.
func withThread(node *Thread) threadOption {
	return func(m *ThreadMutation) {
		m.oldValue = func(context.Context) (*Thread, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ThreadMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ThreadMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ThreadMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ThreadMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Thread.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ThreadMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ThreadMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ThreadMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ThreadMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ThreadMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ThreadMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ThreadMutation) SetDeletedAt(i int) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ThreadMutation) DeletedAt() (r int, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldDeletedAt(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *ThreadMutation) AddDeletedAt(i int) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *ThreadMutation) AddedDeletedAt() (r int, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ThreadMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetProjectID sets the "project_id" field.
func (m *ThreadMutation) SetProjectID(i int) {
	m.project = &i
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *ThreadMutation) ProjectID() (r int, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldProjectID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *ThreadMutation) ResetProjectID() {
	m.project = nil
}

// SetThreadID sets the "thread_id" field.
func (m *ThreadMutation) SetThreadID(s string) {
	m.thread_id = &s
}

// ThreadID returns the value of the "thread_id" field in the mutation.
func (m *ThreadMutation) ThreadID() (r string, exists bool) {
	v := m.thread_id
	if v == nil {
		return
	}
	return *v, true
}

// OldThreadID returns the old "thread_id" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldThreadID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThreadID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThreadID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThreadID: %w", err)
	}
	return oldValue.ThreadID, nil
}

// ResetThreadID resets all changes to the "thread_id" field.
func (m *ThreadMutation) ResetThreadID() {
	m.thread_id = nil
}

// ClearProject clears the "project" edge to the Project entity.
func (m *ThreadMutation) ClearProject() {
	m.clearedproject = true
	m.clearedFields[thread.FieldProjectID] = struct{}{}
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *ThreadMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *ThreadMutation) ProjectIDs() (ids []int) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *ThreadMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// AddTraceIDs adds the "traces" edge to the Trace entity by ids.
func (m *ThreadMutation) AddTraceIDs(ids ...int) {
	if m.traces == nil {
		m.traces = make(map[int]struct{})
	}
	for i := range ids {
		m.traces[ids[i]] = struct{}{}
	}
}

// ClearTraces clears the "traces" edge to the Trace entity.
func (m *ThreadMutation) ClearTraces() {
	m.clearedtraces = true
}

// TracesCleared reports if the "traces" edge to the Trace entity was cleared.
func (m *ThreadMutation) TracesCleared() bool {
	return m.clearedtraces
}

// RemoveTraceIDs removes the "traces" edge to the Trace entity by IDs.
func (m *ThreadMutation) RemoveTraceIDs(ids ...int) {
	if m.removedtraces == nil {
		m.removedtraces = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.traces, ids[i])
		m.removedtraces[ids[i]] = struct{}{}
	}
}

// RemovedTraces returns the removed IDs of the "traces" edge to the Trace entity.
func (m *ThreadMutation) RemovedTracesIDs() (ids []int) {
	for id := range m.removedtraces {
		ids = append(ids, id)
	}
	return
}

// TracesIDs returns the "traces" edge IDs in the mutation.
func (m *ThreadMutation) TracesIDs() (ids []int) {
	for id := range m.traces {
		ids = append(ids, id)
	}
	return
}

// ResetTraces resets all changes to the "traces" edge.
func (m *ThreadMutation) ResetTraces() {
	m.traces = nil
	m.clearedtraces = false
	m.removedtraces = nil
}

// Where appends a list predicates to the ThreadMutation builder.
func (m *ThreadMutation) Where(ps ...predicate.Thread) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ThreadMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ThreadMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Thread, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ThreadMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ThreadMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Thread).
func (m *ThreadMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ThreadMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, thread.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, thread.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, thread.FieldDeletedAt)
	}
	if m.project != nil {
		fields = append(fields, thread.FieldProjectID)
	}
	if m.thread_id != nil {
		fields = append(fields, thread.FieldThreadID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ThreadMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case thread.FieldCreatedAt:
		return m.CreatedAt()
	case thread.FieldUpdatedAt:
		return m.UpdatedAt()
	case thread.FieldDeletedAt:
		return m.DeletedAt()
	case thread.FieldProjectID:
		return m.ProjectID()
	case thread.FieldThreadID:
		return m.ThreadID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ThreadMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case thread.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case thread.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case thread.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case thread.FieldProjectID:
		return m.OldProjectID(ctx)
	case thread.FieldThreadID:
		return m.OldThreadID(ctx)
	}
	return nil, fmt.Errorf("unknown Thread field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ThreadMutation) SetField(name string, value ent.Value) error {
	switch name {
	case thread.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case thread.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case thread.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case thread.FieldProjectID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case thread.FieldThreadID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThreadID(v)
		return nil
	}
	return fmt.Errorf("unknown Thread field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ThreadMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, thread.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ThreadMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case thread.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ThreadMutation) AddField(name string, value ent.Value) error {
	switch name {
	case thread.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Thread numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ThreadMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ThreadMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ThreadMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Thread nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ThreadMutation) ResetField(name string) error {
	switch name {
	case thread.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case thread.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case thread.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case thread.FieldProjectID:
		m.ResetProjectID()
		return nil
	case thread.FieldThreadID:
		m.ResetThreadID()
		return nil
	}
	return fmt.Errorf("unknown Thread field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ThreadMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.project != nil {
		edges = append(edges, thread.EdgeProject)
	}
	if m.traces != nil {
		edges = append(edges, thread.EdgeTraces)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ThreadMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case thread.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case thread.EdgeTraces:
		ids := make([]ent.Value, 0, len(m.traces))
		for id := range m.traces {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ThreadMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtraces != nil {
		edges = append(edges, thread.EdgeTraces)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ThreadMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case thread.EdgeTraces:
		ids := make([]ent.Value, 0, len(m.removedtraces))
		for id := range m.removedtraces {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ThreadMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproject {
		edges = append(edges, thread.EdgeProject)
	}
	if m.clearedtraces {
		edges = append(edges, thread.EdgeTraces)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ThreadMutation) EdgeCleared(name string) bool {
	switch name {
	case thread.EdgeProject:
		return m.clearedproject
	case thread.EdgeTraces:
		return m.clearedtraces
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ThreadMutation) ClearEdge(name string) error {
	switch name {
	case thread.EdgeProject:
		m.ClearProject()
		return nil
	}
	return fmt.Errorf("unknown Thread unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ThreadMutation) ResetEdge(name string) error {
	switch name {
	case thread.EdgeProject:
		m.ResetProject()
		return nil
	case thread.EdgeTraces:
		m.ResetTraces()
		return nil
	}
	return fmt.Errorf("unknown Thread edge %s", name)
}

// TraceMutation represents an operation that mutates the Trace nodes in the graph.
type TraceMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *int
	adddeleted_at   *int
	trace_id        *string
	clearedFields   map[string]struct{}
	project         *int
	clearedproject  bool
	thread          *int
	clearedthread   bool
	requests        map[int]struct{}
	removedrequests map[int]struct{}
	clearedrequests bool
	done            bool
	oldValue        func(context.Context) (*Trace, error)
	predicates      []predicate.Trace
}

var _ ent.Mutation = (*TraceMutation)(nil)

// traceOption allows management of the mutation configuration using functional options.
type traceOption func(*TraceMutation)

// newTraceMutation creates new mutation for the Trace entity.
func newTraceMutation(c config, op Op, opts ...traceOption) *TraceMutation {
	m := &TraceMutation{
		config:        c,
		op:            op,
		typ:           TypeTrace,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTraceID sets the ID field of the mutation.
func withTraceID(id int) traceOption {
	return func(m *TraceMutation) {
		var (
			err   error
			once  sync.Once
			value *Trace
		)
		m.oldValue = func(ctx context.Context) (*Trace, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Trace.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTrace sets the old Trace of the mutation.
func withTrace(node *Trace) traceOption {
	return func(m *TraceMutation) {
		m.oldValue = func(context.Context) (*Trace, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TraceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TraceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TraceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TraceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Trace.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TraceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TraceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Trace entity.
// If the Trace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TraceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TraceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TraceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TraceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Trace entity.
// If the Trace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TraceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TraceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TraceMutation) SetDeletedAt(i int) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TraceMutation) DeletedAt() (r int, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Trace entity.
// If the Trace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TraceMutation) OldDeletedAt(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *TraceMutation) AddDeletedAt(i int) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *TraceMutation) AddedDeletedAt() (r int, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TraceMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetProjectID sets the "project_id" field.
func (m *TraceMutation) SetProjectID(i int) {
	m.project = &i
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *TraceMutation) ProjectID() (r int, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the Trace entity.
// If the Trace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TraceMutation) OldProjectID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *TraceMutation) ResetProjectID() {
	m.project = nil
}

// SetTraceID sets the "trace_id" field.
func (m *TraceMutation) SetTraceID(s string) {
	m.trace_id = &s
}

// TraceID returns the value of the "trace_id" field in the mutation.
func (m *TraceMutation) TraceID() (r string, exists bool) {
	v := m.trace_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTraceID returns the old "trace_id" field's value of the Trace entity.
// If the Trace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TraceMutation) OldTraceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTraceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTraceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTraceID: %w", err)
	}
	return oldValue.TraceID, nil
}

// ResetTraceID resets all changes to the "trace_id" field.
func (m *TraceMutation) ResetTraceID() {
	m.trace_id = nil
}

// SetThreadID sets the "thread_id" field.
func (m *TraceMutation) SetThreadID(i int) {
	m.thread = &i
}

// ThreadID returns the value of the "thread_id" field in the mutation.
func (m *TraceMutation) ThreadID() (r int, exists bool) {
	v := m.thread
	if v == nil {
		return
	}
	return *v, true
}

// OldThreadID returns the old "thread_id" field's value of the Trace entity.
// If the Trace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TraceMutation) OldThreadID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThreadID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThreadID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThreadID: %w", err)
	}
	return oldValue.ThreadID, nil
}

// ClearThreadID clears the value of the "thread_id" field.
func (m *TraceMutation) ClearThreadID() {
	m.thread = nil
	m.clearedFields[trace.FieldThreadID] = struct{}{}
}

// ThreadIDCleared returns if the "thread_id" field was cleared in this mutation.
func (m *TraceMutation) ThreadIDCleared() bool {
	_, ok := m.clearedFields[trace.FieldThreadID]
	return ok
}

// ResetThreadID resets all changes to the "thread_id" field.
func (m *TraceMutation) ResetThreadID() {
	m.thread = nil
	delete(m.clearedFields, trace.FieldThreadID)
}

// ClearProject clears the "project" edge to the Project entity.
func (m *TraceMutation) ClearProject() {
	m.clearedproject = true
	m.clearedFields[trace.FieldProjectID] = struct{}{}
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *TraceMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *TraceMutation) ProjectIDs() (ids []int) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *TraceMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// ClearThread clears the "thread" edge to the Thread entity.
func (m *TraceMutation) ClearThread() {
	m.clearedthread = true
	m.clearedFields[trace.FieldThreadID] = struct{}{}
}

// ThreadCleared reports if the "thread" edge to the Thread entity was cleared.
func (m *TraceMutation) ThreadCleared() bool {
	return m.ThreadIDCleared() || m.clearedthread
}

// ThreadIDs returns the "thread" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ThreadID instead. It exists only for internal usage by the builders.
func (m *TraceMutation) ThreadIDs() (ids []int) {
	if id := m.thread; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetThread resets all changes to the "thread" edge.
func (m *TraceMutation) ResetThread() {
	m.thread = nil
	m.clearedthread = false
}

// AddRequestIDs adds the "requests" edge to the Request entity by ids.
func (m *TraceMutation) AddRequestIDs(ids ...int) {
	if m.requests == nil {
		m.requests = make(map[int]struct{})
	}
	for i := range ids {
		m.requests[ids[i]] = struct{}{}
	}
}

// ClearRequests clears the "requests" edge to the Request entity.
func (m *TraceMutation) ClearRequests() {
	m.clearedrequests = true
}

// RequestsCleared reports if the "requests" edge to the Request entity was cleared.
func (m *TraceMutation) RequestsCleared() bool {
	return m.clearedrequests
}

// RemoveRequestIDs removes the "requests" edge to the Request entity by IDs.
func (m *TraceMutation) RemoveRequestIDs(ids ...int) {
	if m.removedrequests == nil {
		m.removedrequests = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.requests, ids[i])
		m.removedrequests[ids[i]] = struct{}{}
	}
}

// RemovedRequests returns the removed IDs of the "requests" edge to the Request entity.
func (m *TraceMutation) RemovedRequestsIDs() (ids []int) {
	for id := range m.removedrequests {
		ids = append(ids, id)
	}
	return
}

// RequestsIDs returns the "requests" edge IDs in the mutation.
func (m *TraceMutation) RequestsIDs() (ids []int) {
	for id := range m.requests {
		ids = append(ids, id)
	}
	return
}

// ResetRequests resets all changes to the "requests" edge.
func (m *TraceMutation) ResetRequests() {
	m.requests = nil
	m.clearedrequests = false
	m.removedrequests = nil
}

// Where appends a list predicates to the TraceMutation builder.
func (m *TraceMutation) Where(ps ...predicate.Trace) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TraceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TraceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Trace, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TraceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TraceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Trace).
func (m *TraceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TraceMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, trace.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, trace.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, trace.FieldDeletedAt)
	}
	if m.project != nil {
		fields = append(fields, trace.FieldProjectID)
	}
	if m.trace_id != nil {
		fields = append(fields, trace.FieldTraceID)
	}
	if m.thread != nil {
		fields = append(fields, trace.FieldThreadID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TraceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case trace.FieldCreatedAt:
		return m.CreatedAt()
	case trace.FieldUpdatedAt:
		return m.UpdatedAt()
	case trace.FieldDeletedAt:
		return m.DeletedAt()
	case trace.FieldProjectID:
		return m.ProjectID()
	case trace.FieldTraceID:
		return m.TraceID()
	case trace.FieldThreadID:
		return m.ThreadID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TraceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case trace.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case trace.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case trace.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case trace.FieldProjectID:
		return m.OldProjectID(ctx)
	case trace.FieldTraceID:
		return m.OldTraceID(ctx)
	case trace.FieldThreadID:
		return m.OldThreadID(ctx)
	}
	return nil, fmt.Errorf("unknown Trace field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TraceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case trace.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case trace.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case trace.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case trace.FieldProjectID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case trace.FieldTraceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTraceID(v)
		return nil
	case trace.FieldThreadID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThreadID(v)
		return nil
	}
	return fmt.Errorf("unknown Trace field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TraceMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, trace.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TraceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case trace.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TraceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case trace.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Trace numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TraceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(trace.FieldThreadID) {
		fields = append(fields, trace.FieldThreadID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TraceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TraceMutation) ClearField(name string) error {
	switch name {
	case trace.FieldThreadID:
		m.ClearThreadID()
		return nil
	}
	return fmt.Errorf("unknown Trace nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TraceMutation) ResetField(name string) error {
	switch name {
	case trace.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case trace.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case trace.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case trace.FieldProjectID:
		m.ResetProjectID()
		return nil
	case trace.FieldTraceID:
		m.ResetTraceID()
		return nil
	case trace.FieldThreadID:
		m.ResetThreadID()
		return nil
	}
	return fmt.Errorf("unknown Trace field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TraceMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.project != nil {
		edges = append(edges, trace.EdgeProject)
	}
	if m.thread != nil {
		edges = append(edges, trace.EdgeThread)
	}
	if m.requests != nil {
		edges = append(edges, trace.EdgeRequests)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TraceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case trace.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case trace.EdgeThread:
		if id := m.thread; id != nil {
			return []ent.Value{*id}
		}
	case trace.EdgeRequests:
		ids := make([]ent.Value, 0, len(m.requests))
		for id := range m.requests {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TraceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedrequests != nil {
		edges = append(edges, trace.EdgeRequests)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TraceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case trace.EdgeRequests:
		ids := make([]ent.Value, 0, len(m.removedrequests))
		for id := range m.removedrequests {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TraceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedproject {
		edges = append(edges, trace.EdgeProject)
	}
	if m.clearedthread {
		edges = append(edges, trace.EdgeThread)
	}
	if m.clearedrequests {
		edges = append(edges, trace.EdgeRequests)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TraceMutation) EdgeCleared(name string) bool {
	switch name {
	case trace.EdgeProject:
		return m.clearedproject
	case trace.EdgeThread:
		return m.clearedthread
	case trace.EdgeRequests:
		return m.clearedrequests
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TraceMutation) ClearEdge(name string) error {
	switch name {
	case trace.EdgeProject:
		m.ClearProject()
		return nil
	case trace.EdgeThread:
		m.ClearThread()
		return nil
	}
	return fmt.Errorf("unknown Trace unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TraceMutation) ResetEdge(name string) error {
	switch name {
	case trace.EdgeProject:
		m.ResetProject()
		return nil
	case trace.EdgeThread:
		m.ResetThread()
		return nil
	case trace.EdgeRequests:
		m.ResetRequests()
		return nil
	}
	return fmt.Errorf("unknown Trace edge %s", name)
}

// UsageLogMutation represents an operation that mutates the UsageLog nodes in the graph.
type UsageLogMutation struct {
	config
	op                                       Op
	typ                                      string
	id                                       *int
	created_at                               *time.Time
	updated_at                               *time.Time
	deleted_at                               *int
	adddeleted_at                            *int
	model_id                                 *string
	prompt_tokens                            *int64
	addprompt_tokens                         *int64
	completion_tokens                        *int64
	addcompletion_tokens                     *int64
	total_tokens                             *int64
	addtotal_tokens                          *int64
	prompt_audio_tokens                      *int64
	addprompt_audio_tokens                   *int64
	prompt_cached_tokens                     *int64
	addprompt_cached_tokens                  *int64
	completion_audio_tokens                  *int64
	addcompletion_audio_tokens               *int64
	completion_reasoning_tokens              *int64
	addcompletion_reasoning_tokens           *int64
	completion_accepted_prediction_tokens    *int64
	addcompletion_accepted_prediction_tokens *int64
	completion_rejected_prediction_tokens    *int64
	addcompletion_rejected_prediction_tokens *int64
	source                                   *usagelog.Source
	format                                   *string
	clearedFields                            map[string]struct{}
	request                                  *int
	clearedrequest                           bool
	project                                  *int
	clearedproject                           bool
	channel                                  *int
	clearedchannel                           bool
	done                                     bool
	oldValue                                 func(context.Context) (*UsageLog, error)
	predicates                               []predicate.UsageLog
}

var _ ent.Mutation = (*UsageLogMutation)(nil)

// usagelogOption allows management of the mutation configuration using functional options.
type usagelogOption func(*UsageLogMutation)

// newUsageLogMutation creates new mutation for the UsageLog entity.
func newUsageLogMutation(c config, op Op, opts ...usagelogOption) *UsageLogMutation {
	m := &UsageLogMutation{
		config:        c,
		op:            op,
		typ:           TypeUsageLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUsageLogID sets the ID field of the mutation.
func withUsageLogID(id int) usagelogOption {
	return func(m *UsageLogMutation) {
		var (
			err   error
			once  sync.Once
			value *UsageLog
		)
		m.oldValue = func(ctx context.Context) (*UsageLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UsageLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUsageLog sets the old UsageLog of the mutation.
func withUsageLog(node *UsageLog) usagelogOption {
	return func(m *UsageLogMutation) {
		m.oldValue = func(context.Context) (*UsageLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UsageLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UsageLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UsageLogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UsageLogMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UsageLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UsageLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UsageLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UsageLogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UsageLogMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UsageLogMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UsageLogMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UsageLogMutation) SetDeletedAt(i int) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UsageLogMutation) DeletedAt() (r int, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldDeletedAt(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *UsageLogMutation) AddDeletedAt(i int) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *UsageLogMutation) AddedDeletedAt() (r int, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UsageLogMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetRequestID sets the "request_id" field.
func (m *UsageLogMutation) SetRequestID(i int) {
	m.request = &i
}

// RequestID returns the value of the "request_id" field in the mutation.
func (m *UsageLogMutation) RequestID() (r int, exists bool) {
	v := m.request
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestID returns the old "request_id" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldRequestID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestID: %w", err)
	}
	return oldValue.RequestID, nil
}

// ResetRequestID resets all changes to the "request_id" field.
func (m *UsageLogMutation) ResetRequestID() {
	m.request = nil
}

// SetProjectID sets the "project_id" field.
func (m *UsageLogMutation) SetProjectID(i int) {
	m.project = &i
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *UsageLogMutation) ProjectID() (r int, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldProjectID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *UsageLogMutation) ResetProjectID() {
	m.project = nil
}

// SetChannelID sets the "channel_id" field.
func (m *UsageLogMutation) SetChannelID(i int) {
	m.channel = &i
}

// ChannelID returns the value of the "channel_id" field in the mutation.
func (m *UsageLogMutation) ChannelID() (r int, exists bool) {
	v := m.channel
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelID returns the old "channel_id" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldChannelID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelID: %w", err)
	}
	return oldValue.ChannelID, nil
}

// ClearChannelID clears the value of the "channel_id" field.
func (m *UsageLogMutation) ClearChannelID() {
	m.channel = nil
	m.clearedFields[usagelog.FieldChannelID] = struct{}{}
}

// ChannelIDCleared returns if the "channel_id" field was cleared in this mutation.
func (m *UsageLogMutation) ChannelIDCleared() bool {
	_, ok := m.clearedFields[usagelog.FieldChannelID]
	return ok
}

// ResetChannelID resets all changes to the "channel_id" field.
func (m *UsageLogMutation) ResetChannelID() {
	m.channel = nil
	delete(m.clearedFields, usagelog.FieldChannelID)
}

// SetModelID sets the "model_id" field.
func (m *UsageLogMutation) SetModelID(s string) {
	m.model_id = &s
}

// ModelID returns the value of the "model_id" field in the mutation.
func (m *UsageLogMutation) ModelID() (r string, exists bool) {
	v := m.model_id
	if v == nil {
		return
	}
	return *v, true
}

// OldModelID returns the old "model_id" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldModelID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModelID: %w", err)
	}
	return oldValue.ModelID, nil
}

// ResetModelID resets all changes to the "model_id" field.
func (m *UsageLogMutation) ResetModelID() {
	m.model_id = nil
}

// SetPromptTokens sets the "prompt_tokens" field.
func (m *UsageLogMutation) SetPromptTokens(i int64) {
	m.prompt_tokens = &i
	m.addprompt_tokens = nil
}

// PromptTokens returns the value of the "prompt_tokens" field in the mutation.
func (m *UsageLogMutation) PromptTokens() (r int64, exists bool) {
	v := m.prompt_tokens
	if v == nil {
		return
	}
	return *v, true
}

// OldPromptTokens returns the old "prompt_tokens" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldPromptTokens(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPromptTokens is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPromptTokens requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPromptTokens: %w", err)
	}
	return oldValue.PromptTokens, nil
}

// AddPromptTokens adds i to the "prompt_tokens" field.
func (m *UsageLogMutation) AddPromptTokens(i int64) {
	if m.addprompt_tokens != nil {
		*m.addprompt_tokens += i
	} else {
		m.addprompt_tokens = &i
	}
}

// AddedPromptTokens returns the value that was added to the "prompt_tokens" field in this mutation.
func (m *UsageLogMutation) AddedPromptTokens() (r int64, exists bool) {
	v := m.addprompt_tokens
	if v == nil {
		return
	}
	return *v, true
}

// ResetPromptTokens resets all changes to the "prompt_tokens" field.
func (m *UsageLogMutation) ResetPromptTokens() {
	m.prompt_tokens = nil
	m.addprompt_tokens = nil
}

// SetCompletionTokens sets the "completion_tokens" field.
func (m *UsageLogMutation) SetCompletionTokens(i int64) {
	m.completion_tokens = &i
	m.addcompletion_tokens = nil
}

// CompletionTokens returns the value of the "completion_tokens" field in the mutation.
func (m *UsageLogMutation) CompletionTokens() (r int64, exists bool) {
	v := m.completion_tokens
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletionTokens returns the old "completion_tokens" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldCompletionTokens(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletionTokens is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletionTokens requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletionTokens: %w", err)
	}
	return oldValue.CompletionTokens, nil
}

// AddCompletionTokens adds i to the "completion_tokens" field.
func (m *UsageLogMutation) AddCompletionTokens(i int64) {
	if m.addcompletion_tokens != nil {
		*m.addcompletion_tokens += i
	} else {
		m.addcompletion_tokens = &i
	}
}

// AddedCompletionTokens returns the value that was added to the "completion_tokens" field in this mutation.
func (m *UsageLogMutation) AddedCompletionTokens() (r int64, exists bool) {
	v := m.addcompletion_tokens
	if v == nil {
		return
	}
	return *v, true
}

// ResetCompletionTokens resets all changes to the "completion_tokens" field.
func (m *UsageLogMutation) ResetCompletionTokens() {
	m.completion_tokens = nil
	m.addcompletion_tokens = nil
}

// SetTotalTokens sets the "total_tokens" field.
func (m *UsageLogMutation) SetTotalTokens(i int64) {
	m.total_tokens = &i
	m.addtotal_tokens = nil
}

// TotalTokens returns the value of the "total_tokens" field in the mutation.
func (m *UsageLogMutation) TotalTokens() (r int64, exists bool) {
	v := m.total_tokens
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalTokens returns the old "total_tokens" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldTotalTokens(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalTokens is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalTokens requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalTokens: %w", err)
	}
	return oldValue.TotalTokens, nil
}

// AddTotalTokens adds i to the "total_tokens" field.
func (m *UsageLogMutation) AddTotalTokens(i int64) {
	if m.addtotal_tokens != nil {
		*m.addtotal_tokens += i
	} else {
		m.addtotal_tokens = &i
	}
}

// AddedTotalTokens returns the value that was added to the "total_tokens" field in this mutation.
func (m *UsageLogMutation) AddedTotalTokens() (r int64, exists bool) {
	v := m.addtotal_tokens
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalTokens resets all changes to the "total_tokens" field.
func (m *UsageLogMutation) ResetTotalTokens() {
	m.total_tokens = nil
	m.addtotal_tokens = nil
}

// SetPromptAudioTokens sets the "prompt_audio_tokens" field.
func (m *UsageLogMutation) SetPromptAudioTokens(i int64) {
	m.prompt_audio_tokens = &i
	m.addprompt_audio_tokens = nil
}

// PromptAudioTokens returns the value of the "prompt_audio_tokens" field in the mutation.
func (m *UsageLogMutation) PromptAudioTokens() (r int64, exists bool) {
	v := m.prompt_audio_tokens
	if v == nil {
		return
	}
	return *v, true
}

// OldPromptAudioTokens returns the old "prompt_audio_tokens" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldPromptAudioTokens(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPromptAudioTokens is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPromptAudioTokens requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPromptAudioTokens: %w", err)
	}
	return oldValue.PromptAudioTokens, nil
}

// AddPromptAudioTokens adds i to the "prompt_audio_tokens" field.
func (m *UsageLogMutation) AddPromptAudioTokens(i int64) {
	if m.addprompt_audio_tokens != nil {
		*m.addprompt_audio_tokens += i
	} else {
		m.addprompt_audio_tokens = &i
	}
}

// AddedPromptAudioTokens returns the value that was added to the "prompt_audio_tokens" field in this mutation.
func (m *UsageLogMutation) AddedPromptAudioTokens() (r int64, exists bool) {
	v := m.addprompt_audio_tokens
	if v == nil {
		return
	}
	return *v, true
}

// ClearPromptAudioTokens clears the value of the "prompt_audio_tokens" field.
func (m *UsageLogMutation) ClearPromptAudioTokens() {
	m.prompt_audio_tokens = nil
	m.addprompt_audio_tokens = nil
	m.clearedFields[usagelog.FieldPromptAudioTokens] = struct{}{}
}

// PromptAudioTokensCleared returns if the "prompt_audio_tokens" field was cleared in this mutation.
func (m *UsageLogMutation) PromptAudioTokensCleared() bool {
	_, ok := m.clearedFields[usagelog.FieldPromptAudioTokens]
	return ok
}

// ResetPromptAudioTokens resets all changes to the "prompt_audio_tokens" field.
func (m *UsageLogMutation) ResetPromptAudioTokens() {
	m.prompt_audio_tokens = nil
	m.addprompt_audio_tokens = nil
	delete(m.clearedFields, usagelog.FieldPromptAudioTokens)
}

// SetPromptCachedTokens sets the "prompt_cached_tokens" field.
func (m *UsageLogMutation) SetPromptCachedTokens(i int64) {
	m.prompt_cached_tokens = &i
	m.addprompt_cached_tokens = nil
}

// PromptCachedTokens returns the value of the "prompt_cached_tokens" field in the mutation.
func (m *UsageLogMutation) PromptCachedTokens() (r int64, exists bool) {
	v := m.prompt_cached_tokens
	if v == nil {
		return
	}
	return *v, true
}

// OldPromptCachedTokens returns the old "prompt_cached_tokens" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldPromptCachedTokens(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPromptCachedTokens is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPromptCachedTokens requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPromptCachedTokens: %w", err)
	}
	return oldValue.PromptCachedTokens, nil
}

// AddPromptCachedTokens adds i to the "prompt_cached_tokens" field.
func (m *UsageLogMutation) AddPromptCachedTokens(i int64) {
	if m.addprompt_cached_tokens != nil {
		*m.addprompt_cached_tokens += i
	} else {
		m.addprompt_cached_tokens = &i
	}
}

// AddedPromptCachedTokens returns the value that was added to the "prompt_cached_tokens" field in this mutation.
func (m *UsageLogMutation) AddedPromptCachedTokens() (r int64, exists bool) {
	v := m.addprompt_cached_tokens
	if v == nil {
		return
	}
	return *v, true
}

// ClearPromptCachedTokens clears the value of the "prompt_cached_tokens" field.
func (m *UsageLogMutation) ClearPromptCachedTokens() {
	m.prompt_cached_tokens = nil
	m.addprompt_cached_tokens = nil
	m.clearedFields[usagelog.FieldPromptCachedTokens] = struct{}{}
}

// PromptCachedTokensCleared returns if the "prompt_cached_tokens" field was cleared in this mutation.
func (m *UsageLogMutation) PromptCachedTokensCleared() bool {
	_, ok := m.clearedFields[usagelog.FieldPromptCachedTokens]
	return ok
}

// ResetPromptCachedTokens resets all changes to the "prompt_cached_tokens" field.
func (m *UsageLogMutation) ResetPromptCachedTokens() {
	m.prompt_cached_tokens = nil
	m.addprompt_cached_tokens = nil
	delete(m.clearedFields, usagelog.FieldPromptCachedTokens)
}

// SetCompletionAudioTokens sets the "completion_audio_tokens" field.
func (m *UsageLogMutation) SetCompletionAudioTokens(i int64) {
	m.completion_audio_tokens = &i
	m.addcompletion_audio_tokens = nil
}

// CompletionAudioTokens returns the value of the "completion_audio_tokens" field in the mutation.
func (m *UsageLogMutation) CompletionAudioTokens() (r int64, exists bool) {
	v := m.completion_audio_tokens
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletionAudioTokens returns the old "completion_audio_tokens" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldCompletionAudioTokens(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletionAudioTokens is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletionAudioTokens requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletionAudioTokens: %w", err)
	}
	return oldValue.CompletionAudioTokens, nil
}

// AddCompletionAudioTokens adds i to the "completion_audio_tokens" field.
func (m *UsageLogMutation) AddCompletionAudioTokens(i int64) {
	if m.addcompletion_audio_tokens != nil {
		*m.addcompletion_audio_tokens += i
	} else {
		m.addcompletion_audio_tokens = &i
	}
}

// AddedCompletionAudioTokens returns the value that was added to the "completion_audio_tokens" field in this mutation.
func (m *UsageLogMutation) AddedCompletionAudioTokens() (r int64, exists bool) {
	v := m.addcompletion_audio_tokens
	if v == nil {
		return
	}
	return *v, true
}

// ClearCompletionAudioTokens clears the value of the "completion_audio_tokens" field.
func (m *UsageLogMutation) ClearCompletionAudioTokens() {
	m.completion_audio_tokens = nil
	m.addcompletion_audio_tokens = nil
	m.clearedFields[usagelog.FieldCompletionAudioTokens] = struct{}{}
}

// CompletionAudioTokensCleared returns if the "completion_audio_tokens" field was cleared in this mutation.
func (m *UsageLogMutation) CompletionAudioTokensCleared() bool {
	_, ok := m.clearedFields[usagelog.FieldCompletionAudioTokens]
	return ok
}

// ResetCompletionAudioTokens resets all changes to the "completion_audio_tokens" field.
func (m *UsageLogMutation) ResetCompletionAudioTokens() {
	m.completion_audio_tokens = nil
	m.addcompletion_audio_tokens = nil
	delete(m.clearedFields, usagelog.FieldCompletionAudioTokens)
}

// SetCompletionReasoningTokens sets the "completion_reasoning_tokens" field.
func (m *UsageLogMutation) SetCompletionReasoningTokens(i int64) {
	m.completion_reasoning_tokens = &i
	m.addcompletion_reasoning_tokens = nil
}

// CompletionReasoningTokens returns the value of the "completion_reasoning_tokens" field in the mutation.
func (m *UsageLogMutation) CompletionReasoningTokens() (r int64, exists bool) {
	v := m.completion_reasoning_tokens
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletionReasoningTokens returns the old "completion_reasoning_tokens" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldCompletionReasoningTokens(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletionReasoningTokens is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletionReasoningTokens requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletionReasoningTokens: %w", err)
	}
	return oldValue.CompletionReasoningTokens, nil
}

// AddCompletionReasoningTokens adds i to the "completion_reasoning_tokens" field.
func (m *UsageLogMutation) AddCompletionReasoningTokens(i int64) {
	if m.addcompletion_reasoning_tokens != nil {
		*m.addcompletion_reasoning_tokens += i
	} else {
		m.addcompletion_reasoning_tokens = &i
	}
}

// AddedCompletionReasoningTokens returns the value that was added to the "completion_reasoning_tokens" field in this mutation.
func (m *UsageLogMutation) AddedCompletionReasoningTokens() (r int64, exists bool) {
	v := m.addcompletion_reasoning_tokens
	if v == nil {
		return
	}
	return *v, true
}

// ClearCompletionReasoningTokens clears the value of the "completion_reasoning_tokens" field.
func (m *UsageLogMutation) ClearCompletionReasoningTokens() {
	m.completion_reasoning_tokens = nil
	m.addcompletion_reasoning_tokens = nil
	m.clearedFields[usagelog.FieldCompletionReasoningTokens] = struct{}{}
}

// CompletionReasoningTokensCleared returns if the "completion_reasoning_tokens" field was cleared in this mutation.
func (m *UsageLogMutation) CompletionReasoningTokensCleared() bool {
	_, ok := m.clearedFields[usagelog.FieldCompletionReasoningTokens]
	return ok
}

// ResetCompletionReasoningTokens resets all changes to the "completion_reasoning_tokens" field.
func (m *UsageLogMutation) ResetCompletionReasoningTokens() {
	m.completion_reasoning_tokens = nil
	m.addcompletion_reasoning_tokens = nil
	delete(m.clearedFields, usagelog.FieldCompletionReasoningTokens)
}

// SetCompletionAcceptedPredictionTokens sets the "completion_accepted_prediction_tokens" field.
func (m *UsageLogMutation) SetCompletionAcceptedPredictionTokens(i int64) {
	m.completion_accepted_prediction_tokens = &i
	m.addcompletion_accepted_prediction_tokens = nil
}

// CompletionAcceptedPredictionTokens returns the value of the "completion_accepted_prediction_tokens" field in the mutation.
func (m *UsageLogMutation) CompletionAcceptedPredictionTokens() (r int64, exists bool) {
	v := m.completion_accepted_prediction_tokens
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletionAcceptedPredictionTokens returns the old "completion_accepted_prediction_tokens" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldCompletionAcceptedPredictionTokens(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletionAcceptedPredictionTokens is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletionAcceptedPredictionTokens requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletionAcceptedPredictionTokens: %w", err)
	}
	return oldValue.CompletionAcceptedPredictionTokens, nil
}

// AddCompletionAcceptedPredictionTokens adds i to the "completion_accepted_prediction_tokens" field.
func (m *UsageLogMutation) AddCompletionAcceptedPredictionTokens(i int64) {
	if m.addcompletion_accepted_prediction_tokens != nil {
		*m.addcompletion_accepted_prediction_tokens += i
	} else {
		m.addcompletion_accepted_prediction_tokens = &i
	}
}

// AddedCompletionAcceptedPredictionTokens returns the value that was added to the "completion_accepted_prediction_tokens" field in this mutation.
func (m *UsageLogMutation) AddedCompletionAcceptedPredictionTokens() (r int64, exists bool) {
	v := m.addcompletion_accepted_prediction_tokens
	if v == nil {
		return
	}
	return *v, true
}

// ClearCompletionAcceptedPredictionTokens clears the value of the "completion_accepted_prediction_tokens" field.
func (m *UsageLogMutation) ClearCompletionAcceptedPredictionTokens() {
	m.completion_accepted_prediction_tokens = nil
	m.addcompletion_accepted_prediction_tokens = nil
	m.clearedFields[usagelog.FieldCompletionAcceptedPredictionTokens] = struct{}{}
}

// CompletionAcceptedPredictionTokensCleared returns if the "completion_accepted_prediction_tokens" field was cleared in this mutation.
func (m *UsageLogMutation) CompletionAcceptedPredictionTokensCleared() bool {
	_, ok := m.clearedFields[usagelog.FieldCompletionAcceptedPredictionTokens]
	return ok
}

// ResetCompletionAcceptedPredictionTokens resets all changes to the "completion_accepted_prediction_tokens" field.
func (m *UsageLogMutation) ResetCompletionAcceptedPredictionTokens() {
	m.completion_accepted_prediction_tokens = nil
	m.addcompletion_accepted_prediction_tokens = nil
	delete(m.clearedFields, usagelog.FieldCompletionAcceptedPredictionTokens)
}

// SetCompletionRejectedPredictionTokens sets the "completion_rejected_prediction_tokens" field.
func (m *UsageLogMutation) SetCompletionRejectedPredictionTokens(i int64) {
	m.completion_rejected_prediction_tokens = &i
	m.addcompletion_rejected_prediction_tokens = nil
}

// CompletionRejectedPredictionTokens returns the value of the "completion_rejected_prediction_tokens" field in the mutation.
func (m *UsageLogMutation) CompletionRejectedPredictionTokens() (r int64, exists bool) {
	v := m.completion_rejected_prediction_tokens
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletionRejectedPredictionTokens returns the old "completion_rejected_prediction_tokens" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldCompletionRejectedPredictionTokens(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletionRejectedPredictionTokens is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletionRejectedPredictionTokens requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletionRejectedPredictionTokens: %w", err)
	}
	return oldValue.CompletionRejectedPredictionTokens, nil
}

// AddCompletionRejectedPredictionTokens adds i to the "completion_rejected_prediction_tokens" field.
func (m *UsageLogMutation) AddCompletionRejectedPredictionTokens(i int64) {
	if m.addcompletion_rejected_prediction_tokens != nil {
		*m.addcompletion_rejected_prediction_tokens += i
	} else {
		m.addcompletion_rejected_prediction_tokens = &i
	}
}

// AddedCompletionRejectedPredictionTokens returns the value that was added to the "completion_rejected_prediction_tokens" field in this mutation.
func (m *UsageLogMutation) AddedCompletionRejectedPredictionTokens() (r int64, exists bool) {
	v := m.addcompletion_rejected_prediction_tokens
	if v == nil {
		return
	}
	return *v, true
}

// ClearCompletionRejectedPredictionTokens clears the value of the "completion_rejected_prediction_tokens" field.
func (m *UsageLogMutation) ClearCompletionRejectedPredictionTokens() {
	m.completion_rejected_prediction_tokens = nil
	m.addcompletion_rejected_prediction_tokens = nil
	m.clearedFields[usagelog.FieldCompletionRejectedPredictionTokens] = struct{}{}
}

// CompletionRejectedPredictionTokensCleared returns if the "completion_rejected_prediction_tokens" field was cleared in this mutation.
func (m *UsageLogMutation) CompletionRejectedPredictionTokensCleared() bool {
	_, ok := m.clearedFields[usagelog.FieldCompletionRejectedPredictionTokens]
	return ok
}

// ResetCompletionRejectedPredictionTokens resets all changes to the "completion_rejected_prediction_tokens" field.
func (m *UsageLogMutation) ResetCompletionRejectedPredictionTokens() {
	m.completion_rejected_prediction_tokens = nil
	m.addcompletion_rejected_prediction_tokens = nil
	delete(m.clearedFields, usagelog.FieldCompletionRejectedPredictionTokens)
}

// SetSource sets the "source" field.
func (m *UsageLogMutation) SetSource(u usagelog.Source) {
	m.source = &u
}

// Source returns the value of the "source" field in the mutation.
func (m *UsageLogMutation) Source() (r usagelog.Source, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldSource(ctx context.Context) (v usagelog.Source, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *UsageLogMutation) ResetSource() {
	m.source = nil
}

// SetFormat sets the "format" field.
func (m *UsageLogMutation) SetFormat(s string) {
	m.format = &s
}

// Format returns the value of the "format" field in the mutation.
func (m *UsageLogMutation) Format() (r string, exists bool) {
	v := m.format
	if v == nil {
		return
	}
	return *v, true
}

// OldFormat returns the old "format" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldFormat(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFormat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFormat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormat: %w", err)
	}
	return oldValue.Format, nil
}

// ResetFormat resets all changes to the "format" field.
func (m *UsageLogMutation) ResetFormat() {
	m.format = nil
}

// ClearRequest clears the "request" edge to the Request entity.
func (m *UsageLogMutation) ClearRequest() {
	m.clearedrequest = true
	m.clearedFields[usagelog.FieldRequestID] = struct{}{}
}

// RequestCleared reports if the "request" edge to the Request entity was cleared.
func (m *UsageLogMutation) RequestCleared() bool {
	return m.clearedrequest
}

// RequestIDs returns the "request" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RequestID instead. It exists only for internal usage by the builders.
func (m *UsageLogMutation) RequestIDs() (ids []int) {
	if id := m.request; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRequest resets all changes to the "request" edge.
func (m *UsageLogMutation) ResetRequest() {
	m.request = nil
	m.clearedrequest = false
}

// ClearProject clears the "project" edge to the Project entity.
func (m *UsageLogMutation) ClearProject() {
	m.clearedproject = true
	m.clearedFields[usagelog.FieldProjectID] = struct{}{}
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *UsageLogMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *UsageLogMutation) ProjectIDs() (ids []int) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *UsageLogMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// ClearChannel clears the "channel" edge to the Channel entity.
func (m *UsageLogMutation) ClearChannel() {
	m.clearedchannel = true
	m.clearedFields[usagelog.FieldChannelID] = struct{}{}
}

// ChannelCleared reports if the "channel" edge to the Channel entity was cleared.
func (m *UsageLogMutation) ChannelCleared() bool {
	return m.ChannelIDCleared() || m.clearedchannel
}

// ChannelIDs returns the "channel" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChannelID instead. It exists only for internal usage by the builders.
func (m *UsageLogMutation) ChannelIDs() (ids []int) {
	if id := m.channel; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChannel resets all changes to the "channel" edge.
func (m *UsageLogMutation) ResetChannel() {
	m.channel = nil
	m.clearedchannel = false
}

// Where appends a list predicates to the UsageLogMutation builder.
func (m *UsageLogMutation) Where(ps ...predicate.UsageLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UsageLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UsageLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UsageLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UsageLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UsageLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UsageLog).
func (m *UsageLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UsageLogMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.created_at != nil {
		fields = append(fields, usagelog.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, usagelog.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, usagelog.FieldDeletedAt)
	}
	if m.request != nil {
		fields = append(fields, usagelog.FieldRequestID)
	}
	if m.project != nil {
		fields = append(fields, usagelog.FieldProjectID)
	}
	if m.channel != nil {
		fields = append(fields, usagelog.FieldChannelID)
	}
	if m.model_id != nil {
		fields = append(fields, usagelog.FieldModelID)
	}
	if m.prompt_tokens != nil {
		fields = append(fields, usagelog.FieldPromptTokens)
	}
	if m.completion_tokens != nil {
		fields = append(fields, usagelog.FieldCompletionTokens)
	}
	if m.total_tokens != nil {
		fields = append(fields, usagelog.FieldTotalTokens)
	}
	if m.prompt_audio_tokens != nil {
		fields = append(fields, usagelog.FieldPromptAudioTokens)
	}
	if m.prompt_cached_tokens != nil {
		fields = append(fields, usagelog.FieldPromptCachedTokens)
	}
	if m.completion_audio_tokens != nil {
		fields = append(fields, usagelog.FieldCompletionAudioTokens)
	}
	if m.completion_reasoning_tokens != nil {
		fields = append(fields, usagelog.FieldCompletionReasoningTokens)
	}
	if m.completion_accepted_prediction_tokens != nil {
		fields = append(fields, usagelog.FieldCompletionAcceptedPredictionTokens)
	}
	if m.completion_rejected_prediction_tokens != nil {
		fields = append(fields, usagelog.FieldCompletionRejectedPredictionTokens)
	}
	if m.source != nil {
		fields = append(fields, usagelog.FieldSource)
	}
	if m.format != nil {
		fields = append(fields, usagelog.FieldFormat)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UsageLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usagelog.FieldCreatedAt:
		return m.CreatedAt()
	case usagelog.FieldUpdatedAt:
		return m.UpdatedAt()
	case usagelog.FieldDeletedAt:
		return m.DeletedAt()
	case usagelog.FieldRequestID:
		return m.RequestID()
	case usagelog.FieldProjectID:
		return m.ProjectID()
	case usagelog.FieldChannelID:
		return m.ChannelID()
	case usagelog.FieldModelID:
		return m.ModelID()
	case usagelog.FieldPromptTokens:
		return m.PromptTokens()
	case usagelog.FieldCompletionTokens:
		return m.CompletionTokens()
	case usagelog.FieldTotalTokens:
		return m.TotalTokens()
	case usagelog.FieldPromptAudioTokens:
		return m.PromptAudioTokens()
	case usagelog.FieldPromptCachedTokens:
		return m.PromptCachedTokens()
	case usagelog.FieldCompletionAudioTokens:
		return m.CompletionAudioTokens()
	case usagelog.FieldCompletionReasoningTokens:
		return m.CompletionReasoningTokens()
	case usagelog.FieldCompletionAcceptedPredictionTokens:
		return m.CompletionAcceptedPredictionTokens()
	case usagelog.FieldCompletionRejectedPredictionTokens:
		return m.CompletionRejectedPredictionTokens()
	case usagelog.FieldSource:
		return m.Source()
	case usagelog.FieldFormat:
		return m.Format()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UsageLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usagelog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case usagelog.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case usagelog.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case usagelog.FieldRequestID:
		return m.OldRequestID(ctx)
	case usagelog.FieldProjectID:
		return m.OldProjectID(ctx)
	case usagelog.FieldChannelID:
		return m.OldChannelID(ctx)
	case usagelog.FieldModelID:
		return m.OldModelID(ctx)
	case usagelog.FieldPromptTokens:
		return m.OldPromptTokens(ctx)
	case usagelog.FieldCompletionTokens:
		return m.OldCompletionTokens(ctx)
	case usagelog.FieldTotalTokens:
		return m.OldTotalTokens(ctx)
	case usagelog.FieldPromptAudioTokens:
		return m.OldPromptAudioTokens(ctx)
	case usagelog.FieldPromptCachedTokens:
		return m.OldPromptCachedTokens(ctx)
	case usagelog.FieldCompletionAudioTokens:
		return m.OldCompletionAudioTokens(ctx)
	case usagelog.FieldCompletionReasoningTokens:
		return m.OldCompletionReasoningTokens(ctx)
	case usagelog.FieldCompletionAcceptedPredictionTokens:
		return m.OldCompletionAcceptedPredictionTokens(ctx)
	case usagelog.FieldCompletionRejectedPredictionTokens:
		return m.OldCompletionRejectedPredictionTokens(ctx)
	case usagelog.FieldSource:
		return m.OldSource(ctx)
	case usagelog.FieldFormat:
		return m.OldFormat(ctx)
	}
	return nil, fmt.Errorf("unknown UsageLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UsageLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usagelog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case usagelog.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case usagelog.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case usagelog.FieldRequestID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestID(v)
		return nil
	case usagelog.FieldProjectID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case usagelog.FieldChannelID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelID(v)
		return nil
	case usagelog.FieldModelID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModelID(v)
		return nil
	case usagelog.FieldPromptTokens:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPromptTokens(v)
		return nil
	case usagelog.FieldCompletionTokens:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletionTokens(v)
		return nil
	case usagelog.FieldTotalTokens:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalTokens(v)
		return nil
	case usagelog.FieldPromptAudioTokens:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPromptAudioTokens(v)
		return nil
	case usagelog.FieldPromptCachedTokens:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPromptCachedTokens(v)
		return nil
	case usagelog.FieldCompletionAudioTokens:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletionAudioTokens(v)
		return nil
	case usagelog.FieldCompletionReasoningTokens:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletionReasoningTokens(v)
		return nil
	case usagelog.FieldCompletionAcceptedPredictionTokens:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletionAcceptedPredictionTokens(v)
		return nil
	case usagelog.FieldCompletionRejectedPredictionTokens:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletionRejectedPredictionTokens(v)
		return nil
	case usagelog.FieldSource:
		v, ok := value.(usagelog.Source)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case usagelog.FieldFormat:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormat(v)
		return nil
	}
	return fmt.Errorf("unknown UsageLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UsageLogMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, usagelog.FieldDeletedAt)
	}
	if m.addprompt_tokens != nil {
		fields = append(fields, usagelog.FieldPromptTokens)
	}
	if m.addcompletion_tokens != nil {
		fields = append(fields, usagelog.FieldCompletionTokens)
	}
	if m.addtotal_tokens != nil {
		fields = append(fields, usagelog.FieldTotalTokens)
	}
	if m.addprompt_audio_tokens != nil {
		fields = append(fields, usagelog.FieldPromptAudioTokens)
	}
	if m.addprompt_cached_tokens != nil {
		fields = append(fields, usagelog.FieldPromptCachedTokens)
	}
	if m.addcompletion_audio_tokens != nil {
		fields = append(fields, usagelog.FieldCompletionAudioTokens)
	}
	if m.addcompletion_reasoning_tokens != nil {
		fields = append(fields, usagelog.FieldCompletionReasoningTokens)
	}
	if m.addcompletion_accepted_prediction_tokens != nil {
		fields = append(fields, usagelog.FieldCompletionAcceptedPredictionTokens)
	}
	if m.addcompletion_rejected_prediction_tokens != nil {
		fields = append(fields, usagelog.FieldCompletionRejectedPredictionTokens)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UsageLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case usagelog.FieldDeletedAt:
		return m.AddedDeletedAt()
	case usagelog.FieldPromptTokens:
		return m.AddedPromptTokens()
	case usagelog.FieldCompletionTokens:
		return m.AddedCompletionTokens()
	case usagelog.FieldTotalTokens:
		return m.AddedTotalTokens()
	case usagelog.FieldPromptAudioTokens:
		return m.AddedPromptAudioTokens()
	case usagelog.FieldPromptCachedTokens:
		return m.AddedPromptCachedTokens()
	case usagelog.FieldCompletionAudioTokens:
		return m.AddedCompletionAudioTokens()
	case usagelog.FieldCompletionReasoningTokens:
		return m.AddedCompletionReasoningTokens()
	case usagelog.FieldCompletionAcceptedPredictionTokens:
		return m.AddedCompletionAcceptedPredictionTokens()
	case usagelog.FieldCompletionRejectedPredictionTokens:
		return m.AddedCompletionRejectedPredictionTokens()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UsageLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case usagelog.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case usagelog.FieldPromptTokens:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPromptTokens(v)
		return nil
	case usagelog.FieldCompletionTokens:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCompletionTokens(v)
		return nil
	case usagelog.FieldTotalTokens:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalTokens(v)
		return nil
	case usagelog.FieldPromptAudioTokens:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPromptAudioTokens(v)
		return nil
	case usagelog.FieldPromptCachedTokens:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPromptCachedTokens(v)
		return nil
	case usagelog.FieldCompletionAudioTokens:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCompletionAudioTokens(v)
		return nil
	case usagelog.FieldCompletionReasoningTokens:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCompletionReasoningTokens(v)
		return nil
	case usagelog.FieldCompletionAcceptedPredictionTokens:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCompletionAcceptedPredictionTokens(v)
		return nil
	case usagelog.FieldCompletionRejectedPredictionTokens:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCompletionRejectedPredictionTokens(v)
		return nil
	}
	return fmt.Errorf("unknown UsageLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UsageLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(usagelog.FieldChannelID) {
		fields = append(fields, usagelog.FieldChannelID)
	}
	if m.FieldCleared(usagelog.FieldPromptAudioTokens) {
		fields = append(fields, usagelog.FieldPromptAudioTokens)
	}
	if m.FieldCleared(usagelog.FieldPromptCachedTokens) {
		fields = append(fields, usagelog.FieldPromptCachedTokens)
	}
	if m.FieldCleared(usagelog.FieldCompletionAudioTokens) {
		fields = append(fields, usagelog.FieldCompletionAudioTokens)
	}
	if m.FieldCleared(usagelog.FieldCompletionReasoningTokens) {
		fields = append(fields, usagelog.FieldCompletionReasoningTokens)
	}
	if m.FieldCleared(usagelog.FieldCompletionAcceptedPredictionTokens) {
		fields = append(fields, usagelog.FieldCompletionAcceptedPredictionTokens)
	}
	if m.FieldCleared(usagelog.FieldCompletionRejectedPredictionTokens) {
		fields = append(fields, usagelog.FieldCompletionRejectedPredictionTokens)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UsageLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UsageLogMutation) ClearField(name string) error {
	switch name {
	case usagelog.FieldChannelID:
		m.ClearChannelID()
		return nil
	case usagelog.FieldPromptAudioTokens:
		m.ClearPromptAudioTokens()
		return nil
	case usagelog.FieldPromptCachedTokens:
		m.ClearPromptCachedTokens()
		return nil
	case usagelog.FieldCompletionAudioTokens:
		m.ClearCompletionAudioTokens()
		return nil
	case usagelog.FieldCompletionReasoningTokens:
		m.ClearCompletionReasoningTokens()
		return nil
	case usagelog.FieldCompletionAcceptedPredictionTokens:
		m.ClearCompletionAcceptedPredictionTokens()
		return nil
	case usagelog.FieldCompletionRejectedPredictionTokens:
		m.ClearCompletionRejectedPredictionTokens()
		return nil
	}
	return fmt.Errorf("unknown UsageLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UsageLogMutation) ResetField(name string) error {
	switch name {
	case usagelog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case usagelog.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case usagelog.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case usagelog.FieldRequestID:
		m.ResetRequestID()
		return nil
	case usagelog.FieldProjectID:
		m.ResetProjectID()
		return nil
	case usagelog.FieldChannelID:
		m.ResetChannelID()
		return nil
	case usagelog.FieldModelID:
		m.ResetModelID()
		return nil
	case usagelog.FieldPromptTokens:
		m.ResetPromptTokens()
		return nil
	case usagelog.FieldCompletionTokens:
		m.ResetCompletionTokens()
		return nil
	case usagelog.FieldTotalTokens:
		m.ResetTotalTokens()
		return nil
	case usagelog.FieldPromptAudioTokens:
		m.ResetPromptAudioTokens()
		return nil
	case usagelog.FieldPromptCachedTokens:
		m.ResetPromptCachedTokens()
		return nil
	case usagelog.FieldCompletionAudioTokens:
		m.ResetCompletionAudioTokens()
		return nil
	case usagelog.FieldCompletionReasoningTokens:
		m.ResetCompletionReasoningTokens()
		return nil
	case usagelog.FieldCompletionAcceptedPredictionTokens:
		m.ResetCompletionAcceptedPredictionTokens()
		return nil
	case usagelog.FieldCompletionRejectedPredictionTokens:
		m.ResetCompletionRejectedPredictionTokens()
		return nil
	case usagelog.FieldSource:
		m.ResetSource()
		return nil
	case usagelog.FieldFormat:
		m.ResetFormat()
		return nil
	}
	return fmt.Errorf("unknown UsageLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UsageLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.request != nil {
		edges = append(edges, usagelog.EdgeRequest)
	}
	if m.project != nil {
		edges = append(edges, usagelog.EdgeProject)
	}
	if m.channel != nil {
		edges = append(edges, usagelog.EdgeChannel)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UsageLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usagelog.EdgeRequest:
		if id := m.request; id != nil {
			return []ent.Value{*id}
		}
	case usagelog.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case usagelog.EdgeChannel:
		if id := m.channel; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UsageLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UsageLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UsageLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedrequest {
		edges = append(edges, usagelog.EdgeRequest)
	}
	if m.clearedproject {
		edges = append(edges, usagelog.EdgeProject)
	}
	if m.clearedchannel {
		edges = append(edges, usagelog.EdgeChannel)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UsageLogMutation) EdgeCleared(name string) bool {
	switch name {
	case usagelog.EdgeRequest:
		return m.clearedrequest
	case usagelog.EdgeProject:
		return m.clearedproject
	case usagelog.EdgeChannel:
		return m.clearedchannel
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UsageLogMutation) ClearEdge(name string) error {
	switch name {
	case usagelog.EdgeRequest:
		m.ClearRequest()
		return nil
	case usagelog.EdgeProject:
		m.ClearProject()
		return nil
	case usagelog.EdgeChannel:
		m.ClearChannel()
		return nil
	}
	return fmt.Errorf("unknown UsageLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UsageLogMutation) ResetEdge(name string) error {
	switch name {
	case usagelog.EdgeRequest:
		m.ResetRequest()
		return nil
	case usagelog.EdgeProject:
		m.ResetProject()
		return nil
	case usagelog.EdgeChannel:
		m.ResetChannel()
		return nil
	}
	return fmt.Errorf("unknown UsageLog edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	created_at           *time.Time
	updated_at           *time.Time
	deleted_at           *int
	adddeleted_at        *int
	email                *string
	status               *user.Status
	prefer_language      *string
	password             *string
	first_name           *string
	last_name            *string
	avatar               *string
	is_owner             *bool
	scopes               *[]string
	appendscopes         []string
	clearedFields        map[string]struct{}
	projects             map[int]struct{}
	removedprojects      map[int]struct{}
	clearedprojects      bool
	api_keys             map[int]struct{}
	removedapi_keys      map[int]struct{}
	clearedapi_keys      bool
	roles                map[int]struct{}
	removedroles         map[int]struct{}
	clearedroles         bool
	project_users        map[int]struct{}
	removedproject_users map[int]struct{}
	clearedproject_users bool
	user_roles           map[int]struct{}
	removeduser_roles    map[int]struct{}
	cleareduser_roles    bool
	done                 bool
	oldValue             func(context.Context) (*User, error)
	predicates           []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserMutation) SetDeletedAt(i int) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserMutation) DeletedAt() (r int, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedAt(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *UserMutation) AddDeletedAt(i int) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *UserMutation) AddedDeletedAt() (r int, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetStatus sets the "status" field.
func (m *UserMutation) SetStatus(u user.Status) {
	m.status = &u
}

// Status returns the value of the "status" field in the mutation.
func (m *UserMutation) Status() (r user.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStatus(ctx context.Context) (v user.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *UserMutation) ResetStatus() {
	m.status = nil
}

// SetPreferLanguage sets the "prefer_language" field.
func (m *UserMutation) SetPreferLanguage(s string) {
	m.prefer_language = &s
}

// PreferLanguage returns the value of the "prefer_language" field in the mutation.
func (m *UserMutation) PreferLanguage() (r string, exists bool) {
	v := m.prefer_language
	if v == nil {
		return
	}
	return *v, true
}

// OldPreferLanguage returns the old "prefer_language" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPreferLanguage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPreferLanguage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPreferLanguage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPreferLanguage: %w", err)
	}
	return oldValue.PreferLanguage, nil
}

// ResetPreferLanguage resets all changes to the "prefer_language" field.
func (m *UserMutation) ResetPreferLanguage() {
	m.prefer_language = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetFirstName sets the "first_name" field.
func (m *UserMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *UserMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *UserMutation) ResetFirstName() {
	m.first_name = nil
}

// SetLastName sets the "last_name" field.
func (m *UserMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *UserMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *UserMutation) ResetLastName() {
	m.last_name = nil
}

// SetAvatar sets the "avatar" field.
func (m *UserMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *UserMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ClearAvatar clears the value of the "avatar" field.
func (m *UserMutation) ClearAvatar() {
	m.avatar = nil
	m.clearedFields[user.FieldAvatar] = struct{}{}
}

// AvatarCleared returns if the "avatar" field was cleared in this mutation.
func (m *UserMutation) AvatarCleared() bool {
	_, ok := m.clearedFields[user.FieldAvatar]
	return ok
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *UserMutation) ResetAvatar() {
	m.avatar = nil
	delete(m.clearedFields, user.FieldAvatar)
}

// SetIsOwner sets the "is_owner" field.
func (m *UserMutation) SetIsOwner(b bool) {
	m.is_owner = &b
}

// IsOwner returns the value of the "is_owner" field in the mutation.
func (m *UserMutation) IsOwner() (r bool, exists bool) {
	v := m.is_owner
	if v == nil {
		return
	}
	return *v, true
}

// OldIsOwner returns the old "is_owner" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsOwner(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsOwner is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsOwner requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsOwner: %w", err)
	}
	return oldValue.IsOwner, nil
}

// ResetIsOwner resets all changes to the "is_owner" field.
func (m *UserMutation) ResetIsOwner() {
	m.is_owner = nil
}

// SetScopes sets the "scopes" field.
func (m *UserMutation) SetScopes(s []string) {
	m.scopes = &s
	m.appendscopes = nil
}

// Scopes returns the value of the "scopes" field in the mutation.
func (m *UserMutation) Scopes() (r []string, exists bool) {
	v := m.scopes
	if v == nil {
		return
	}
	return *v, true
}

// OldScopes returns the old "scopes" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldScopes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopes: %w", err)
	}
	return oldValue.Scopes, nil
}

// AppendScopes adds s to the "scopes" field.
func (m *UserMutation) AppendScopes(s []string) {
	m.appendscopes = append(m.appendscopes, s...)
}

// AppendedScopes returns the list of values that were appended to the "scopes" field in this mutation.
func (m *UserMutation) AppendedScopes() ([]string, bool) {
	if len(m.appendscopes) == 0 {
		return nil, false
	}
	return m.appendscopes, true
}

// ClearScopes clears the value of the "scopes" field.
func (m *UserMutation) ClearScopes() {
	m.scopes = nil
	m.appendscopes = nil
	m.clearedFields[user.FieldScopes] = struct{}{}
}

// ScopesCleared returns if the "scopes" field was cleared in this mutation.
func (m *UserMutation) ScopesCleared() bool {
	_, ok := m.clearedFields[user.FieldScopes]
	return ok
}

// ResetScopes resets all changes to the "scopes" field.
func (m *UserMutation) ResetScopes() {
	m.scopes = nil
	m.appendscopes = nil
	delete(m.clearedFields, user.FieldScopes)
}

// AddProjectIDs adds the "projects" edge to the Project entity by ids.
func (m *UserMutation) AddProjectIDs(ids ...int) {
	if m.projects == nil {
		m.projects = make(map[int]struct{})
	}
	for i := range ids {
		m.projects[ids[i]] = struct{}{}
	}
}

// ClearProjects clears the "projects" edge to the Project entity.
func (m *UserMutation) ClearProjects() {
	m.clearedprojects = true
}

// ProjectsCleared reports if the "projects" edge to the Project entity was cleared.
func (m *UserMutation) ProjectsCleared() bool {
	return m.clearedprojects
}

// RemoveProjectIDs removes the "projects" edge to the Project entity by IDs.
func (m *UserMutation) RemoveProjectIDs(ids ...int) {
	if m.removedprojects == nil {
		m.removedprojects = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.projects, ids[i])
		m.removedprojects[ids[i]] = struct{}{}
	}
}

// RemovedProjects returns the removed IDs of the "projects" edge to the Project entity.
func (m *UserMutation) RemovedProjectsIDs() (ids []int) {
	for id := range m.removedprojects {
		ids = append(ids, id)
	}
	return
}

// ProjectsIDs returns the "projects" edge IDs in the mutation.
func (m *UserMutation) ProjectsIDs() (ids []int) {
	for id := range m.projects {
		ids = append(ids, id)
	}
	return
}

// ResetProjects resets all changes to the "projects" edge.
func (m *UserMutation) ResetProjects() {
	m.projects = nil
	m.clearedprojects = false
	m.removedprojects = nil
}

// AddAPIKeyIDs adds the "api_keys" edge to the APIKey entity by ids.
func (m *UserMutation) AddAPIKeyIDs(ids ...int) {
	if m.api_keys == nil {
		m.api_keys = make(map[int]struct{})
	}
	for i := range ids {
		m.api_keys[ids[i]] = struct{}{}
	}
}

// ClearAPIKeys clears the "api_keys" edge to the APIKey entity.
func (m *UserMutation) ClearAPIKeys() {
	m.clearedapi_keys = true
}

// APIKeysCleared reports if the "api_keys" edge to the APIKey entity was cleared.
func (m *UserMutation) APIKeysCleared() bool {
	return m.clearedapi_keys
}

// RemoveAPIKeyIDs removes the "api_keys" edge to the APIKey entity by IDs.
func (m *UserMutation) RemoveAPIKeyIDs(ids ...int) {
	if m.removedapi_keys == nil {
		m.removedapi_keys = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.api_keys, ids[i])
		m.removedapi_keys[ids[i]] = struct{}{}
	}
}

// RemovedAPIKeys returns the removed IDs of the "api_keys" edge to the APIKey entity.
func (m *UserMutation) RemovedAPIKeysIDs() (ids []int) {
	for id := range m.removedapi_keys {
		ids = append(ids, id)
	}
	return
}

// APIKeysIDs returns the "api_keys" edge IDs in the mutation.
func (m *UserMutation) APIKeysIDs() (ids []int) {
	for id := range m.api_keys {
		ids = append(ids, id)
	}
	return
}

// ResetAPIKeys resets all changes to the "api_keys" edge.
func (m *UserMutation) ResetAPIKeys() {
	m.api_keys = nil
	m.clearedapi_keys = false
	m.removedapi_keys = nil
}

// AddRoleIDs adds the "roles" edge to the Role entity by ids.
func (m *UserMutation) AddRoleIDs(ids ...int) {
	if m.roles == nil {
		m.roles = make(map[int]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the Role entity.
func (m *UserMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the Role entity was cleared.
func (m *UserMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the Role entity by IDs.
func (m *UserMutation) RemoveRoleIDs(ids ...int) {
	if m.removedroles == nil {
		m.removedroles = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the Role entity.
func (m *UserMutation) RemovedRolesIDs() (ids []int) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *UserMutation) RolesIDs() (ids []int) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *UserMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// AddProjectUserIDs adds the "project_users" edge to the UserProject entity by ids.
func (m *UserMutation) AddProjectUserIDs(ids ...int) {
	if m.project_users == nil {
		m.project_users = make(map[int]struct{})
	}
	for i := range ids {
		m.project_users[ids[i]] = struct{}{}
	}
}

// ClearProjectUsers clears the "project_users" edge to the UserProject entity.
func (m *UserMutation) ClearProjectUsers() {
	m.clearedproject_users = true
}

// ProjectUsersCleared reports if the "project_users" edge to the UserProject entity was cleared.
func (m *UserMutation) ProjectUsersCleared() bool {
	return m.clearedproject_users
}

// RemoveProjectUserIDs removes the "project_users" edge to the UserProject entity by IDs.
func (m *UserMutation) RemoveProjectUserIDs(ids ...int) {
	if m.removedproject_users == nil {
		m.removedproject_users = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.project_users, ids[i])
		m.removedproject_users[ids[i]] = struct{}{}
	}
}

// RemovedProjectUsers returns the removed IDs of the "project_users" edge to the UserProject entity.
func (m *UserMutation) RemovedProjectUsersIDs() (ids []int) {
	for id := range m.removedproject_users {
		ids = append(ids, id)
	}
	return
}

// ProjectUsersIDs returns the "project_users" edge IDs in the mutation.
func (m *UserMutation) ProjectUsersIDs() (ids []int) {
	for id := range m.project_users {
		ids = append(ids, id)
	}
	return
}

// ResetProjectUsers resets all changes to the "project_users" edge.
func (m *UserMutation) ResetProjectUsers() {
	m.project_users = nil
	m.clearedproject_users = false
	m.removedproject_users = nil
}

// AddUserRoleIDs adds the "user_roles" edge to the UserRole entity by ids.
func (m *UserMutation) AddUserRoleIDs(ids ...int) {
	if m.user_roles == nil {
		m.user_roles = make(map[int]struct{})
	}
	for i := range ids {
		m.user_roles[ids[i]] = struct{}{}
	}
}

// ClearUserRoles clears the "user_roles" edge to the UserRole entity.
func (m *UserMutation) ClearUserRoles() {
	m.cleareduser_roles = true
}

// UserRolesCleared reports if the "user_roles" edge to the UserRole entity was cleared.
func (m *UserMutation) UserRolesCleared() bool {
	return m.cleareduser_roles
}

// RemoveUserRoleIDs removes the "user_roles" edge to the UserRole entity by IDs.
func (m *UserMutation) RemoveUserRoleIDs(ids ...int) {
	if m.removeduser_roles == nil {
		m.removeduser_roles = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user_roles, ids[i])
		m.removeduser_roles[ids[i]] = struct{}{}
	}
}

// RemovedUserRoles returns the removed IDs of the "user_roles" edge to the UserRole entity.
func (m *UserMutation) RemovedUserRolesIDs() (ids []int) {
	for id := range m.removeduser_roles {
		ids = append(ids, id)
	}
	return
}

// UserRolesIDs returns the "user_roles" edge IDs in the mutation.
func (m *UserMutation) UserRolesIDs() (ids []int) {
	for id := range m.user_roles {
		ids = append(ids, id)
	}
	return
}

// ResetUserRoles resets all changes to the "user_roles" edge.
func (m *UserMutation) ResetUserRoles() {
	m.user_roles = nil
	m.cleareduser_roles = false
	m.removeduser_roles = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.status != nil {
		fields = append(fields, user.FieldStatus)
	}
	if m.prefer_language != nil {
		fields = append(fields, user.FieldPreferLanguage)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.first_name != nil {
		fields = append(fields, user.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, user.FieldLastName)
	}
	if m.avatar != nil {
		fields = append(fields, user.FieldAvatar)
	}
	if m.is_owner != nil {
		fields = append(fields, user.FieldIsOwner)
	}
	if m.scopes != nil {
		fields = append(fields, user.FieldScopes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldDeletedAt:
		return m.DeletedAt()
	case user.FieldEmail:
		return m.Email()
	case user.FieldStatus:
		return m.Status()
	case user.FieldPreferLanguage:
		return m.PreferLanguage()
	case user.FieldPassword:
		return m.Password()
	case user.FieldFirstName:
		return m.FirstName()
	case user.FieldLastName:
		return m.LastName()
	case user.FieldAvatar:
		return m.Avatar()
	case user.FieldIsOwner:
		return m.IsOwner()
	case user.FieldScopes:
		return m.Scopes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldStatus:
		return m.OldStatus(ctx)
	case user.FieldPreferLanguage:
		return m.OldPreferLanguage(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldFirstName:
		return m.OldFirstName(ctx)
	case user.FieldLastName:
		return m.OldLastName(ctx)
	case user.FieldAvatar:
		return m.OldAvatar(ctx)
	case user.FieldIsOwner:
		return m.OldIsOwner(ctx)
	case user.FieldScopes:
		return m.OldScopes(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(user.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case user.FieldPreferLanguage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPreferLanguage(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case user.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case user.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case user.FieldIsOwner:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsOwner(v)
		return nil
	case user.FieldScopes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopes(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldAvatar) {
		fields = append(fields, user.FieldAvatar)
	}
	if m.FieldCleared(user.FieldScopes) {
		fields = append(fields, user.FieldScopes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldAvatar:
		m.ClearAvatar()
		return nil
	case user.FieldScopes:
		m.ClearScopes()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldStatus:
		m.ResetStatus()
		return nil
	case user.FieldPreferLanguage:
		m.ResetPreferLanguage()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldFirstName:
		m.ResetFirstName()
		return nil
	case user.FieldLastName:
		m.ResetLastName()
		return nil
	case user.FieldAvatar:
		m.ResetAvatar()
		return nil
	case user.FieldIsOwner:
		m.ResetIsOwner()
		return nil
	case user.FieldScopes:
		m.ResetScopes()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.projects != nil {
		edges = append(edges, user.EdgeProjects)
	}
	if m.api_keys != nil {
		edges = append(edges, user.EdgeAPIKeys)
	}
	if m.roles != nil {
		edges = append(edges, user.EdgeRoles)
	}
	if m.project_users != nil {
		edges = append(edges, user.EdgeProjectUsers)
	}
	if m.user_roles != nil {
		edges = append(edges, user.EdgeUserRoles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.projects))
		for id := range m.projects {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAPIKeys:
		ids := make([]ent.Value, 0, len(m.api_keys))
		for id := range m.api_keys {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeProjectUsers:
		ids := make([]ent.Value, 0, len(m.project_users))
		for id := range m.project_users {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserRoles:
		ids := make([]ent.Value, 0, len(m.user_roles))
		for id := range m.user_roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedprojects != nil {
		edges = append(edges, user.EdgeProjects)
	}
	if m.removedapi_keys != nil {
		edges = append(edges, user.EdgeAPIKeys)
	}
	if m.removedroles != nil {
		edges = append(edges, user.EdgeRoles)
	}
	if m.removedproject_users != nil {
		edges = append(edges, user.EdgeProjectUsers)
	}
	if m.removeduser_roles != nil {
		edges = append(edges, user.EdgeUserRoles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.removedprojects))
		for id := range m.removedprojects {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAPIKeys:
		ids := make([]ent.Value, 0, len(m.removedapi_keys))
		for id := range m.removedapi_keys {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeProjectUsers:
		ids := make([]ent.Value, 0, len(m.removedproject_users))
		for id := range m.removedproject_users {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserRoles:
		ids := make([]ent.Value, 0, len(m.removeduser_roles))
		for id := range m.removeduser_roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedprojects {
		edges = append(edges, user.EdgeProjects)
	}
	if m.clearedapi_keys {
		edges = append(edges, user.EdgeAPIKeys)
	}
	if m.clearedroles {
		edges = append(edges, user.EdgeRoles)
	}
	if m.clearedproject_users {
		edges = append(edges, user.EdgeProjectUsers)
	}
	if m.cleareduser_roles {
		edges = append(edges, user.EdgeUserRoles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeProjects:
		return m.clearedprojects
	case user.EdgeAPIKeys:
		return m.clearedapi_keys
	case user.EdgeRoles:
		return m.clearedroles
	case user.EdgeProjectUsers:
		return m.clearedproject_users
	case user.EdgeUserRoles:
		return m.cleareduser_roles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeProjects:
		m.ResetProjects()
		return nil
	case user.EdgeAPIKeys:
		m.ResetAPIKeys()
		return nil
	case user.EdgeRoles:
		m.ResetRoles()
		return nil
	case user.EdgeProjectUsers:
		m.ResetProjectUsers()
		return nil
	case user.EdgeUserRoles:
		m.ResetUserRoles()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserProjectMutation represents an operation that mutates the UserProject nodes in the graph.
type UserProjectMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	updated_at     *time.Time
	deleted_at     *int
	adddeleted_at  *int
	is_owner       *bool
	scopes         *[]string
	appendscopes   []string
	clearedFields  map[string]struct{}
	user           *int
	cleareduser    bool
	project        *int
	clearedproject bool
	done           bool
	oldValue       func(context.Context) (*UserProject, error)
	predicates     []predicate.UserProject
}

var _ ent.Mutation = (*UserProjectMutation)(nil)

// userprojectOption allows management of the mutation configuration using functional options.
type userprojectOption func(*UserProjectMutation)

// newUserProjectMutation creates new mutation for the UserProject entity.
func newUserProjectMutation(c config, op Op, opts ...userprojectOption) *UserProjectMutation {
	m := &UserProjectMutation{
		config:        c,
		op:            op,
		typ:           TypeUserProject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserProjectID sets the ID field of the mutation.
func withUserProjectID(id int) userprojectOption {
	return func(m *UserProjectMutation) {
		var (
			err   error
			once  sync.Once
			value *UserProject
		)
		m.oldValue = func(ctx context.Context) (*UserProject, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserProject.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserProject sets the old UserProject of the mutation.
func withUserProject(node *UserProject) userprojectOption {
	return func(m *UserProjectMutation) {
		m.oldValue = func(context.Context) (*UserProject, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserProjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserProjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserProjectMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserProjectMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserProject.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserProjectMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserProjectMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserProject entity.
// If the UserProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProjectMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserProjectMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserProjectMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserProjectMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserProject entity.
// If the UserProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProjectMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserProjectMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserProjectMutation) SetDeletedAt(i int) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserProjectMutation) DeletedAt() (r int, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the UserProject entity.
// If the UserProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProjectMutation) OldDeletedAt(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *UserProjectMutation) AddDeletedAt(i int) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *UserProjectMutation) AddedDeletedAt() (r int, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserProjectMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetUserID sets the "user_id" field.
func (m *UserProjectMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserProjectMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserProject entity.
// If the UserProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProjectMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserProjectMutation) ResetUserID() {
	m.user = nil
}

// SetProjectID sets the "project_id" field.
func (m *UserProjectMutation) SetProjectID(i int) {
	m.project = &i
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *UserProjectMutation) ProjectID() (r int, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the UserProject entity.
// If the UserProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProjectMutation) OldProjectID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *UserProjectMutation) ResetProjectID() {
	m.project = nil
}

// SetIsOwner sets the "is_owner" field.
func (m *UserProjectMutation) SetIsOwner(b bool) {
	m.is_owner = &b
}

// IsOwner returns the value of the "is_owner" field in the mutation.
func (m *UserProjectMutation) IsOwner() (r bool, exists bool) {
	v := m.is_owner
	if v == nil {
		return
	}
	return *v, true
}

// OldIsOwner returns the old "is_owner" field's value of the UserProject entity.
// If the UserProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProjectMutation) OldIsOwner(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsOwner is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsOwner requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsOwner: %w", err)
	}
	return oldValue.IsOwner, nil
}

// ResetIsOwner resets all changes to the "is_owner" field.
func (m *UserProjectMutation) ResetIsOwner() {
	m.is_owner = nil
}

// SetScopes sets the "scopes" field.
func (m *UserProjectMutation) SetScopes(s []string) {
	m.scopes = &s
	m.appendscopes = nil
}

// Scopes returns the value of the "scopes" field in the mutation.
func (m *UserProjectMutation) Scopes() (r []string, exists bool) {
	v := m.scopes
	if v == nil {
		return
	}
	return *v, true
}

// OldScopes returns the old "scopes" field's value of the UserProject entity.
// If the UserProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProjectMutation) OldScopes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopes: %w", err)
	}
	return oldValue.Scopes, nil
}

// AppendScopes adds s to the "scopes" field.
func (m *UserProjectMutation) AppendScopes(s []string) {
	m.appendscopes = append(m.appendscopes, s...)
}

// AppendedScopes returns the list of values that were appended to the "scopes" field in this mutation.
func (m *UserProjectMutation) AppendedScopes() ([]string, bool) {
	if len(m.appendscopes) == 0 {
		return nil, false
	}
	return m.appendscopes, true
}

// ClearScopes clears the value of the "scopes" field.
func (m *UserProjectMutation) ClearScopes() {
	m.scopes = nil
	m.appendscopes = nil
	m.clearedFields[userproject.FieldScopes] = struct{}{}
}

// ScopesCleared returns if the "scopes" field was cleared in this mutation.
func (m *UserProjectMutation) ScopesCleared() bool {
	_, ok := m.clearedFields[userproject.FieldScopes]
	return ok
}

// ResetScopes resets all changes to the "scopes" field.
func (m *UserProjectMutation) ResetScopes() {
	m.scopes = nil
	m.appendscopes = nil
	delete(m.clearedFields, userproject.FieldScopes)
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserProjectMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[userproject.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserProjectMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserProjectMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserProjectMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearProject clears the "project" edge to the Project entity.
func (m *UserProjectMutation) ClearProject() {
	m.clearedproject = true
	m.clearedFields[userproject.FieldProjectID] = struct{}{}
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *UserProjectMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *UserProjectMutation) ProjectIDs() (ids []int) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *UserProjectMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// Where appends a list predicates to the UserProjectMutation builder.
func (m *UserProjectMutation) Where(ps ...predicate.UserProject) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserProjectMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserProjectMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserProject, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserProjectMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserProjectMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserProject).
func (m *UserProjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserProjectMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, userproject.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userproject.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, userproject.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, userproject.FieldUserID)
	}
	if m.project != nil {
		fields = append(fields, userproject.FieldProjectID)
	}
	if m.is_owner != nil {
		fields = append(fields, userproject.FieldIsOwner)
	}
	if m.scopes != nil {
		fields = append(fields, userproject.FieldScopes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserProjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userproject.FieldCreatedAt:
		return m.CreatedAt()
	case userproject.FieldUpdatedAt:
		return m.UpdatedAt()
	case userproject.FieldDeletedAt:
		return m.DeletedAt()
	case userproject.FieldUserID:
		return m.UserID()
	case userproject.FieldProjectID:
		return m.ProjectID()
	case userproject.FieldIsOwner:
		return m.IsOwner()
	case userproject.FieldScopes:
		return m.Scopes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserProjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userproject.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userproject.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userproject.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case userproject.FieldUserID:
		return m.OldUserID(ctx)
	case userproject.FieldProjectID:
		return m.OldProjectID(ctx)
	case userproject.FieldIsOwner:
		return m.OldIsOwner(ctx)
	case userproject.FieldScopes:
		return m.OldScopes(ctx)
	}
	return nil, fmt.Errorf("unknown UserProject field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserProjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userproject.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userproject.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userproject.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case userproject.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userproject.FieldProjectID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case userproject.FieldIsOwner:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsOwner(v)
		return nil
	case userproject.FieldScopes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopes(v)
		return nil
	}
	return fmt.Errorf("unknown UserProject field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserProjectMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, userproject.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserProjectMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userproject.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserProjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userproject.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserProject numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserProjectMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userproject.FieldScopes) {
		fields = append(fields, userproject.FieldScopes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserProjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserProjectMutation) ClearField(name string) error {
	switch name {
	case userproject.FieldScopes:
		m.ClearScopes()
		return nil
	}
	return fmt.Errorf("unknown UserProject nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserProjectMutation) ResetField(name string) error {
	switch name {
	case userproject.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userproject.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userproject.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case userproject.FieldUserID:
		m.ResetUserID()
		return nil
	case userproject.FieldProjectID:
		m.ResetProjectID()
		return nil
	case userproject.FieldIsOwner:
		m.ResetIsOwner()
		return nil
	case userproject.FieldScopes:
		m.ResetScopes()
		return nil
	}
	return fmt.Errorf("unknown UserProject field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserProjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, userproject.EdgeUser)
	}
	if m.project != nil {
		edges = append(edges, userproject.EdgeProject)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserProjectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userproject.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case userproject.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserProjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserProjectMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserProjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, userproject.EdgeUser)
	}
	if m.clearedproject {
		edges = append(edges, userproject.EdgeProject)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserProjectMutation) EdgeCleared(name string) bool {
	switch name {
	case userproject.EdgeUser:
		return m.cleareduser
	case userproject.EdgeProject:
		return m.clearedproject
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserProjectMutation) ClearEdge(name string) error {
	switch name {
	case userproject.EdgeUser:
		m.ClearUser()
		return nil
	case userproject.EdgeProject:
		m.ClearProject()
		return nil
	}
	return fmt.Errorf("unknown UserProject unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserProjectMutation) ResetEdge(name string) error {
	switch name {
	case userproject.EdgeUser:
		m.ResetUser()
		return nil
	case userproject.EdgeProject:
		m.ResetProject()
		return nil
	}
	return fmt.Errorf("unknown UserProject edge %s", name)
}

// UserRoleMutation represents an operation that mutates the UserRole nodes in the graph.
type UserRoleMutation struct {
	config
	op            Op
	typ           string
	id            *int
	deleted_at    *int
	adddeleted_at *int
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	role          *int
	clearedrole   bool
	done          bool
	oldValue      func(context.Context) (*UserRole, error)
	predicates    []predicate.UserRole
}

var _ ent.Mutation = (*UserRoleMutation)(nil)

// userroleOption allows management of the mutation configuration using functional options.
type userroleOption func(*UserRoleMutation)

// newUserRoleMutation creates new mutation for the UserRole entity.
func newUserRoleMutation(c config, op Op, opts ...userroleOption) *UserRoleMutation {
	m := &UserRoleMutation{
		config:        c,
		op:            op,
		typ:           TypeUserRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserRoleID sets the ID field of the mutation.
func withUserRoleID(id int) userroleOption {
	return func(m *UserRoleMutation) {
		var (
			err   error
			once  sync.Once
			value *UserRole
		)
		m.oldValue = func(ctx context.Context) (*UserRole, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserRole.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserRole sets the old UserRole of the mutation.
func withUserRole(node *UserRole) userroleOption {
	return func(m *UserRoleMutation) {
		m.oldValue = func(context.Context) (*UserRole, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserRoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserRoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserRoleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserRoleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserRole.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserRoleMutation) SetDeletedAt(i int) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserRoleMutation) DeletedAt() (r int, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldDeletedAt(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *UserRoleMutation) AddDeletedAt(i int) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *UserRoleMutation) AddedDeletedAt() (r int, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserRoleMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetUserID sets the "user_id" field.
func (m *UserRoleMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserRoleMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserRoleMutation) ResetUserID() {
	m.user = nil
}

// SetRoleID sets the "role_id" field.
func (m *UserRoleMutation) SetRoleID(i int) {
	m.role = &i
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *UserRoleMutation) RoleID() (r int, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldRoleID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *UserRoleMutation) ResetRoleID() {
	m.role = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserRoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserRoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *UserRoleMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[userrole.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *UserRoleMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[userrole.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserRoleMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, userrole.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserRoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserRoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserRoleMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[userrole.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserRoleMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[userrole.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserRoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, userrole.FieldUpdatedAt)
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserRoleMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[userrole.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserRoleMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserRoleMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserRoleMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearRole clears the "role" edge to the Role entity.
func (m *UserRoleMutation) ClearRole() {
	m.clearedrole = true
	m.clearedFields[userrole.FieldRoleID] = struct{}{}
}

// RoleCleared reports if the "role" edge to the Role entity was cleared.
func (m *UserRoleMutation) RoleCleared() bool {
	return m.clearedrole
}

// RoleIDs returns the "role" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoleID instead. It exists only for internal usage by the builders.
func (m *UserRoleMutation) RoleIDs() (ids []int) {
	if id := m.role; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRole resets all changes to the "role" edge.
func (m *UserRoleMutation) ResetRole() {
	m.role = nil
	m.clearedrole = false
}

// Where appends a list predicates to the UserRoleMutation builder.
func (m *UserRoleMutation) Where(ps ...predicate.UserRole) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserRoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserRoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserRole, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserRoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserRoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserRole).
func (m *UserRoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserRoleMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.deleted_at != nil {
		fields = append(fields, userrole.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, userrole.FieldUserID)
	}
	if m.role != nil {
		fields = append(fields, userrole.FieldRoleID)
	}
	if m.created_at != nil {
		fields = append(fields, userrole.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userrole.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserRoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userrole.FieldDeletedAt:
		return m.DeletedAt()
	case userrole.FieldUserID:
		return m.UserID()
	case userrole.FieldRoleID:
		return m.RoleID()
	case userrole.FieldCreatedAt:
		return m.CreatedAt()
	case userrole.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserRoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userrole.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case userrole.FieldUserID:
		return m.OldUserID(ctx)
	case userrole.FieldRoleID:
		return m.OldRoleID(ctx)
	case userrole.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userrole.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UserRole field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserRoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userrole.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case userrole.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userrole.FieldRoleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	case userrole.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userrole.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserRole field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserRoleMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, userrole.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserRoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userrole.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserRoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userrole.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserRole numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserRoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userrole.FieldCreatedAt) {
		fields = append(fields, userrole.FieldCreatedAt)
	}
	if m.FieldCleared(userrole.FieldUpdatedAt) {
		fields = append(fields, userrole.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserRoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserRoleMutation) ClearField(name string) error {
	switch name {
	case userrole.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case userrole.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown UserRole nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserRoleMutation) ResetField(name string) error {
	switch name {
	case userrole.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case userrole.FieldUserID:
		m.ResetUserID()
		return nil
	case userrole.FieldRoleID:
		m.ResetRoleID()
		return nil
	case userrole.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userrole.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown UserRole field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserRoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, userrole.EdgeUser)
	}
	if m.role != nil {
		edges = append(edges, userrole.EdgeRole)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserRoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userrole.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case userrole.EdgeRole:
		if id := m.role; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserRoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserRoleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserRoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, userrole.EdgeUser)
	}
	if m.clearedrole {
		edges = append(edges, userrole.EdgeRole)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserRoleMutation) EdgeCleared(name string) bool {
	switch name {
	case userrole.EdgeUser:
		return m.cleareduser
	case userrole.EdgeRole:
		return m.clearedrole
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserRoleMutation) ClearEdge(name string) error {
	switch name {
	case userrole.EdgeUser:
		m.ClearUser()
		return nil
	case userrole.EdgeRole:
		m.ClearRole()
		return nil
	}
	return fmt.Errorf("unknown UserRole unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserRoleMutation) ResetEdge(name string) error {
	switch name {
	case userrole.EdgeUser:
		m.ResetUser()
		return nil
	case userrole.EdgeRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown UserRole edge %s", name)
}
