// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/looplj/axonhub/internal/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/looplj/axonhub/internal/ent/apikey"
	"github.com/looplj/axonhub/internal/ent/channel"
	"github.com/looplj/axonhub/internal/ent/channelperformance"
	"github.com/looplj/axonhub/internal/ent/datastorage"
	"github.com/looplj/axonhub/internal/ent/project"
	"github.com/looplj/axonhub/internal/ent/request"
	"github.com/looplj/axonhub/internal/ent/requestexecution"
	"github.com/looplj/axonhub/internal/ent/role"
	"github.com/looplj/axonhub/internal/ent/system"
	"github.com/looplj/axonhub/internal/ent/thread"
	"github.com/looplj/axonhub/internal/ent/trace"
	"github.com/looplj/axonhub/internal/ent/usagelog"
	"github.com/looplj/axonhub/internal/ent/user"
	"github.com/looplj/axonhub/internal/ent/userproject"
	"github.com/looplj/axonhub/internal/ent/userrole"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// APIKey is the client for interacting with the APIKey builders.
	APIKey *APIKeyClient
	// Channel is the client for interacting with the Channel builders.
	Channel *ChannelClient
	// ChannelPerformance is the client for interacting with the ChannelPerformance builders.
	ChannelPerformance *ChannelPerformanceClient
	// DataStorage is the client for interacting with the DataStorage builders.
	DataStorage *DataStorageClient
	// Project is the client for interacting with the Project builders.
	Project *ProjectClient
	// Request is the client for interacting with the Request builders.
	Request *RequestClient
	// RequestExecution is the client for interacting with the RequestExecution builders.
	RequestExecution *RequestExecutionClient
	// Role is the client for interacting with the Role builders.
	Role *RoleClient
	// System is the client for interacting with the System builders.
	System *SystemClient
	// Thread is the client for interacting with the Thread builders.
	Thread *ThreadClient
	// Trace is the client for interacting with the Trace builders.
	Trace *TraceClient
	// UsageLog is the client for interacting with the UsageLog builders.
	UsageLog *UsageLogClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// UserProject is the client for interacting with the UserProject builders.
	UserProject *UserProjectClient
	// UserRole is the client for interacting with the UserRole builders.
	UserRole *UserRoleClient
	// additional fields for node api
	tables tables
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.APIKey = NewAPIKeyClient(c.config)
	c.Channel = NewChannelClient(c.config)
	c.ChannelPerformance = NewChannelPerformanceClient(c.config)
	c.DataStorage = NewDataStorageClient(c.config)
	c.Project = NewProjectClient(c.config)
	c.Request = NewRequestClient(c.config)
	c.RequestExecution = NewRequestExecutionClient(c.config)
	c.Role = NewRoleClient(c.config)
	c.System = NewSystemClient(c.config)
	c.Thread = NewThreadClient(c.config)
	c.Trace = NewTraceClient(c.config)
	c.UsageLog = NewUsageLogClient(c.config)
	c.User = NewUserClient(c.config)
	c.UserProject = NewUserProjectClient(c.config)
	c.UserRole = NewUserRoleClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                ctx,
		config:             cfg,
		APIKey:             NewAPIKeyClient(cfg),
		Channel:            NewChannelClient(cfg),
		ChannelPerformance: NewChannelPerformanceClient(cfg),
		DataStorage:        NewDataStorageClient(cfg),
		Project:            NewProjectClient(cfg),
		Request:            NewRequestClient(cfg),
		RequestExecution:   NewRequestExecutionClient(cfg),
		Role:               NewRoleClient(cfg),
		System:             NewSystemClient(cfg),
		Thread:             NewThreadClient(cfg),
		Trace:              NewTraceClient(cfg),
		UsageLog:           NewUsageLogClient(cfg),
		User:               NewUserClient(cfg),
		UserProject:        NewUserProjectClient(cfg),
		UserRole:           NewUserRoleClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                ctx,
		config:             cfg,
		APIKey:             NewAPIKeyClient(cfg),
		Channel:            NewChannelClient(cfg),
		ChannelPerformance: NewChannelPerformanceClient(cfg),
		DataStorage:        NewDataStorageClient(cfg),
		Project:            NewProjectClient(cfg),
		Request:            NewRequestClient(cfg),
		RequestExecution:   NewRequestExecutionClient(cfg),
		Role:               NewRoleClient(cfg),
		System:             NewSystemClient(cfg),
		Thread:             NewThreadClient(cfg),
		Trace:              NewTraceClient(cfg),
		UsageLog:           NewUsageLogClient(cfg),
		User:               NewUserClient(cfg),
		UserProject:        NewUserProjectClient(cfg),
		UserRole:           NewUserRoleClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		APIKey.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.APIKey, c.Channel, c.ChannelPerformance, c.DataStorage, c.Project, c.Request,
		c.RequestExecution, c.Role, c.System, c.Thread, c.Trace, c.UsageLog, c.User,
		c.UserProject, c.UserRole,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.APIKey, c.Channel, c.ChannelPerformance, c.DataStorage, c.Project, c.Request,
		c.RequestExecution, c.Role, c.System, c.Thread, c.Trace, c.UsageLog, c.User,
		c.UserProject, c.UserRole,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *APIKeyMutation:
		return c.APIKey.mutate(ctx, m)
	case *ChannelMutation:
		return c.Channel.mutate(ctx, m)
	case *ChannelPerformanceMutation:
		return c.ChannelPerformance.mutate(ctx, m)
	case *DataStorageMutation:
		return c.DataStorage.mutate(ctx, m)
	case *ProjectMutation:
		return c.Project.mutate(ctx, m)
	case *RequestMutation:
		return c.Request.mutate(ctx, m)
	case *RequestExecutionMutation:
		return c.RequestExecution.mutate(ctx, m)
	case *RoleMutation:
		return c.Role.mutate(ctx, m)
	case *SystemMutation:
		return c.System.mutate(ctx, m)
	case *ThreadMutation:
		return c.Thread.mutate(ctx, m)
	case *TraceMutation:
		return c.Trace.mutate(ctx, m)
	case *UsageLogMutation:
		return c.UsageLog.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	case *UserProjectMutation:
		return c.UserProject.mutate(ctx, m)
	case *UserRoleMutation:
		return c.UserRole.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// APIKeyClient is a client for the APIKey schema.
type APIKeyClient struct {
	config
}

// NewAPIKeyClient returns a client for the APIKey from the given config.
func NewAPIKeyClient(c config) *APIKeyClient {
	return &APIKeyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `apikey.Hooks(f(g(h())))`.
func (c *APIKeyClient) Use(hooks ...Hook) {
	c.hooks.APIKey = append(c.hooks.APIKey, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `apikey.Intercept(f(g(h())))`.
func (c *APIKeyClient) Intercept(interceptors ...Interceptor) {
	c.inters.APIKey = append(c.inters.APIKey, interceptors...)
}

// Create returns a builder for creating a APIKey entity.
func (c *APIKeyClient) Create() *APIKeyCreate {
	mutation := newAPIKeyMutation(c.config, OpCreate)
	return &APIKeyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of APIKey entities.
func (c *APIKeyClient) CreateBulk(builders ...*APIKeyCreate) *APIKeyCreateBulk {
	return &APIKeyCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *APIKeyClient) MapCreateBulk(slice any, setFunc func(*APIKeyCreate, int)) *APIKeyCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &APIKeyCreateBulk{err: fmt.Errorf("calling to APIKeyClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*APIKeyCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &APIKeyCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for APIKey.
func (c *APIKeyClient) Update() *APIKeyUpdate {
	mutation := newAPIKeyMutation(c.config, OpUpdate)
	return &APIKeyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *APIKeyClient) UpdateOne(_m *APIKey) *APIKeyUpdateOne {
	mutation := newAPIKeyMutation(c.config, OpUpdateOne, withAPIKey(_m))
	return &APIKeyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *APIKeyClient) UpdateOneID(id int) *APIKeyUpdateOne {
	mutation := newAPIKeyMutation(c.config, OpUpdateOne, withAPIKeyID(id))
	return &APIKeyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for APIKey.
func (c *APIKeyClient) Delete() *APIKeyDelete {
	mutation := newAPIKeyMutation(c.config, OpDelete)
	return &APIKeyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *APIKeyClient) DeleteOne(_m *APIKey) *APIKeyDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *APIKeyClient) DeleteOneID(id int) *APIKeyDeleteOne {
	builder := c.Delete().Where(apikey.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &APIKeyDeleteOne{builder}
}

// Query returns a query builder for APIKey.
func (c *APIKeyClient) Query() *APIKeyQuery {
	return &APIKeyQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAPIKey},
		inters: c.Interceptors(),
	}
}

// Get returns a APIKey entity by its id.
func (c *APIKeyClient) Get(ctx context.Context, id int) (*APIKey, error) {
	return c.Query().Where(apikey.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *APIKeyClient) GetX(ctx context.Context, id int) *APIKey {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a APIKey.
func (c *APIKeyClient) QueryUser(_m *APIKey) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(apikey.Table, apikey.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, apikey.UserTable, apikey.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProject queries the project edge of a APIKey.
func (c *APIKeyClient) QueryProject(_m *APIKey) *ProjectQuery {
	query := (&ProjectClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(apikey.Table, apikey.FieldID, id),
			sqlgraph.To(project.Table, project.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, apikey.ProjectTable, apikey.ProjectColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRequests queries the requests edge of a APIKey.
func (c *APIKeyClient) QueryRequests(_m *APIKey) *RequestQuery {
	query := (&RequestClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(apikey.Table, apikey.FieldID, id),
			sqlgraph.To(request.Table, request.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, apikey.RequestsTable, apikey.RequestsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *APIKeyClient) Hooks() []Hook {
	hooks := c.hooks.APIKey
	return append(hooks[:len(hooks):len(hooks)], apikey.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *APIKeyClient) Interceptors() []Interceptor {
	inters := c.inters.APIKey
	return append(inters[:len(inters):len(inters)], apikey.Interceptors[:]...)
}

func (c *APIKeyClient) mutate(ctx context.Context, m *APIKeyMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&APIKeyCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&APIKeyUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&APIKeyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&APIKeyDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown APIKey mutation op: %q", m.Op())
	}
}

// ChannelClient is a client for the Channel schema.
type ChannelClient struct {
	config
}

// NewChannelClient returns a client for the Channel from the given config.
func NewChannelClient(c config) *ChannelClient {
	return &ChannelClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `channel.Hooks(f(g(h())))`.
func (c *ChannelClient) Use(hooks ...Hook) {
	c.hooks.Channel = append(c.hooks.Channel, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `channel.Intercept(f(g(h())))`.
func (c *ChannelClient) Intercept(interceptors ...Interceptor) {
	c.inters.Channel = append(c.inters.Channel, interceptors...)
}

// Create returns a builder for creating a Channel entity.
func (c *ChannelClient) Create() *ChannelCreate {
	mutation := newChannelMutation(c.config, OpCreate)
	return &ChannelCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Channel entities.
func (c *ChannelClient) CreateBulk(builders ...*ChannelCreate) *ChannelCreateBulk {
	return &ChannelCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ChannelClient) MapCreateBulk(slice any, setFunc func(*ChannelCreate, int)) *ChannelCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ChannelCreateBulk{err: fmt.Errorf("calling to ChannelClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ChannelCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ChannelCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Channel.
func (c *ChannelClient) Update() *ChannelUpdate {
	mutation := newChannelMutation(c.config, OpUpdate)
	return &ChannelUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ChannelClient) UpdateOne(_m *Channel) *ChannelUpdateOne {
	mutation := newChannelMutation(c.config, OpUpdateOne, withChannel(_m))
	return &ChannelUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ChannelClient) UpdateOneID(id int) *ChannelUpdateOne {
	mutation := newChannelMutation(c.config, OpUpdateOne, withChannelID(id))
	return &ChannelUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Channel.
func (c *ChannelClient) Delete() *ChannelDelete {
	mutation := newChannelMutation(c.config, OpDelete)
	return &ChannelDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ChannelClient) DeleteOne(_m *Channel) *ChannelDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ChannelClient) DeleteOneID(id int) *ChannelDeleteOne {
	builder := c.Delete().Where(channel.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ChannelDeleteOne{builder}
}

// Query returns a query builder for Channel.
func (c *ChannelClient) Query() *ChannelQuery {
	return &ChannelQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeChannel},
		inters: c.Interceptors(),
	}
}

// Get returns a Channel entity by its id.
func (c *ChannelClient) Get(ctx context.Context, id int) (*Channel, error) {
	return c.Query().Where(channel.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ChannelClient) GetX(ctx context.Context, id int) *Channel {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRequests queries the requests edge of a Channel.
func (c *ChannelClient) QueryRequests(_m *Channel) *RequestQuery {
	query := (&RequestClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(channel.Table, channel.FieldID, id),
			sqlgraph.To(request.Table, request.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, channel.RequestsTable, channel.RequestsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryExecutions queries the executions edge of a Channel.
func (c *ChannelClient) QueryExecutions(_m *Channel) *RequestExecutionQuery {
	query := (&RequestExecutionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(channel.Table, channel.FieldID, id),
			sqlgraph.To(requestexecution.Table, requestexecution.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, channel.ExecutionsTable, channel.ExecutionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUsageLogs queries the usage_logs edge of a Channel.
func (c *ChannelClient) QueryUsageLogs(_m *Channel) *UsageLogQuery {
	query := (&UsageLogClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(channel.Table, channel.FieldID, id),
			sqlgraph.To(usagelog.Table, usagelog.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, channel.UsageLogsTable, channel.UsageLogsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryChannelPerformance queries the channel_performance edge of a Channel.
func (c *ChannelClient) QueryChannelPerformance(_m *Channel) *ChannelPerformanceQuery {
	query := (&ChannelPerformanceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(channel.Table, channel.FieldID, id),
			sqlgraph.To(channelperformance.Table, channelperformance.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, channel.ChannelPerformanceTable, channel.ChannelPerformanceColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ChannelClient) Hooks() []Hook {
	hooks := c.hooks.Channel
	return append(hooks[:len(hooks):len(hooks)], channel.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ChannelClient) Interceptors() []Interceptor {
	inters := c.inters.Channel
	return append(inters[:len(inters):len(inters)], channel.Interceptors[:]...)
}

func (c *ChannelClient) mutate(ctx context.Context, m *ChannelMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ChannelCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ChannelUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ChannelUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ChannelDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Channel mutation op: %q", m.Op())
	}
}

// ChannelPerformanceClient is a client for the ChannelPerformance schema.
type ChannelPerformanceClient struct {
	config
}

// NewChannelPerformanceClient returns a client for the ChannelPerformance from the given config.
func NewChannelPerformanceClient(c config) *ChannelPerformanceClient {
	return &ChannelPerformanceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `channelperformance.Hooks(f(g(h())))`.
func (c *ChannelPerformanceClient) Use(hooks ...Hook) {
	c.hooks.ChannelPerformance = append(c.hooks.ChannelPerformance, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `channelperformance.Intercept(f(g(h())))`.
func (c *ChannelPerformanceClient) Intercept(interceptors ...Interceptor) {
	c.inters.ChannelPerformance = append(c.inters.ChannelPerformance, interceptors...)
}

// Create returns a builder for creating a ChannelPerformance entity.
func (c *ChannelPerformanceClient) Create() *ChannelPerformanceCreate {
	mutation := newChannelPerformanceMutation(c.config, OpCreate)
	return &ChannelPerformanceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ChannelPerformance entities.
func (c *ChannelPerformanceClient) CreateBulk(builders ...*ChannelPerformanceCreate) *ChannelPerformanceCreateBulk {
	return &ChannelPerformanceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ChannelPerformanceClient) MapCreateBulk(slice any, setFunc func(*ChannelPerformanceCreate, int)) *ChannelPerformanceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ChannelPerformanceCreateBulk{err: fmt.Errorf("calling to ChannelPerformanceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ChannelPerformanceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ChannelPerformanceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ChannelPerformance.
func (c *ChannelPerformanceClient) Update() *ChannelPerformanceUpdate {
	mutation := newChannelPerformanceMutation(c.config, OpUpdate)
	return &ChannelPerformanceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ChannelPerformanceClient) UpdateOne(_m *ChannelPerformance) *ChannelPerformanceUpdateOne {
	mutation := newChannelPerformanceMutation(c.config, OpUpdateOne, withChannelPerformance(_m))
	return &ChannelPerformanceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ChannelPerformanceClient) UpdateOneID(id int) *ChannelPerformanceUpdateOne {
	mutation := newChannelPerformanceMutation(c.config, OpUpdateOne, withChannelPerformanceID(id))
	return &ChannelPerformanceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ChannelPerformance.
func (c *ChannelPerformanceClient) Delete() *ChannelPerformanceDelete {
	mutation := newChannelPerformanceMutation(c.config, OpDelete)
	return &ChannelPerformanceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ChannelPerformanceClient) DeleteOne(_m *ChannelPerformance) *ChannelPerformanceDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ChannelPerformanceClient) DeleteOneID(id int) *ChannelPerformanceDeleteOne {
	builder := c.Delete().Where(channelperformance.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ChannelPerformanceDeleteOne{builder}
}

// Query returns a query builder for ChannelPerformance.
func (c *ChannelPerformanceClient) Query() *ChannelPerformanceQuery {
	return &ChannelPerformanceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeChannelPerformance},
		inters: c.Interceptors(),
	}
}

// Get returns a ChannelPerformance entity by its id.
func (c *ChannelPerformanceClient) Get(ctx context.Context, id int) (*ChannelPerformance, error) {
	return c.Query().Where(channelperformance.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ChannelPerformanceClient) GetX(ctx context.Context, id int) *ChannelPerformance {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryChannel queries the channel edge of a ChannelPerformance.
func (c *ChannelPerformanceClient) QueryChannel(_m *ChannelPerformance) *ChannelQuery {
	query := (&ChannelClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(channelperformance.Table, channelperformance.FieldID, id),
			sqlgraph.To(channel.Table, channel.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, channelperformance.ChannelTable, channelperformance.ChannelColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ChannelPerformanceClient) Hooks() []Hook {
	hooks := c.hooks.ChannelPerformance
	return append(hooks[:len(hooks):len(hooks)], channelperformance.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ChannelPerformanceClient) Interceptors() []Interceptor {
	inters := c.inters.ChannelPerformance
	return append(inters[:len(inters):len(inters)], channelperformance.Interceptors[:]...)
}

func (c *ChannelPerformanceClient) mutate(ctx context.Context, m *ChannelPerformanceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ChannelPerformanceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ChannelPerformanceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ChannelPerformanceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ChannelPerformanceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ChannelPerformance mutation op: %q", m.Op())
	}
}

// DataStorageClient is a client for the DataStorage schema.
type DataStorageClient struct {
	config
}

// NewDataStorageClient returns a client for the DataStorage from the given config.
func NewDataStorageClient(c config) *DataStorageClient {
	return &DataStorageClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `datastorage.Hooks(f(g(h())))`.
func (c *DataStorageClient) Use(hooks ...Hook) {
	c.hooks.DataStorage = append(c.hooks.DataStorage, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `datastorage.Intercept(f(g(h())))`.
func (c *DataStorageClient) Intercept(interceptors ...Interceptor) {
	c.inters.DataStorage = append(c.inters.DataStorage, interceptors...)
}

// Create returns a builder for creating a DataStorage entity.
func (c *DataStorageClient) Create() *DataStorageCreate {
	mutation := newDataStorageMutation(c.config, OpCreate)
	return &DataStorageCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DataStorage entities.
func (c *DataStorageClient) CreateBulk(builders ...*DataStorageCreate) *DataStorageCreateBulk {
	return &DataStorageCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DataStorageClient) MapCreateBulk(slice any, setFunc func(*DataStorageCreate, int)) *DataStorageCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DataStorageCreateBulk{err: fmt.Errorf("calling to DataStorageClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DataStorageCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DataStorageCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DataStorage.
func (c *DataStorageClient) Update() *DataStorageUpdate {
	mutation := newDataStorageMutation(c.config, OpUpdate)
	return &DataStorageUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DataStorageClient) UpdateOne(_m *DataStorage) *DataStorageUpdateOne {
	mutation := newDataStorageMutation(c.config, OpUpdateOne, withDataStorage(_m))
	return &DataStorageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DataStorageClient) UpdateOneID(id int) *DataStorageUpdateOne {
	mutation := newDataStorageMutation(c.config, OpUpdateOne, withDataStorageID(id))
	return &DataStorageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DataStorage.
func (c *DataStorageClient) Delete() *DataStorageDelete {
	mutation := newDataStorageMutation(c.config, OpDelete)
	return &DataStorageDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DataStorageClient) DeleteOne(_m *DataStorage) *DataStorageDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DataStorageClient) DeleteOneID(id int) *DataStorageDeleteOne {
	builder := c.Delete().Where(datastorage.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DataStorageDeleteOne{builder}
}

// Query returns a query builder for DataStorage.
func (c *DataStorageClient) Query() *DataStorageQuery {
	return &DataStorageQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDataStorage},
		inters: c.Interceptors(),
	}
}

// Get returns a DataStorage entity by its id.
func (c *DataStorageClient) Get(ctx context.Context, id int) (*DataStorage, error) {
	return c.Query().Where(datastorage.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DataStorageClient) GetX(ctx context.Context, id int) *DataStorage {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRequests queries the requests edge of a DataStorage.
func (c *DataStorageClient) QueryRequests(_m *DataStorage) *RequestQuery {
	query := (&RequestClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(datastorage.Table, datastorage.FieldID, id),
			sqlgraph.To(request.Table, request.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, datastorage.RequestsTable, datastorage.RequestsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryExecutions queries the executions edge of a DataStorage.
func (c *DataStorageClient) QueryExecutions(_m *DataStorage) *RequestExecutionQuery {
	query := (&RequestExecutionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(datastorage.Table, datastorage.FieldID, id),
			sqlgraph.To(requestexecution.Table, requestexecution.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, datastorage.ExecutionsTable, datastorage.ExecutionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DataStorageClient) Hooks() []Hook {
	hooks := c.hooks.DataStorage
	return append(hooks[:len(hooks):len(hooks)], datastorage.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *DataStorageClient) Interceptors() []Interceptor {
	inters := c.inters.DataStorage
	return append(inters[:len(inters):len(inters)], datastorage.Interceptors[:]...)
}

func (c *DataStorageClient) mutate(ctx context.Context, m *DataStorageMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DataStorageCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DataStorageUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DataStorageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DataStorageDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown DataStorage mutation op: %q", m.Op())
	}
}

// ProjectClient is a client for the Project schema.
type ProjectClient struct {
	config
}

// NewProjectClient returns a client for the Project from the given config.
func NewProjectClient(c config) *ProjectClient {
	return &ProjectClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `project.Hooks(f(g(h())))`.
func (c *ProjectClient) Use(hooks ...Hook) {
	c.hooks.Project = append(c.hooks.Project, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `project.Intercept(f(g(h())))`.
func (c *ProjectClient) Intercept(interceptors ...Interceptor) {
	c.inters.Project = append(c.inters.Project, interceptors...)
}

// Create returns a builder for creating a Project entity.
func (c *ProjectClient) Create() *ProjectCreate {
	mutation := newProjectMutation(c.config, OpCreate)
	return &ProjectCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Project entities.
func (c *ProjectClient) CreateBulk(builders ...*ProjectCreate) *ProjectCreateBulk {
	return &ProjectCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProjectClient) MapCreateBulk(slice any, setFunc func(*ProjectCreate, int)) *ProjectCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProjectCreateBulk{err: fmt.Errorf("calling to ProjectClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProjectCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProjectCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Project.
func (c *ProjectClient) Update() *ProjectUpdate {
	mutation := newProjectMutation(c.config, OpUpdate)
	return &ProjectUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProjectClient) UpdateOne(_m *Project) *ProjectUpdateOne {
	mutation := newProjectMutation(c.config, OpUpdateOne, withProject(_m))
	return &ProjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProjectClient) UpdateOneID(id int) *ProjectUpdateOne {
	mutation := newProjectMutation(c.config, OpUpdateOne, withProjectID(id))
	return &ProjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Project.
func (c *ProjectClient) Delete() *ProjectDelete {
	mutation := newProjectMutation(c.config, OpDelete)
	return &ProjectDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProjectClient) DeleteOne(_m *Project) *ProjectDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProjectClient) DeleteOneID(id int) *ProjectDeleteOne {
	builder := c.Delete().Where(project.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProjectDeleteOne{builder}
}

// Query returns a query builder for Project.
func (c *ProjectClient) Query() *ProjectQuery {
	return &ProjectQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProject},
		inters: c.Interceptors(),
	}
}

// Get returns a Project entity by its id.
func (c *ProjectClient) Get(ctx context.Context, id int) (*Project, error) {
	return c.Query().Where(project.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProjectClient) GetX(ctx context.Context, id int) *Project {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUsers queries the users edge of a Project.
func (c *ProjectClient) QueryUsers(_m *Project) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(project.Table, project.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, project.UsersTable, project.UsersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRoles queries the roles edge of a Project.
func (c *ProjectClient) QueryRoles(_m *Project) *RoleQuery {
	query := (&RoleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(project.Table, project.FieldID, id),
			sqlgraph.To(role.Table, role.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, project.RolesTable, project.RolesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAPIKeys queries the api_keys edge of a Project.
func (c *ProjectClient) QueryAPIKeys(_m *Project) *APIKeyQuery {
	query := (&APIKeyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(project.Table, project.FieldID, id),
			sqlgraph.To(apikey.Table, apikey.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, project.APIKeysTable, project.APIKeysColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRequests queries the requests edge of a Project.
func (c *ProjectClient) QueryRequests(_m *Project) *RequestQuery {
	query := (&RequestClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(project.Table, project.FieldID, id),
			sqlgraph.To(request.Table, request.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, project.RequestsTable, project.RequestsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUsageLogs queries the usage_logs edge of a Project.
func (c *ProjectClient) QueryUsageLogs(_m *Project) *UsageLogQuery {
	query := (&UsageLogClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(project.Table, project.FieldID, id),
			sqlgraph.To(usagelog.Table, usagelog.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, project.UsageLogsTable, project.UsageLogsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryThreads queries the threads edge of a Project.
func (c *ProjectClient) QueryThreads(_m *Project) *ThreadQuery {
	query := (&ThreadClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(project.Table, project.FieldID, id),
			sqlgraph.To(thread.Table, thread.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, project.ThreadsTable, project.ThreadsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTraces queries the traces edge of a Project.
func (c *ProjectClient) QueryTraces(_m *Project) *TraceQuery {
	query := (&TraceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(project.Table, project.FieldID, id),
			sqlgraph.To(trace.Table, trace.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, project.TracesTable, project.TracesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProjectUsers queries the project_users edge of a Project.
func (c *ProjectClient) QueryProjectUsers(_m *Project) *UserProjectQuery {
	query := (&UserProjectClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(project.Table, project.FieldID, id),
			sqlgraph.To(userproject.Table, userproject.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, project.ProjectUsersTable, project.ProjectUsersColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProjectClient) Hooks() []Hook {
	hooks := c.hooks.Project
	return append(hooks[:len(hooks):len(hooks)], project.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ProjectClient) Interceptors() []Interceptor {
	inters := c.inters.Project
	return append(inters[:len(inters):len(inters)], project.Interceptors[:]...)
}

func (c *ProjectClient) mutate(ctx context.Context, m *ProjectMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProjectCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProjectUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProjectDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Project mutation op: %q", m.Op())
	}
}

// RequestClient is a client for the Request schema.
type RequestClient struct {
	config
}

// NewRequestClient returns a client for the Request from the given config.
func NewRequestClient(c config) *RequestClient {
	return &RequestClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `request.Hooks(f(g(h())))`.
func (c *RequestClient) Use(hooks ...Hook) {
	c.hooks.Request = append(c.hooks.Request, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `request.Intercept(f(g(h())))`.
func (c *RequestClient) Intercept(interceptors ...Interceptor) {
	c.inters.Request = append(c.inters.Request, interceptors...)
}

// Create returns a builder for creating a Request entity.
func (c *RequestClient) Create() *RequestCreate {
	mutation := newRequestMutation(c.config, OpCreate)
	return &RequestCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Request entities.
func (c *RequestClient) CreateBulk(builders ...*RequestCreate) *RequestCreateBulk {
	return &RequestCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RequestClient) MapCreateBulk(slice any, setFunc func(*RequestCreate, int)) *RequestCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RequestCreateBulk{err: fmt.Errorf("calling to RequestClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RequestCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RequestCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Request.
func (c *RequestClient) Update() *RequestUpdate {
	mutation := newRequestMutation(c.config, OpUpdate)
	return &RequestUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RequestClient) UpdateOne(_m *Request) *RequestUpdateOne {
	mutation := newRequestMutation(c.config, OpUpdateOne, withRequest(_m))
	return &RequestUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RequestClient) UpdateOneID(id int) *RequestUpdateOne {
	mutation := newRequestMutation(c.config, OpUpdateOne, withRequestID(id))
	return &RequestUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Request.
func (c *RequestClient) Delete() *RequestDelete {
	mutation := newRequestMutation(c.config, OpDelete)
	return &RequestDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RequestClient) DeleteOne(_m *Request) *RequestDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RequestClient) DeleteOneID(id int) *RequestDeleteOne {
	builder := c.Delete().Where(request.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RequestDeleteOne{builder}
}

// Query returns a query builder for Request.
func (c *RequestClient) Query() *RequestQuery {
	return &RequestQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRequest},
		inters: c.Interceptors(),
	}
}

// Get returns a Request entity by its id.
func (c *RequestClient) Get(ctx context.Context, id int) (*Request, error) {
	return c.Query().Where(request.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RequestClient) GetX(ctx context.Context, id int) *Request {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAPIKey queries the api_key edge of a Request.
func (c *RequestClient) QueryAPIKey(_m *Request) *APIKeyQuery {
	query := (&APIKeyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(request.Table, request.FieldID, id),
			sqlgraph.To(apikey.Table, apikey.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, request.APIKeyTable, request.APIKeyColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProject queries the project edge of a Request.
func (c *RequestClient) QueryProject(_m *Request) *ProjectQuery {
	query := (&ProjectClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(request.Table, request.FieldID, id),
			sqlgraph.To(project.Table, project.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, request.ProjectTable, request.ProjectColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTrace queries the trace edge of a Request.
func (c *RequestClient) QueryTrace(_m *Request) *TraceQuery {
	query := (&TraceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(request.Table, request.FieldID, id),
			sqlgraph.To(trace.Table, trace.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, request.TraceTable, request.TraceColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDataStorage queries the data_storage edge of a Request.
func (c *RequestClient) QueryDataStorage(_m *Request) *DataStorageQuery {
	query := (&DataStorageClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(request.Table, request.FieldID, id),
			sqlgraph.To(datastorage.Table, datastorage.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, request.DataStorageTable, request.DataStorageColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryExecutions queries the executions edge of a Request.
func (c *RequestClient) QueryExecutions(_m *Request) *RequestExecutionQuery {
	query := (&RequestExecutionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(request.Table, request.FieldID, id),
			sqlgraph.To(requestexecution.Table, requestexecution.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, request.ExecutionsTable, request.ExecutionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryChannel queries the channel edge of a Request.
func (c *RequestClient) QueryChannel(_m *Request) *ChannelQuery {
	query := (&ChannelClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(request.Table, request.FieldID, id),
			sqlgraph.To(channel.Table, channel.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, request.ChannelTable, request.ChannelColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUsageLogs queries the usage_logs edge of a Request.
func (c *RequestClient) QueryUsageLogs(_m *Request) *UsageLogQuery {
	query := (&UsageLogClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(request.Table, request.FieldID, id),
			sqlgraph.To(usagelog.Table, usagelog.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, request.UsageLogsTable, request.UsageLogsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RequestClient) Hooks() []Hook {
	hooks := c.hooks.Request
	return append(hooks[:len(hooks):len(hooks)], request.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *RequestClient) Interceptors() []Interceptor {
	return c.inters.Request
}

func (c *RequestClient) mutate(ctx context.Context, m *RequestMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RequestCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RequestUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RequestUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RequestDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Request mutation op: %q", m.Op())
	}
}

// RequestExecutionClient is a client for the RequestExecution schema.
type RequestExecutionClient struct {
	config
}

// NewRequestExecutionClient returns a client for the RequestExecution from the given config.
func NewRequestExecutionClient(c config) *RequestExecutionClient {
	return &RequestExecutionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `requestexecution.Hooks(f(g(h())))`.
func (c *RequestExecutionClient) Use(hooks ...Hook) {
	c.hooks.RequestExecution = append(c.hooks.RequestExecution, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `requestexecution.Intercept(f(g(h())))`.
func (c *RequestExecutionClient) Intercept(interceptors ...Interceptor) {
	c.inters.RequestExecution = append(c.inters.RequestExecution, interceptors...)
}

// Create returns a builder for creating a RequestExecution entity.
func (c *RequestExecutionClient) Create() *RequestExecutionCreate {
	mutation := newRequestExecutionMutation(c.config, OpCreate)
	return &RequestExecutionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of RequestExecution entities.
func (c *RequestExecutionClient) CreateBulk(builders ...*RequestExecutionCreate) *RequestExecutionCreateBulk {
	return &RequestExecutionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RequestExecutionClient) MapCreateBulk(slice any, setFunc func(*RequestExecutionCreate, int)) *RequestExecutionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RequestExecutionCreateBulk{err: fmt.Errorf("calling to RequestExecutionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RequestExecutionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RequestExecutionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for RequestExecution.
func (c *RequestExecutionClient) Update() *RequestExecutionUpdate {
	mutation := newRequestExecutionMutation(c.config, OpUpdate)
	return &RequestExecutionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RequestExecutionClient) UpdateOne(_m *RequestExecution) *RequestExecutionUpdateOne {
	mutation := newRequestExecutionMutation(c.config, OpUpdateOne, withRequestExecution(_m))
	return &RequestExecutionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RequestExecutionClient) UpdateOneID(id int) *RequestExecutionUpdateOne {
	mutation := newRequestExecutionMutation(c.config, OpUpdateOne, withRequestExecutionID(id))
	return &RequestExecutionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for RequestExecution.
func (c *RequestExecutionClient) Delete() *RequestExecutionDelete {
	mutation := newRequestExecutionMutation(c.config, OpDelete)
	return &RequestExecutionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RequestExecutionClient) DeleteOne(_m *RequestExecution) *RequestExecutionDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RequestExecutionClient) DeleteOneID(id int) *RequestExecutionDeleteOne {
	builder := c.Delete().Where(requestexecution.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RequestExecutionDeleteOne{builder}
}

// Query returns a query builder for RequestExecution.
func (c *RequestExecutionClient) Query() *RequestExecutionQuery {
	return &RequestExecutionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRequestExecution},
		inters: c.Interceptors(),
	}
}

// Get returns a RequestExecution entity by its id.
func (c *RequestExecutionClient) Get(ctx context.Context, id int) (*RequestExecution, error) {
	return c.Query().Where(requestexecution.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RequestExecutionClient) GetX(ctx context.Context, id int) *RequestExecution {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRequest queries the request edge of a RequestExecution.
func (c *RequestExecutionClient) QueryRequest(_m *RequestExecution) *RequestQuery {
	query := (&RequestClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(requestexecution.Table, requestexecution.FieldID, id),
			sqlgraph.To(request.Table, request.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, requestexecution.RequestTable, requestexecution.RequestColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryChannel queries the channel edge of a RequestExecution.
func (c *RequestExecutionClient) QueryChannel(_m *RequestExecution) *ChannelQuery {
	query := (&ChannelClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(requestexecution.Table, requestexecution.FieldID, id),
			sqlgraph.To(channel.Table, channel.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, requestexecution.ChannelTable, requestexecution.ChannelColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDataStorage queries the data_storage edge of a RequestExecution.
func (c *RequestExecutionClient) QueryDataStorage(_m *RequestExecution) *DataStorageQuery {
	query := (&DataStorageClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(requestexecution.Table, requestexecution.FieldID, id),
			sqlgraph.To(datastorage.Table, datastorage.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, requestexecution.DataStorageTable, requestexecution.DataStorageColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RequestExecutionClient) Hooks() []Hook {
	return c.hooks.RequestExecution
}

// Interceptors returns the client interceptors.
func (c *RequestExecutionClient) Interceptors() []Interceptor {
	return c.inters.RequestExecution
}

func (c *RequestExecutionClient) mutate(ctx context.Context, m *RequestExecutionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RequestExecutionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RequestExecutionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RequestExecutionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RequestExecutionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown RequestExecution mutation op: %q", m.Op())
	}
}

// RoleClient is a client for the Role schema.
type RoleClient struct {
	config
}

// NewRoleClient returns a client for the Role from the given config.
func NewRoleClient(c config) *RoleClient {
	return &RoleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `role.Hooks(f(g(h())))`.
func (c *RoleClient) Use(hooks ...Hook) {
	c.hooks.Role = append(c.hooks.Role, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `role.Intercept(f(g(h())))`.
func (c *RoleClient) Intercept(interceptors ...Interceptor) {
	c.inters.Role = append(c.inters.Role, interceptors...)
}

// Create returns a builder for creating a Role entity.
func (c *RoleClient) Create() *RoleCreate {
	mutation := newRoleMutation(c.config, OpCreate)
	return &RoleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Role entities.
func (c *RoleClient) CreateBulk(builders ...*RoleCreate) *RoleCreateBulk {
	return &RoleCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RoleClient) MapCreateBulk(slice any, setFunc func(*RoleCreate, int)) *RoleCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RoleCreateBulk{err: fmt.Errorf("calling to RoleClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RoleCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RoleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Role.
func (c *RoleClient) Update() *RoleUpdate {
	mutation := newRoleMutation(c.config, OpUpdate)
	return &RoleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RoleClient) UpdateOne(_m *Role) *RoleUpdateOne {
	mutation := newRoleMutation(c.config, OpUpdateOne, withRole(_m))
	return &RoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RoleClient) UpdateOneID(id int) *RoleUpdateOne {
	mutation := newRoleMutation(c.config, OpUpdateOne, withRoleID(id))
	return &RoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Role.
func (c *RoleClient) Delete() *RoleDelete {
	mutation := newRoleMutation(c.config, OpDelete)
	return &RoleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RoleClient) DeleteOne(_m *Role) *RoleDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RoleClient) DeleteOneID(id int) *RoleDeleteOne {
	builder := c.Delete().Where(role.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RoleDeleteOne{builder}
}

// Query returns a query builder for Role.
func (c *RoleClient) Query() *RoleQuery {
	return &RoleQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRole},
		inters: c.Interceptors(),
	}
}

// Get returns a Role entity by its id.
func (c *RoleClient) Get(ctx context.Context, id int) (*Role, error) {
	return c.Query().Where(role.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RoleClient) GetX(ctx context.Context, id int) *Role {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUsers queries the users edge of a Role.
func (c *RoleClient) QueryUsers(_m *Role) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(role.Table, role.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, role.UsersTable, role.UsersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProject queries the project edge of a Role.
func (c *RoleClient) QueryProject(_m *Role) *ProjectQuery {
	query := (&ProjectClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(role.Table, role.FieldID, id),
			sqlgraph.To(project.Table, project.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, role.ProjectTable, role.ProjectColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserRoles queries the user_roles edge of a Role.
func (c *RoleClient) QueryUserRoles(_m *Role) *UserRoleQuery {
	query := (&UserRoleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(role.Table, role.FieldID, id),
			sqlgraph.To(userrole.Table, userrole.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, role.UserRolesTable, role.UserRolesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RoleClient) Hooks() []Hook {
	hooks := c.hooks.Role
	return append(hooks[:len(hooks):len(hooks)], role.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *RoleClient) Interceptors() []Interceptor {
	inters := c.inters.Role
	return append(inters[:len(inters):len(inters)], role.Interceptors[:]...)
}

func (c *RoleClient) mutate(ctx context.Context, m *RoleMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RoleCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RoleUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RoleDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Role mutation op: %q", m.Op())
	}
}

// SystemClient is a client for the System schema.
type SystemClient struct {
	config
}

// NewSystemClient returns a client for the System from the given config.
func NewSystemClient(c config) *SystemClient {
	return &SystemClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `system.Hooks(f(g(h())))`.
func (c *SystemClient) Use(hooks ...Hook) {
	c.hooks.System = append(c.hooks.System, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `system.Intercept(f(g(h())))`.
func (c *SystemClient) Intercept(interceptors ...Interceptor) {
	c.inters.System = append(c.inters.System, interceptors...)
}

// Create returns a builder for creating a System entity.
func (c *SystemClient) Create() *SystemCreate {
	mutation := newSystemMutation(c.config, OpCreate)
	return &SystemCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of System entities.
func (c *SystemClient) CreateBulk(builders ...*SystemCreate) *SystemCreateBulk {
	return &SystemCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SystemClient) MapCreateBulk(slice any, setFunc func(*SystemCreate, int)) *SystemCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SystemCreateBulk{err: fmt.Errorf("calling to SystemClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SystemCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SystemCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for System.
func (c *SystemClient) Update() *SystemUpdate {
	mutation := newSystemMutation(c.config, OpUpdate)
	return &SystemUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SystemClient) UpdateOne(_m *System) *SystemUpdateOne {
	mutation := newSystemMutation(c.config, OpUpdateOne, withSystem(_m))
	return &SystemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SystemClient) UpdateOneID(id int) *SystemUpdateOne {
	mutation := newSystemMutation(c.config, OpUpdateOne, withSystemID(id))
	return &SystemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for System.
func (c *SystemClient) Delete() *SystemDelete {
	mutation := newSystemMutation(c.config, OpDelete)
	return &SystemDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SystemClient) DeleteOne(_m *System) *SystemDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SystemClient) DeleteOneID(id int) *SystemDeleteOne {
	builder := c.Delete().Where(system.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SystemDeleteOne{builder}
}

// Query returns a query builder for System.
func (c *SystemClient) Query() *SystemQuery {
	return &SystemQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSystem},
		inters: c.Interceptors(),
	}
}

// Get returns a System entity by its id.
func (c *SystemClient) Get(ctx context.Context, id int) (*System, error) {
	return c.Query().Where(system.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SystemClient) GetX(ctx context.Context, id int) *System {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *SystemClient) Hooks() []Hook {
	hooks := c.hooks.System
	return append(hooks[:len(hooks):len(hooks)], system.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *SystemClient) Interceptors() []Interceptor {
	inters := c.inters.System
	return append(inters[:len(inters):len(inters)], system.Interceptors[:]...)
}

func (c *SystemClient) mutate(ctx context.Context, m *SystemMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SystemCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SystemUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SystemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SystemDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown System mutation op: %q", m.Op())
	}
}

// ThreadClient is a client for the Thread schema.
type ThreadClient struct {
	config
}

// NewThreadClient returns a client for the Thread from the given config.
func NewThreadClient(c config) *ThreadClient {
	return &ThreadClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `thread.Hooks(f(g(h())))`.
func (c *ThreadClient) Use(hooks ...Hook) {
	c.hooks.Thread = append(c.hooks.Thread, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `thread.Intercept(f(g(h())))`.
func (c *ThreadClient) Intercept(interceptors ...Interceptor) {
	c.inters.Thread = append(c.inters.Thread, interceptors...)
}

// Create returns a builder for creating a Thread entity.
func (c *ThreadClient) Create() *ThreadCreate {
	mutation := newThreadMutation(c.config, OpCreate)
	return &ThreadCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Thread entities.
func (c *ThreadClient) CreateBulk(builders ...*ThreadCreate) *ThreadCreateBulk {
	return &ThreadCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ThreadClient) MapCreateBulk(slice any, setFunc func(*ThreadCreate, int)) *ThreadCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ThreadCreateBulk{err: fmt.Errorf("calling to ThreadClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ThreadCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ThreadCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Thread.
func (c *ThreadClient) Update() *ThreadUpdate {
	mutation := newThreadMutation(c.config, OpUpdate)
	return &ThreadUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ThreadClient) UpdateOne(_m *Thread) *ThreadUpdateOne {
	mutation := newThreadMutation(c.config, OpUpdateOne, withThread(_m))
	return &ThreadUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ThreadClient) UpdateOneID(id int) *ThreadUpdateOne {
	mutation := newThreadMutation(c.config, OpUpdateOne, withThreadID(id))
	return &ThreadUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Thread.
func (c *ThreadClient) Delete() *ThreadDelete {
	mutation := newThreadMutation(c.config, OpDelete)
	return &ThreadDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ThreadClient) DeleteOne(_m *Thread) *ThreadDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ThreadClient) DeleteOneID(id int) *ThreadDeleteOne {
	builder := c.Delete().Where(thread.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ThreadDeleteOne{builder}
}

// Query returns a query builder for Thread.
func (c *ThreadClient) Query() *ThreadQuery {
	return &ThreadQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeThread},
		inters: c.Interceptors(),
	}
}

// Get returns a Thread entity by its id.
func (c *ThreadClient) Get(ctx context.Context, id int) (*Thread, error) {
	return c.Query().Where(thread.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ThreadClient) GetX(ctx context.Context, id int) *Thread {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProject queries the project edge of a Thread.
func (c *ThreadClient) QueryProject(_m *Thread) *ProjectQuery {
	query := (&ProjectClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(thread.Table, thread.FieldID, id),
			sqlgraph.To(project.Table, project.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, thread.ProjectTable, thread.ProjectColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTraces queries the traces edge of a Thread.
func (c *ThreadClient) QueryTraces(_m *Thread) *TraceQuery {
	query := (&TraceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(thread.Table, thread.FieldID, id),
			sqlgraph.To(trace.Table, trace.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, thread.TracesTable, thread.TracesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ThreadClient) Hooks() []Hook {
	hooks := c.hooks.Thread
	return append(hooks[:len(hooks):len(hooks)], thread.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ThreadClient) Interceptors() []Interceptor {
	return c.inters.Thread
}

func (c *ThreadClient) mutate(ctx context.Context, m *ThreadMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ThreadCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ThreadUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ThreadUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ThreadDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Thread mutation op: %q", m.Op())
	}
}

// TraceClient is a client for the Trace schema.
type TraceClient struct {
	config
}

// NewTraceClient returns a client for the Trace from the given config.
func NewTraceClient(c config) *TraceClient {
	return &TraceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `trace.Hooks(f(g(h())))`.
func (c *TraceClient) Use(hooks ...Hook) {
	c.hooks.Trace = append(c.hooks.Trace, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `trace.Intercept(f(g(h())))`.
func (c *TraceClient) Intercept(interceptors ...Interceptor) {
	c.inters.Trace = append(c.inters.Trace, interceptors...)
}

// Create returns a builder for creating a Trace entity.
func (c *TraceClient) Create() *TraceCreate {
	mutation := newTraceMutation(c.config, OpCreate)
	return &TraceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Trace entities.
func (c *TraceClient) CreateBulk(builders ...*TraceCreate) *TraceCreateBulk {
	return &TraceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TraceClient) MapCreateBulk(slice any, setFunc func(*TraceCreate, int)) *TraceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TraceCreateBulk{err: fmt.Errorf("calling to TraceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TraceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TraceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Trace.
func (c *TraceClient) Update() *TraceUpdate {
	mutation := newTraceMutation(c.config, OpUpdate)
	return &TraceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TraceClient) UpdateOne(_m *Trace) *TraceUpdateOne {
	mutation := newTraceMutation(c.config, OpUpdateOne, withTrace(_m))
	return &TraceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TraceClient) UpdateOneID(id int) *TraceUpdateOne {
	mutation := newTraceMutation(c.config, OpUpdateOne, withTraceID(id))
	return &TraceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Trace.
func (c *TraceClient) Delete() *TraceDelete {
	mutation := newTraceMutation(c.config, OpDelete)
	return &TraceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TraceClient) DeleteOne(_m *Trace) *TraceDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TraceClient) DeleteOneID(id int) *TraceDeleteOne {
	builder := c.Delete().Where(trace.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TraceDeleteOne{builder}
}

// Query returns a query builder for Trace.
func (c *TraceClient) Query() *TraceQuery {
	return &TraceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTrace},
		inters: c.Interceptors(),
	}
}

// Get returns a Trace entity by its id.
func (c *TraceClient) Get(ctx context.Context, id int) (*Trace, error) {
	return c.Query().Where(trace.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TraceClient) GetX(ctx context.Context, id int) *Trace {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProject queries the project edge of a Trace.
func (c *TraceClient) QueryProject(_m *Trace) *ProjectQuery {
	query := (&ProjectClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(trace.Table, trace.FieldID, id),
			sqlgraph.To(project.Table, project.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, trace.ProjectTable, trace.ProjectColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryThread queries the thread edge of a Trace.
func (c *TraceClient) QueryThread(_m *Trace) *ThreadQuery {
	query := (&ThreadClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(trace.Table, trace.FieldID, id),
			sqlgraph.To(thread.Table, thread.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, trace.ThreadTable, trace.ThreadColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRequests queries the requests edge of a Trace.
func (c *TraceClient) QueryRequests(_m *Trace) *RequestQuery {
	query := (&RequestClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(trace.Table, trace.FieldID, id),
			sqlgraph.To(request.Table, request.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, trace.RequestsTable, trace.RequestsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TraceClient) Hooks() []Hook {
	hooks := c.hooks.Trace
	return append(hooks[:len(hooks):len(hooks)], trace.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *TraceClient) Interceptors() []Interceptor {
	return c.inters.Trace
}

func (c *TraceClient) mutate(ctx context.Context, m *TraceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TraceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TraceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TraceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TraceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Trace mutation op: %q", m.Op())
	}
}

// UsageLogClient is a client for the UsageLog schema.
type UsageLogClient struct {
	config
}

// NewUsageLogClient returns a client for the UsageLog from the given config.
func NewUsageLogClient(c config) *UsageLogClient {
	return &UsageLogClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `usagelog.Hooks(f(g(h())))`.
func (c *UsageLogClient) Use(hooks ...Hook) {
	c.hooks.UsageLog = append(c.hooks.UsageLog, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `usagelog.Intercept(f(g(h())))`.
func (c *UsageLogClient) Intercept(interceptors ...Interceptor) {
	c.inters.UsageLog = append(c.inters.UsageLog, interceptors...)
}

// Create returns a builder for creating a UsageLog entity.
func (c *UsageLogClient) Create() *UsageLogCreate {
	mutation := newUsageLogMutation(c.config, OpCreate)
	return &UsageLogCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UsageLog entities.
func (c *UsageLogClient) CreateBulk(builders ...*UsageLogCreate) *UsageLogCreateBulk {
	return &UsageLogCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UsageLogClient) MapCreateBulk(slice any, setFunc func(*UsageLogCreate, int)) *UsageLogCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UsageLogCreateBulk{err: fmt.Errorf("calling to UsageLogClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UsageLogCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UsageLogCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UsageLog.
func (c *UsageLogClient) Update() *UsageLogUpdate {
	mutation := newUsageLogMutation(c.config, OpUpdate)
	return &UsageLogUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UsageLogClient) UpdateOne(_m *UsageLog) *UsageLogUpdateOne {
	mutation := newUsageLogMutation(c.config, OpUpdateOne, withUsageLog(_m))
	return &UsageLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UsageLogClient) UpdateOneID(id int) *UsageLogUpdateOne {
	mutation := newUsageLogMutation(c.config, OpUpdateOne, withUsageLogID(id))
	return &UsageLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UsageLog.
func (c *UsageLogClient) Delete() *UsageLogDelete {
	mutation := newUsageLogMutation(c.config, OpDelete)
	return &UsageLogDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UsageLogClient) DeleteOne(_m *UsageLog) *UsageLogDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UsageLogClient) DeleteOneID(id int) *UsageLogDeleteOne {
	builder := c.Delete().Where(usagelog.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UsageLogDeleteOne{builder}
}

// Query returns a query builder for UsageLog.
func (c *UsageLogClient) Query() *UsageLogQuery {
	return &UsageLogQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUsageLog},
		inters: c.Interceptors(),
	}
}

// Get returns a UsageLog entity by its id.
func (c *UsageLogClient) Get(ctx context.Context, id int) (*UsageLog, error) {
	return c.Query().Where(usagelog.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UsageLogClient) GetX(ctx context.Context, id int) *UsageLog {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRequest queries the request edge of a UsageLog.
func (c *UsageLogClient) QueryRequest(_m *UsageLog) *RequestQuery {
	query := (&RequestClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(usagelog.Table, usagelog.FieldID, id),
			sqlgraph.To(request.Table, request.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, usagelog.RequestTable, usagelog.RequestColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProject queries the project edge of a UsageLog.
func (c *UsageLogClient) QueryProject(_m *UsageLog) *ProjectQuery {
	query := (&ProjectClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(usagelog.Table, usagelog.FieldID, id),
			sqlgraph.To(project.Table, project.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, usagelog.ProjectTable, usagelog.ProjectColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryChannel queries the channel edge of a UsageLog.
func (c *UsageLogClient) QueryChannel(_m *UsageLog) *ChannelQuery {
	query := (&ChannelClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(usagelog.Table, usagelog.FieldID, id),
			sqlgraph.To(channel.Table, channel.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, usagelog.ChannelTable, usagelog.ChannelColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UsageLogClient) Hooks() []Hook {
	hooks := c.hooks.UsageLog
	return append(hooks[:len(hooks):len(hooks)], usagelog.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *UsageLogClient) Interceptors() []Interceptor {
	return c.inters.UsageLog
}

func (c *UsageLogClient) mutate(ctx context.Context, m *UsageLogMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UsageLogCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UsageLogUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UsageLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UsageLogDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UsageLog mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(_m *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(_m))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id int) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(_m *User) *UserDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id int) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id int) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id int) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProjects queries the projects edge of a User.
func (c *UserClient) QueryProjects(_m *User) *ProjectQuery {
	query := (&ProjectClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(project.Table, project.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, user.ProjectsTable, user.ProjectsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAPIKeys queries the api_keys edge of a User.
func (c *UserClient) QueryAPIKeys(_m *User) *APIKeyQuery {
	query := (&APIKeyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(apikey.Table, apikey.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.APIKeysTable, user.APIKeysColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRoles queries the roles edge of a User.
func (c *UserClient) QueryRoles(_m *User) *RoleQuery {
	query := (&RoleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(role.Table, role.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, user.RolesTable, user.RolesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProjectUsers queries the project_users edge of a User.
func (c *UserClient) QueryProjectUsers(_m *User) *UserProjectQuery {
	query := (&UserProjectClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(userproject.Table, userproject.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, user.ProjectUsersTable, user.ProjectUsersColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserRoles queries the user_roles edge of a User.
func (c *UserClient) QueryUserRoles(_m *User) *UserRoleQuery {
	query := (&UserRoleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(userrole.Table, userrole.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, user.UserRolesTable, user.UserRolesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	hooks := c.hooks.User
	return append(hooks[:len(hooks):len(hooks)], user.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	inters := c.inters.User
	return append(inters[:len(inters):len(inters)], user.Interceptors[:]...)
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// UserProjectClient is a client for the UserProject schema.
type UserProjectClient struct {
	config
}

// NewUserProjectClient returns a client for the UserProject from the given config.
func NewUserProjectClient(c config) *UserProjectClient {
	return &UserProjectClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userproject.Hooks(f(g(h())))`.
func (c *UserProjectClient) Use(hooks ...Hook) {
	c.hooks.UserProject = append(c.hooks.UserProject, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userproject.Intercept(f(g(h())))`.
func (c *UserProjectClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserProject = append(c.inters.UserProject, interceptors...)
}

// Create returns a builder for creating a UserProject entity.
func (c *UserProjectClient) Create() *UserProjectCreate {
	mutation := newUserProjectMutation(c.config, OpCreate)
	return &UserProjectCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserProject entities.
func (c *UserProjectClient) CreateBulk(builders ...*UserProjectCreate) *UserProjectCreateBulk {
	return &UserProjectCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserProjectClient) MapCreateBulk(slice any, setFunc func(*UserProjectCreate, int)) *UserProjectCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserProjectCreateBulk{err: fmt.Errorf("calling to UserProjectClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserProjectCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserProjectCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserProject.
func (c *UserProjectClient) Update() *UserProjectUpdate {
	mutation := newUserProjectMutation(c.config, OpUpdate)
	return &UserProjectUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserProjectClient) UpdateOne(_m *UserProject) *UserProjectUpdateOne {
	mutation := newUserProjectMutation(c.config, OpUpdateOne, withUserProject(_m))
	return &UserProjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserProjectClient) UpdateOneID(id int) *UserProjectUpdateOne {
	mutation := newUserProjectMutation(c.config, OpUpdateOne, withUserProjectID(id))
	return &UserProjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserProject.
func (c *UserProjectClient) Delete() *UserProjectDelete {
	mutation := newUserProjectMutation(c.config, OpDelete)
	return &UserProjectDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserProjectClient) DeleteOne(_m *UserProject) *UserProjectDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserProjectClient) DeleteOneID(id int) *UserProjectDeleteOne {
	builder := c.Delete().Where(userproject.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserProjectDeleteOne{builder}
}

// Query returns a query builder for UserProject.
func (c *UserProjectClient) Query() *UserProjectQuery {
	return &UserProjectQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserProject},
		inters: c.Interceptors(),
	}
}

// Get returns a UserProject entity by its id.
func (c *UserProjectClient) Get(ctx context.Context, id int) (*UserProject, error) {
	return c.Query().Where(userproject.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserProjectClient) GetX(ctx context.Context, id int) *UserProject {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a UserProject.
func (c *UserProjectClient) QueryUser(_m *UserProject) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userproject.Table, userproject.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, userproject.UserTable, userproject.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProject queries the project edge of a UserProject.
func (c *UserProjectClient) QueryProject(_m *UserProject) *ProjectQuery {
	query := (&ProjectClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userproject.Table, userproject.FieldID, id),
			sqlgraph.To(project.Table, project.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, userproject.ProjectTable, userproject.ProjectColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserProjectClient) Hooks() []Hook {
	hooks := c.hooks.UserProject
	return append(hooks[:len(hooks):len(hooks)], userproject.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *UserProjectClient) Interceptors() []Interceptor {
	inters := c.inters.UserProject
	return append(inters[:len(inters):len(inters)], userproject.Interceptors[:]...)
}

func (c *UserProjectClient) mutate(ctx context.Context, m *UserProjectMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserProjectCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserProjectUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserProjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserProjectDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserProject mutation op: %q", m.Op())
	}
}

// UserRoleClient is a client for the UserRole schema.
type UserRoleClient struct {
	config
}

// NewUserRoleClient returns a client for the UserRole from the given config.
func NewUserRoleClient(c config) *UserRoleClient {
	return &UserRoleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userrole.Hooks(f(g(h())))`.
func (c *UserRoleClient) Use(hooks ...Hook) {
	c.hooks.UserRole = append(c.hooks.UserRole, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userrole.Intercept(f(g(h())))`.
func (c *UserRoleClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserRole = append(c.inters.UserRole, interceptors...)
}

// Create returns a builder for creating a UserRole entity.
func (c *UserRoleClient) Create() *UserRoleCreate {
	mutation := newUserRoleMutation(c.config, OpCreate)
	return &UserRoleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserRole entities.
func (c *UserRoleClient) CreateBulk(builders ...*UserRoleCreate) *UserRoleCreateBulk {
	return &UserRoleCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserRoleClient) MapCreateBulk(slice any, setFunc func(*UserRoleCreate, int)) *UserRoleCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserRoleCreateBulk{err: fmt.Errorf("calling to UserRoleClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserRoleCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserRoleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserRole.
func (c *UserRoleClient) Update() *UserRoleUpdate {
	mutation := newUserRoleMutation(c.config, OpUpdate)
	return &UserRoleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserRoleClient) UpdateOne(_m *UserRole) *UserRoleUpdateOne {
	mutation := newUserRoleMutation(c.config, OpUpdateOne, withUserRole(_m))
	return &UserRoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserRoleClient) UpdateOneID(id int) *UserRoleUpdateOne {
	mutation := newUserRoleMutation(c.config, OpUpdateOne, withUserRoleID(id))
	return &UserRoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserRole.
func (c *UserRoleClient) Delete() *UserRoleDelete {
	mutation := newUserRoleMutation(c.config, OpDelete)
	return &UserRoleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserRoleClient) DeleteOne(_m *UserRole) *UserRoleDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserRoleClient) DeleteOneID(id int) *UserRoleDeleteOne {
	builder := c.Delete().Where(userrole.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserRoleDeleteOne{builder}
}

// Query returns a query builder for UserRole.
func (c *UserRoleClient) Query() *UserRoleQuery {
	return &UserRoleQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserRole},
		inters: c.Interceptors(),
	}
}

// Get returns a UserRole entity by its id.
func (c *UserRoleClient) Get(ctx context.Context, id int) (*UserRole, error) {
	return c.Query().Where(userrole.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserRoleClient) GetX(ctx context.Context, id int) *UserRole {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a UserRole.
func (c *UserRoleClient) QueryUser(_m *UserRole) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userrole.Table, userrole.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, userrole.UserTable, userrole.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRole queries the role edge of a UserRole.
func (c *UserRoleClient) QueryRole(_m *UserRole) *RoleQuery {
	query := (&RoleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userrole.Table, userrole.FieldID, id),
			sqlgraph.To(role.Table, role.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, userrole.RoleTable, userrole.RoleColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserRoleClient) Hooks() []Hook {
	hooks := c.hooks.UserRole
	return append(hooks[:len(hooks):len(hooks)], userrole.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *UserRoleClient) Interceptors() []Interceptor {
	inters := c.inters.UserRole
	return append(inters[:len(inters):len(inters)], userrole.Interceptors[:]...)
}

func (c *UserRoleClient) mutate(ctx context.Context, m *UserRoleMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserRoleCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserRoleUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserRoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserRoleDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserRole mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		APIKey, Channel, ChannelPerformance, DataStorage, Project, Request,
		RequestExecution, Role, System, Thread, Trace, UsageLog, User, UserProject,
		UserRole []ent.Hook
	}
	inters struct {
		APIKey, Channel, ChannelPerformance, DataStorage, Project, Request,
		RequestExecution, Role, System, Thread, Trace, UsageLog, User, UserProject,
		UserRole []ent.Interceptor
	}
)
