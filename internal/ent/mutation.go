// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/looplj/axonhub/internal/ent/apikey"
	"github.com/looplj/axonhub/internal/ent/channel"
	"github.com/looplj/axonhub/internal/ent/channelmodelprice"
	"github.com/looplj/axonhub/internal/ent/channelmodelpriceversion"
	"github.com/looplj/axonhub/internal/ent/channeloverridetemplate"
	"github.com/looplj/axonhub/internal/ent/channelprobe"
	"github.com/looplj/axonhub/internal/ent/datastorage"
	"github.com/looplj/axonhub/internal/ent/model"
	"github.com/looplj/axonhub/internal/ent/predicate"
	"github.com/looplj/axonhub/internal/ent/project"
	"github.com/looplj/axonhub/internal/ent/prompt"
	"github.com/looplj/axonhub/internal/ent/providerquotastatus"
	"github.com/looplj/axonhub/internal/ent/request"
	"github.com/looplj/axonhub/internal/ent/requestexecution"
	"github.com/looplj/axonhub/internal/ent/role"
	"github.com/looplj/axonhub/internal/ent/system"
	"github.com/looplj/axonhub/internal/ent/thread"
	"github.com/looplj/axonhub/internal/ent/trace"
	"github.com/looplj/axonhub/internal/ent/usagelog"
	"github.com/looplj/axonhub/internal/ent/user"
	"github.com/looplj/axonhub/internal/ent/userproject"
	"github.com/looplj/axonhub/internal/ent/userrole"
	"github.com/looplj/axonhub/internal/objects"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAPIKey                   = "APIKey"
	TypeChannel                  = "Channel"
	TypeChannelModelPrice        = "ChannelModelPrice"
	TypeChannelModelPriceVersion = "ChannelModelPriceVersion"
	TypeChannelOverrideTemplate  = "ChannelOverrideTemplate"
	TypeChannelProbe             = "ChannelProbe"
	TypeDataStorage              = "DataStorage"
	TypeModel                    = "Model"
	TypeProject                  = "Project"
	TypePrompt                   = "Prompt"
	TypeProviderQuotaStatus      = "ProviderQuotaStatus"
	TypeRequest                  = "Request"
	TypeRequestExecution         = "RequestExecution"
	TypeRole                     = "Role"
	TypeSystem                   = "System"
	TypeThread                   = "Thread"
	TypeTrace                    = "Trace"
	TypeUsageLog                 = "UsageLog"
	TypeUser                     = "User"
	TypeUserProject              = "UserProject"
	TypeUserRole                 = "UserRole"
)

// APIKeyMutation represents an operation that mutates the APIKey nodes in the graph.
type APIKeyMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *int
	adddeleted_at   *int
	key             *string
	name            *string
	_type           *apikey.Type
	status          *apikey.Status
	scopes          *[]string
	appendscopes    []string
	profiles        **objects.APIKeyProfiles
	clearedFields   map[string]struct{}
	user            *int
	cleareduser     bool
	project         *int
	clearedproject  bool
	requests        map[int]struct{}
	removedrequests map[int]struct{}
	clearedrequests bool
	done            bool
	oldValue        func(context.Context) (*APIKey, error)
	predicates      []predicate.APIKey
}

var _ ent.Mutation = (*APIKeyMutation)(nil)

// apikeyOption allows management of the mutation configuration using functional options.
type apikeyOption func(*APIKeyMutation)

// newAPIKeyMutation creates new mutation for the APIKey entity.
func newAPIKeyMutation(c config, op Op, opts ...apikeyOption) *APIKeyMutation {
	m := &APIKeyMutation{
		config:        c,
		op:            op,
		typ:           TypeAPIKey,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAPIKeyID sets the ID field of the mutation.
func withAPIKeyID(id int) apikeyOption {
	return func(m *APIKeyMutation) {
		var (
			err   error
			once  sync.Once
			value *APIKey
		)
		m.oldValue = func(ctx context.Context) (*APIKey, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().APIKey.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAPIKey sets the old APIKey of the mutation.
func withAPIKey(node *APIKey) apikeyOption {
	return func(m *APIKeyMutation) {
		m.oldValue = func(context.Context) (*APIKey, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m APIKeyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m APIKeyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *APIKeyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *APIKeyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().APIKey.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *APIKeyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *APIKeyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *APIKeyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *APIKeyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *APIKeyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *APIKeyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *APIKeyMutation) SetDeletedAt(i int) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *APIKeyMutation) DeletedAt() (r int, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldDeletedAt(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *APIKeyMutation) AddDeletedAt(i int) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *APIKeyMutation) AddedDeletedAt() (r int, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *APIKeyMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetUserID sets the "user_id" field.
func (m *APIKeyMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *APIKeyMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *APIKeyMutation) ResetUserID() {
	m.user = nil
}

// SetProjectID sets the "project_id" field.
func (m *APIKeyMutation) SetProjectID(i int) {
	m.project = &i
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *APIKeyMutation) ProjectID() (r int, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldProjectID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *APIKeyMutation) ResetProjectID() {
	m.project = nil
}

// SetKey sets the "key" field.
func (m *APIKeyMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *APIKeyMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *APIKeyMutation) ResetKey() {
	m.key = nil
}

// SetName sets the "name" field.
func (m *APIKeyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *APIKeyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *APIKeyMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *APIKeyMutation) SetType(a apikey.Type) {
	m._type = &a
}

// GetType returns the value of the "type" field in the mutation.
func (m *APIKeyMutation) GetType() (r apikey.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldType(ctx context.Context) (v apikey.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *APIKeyMutation) ResetType() {
	m._type = nil
}

// SetStatus sets the "status" field.
func (m *APIKeyMutation) SetStatus(a apikey.Status) {
	m.status = &a
}

// Status returns the value of the "status" field in the mutation.
func (m *APIKeyMutation) Status() (r apikey.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldStatus(ctx context.Context) (v apikey.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *APIKeyMutation) ResetStatus() {
	m.status = nil
}

// SetScopes sets the "scopes" field.
func (m *APIKeyMutation) SetScopes(s []string) {
	m.scopes = &s
	m.appendscopes = nil
}

// Scopes returns the value of the "scopes" field in the mutation.
func (m *APIKeyMutation) Scopes() (r []string, exists bool) {
	v := m.scopes
	if v == nil {
		return
	}
	return *v, true
}

// OldScopes returns the old "scopes" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldScopes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopes: %w", err)
	}
	return oldValue.Scopes, nil
}

// AppendScopes adds s to the "scopes" field.
func (m *APIKeyMutation) AppendScopes(s []string) {
	m.appendscopes = append(m.appendscopes, s...)
}

// AppendedScopes returns the list of values that were appended to the "scopes" field in this mutation.
func (m *APIKeyMutation) AppendedScopes() ([]string, bool) {
	if len(m.appendscopes) == 0 {
		return nil, false
	}
	return m.appendscopes, true
}

// ClearScopes clears the value of the "scopes" field.
func (m *APIKeyMutation) ClearScopes() {
	m.scopes = nil
	m.appendscopes = nil
	m.clearedFields[apikey.FieldScopes] = struct{}{}
}

// ScopesCleared returns if the "scopes" field was cleared in this mutation.
func (m *APIKeyMutation) ScopesCleared() bool {
	_, ok := m.clearedFields[apikey.FieldScopes]
	return ok
}

// ResetScopes resets all changes to the "scopes" field.
func (m *APIKeyMutation) ResetScopes() {
	m.scopes = nil
	m.appendscopes = nil
	delete(m.clearedFields, apikey.FieldScopes)
}

// SetProfiles sets the "profiles" field.
func (m *APIKeyMutation) SetProfiles(okp *objects.APIKeyProfiles) {
	m.profiles = &okp
}

// Profiles returns the value of the "profiles" field in the mutation.
func (m *APIKeyMutation) Profiles() (r *objects.APIKeyProfiles, exists bool) {
	v := m.profiles
	if v == nil {
		return
	}
	return *v, true
}

// OldProfiles returns the old "profiles" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldProfiles(ctx context.Context) (v *objects.APIKeyProfiles, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfiles is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfiles requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfiles: %w", err)
	}
	return oldValue.Profiles, nil
}

// ClearProfiles clears the value of the "profiles" field.
func (m *APIKeyMutation) ClearProfiles() {
	m.profiles = nil
	m.clearedFields[apikey.FieldProfiles] = struct{}{}
}

// ProfilesCleared returns if the "profiles" field was cleared in this mutation.
func (m *APIKeyMutation) ProfilesCleared() bool {
	_, ok := m.clearedFields[apikey.FieldProfiles]
	return ok
}

// ResetProfiles resets all changes to the "profiles" field.
func (m *APIKeyMutation) ResetProfiles() {
	m.profiles = nil
	delete(m.clearedFields, apikey.FieldProfiles)
}

// ClearUser clears the "user" edge to the User entity.
func (m *APIKeyMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[apikey.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *APIKeyMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *APIKeyMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *APIKeyMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearProject clears the "project" edge to the Project entity.
func (m *APIKeyMutation) ClearProject() {
	m.clearedproject = true
	m.clearedFields[apikey.FieldProjectID] = struct{}{}
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *APIKeyMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *APIKeyMutation) ProjectIDs() (ids []int) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *APIKeyMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// AddRequestIDs adds the "requests" edge to the Request entity by ids.
func (m *APIKeyMutation) AddRequestIDs(ids ...int) {
	if m.requests == nil {
		m.requests = make(map[int]struct{})
	}
	for i := range ids {
		m.requests[ids[i]] = struct{}{}
	}
}

// ClearRequests clears the "requests" edge to the Request entity.
func (m *APIKeyMutation) ClearRequests() {
	m.clearedrequests = true
}

// RequestsCleared reports if the "requests" edge to the Request entity was cleared.
func (m *APIKeyMutation) RequestsCleared() bool {
	return m.clearedrequests
}

// RemoveRequestIDs removes the "requests" edge to the Request entity by IDs.
func (m *APIKeyMutation) RemoveRequestIDs(ids ...int) {
	if m.removedrequests == nil {
		m.removedrequests = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.requests, ids[i])
		m.removedrequests[ids[i]] = struct{}{}
	}
}

// RemovedRequests returns the removed IDs of the "requests" edge to the Request entity.
func (m *APIKeyMutation) RemovedRequestsIDs() (ids []int) {
	for id := range m.removedrequests {
		ids = append(ids, id)
	}
	return
}

// RequestsIDs returns the "requests" edge IDs in the mutation.
func (m *APIKeyMutation) RequestsIDs() (ids []int) {
	for id := range m.requests {
		ids = append(ids, id)
	}
	return
}

// ResetRequests resets all changes to the "requests" edge.
func (m *APIKeyMutation) ResetRequests() {
	m.requests = nil
	m.clearedrequests = false
	m.removedrequests = nil
}

// Where appends a list predicates to the APIKeyMutation builder.
func (m *APIKeyMutation) Where(ps ...predicate.APIKey) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the APIKeyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *APIKeyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.APIKey, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *APIKeyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *APIKeyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (APIKey).
func (m *APIKeyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *APIKeyMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, apikey.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, apikey.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, apikey.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, apikey.FieldUserID)
	}
	if m.project != nil {
		fields = append(fields, apikey.FieldProjectID)
	}
	if m.key != nil {
		fields = append(fields, apikey.FieldKey)
	}
	if m.name != nil {
		fields = append(fields, apikey.FieldName)
	}
	if m._type != nil {
		fields = append(fields, apikey.FieldType)
	}
	if m.status != nil {
		fields = append(fields, apikey.FieldStatus)
	}
	if m.scopes != nil {
		fields = append(fields, apikey.FieldScopes)
	}
	if m.profiles != nil {
		fields = append(fields, apikey.FieldProfiles)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *APIKeyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case apikey.FieldCreatedAt:
		return m.CreatedAt()
	case apikey.FieldUpdatedAt:
		return m.UpdatedAt()
	case apikey.FieldDeletedAt:
		return m.DeletedAt()
	case apikey.FieldUserID:
		return m.UserID()
	case apikey.FieldProjectID:
		return m.ProjectID()
	case apikey.FieldKey:
		return m.Key()
	case apikey.FieldName:
		return m.Name()
	case apikey.FieldType:
		return m.GetType()
	case apikey.FieldStatus:
		return m.Status()
	case apikey.FieldScopes:
		return m.Scopes()
	case apikey.FieldProfiles:
		return m.Profiles()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *APIKeyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case apikey.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case apikey.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case apikey.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case apikey.FieldUserID:
		return m.OldUserID(ctx)
	case apikey.FieldProjectID:
		return m.OldProjectID(ctx)
	case apikey.FieldKey:
		return m.OldKey(ctx)
	case apikey.FieldName:
		return m.OldName(ctx)
	case apikey.FieldType:
		return m.OldType(ctx)
	case apikey.FieldStatus:
		return m.OldStatus(ctx)
	case apikey.FieldScopes:
		return m.OldScopes(ctx)
	case apikey.FieldProfiles:
		return m.OldProfiles(ctx)
	}
	return nil, fmt.Errorf("unknown APIKey field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *APIKeyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case apikey.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case apikey.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case apikey.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case apikey.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case apikey.FieldProjectID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case apikey.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case apikey.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case apikey.FieldType:
		v, ok := value.(apikey.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case apikey.FieldStatus:
		v, ok := value.(apikey.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case apikey.FieldScopes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopes(v)
		return nil
	case apikey.FieldProfiles:
		v, ok := value.(*objects.APIKeyProfiles)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfiles(v)
		return nil
	}
	return fmt.Errorf("unknown APIKey field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *APIKeyMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, apikey.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *APIKeyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case apikey.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *APIKeyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case apikey.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown APIKey numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *APIKeyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(apikey.FieldScopes) {
		fields = append(fields, apikey.FieldScopes)
	}
	if m.FieldCleared(apikey.FieldProfiles) {
		fields = append(fields, apikey.FieldProfiles)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *APIKeyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *APIKeyMutation) ClearField(name string) error {
	switch name {
	case apikey.FieldScopes:
		m.ClearScopes()
		return nil
	case apikey.FieldProfiles:
		m.ClearProfiles()
		return nil
	}
	return fmt.Errorf("unknown APIKey nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *APIKeyMutation) ResetField(name string) error {
	switch name {
	case apikey.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case apikey.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case apikey.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case apikey.FieldUserID:
		m.ResetUserID()
		return nil
	case apikey.FieldProjectID:
		m.ResetProjectID()
		return nil
	case apikey.FieldKey:
		m.ResetKey()
		return nil
	case apikey.FieldName:
		m.ResetName()
		return nil
	case apikey.FieldType:
		m.ResetType()
		return nil
	case apikey.FieldStatus:
		m.ResetStatus()
		return nil
	case apikey.FieldScopes:
		m.ResetScopes()
		return nil
	case apikey.FieldProfiles:
		m.ResetProfiles()
		return nil
	}
	return fmt.Errorf("unknown APIKey field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *APIKeyMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user != nil {
		edges = append(edges, apikey.EdgeUser)
	}
	if m.project != nil {
		edges = append(edges, apikey.EdgeProject)
	}
	if m.requests != nil {
		edges = append(edges, apikey.EdgeRequests)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *APIKeyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case apikey.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case apikey.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case apikey.EdgeRequests:
		ids := make([]ent.Value, 0, len(m.requests))
		for id := range m.requests {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *APIKeyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedrequests != nil {
		edges = append(edges, apikey.EdgeRequests)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *APIKeyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case apikey.EdgeRequests:
		ids := make([]ent.Value, 0, len(m.removedrequests))
		for id := range m.removedrequests {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *APIKeyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, apikey.EdgeUser)
	}
	if m.clearedproject {
		edges = append(edges, apikey.EdgeProject)
	}
	if m.clearedrequests {
		edges = append(edges, apikey.EdgeRequests)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *APIKeyMutation) EdgeCleared(name string) bool {
	switch name {
	case apikey.EdgeUser:
		return m.cleareduser
	case apikey.EdgeProject:
		return m.clearedproject
	case apikey.EdgeRequests:
		return m.clearedrequests
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *APIKeyMutation) ClearEdge(name string) error {
	switch name {
	case apikey.EdgeUser:
		m.ClearUser()
		return nil
	case apikey.EdgeProject:
		m.ClearProject()
		return nil
	}
	return fmt.Errorf("unknown APIKey unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *APIKeyMutation) ResetEdge(name string) error {
	switch name {
	case apikey.EdgeUser:
		m.ResetUser()
		return nil
	case apikey.EdgeProject:
		m.ResetProject()
		return nil
	case apikey.EdgeRequests:
		m.ResetRequests()
		return nil
	}
	return fmt.Errorf("unknown APIKey edge %s", name)
}

// ChannelMutation represents an operation that mutates the Channel nodes in the graph.
type ChannelMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	created_at                   *time.Time
	updated_at                   *time.Time
	deleted_at                   *int
	adddeleted_at                *int
	_type                        *channel.Type
	base_url                     *string
	name                         *string
	status                       *channel.Status
	credentials                  *objects.ChannelCredentials
	disabled_api_keys            *[]objects.DisabledAPIKey
	appenddisabled_api_keys      []objects.DisabledAPIKey
	supported_models             *[]string
	appendsupported_models       []string
	auto_sync_supported_models   *bool
	tags                         *[]string
	appendtags                   []string
	default_test_model           *string
	policies                     *objects.ChannelPolicies
	settings                     **objects.ChannelSettings
	ordering_weight              *int
	addordering_weight           *int
	error_message                *string
	remark                       *string
	clearedFields                map[string]struct{}
	requests                     map[int]struct{}
	removedrequests              map[int]struct{}
	clearedrequests              bool
	executions                   map[int]struct{}
	removedexecutions            map[int]struct{}
	clearedexecutions            bool
	usage_logs                   map[int]struct{}
	removedusage_logs            map[int]struct{}
	clearedusage_logs            bool
	channel_probes               map[int]struct{}
	removedchannel_probes        map[int]struct{}
	clearedchannel_probes        bool
	channel_model_prices         map[int]struct{}
	removedchannel_model_prices  map[int]struct{}
	clearedchannel_model_prices  bool
	provider_quota_status        *int
	clearedprovider_quota_status bool
	done                         bool
	oldValue                     func(context.Context) (*Channel, error)
	predicates                   []predicate.Channel
}

var _ ent.Mutation = (*ChannelMutation)(nil)

// channelOption allows management of the mutation configuration using functional options.
type channelOption func(*ChannelMutation)

// newChannelMutation creates new mutation for the Channel entity.
func newChannelMutation(c config, op Op, opts ...channelOption) *ChannelMutation {
	m := &ChannelMutation{
		config:        c,
		op:            op,
		typ:           TypeChannel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChannelID sets the ID field of the mutation.
func withChannelID(id int) channelOption {
	return func(m *ChannelMutation) {
		var (
			err   error
			once  sync.Once
			value *Channel
		)
		m.oldValue = func(ctx context.Context) (*Channel, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Channel.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChannel sets the old Channel of the mutation.
func withChannel(node *Channel) channelOption {
	return func(m *ChannelMutation) {
		m.oldValue = func(context.Context) (*Channel, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChannelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChannelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChannelMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChannelMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Channel.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ChannelMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ChannelMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ChannelMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ChannelMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ChannelMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ChannelMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ChannelMutation) SetDeletedAt(i int) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ChannelMutation) DeletedAt() (r int, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldDeletedAt(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *ChannelMutation) AddDeletedAt(i int) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *ChannelMutation) AddedDeletedAt() (r int, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ChannelMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetType sets the "type" field.
func (m *ChannelMutation) SetType(c channel.Type) {
	m._type = &c
}

// GetType returns the value of the "type" field in the mutation.
func (m *ChannelMutation) GetType() (r channel.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldType(ctx context.Context) (v channel.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ChannelMutation) ResetType() {
	m._type = nil
}

// SetBaseURL sets the "base_url" field.
func (m *ChannelMutation) SetBaseURL(s string) {
	m.base_url = &s
}

// BaseURL returns the value of the "base_url" field in the mutation.
func (m *ChannelMutation) BaseURL() (r string, exists bool) {
	v := m.base_url
	if v == nil {
		return
	}
	return *v, true
}

// OldBaseURL returns the old "base_url" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldBaseURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaseURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaseURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaseURL: %w", err)
	}
	return oldValue.BaseURL, nil
}

// ClearBaseURL clears the value of the "base_url" field.
func (m *ChannelMutation) ClearBaseURL() {
	m.base_url = nil
	m.clearedFields[channel.FieldBaseURL] = struct{}{}
}

// BaseURLCleared returns if the "base_url" field was cleared in this mutation.
func (m *ChannelMutation) BaseURLCleared() bool {
	_, ok := m.clearedFields[channel.FieldBaseURL]
	return ok
}

// ResetBaseURL resets all changes to the "base_url" field.
func (m *ChannelMutation) ResetBaseURL() {
	m.base_url = nil
	delete(m.clearedFields, channel.FieldBaseURL)
}

// SetName sets the "name" field.
func (m *ChannelMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ChannelMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ChannelMutation) ResetName() {
	m.name = nil
}

// SetStatus sets the "status" field.
func (m *ChannelMutation) SetStatus(c channel.Status) {
	m.status = &c
}

// Status returns the value of the "status" field in the mutation.
func (m *ChannelMutation) Status() (r channel.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldStatus(ctx context.Context) (v channel.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ChannelMutation) ResetStatus() {
	m.status = nil
}

// SetCredentials sets the "credentials" field.
func (m *ChannelMutation) SetCredentials(oc objects.ChannelCredentials) {
	m.credentials = &oc
}

// Credentials returns the value of the "credentials" field in the mutation.
func (m *ChannelMutation) Credentials() (r objects.ChannelCredentials, exists bool) {
	v := m.credentials
	if v == nil {
		return
	}
	return *v, true
}

// OldCredentials returns the old "credentials" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldCredentials(ctx context.Context) (v objects.ChannelCredentials, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCredentials is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCredentials requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCredentials: %w", err)
	}
	return oldValue.Credentials, nil
}

// ResetCredentials resets all changes to the "credentials" field.
func (m *ChannelMutation) ResetCredentials() {
	m.credentials = nil
}

// SetDisabledAPIKeys sets the "disabled_api_keys" field.
func (m *ChannelMutation) SetDisabledAPIKeys(oak []objects.DisabledAPIKey) {
	m.disabled_api_keys = &oak
	m.appenddisabled_api_keys = nil
}

// DisabledAPIKeys returns the value of the "disabled_api_keys" field in the mutation.
func (m *ChannelMutation) DisabledAPIKeys() (r []objects.DisabledAPIKey, exists bool) {
	v := m.disabled_api_keys
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabledAPIKeys returns the old "disabled_api_keys" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldDisabledAPIKeys(ctx context.Context) (v []objects.DisabledAPIKey, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabledAPIKeys is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabledAPIKeys requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabledAPIKeys: %w", err)
	}
	return oldValue.DisabledAPIKeys, nil
}

// AppendDisabledAPIKeys adds oak to the "disabled_api_keys" field.
func (m *ChannelMutation) AppendDisabledAPIKeys(oak []objects.DisabledAPIKey) {
	m.appenddisabled_api_keys = append(m.appenddisabled_api_keys, oak...)
}

// AppendedDisabledAPIKeys returns the list of values that were appended to the "disabled_api_keys" field in this mutation.
func (m *ChannelMutation) AppendedDisabledAPIKeys() ([]objects.DisabledAPIKey, bool) {
	if len(m.appenddisabled_api_keys) == 0 {
		return nil, false
	}
	return m.appenddisabled_api_keys, true
}

// ClearDisabledAPIKeys clears the value of the "disabled_api_keys" field.
func (m *ChannelMutation) ClearDisabledAPIKeys() {
	m.disabled_api_keys = nil
	m.appenddisabled_api_keys = nil
	m.clearedFields[channel.FieldDisabledAPIKeys] = struct{}{}
}

// DisabledAPIKeysCleared returns if the "disabled_api_keys" field was cleared in this mutation.
func (m *ChannelMutation) DisabledAPIKeysCleared() bool {
	_, ok := m.clearedFields[channel.FieldDisabledAPIKeys]
	return ok
}

// ResetDisabledAPIKeys resets all changes to the "disabled_api_keys" field.
func (m *ChannelMutation) ResetDisabledAPIKeys() {
	m.disabled_api_keys = nil
	m.appenddisabled_api_keys = nil
	delete(m.clearedFields, channel.FieldDisabledAPIKeys)
}

// SetSupportedModels sets the "supported_models" field.
func (m *ChannelMutation) SetSupportedModels(s []string) {
	m.supported_models = &s
	m.appendsupported_models = nil
}

// SupportedModels returns the value of the "supported_models" field in the mutation.
func (m *ChannelMutation) SupportedModels() (r []string, exists bool) {
	v := m.supported_models
	if v == nil {
		return
	}
	return *v, true
}

// OldSupportedModels returns the old "supported_models" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldSupportedModels(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupportedModels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupportedModels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupportedModels: %w", err)
	}
	return oldValue.SupportedModels, nil
}

// AppendSupportedModels adds s to the "supported_models" field.
func (m *ChannelMutation) AppendSupportedModels(s []string) {
	m.appendsupported_models = append(m.appendsupported_models, s...)
}

// AppendedSupportedModels returns the list of values that were appended to the "supported_models" field in this mutation.
func (m *ChannelMutation) AppendedSupportedModels() ([]string, bool) {
	if len(m.appendsupported_models) == 0 {
		return nil, false
	}
	return m.appendsupported_models, true
}

// ResetSupportedModels resets all changes to the "supported_models" field.
func (m *ChannelMutation) ResetSupportedModels() {
	m.supported_models = nil
	m.appendsupported_models = nil
}

// SetAutoSyncSupportedModels sets the "auto_sync_supported_models" field.
func (m *ChannelMutation) SetAutoSyncSupportedModels(b bool) {
	m.auto_sync_supported_models = &b
}

// AutoSyncSupportedModels returns the value of the "auto_sync_supported_models" field in the mutation.
func (m *ChannelMutation) AutoSyncSupportedModels() (r bool, exists bool) {
	v := m.auto_sync_supported_models
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoSyncSupportedModels returns the old "auto_sync_supported_models" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldAutoSyncSupportedModels(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAutoSyncSupportedModels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAutoSyncSupportedModels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoSyncSupportedModels: %w", err)
	}
	return oldValue.AutoSyncSupportedModels, nil
}

// ResetAutoSyncSupportedModels resets all changes to the "auto_sync_supported_models" field.
func (m *ChannelMutation) ResetAutoSyncSupportedModels() {
	m.auto_sync_supported_models = nil
}

// SetTags sets the "tags" field.
func (m *ChannelMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *ChannelMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *ChannelMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *ChannelMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *ChannelMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[channel.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *ChannelMutation) TagsCleared() bool {
	_, ok := m.clearedFields[channel.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *ChannelMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, channel.FieldTags)
}

// SetDefaultTestModel sets the "default_test_model" field.
func (m *ChannelMutation) SetDefaultTestModel(s string) {
	m.default_test_model = &s
}

// DefaultTestModel returns the value of the "default_test_model" field in the mutation.
func (m *ChannelMutation) DefaultTestModel() (r string, exists bool) {
	v := m.default_test_model
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultTestModel returns the old "default_test_model" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldDefaultTestModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultTestModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultTestModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultTestModel: %w", err)
	}
	return oldValue.DefaultTestModel, nil
}

// ResetDefaultTestModel resets all changes to the "default_test_model" field.
func (m *ChannelMutation) ResetDefaultTestModel() {
	m.default_test_model = nil
}

// SetPolicies sets the "policies" field.
func (m *ChannelMutation) SetPolicies(op objects.ChannelPolicies) {
	m.policies = &op
}

// Policies returns the value of the "policies" field in the mutation.
func (m *ChannelMutation) Policies() (r objects.ChannelPolicies, exists bool) {
	v := m.policies
	if v == nil {
		return
	}
	return *v, true
}

// OldPolicies returns the old "policies" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldPolicies(ctx context.Context) (v objects.ChannelPolicies, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPolicies is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPolicies requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPolicies: %w", err)
	}
	return oldValue.Policies, nil
}

// ClearPolicies clears the value of the "policies" field.
func (m *ChannelMutation) ClearPolicies() {
	m.policies = nil
	m.clearedFields[channel.FieldPolicies] = struct{}{}
}

// PoliciesCleared returns if the "policies" field was cleared in this mutation.
func (m *ChannelMutation) PoliciesCleared() bool {
	_, ok := m.clearedFields[channel.FieldPolicies]
	return ok
}

// ResetPolicies resets all changes to the "policies" field.
func (m *ChannelMutation) ResetPolicies() {
	m.policies = nil
	delete(m.clearedFields, channel.FieldPolicies)
}

// SetSettings sets the "settings" field.
func (m *ChannelMutation) SetSettings(os *objects.ChannelSettings) {
	m.settings = &os
}

// Settings returns the value of the "settings" field in the mutation.
func (m *ChannelMutation) Settings() (r *objects.ChannelSettings, exists bool) {
	v := m.settings
	if v == nil {
		return
	}
	return *v, true
}

// OldSettings returns the old "settings" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldSettings(ctx context.Context) (v *objects.ChannelSettings, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettings: %w", err)
	}
	return oldValue.Settings, nil
}

// ClearSettings clears the value of the "settings" field.
func (m *ChannelMutation) ClearSettings() {
	m.settings = nil
	m.clearedFields[channel.FieldSettings] = struct{}{}
}

// SettingsCleared returns if the "settings" field was cleared in this mutation.
func (m *ChannelMutation) SettingsCleared() bool {
	_, ok := m.clearedFields[channel.FieldSettings]
	return ok
}

// ResetSettings resets all changes to the "settings" field.
func (m *ChannelMutation) ResetSettings() {
	m.settings = nil
	delete(m.clearedFields, channel.FieldSettings)
}

// SetOrderingWeight sets the "ordering_weight" field.
func (m *ChannelMutation) SetOrderingWeight(i int) {
	m.ordering_weight = &i
	m.addordering_weight = nil
}

// OrderingWeight returns the value of the "ordering_weight" field in the mutation.
func (m *ChannelMutation) OrderingWeight() (r int, exists bool) {
	v := m.ordering_weight
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderingWeight returns the old "ordering_weight" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldOrderingWeight(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderingWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderingWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderingWeight: %w", err)
	}
	return oldValue.OrderingWeight, nil
}

// AddOrderingWeight adds i to the "ordering_weight" field.
func (m *ChannelMutation) AddOrderingWeight(i int) {
	if m.addordering_weight != nil {
		*m.addordering_weight += i
	} else {
		m.addordering_weight = &i
	}
}

// AddedOrderingWeight returns the value that was added to the "ordering_weight" field in this mutation.
func (m *ChannelMutation) AddedOrderingWeight() (r int, exists bool) {
	v := m.addordering_weight
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderingWeight resets all changes to the "ordering_weight" field.
func (m *ChannelMutation) ResetOrderingWeight() {
	m.ordering_weight = nil
	m.addordering_weight = nil
}

// SetErrorMessage sets the "error_message" field.
func (m *ChannelMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *ChannelMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldErrorMessage(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *ChannelMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[channel.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *ChannelMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[channel.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *ChannelMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, channel.FieldErrorMessage)
}

// SetRemark sets the "remark" field.
func (m *ChannelMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *ChannelMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldRemark(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *ChannelMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[channel.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *ChannelMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[channel.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *ChannelMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, channel.FieldRemark)
}

// AddRequestIDs adds the "requests" edge to the Request entity by ids.
func (m *ChannelMutation) AddRequestIDs(ids ...int) {
	if m.requests == nil {
		m.requests = make(map[int]struct{})
	}
	for i := range ids {
		m.requests[ids[i]] = struct{}{}
	}
}

// ClearRequests clears the "requests" edge to the Request entity.
func (m *ChannelMutation) ClearRequests() {
	m.clearedrequests = true
}

// RequestsCleared reports if the "requests" edge to the Request entity was cleared.
func (m *ChannelMutation) RequestsCleared() bool {
	return m.clearedrequests
}

// RemoveRequestIDs removes the "requests" edge to the Request entity by IDs.
func (m *ChannelMutation) RemoveRequestIDs(ids ...int) {
	if m.removedrequests == nil {
		m.removedrequests = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.requests, ids[i])
		m.removedrequests[ids[i]] = struct{}{}
	}
}

// RemovedRequests returns the removed IDs of the "requests" edge to the Request entity.
func (m *ChannelMutation) RemovedRequestsIDs() (ids []int) {
	for id := range m.removedrequests {
		ids = append(ids, id)
	}
	return
}

// RequestsIDs returns the "requests" edge IDs in the mutation.
func (m *ChannelMutation) RequestsIDs() (ids []int) {
	for id := range m.requests {
		ids = append(ids, id)
	}
	return
}

// ResetRequests resets all changes to the "requests" edge.
func (m *ChannelMutation) ResetRequests() {
	m.requests = nil
	m.clearedrequests = false
	m.removedrequests = nil
}

// AddExecutionIDs adds the "executions" edge to the RequestExecution entity by ids.
func (m *ChannelMutation) AddExecutionIDs(ids ...int) {
	if m.executions == nil {
		m.executions = make(map[int]struct{})
	}
	for i := range ids {
		m.executions[ids[i]] = struct{}{}
	}
}

// ClearExecutions clears the "executions" edge to the RequestExecution entity.
func (m *ChannelMutation) ClearExecutions() {
	m.clearedexecutions = true
}

// ExecutionsCleared reports if the "executions" edge to the RequestExecution entity was cleared.
func (m *ChannelMutation) ExecutionsCleared() bool {
	return m.clearedexecutions
}

// RemoveExecutionIDs removes the "executions" edge to the RequestExecution entity by IDs.
func (m *ChannelMutation) RemoveExecutionIDs(ids ...int) {
	if m.removedexecutions == nil {
		m.removedexecutions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.executions, ids[i])
		m.removedexecutions[ids[i]] = struct{}{}
	}
}

// RemovedExecutions returns the removed IDs of the "executions" edge to the RequestExecution entity.
func (m *ChannelMutation) RemovedExecutionsIDs() (ids []int) {
	for id := range m.removedexecutions {
		ids = append(ids, id)
	}
	return
}

// ExecutionsIDs returns the "executions" edge IDs in the mutation.
func (m *ChannelMutation) ExecutionsIDs() (ids []int) {
	for id := range m.executions {
		ids = append(ids, id)
	}
	return
}

// ResetExecutions resets all changes to the "executions" edge.
func (m *ChannelMutation) ResetExecutions() {
	m.executions = nil
	m.clearedexecutions = false
	m.removedexecutions = nil
}

// AddUsageLogIDs adds the "usage_logs" edge to the UsageLog entity by ids.
func (m *ChannelMutation) AddUsageLogIDs(ids ...int) {
	if m.usage_logs == nil {
		m.usage_logs = make(map[int]struct{})
	}
	for i := range ids {
		m.usage_logs[ids[i]] = struct{}{}
	}
}

// ClearUsageLogs clears the "usage_logs" edge to the UsageLog entity.
func (m *ChannelMutation) ClearUsageLogs() {
	m.clearedusage_logs = true
}

// UsageLogsCleared reports if the "usage_logs" edge to the UsageLog entity was cleared.
func (m *ChannelMutation) UsageLogsCleared() bool {
	return m.clearedusage_logs
}

// RemoveUsageLogIDs removes the "usage_logs" edge to the UsageLog entity by IDs.
func (m *ChannelMutation) RemoveUsageLogIDs(ids ...int) {
	if m.removedusage_logs == nil {
		m.removedusage_logs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.usage_logs, ids[i])
		m.removedusage_logs[ids[i]] = struct{}{}
	}
}

// RemovedUsageLogs returns the removed IDs of the "usage_logs" edge to the UsageLog entity.
func (m *ChannelMutation) RemovedUsageLogsIDs() (ids []int) {
	for id := range m.removedusage_logs {
		ids = append(ids, id)
	}
	return
}

// UsageLogsIDs returns the "usage_logs" edge IDs in the mutation.
func (m *ChannelMutation) UsageLogsIDs() (ids []int) {
	for id := range m.usage_logs {
		ids = append(ids, id)
	}
	return
}

// ResetUsageLogs resets all changes to the "usage_logs" edge.
func (m *ChannelMutation) ResetUsageLogs() {
	m.usage_logs = nil
	m.clearedusage_logs = false
	m.removedusage_logs = nil
}

// AddChannelProbeIDs adds the "channel_probes" edge to the ChannelProbe entity by ids.
func (m *ChannelMutation) AddChannelProbeIDs(ids ...int) {
	if m.channel_probes == nil {
		m.channel_probes = make(map[int]struct{})
	}
	for i := range ids {
		m.channel_probes[ids[i]] = struct{}{}
	}
}

// ClearChannelProbes clears the "channel_probes" edge to the ChannelProbe entity.
func (m *ChannelMutation) ClearChannelProbes() {
	m.clearedchannel_probes = true
}

// ChannelProbesCleared reports if the "channel_probes" edge to the ChannelProbe entity was cleared.
func (m *ChannelMutation) ChannelProbesCleared() bool {
	return m.clearedchannel_probes
}

// RemoveChannelProbeIDs removes the "channel_probes" edge to the ChannelProbe entity by IDs.
func (m *ChannelMutation) RemoveChannelProbeIDs(ids ...int) {
	if m.removedchannel_probes == nil {
		m.removedchannel_probes = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.channel_probes, ids[i])
		m.removedchannel_probes[ids[i]] = struct{}{}
	}
}

// RemovedChannelProbes returns the removed IDs of the "channel_probes" edge to the ChannelProbe entity.
func (m *ChannelMutation) RemovedChannelProbesIDs() (ids []int) {
	for id := range m.removedchannel_probes {
		ids = append(ids, id)
	}
	return
}

// ChannelProbesIDs returns the "channel_probes" edge IDs in the mutation.
func (m *ChannelMutation) ChannelProbesIDs() (ids []int) {
	for id := range m.channel_probes {
		ids = append(ids, id)
	}
	return
}

// ResetChannelProbes resets all changes to the "channel_probes" edge.
func (m *ChannelMutation) ResetChannelProbes() {
	m.channel_probes = nil
	m.clearedchannel_probes = false
	m.removedchannel_probes = nil
}

// AddChannelModelPriceIDs adds the "channel_model_prices" edge to the ChannelModelPrice entity by ids.
func (m *ChannelMutation) AddChannelModelPriceIDs(ids ...int) {
	if m.channel_model_prices == nil {
		m.channel_model_prices = make(map[int]struct{})
	}
	for i := range ids {
		m.channel_model_prices[ids[i]] = struct{}{}
	}
}

// ClearChannelModelPrices clears the "channel_model_prices" edge to the ChannelModelPrice entity.
func (m *ChannelMutation) ClearChannelModelPrices() {
	m.clearedchannel_model_prices = true
}

// ChannelModelPricesCleared reports if the "channel_model_prices" edge to the ChannelModelPrice entity was cleared.
func (m *ChannelMutation) ChannelModelPricesCleared() bool {
	return m.clearedchannel_model_prices
}

// RemoveChannelModelPriceIDs removes the "channel_model_prices" edge to the ChannelModelPrice entity by IDs.
func (m *ChannelMutation) RemoveChannelModelPriceIDs(ids ...int) {
	if m.removedchannel_model_prices == nil {
		m.removedchannel_model_prices = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.channel_model_prices, ids[i])
		m.removedchannel_model_prices[ids[i]] = struct{}{}
	}
}

// RemovedChannelModelPrices returns the removed IDs of the "channel_model_prices" edge to the ChannelModelPrice entity.
func (m *ChannelMutation) RemovedChannelModelPricesIDs() (ids []int) {
	for id := range m.removedchannel_model_prices {
		ids = append(ids, id)
	}
	return
}

// ChannelModelPricesIDs returns the "channel_model_prices" edge IDs in the mutation.
func (m *ChannelMutation) ChannelModelPricesIDs() (ids []int) {
	for id := range m.channel_model_prices {
		ids = append(ids, id)
	}
	return
}

// ResetChannelModelPrices resets all changes to the "channel_model_prices" edge.
func (m *ChannelMutation) ResetChannelModelPrices() {
	m.channel_model_prices = nil
	m.clearedchannel_model_prices = false
	m.removedchannel_model_prices = nil
}

// SetProviderQuotaStatusID sets the "provider_quota_status" edge to the ProviderQuotaStatus entity by id.
func (m *ChannelMutation) SetProviderQuotaStatusID(id int) {
	m.provider_quota_status = &id
}

// ClearProviderQuotaStatus clears the "provider_quota_status" edge to the ProviderQuotaStatus entity.
func (m *ChannelMutation) ClearProviderQuotaStatus() {
	m.clearedprovider_quota_status = true
}

// ProviderQuotaStatusCleared reports if the "provider_quota_status" edge to the ProviderQuotaStatus entity was cleared.
func (m *ChannelMutation) ProviderQuotaStatusCleared() bool {
	return m.clearedprovider_quota_status
}

// ProviderQuotaStatusID returns the "provider_quota_status" edge ID in the mutation.
func (m *ChannelMutation) ProviderQuotaStatusID() (id int, exists bool) {
	if m.provider_quota_status != nil {
		return *m.provider_quota_status, true
	}
	return
}

// ProviderQuotaStatusIDs returns the "provider_quota_status" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProviderQuotaStatusID instead. It exists only for internal usage by the builders.
func (m *ChannelMutation) ProviderQuotaStatusIDs() (ids []int) {
	if id := m.provider_quota_status; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProviderQuotaStatus resets all changes to the "provider_quota_status" edge.
func (m *ChannelMutation) ResetProviderQuotaStatus() {
	m.provider_quota_status = nil
	m.clearedprovider_quota_status = false
}

// Where appends a list predicates to the ChannelMutation builder.
func (m *ChannelMutation) Where(ps ...predicate.Channel) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ChannelMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ChannelMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Channel, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ChannelMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ChannelMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Channel).
func (m *ChannelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChannelMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.created_at != nil {
		fields = append(fields, channel.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, channel.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, channel.FieldDeletedAt)
	}
	if m._type != nil {
		fields = append(fields, channel.FieldType)
	}
	if m.base_url != nil {
		fields = append(fields, channel.FieldBaseURL)
	}
	if m.name != nil {
		fields = append(fields, channel.FieldName)
	}
	if m.status != nil {
		fields = append(fields, channel.FieldStatus)
	}
	if m.credentials != nil {
		fields = append(fields, channel.FieldCredentials)
	}
	if m.disabled_api_keys != nil {
		fields = append(fields, channel.FieldDisabledAPIKeys)
	}
	if m.supported_models != nil {
		fields = append(fields, channel.FieldSupportedModels)
	}
	if m.auto_sync_supported_models != nil {
		fields = append(fields, channel.FieldAutoSyncSupportedModels)
	}
	if m.tags != nil {
		fields = append(fields, channel.FieldTags)
	}
	if m.default_test_model != nil {
		fields = append(fields, channel.FieldDefaultTestModel)
	}
	if m.policies != nil {
		fields = append(fields, channel.FieldPolicies)
	}
	if m.settings != nil {
		fields = append(fields, channel.FieldSettings)
	}
	if m.ordering_weight != nil {
		fields = append(fields, channel.FieldOrderingWeight)
	}
	if m.error_message != nil {
		fields = append(fields, channel.FieldErrorMessage)
	}
	if m.remark != nil {
		fields = append(fields, channel.FieldRemark)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChannelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case channel.FieldCreatedAt:
		return m.CreatedAt()
	case channel.FieldUpdatedAt:
		return m.UpdatedAt()
	case channel.FieldDeletedAt:
		return m.DeletedAt()
	case channel.FieldType:
		return m.GetType()
	case channel.FieldBaseURL:
		return m.BaseURL()
	case channel.FieldName:
		return m.Name()
	case channel.FieldStatus:
		return m.Status()
	case channel.FieldCredentials:
		return m.Credentials()
	case channel.FieldDisabledAPIKeys:
		return m.DisabledAPIKeys()
	case channel.FieldSupportedModels:
		return m.SupportedModels()
	case channel.FieldAutoSyncSupportedModels:
		return m.AutoSyncSupportedModels()
	case channel.FieldTags:
		return m.Tags()
	case channel.FieldDefaultTestModel:
		return m.DefaultTestModel()
	case channel.FieldPolicies:
		return m.Policies()
	case channel.FieldSettings:
		return m.Settings()
	case channel.FieldOrderingWeight:
		return m.OrderingWeight()
	case channel.FieldErrorMessage:
		return m.ErrorMessage()
	case channel.FieldRemark:
		return m.Remark()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChannelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case channel.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case channel.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case channel.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case channel.FieldType:
		return m.OldType(ctx)
	case channel.FieldBaseURL:
		return m.OldBaseURL(ctx)
	case channel.FieldName:
		return m.OldName(ctx)
	case channel.FieldStatus:
		return m.OldStatus(ctx)
	case channel.FieldCredentials:
		return m.OldCredentials(ctx)
	case channel.FieldDisabledAPIKeys:
		return m.OldDisabledAPIKeys(ctx)
	case channel.FieldSupportedModels:
		return m.OldSupportedModels(ctx)
	case channel.FieldAutoSyncSupportedModels:
		return m.OldAutoSyncSupportedModels(ctx)
	case channel.FieldTags:
		return m.OldTags(ctx)
	case channel.FieldDefaultTestModel:
		return m.OldDefaultTestModel(ctx)
	case channel.FieldPolicies:
		return m.OldPolicies(ctx)
	case channel.FieldSettings:
		return m.OldSettings(ctx)
	case channel.FieldOrderingWeight:
		return m.OldOrderingWeight(ctx)
	case channel.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case channel.FieldRemark:
		return m.OldRemark(ctx)
	}
	return nil, fmt.Errorf("unknown Channel field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChannelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case channel.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case channel.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case channel.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case channel.FieldType:
		v, ok := value.(channel.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case channel.FieldBaseURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaseURL(v)
		return nil
	case channel.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case channel.FieldStatus:
		v, ok := value.(channel.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case channel.FieldCredentials:
		v, ok := value.(objects.ChannelCredentials)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCredentials(v)
		return nil
	case channel.FieldDisabledAPIKeys:
		v, ok := value.([]objects.DisabledAPIKey)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabledAPIKeys(v)
		return nil
	case channel.FieldSupportedModels:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupportedModels(v)
		return nil
	case channel.FieldAutoSyncSupportedModels:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoSyncSupportedModels(v)
		return nil
	case channel.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case channel.FieldDefaultTestModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultTestModel(v)
		return nil
	case channel.FieldPolicies:
		v, ok := value.(objects.ChannelPolicies)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPolicies(v)
		return nil
	case channel.FieldSettings:
		v, ok := value.(*objects.ChannelSettings)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettings(v)
		return nil
	case channel.FieldOrderingWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderingWeight(v)
		return nil
	case channel.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case channel.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	}
	return fmt.Errorf("unknown Channel field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChannelMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, channel.FieldDeletedAt)
	}
	if m.addordering_weight != nil {
		fields = append(fields, channel.FieldOrderingWeight)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChannelMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case channel.FieldDeletedAt:
		return m.AddedDeletedAt()
	case channel.FieldOrderingWeight:
		return m.AddedOrderingWeight()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChannelMutation) AddField(name string, value ent.Value) error {
	switch name {
	case channel.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case channel.FieldOrderingWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderingWeight(v)
		return nil
	}
	return fmt.Errorf("unknown Channel numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChannelMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(channel.FieldBaseURL) {
		fields = append(fields, channel.FieldBaseURL)
	}
	if m.FieldCleared(channel.FieldDisabledAPIKeys) {
		fields = append(fields, channel.FieldDisabledAPIKeys)
	}
	if m.FieldCleared(channel.FieldTags) {
		fields = append(fields, channel.FieldTags)
	}
	if m.FieldCleared(channel.FieldPolicies) {
		fields = append(fields, channel.FieldPolicies)
	}
	if m.FieldCleared(channel.FieldSettings) {
		fields = append(fields, channel.FieldSettings)
	}
	if m.FieldCleared(channel.FieldErrorMessage) {
		fields = append(fields, channel.FieldErrorMessage)
	}
	if m.FieldCleared(channel.FieldRemark) {
		fields = append(fields, channel.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChannelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChannelMutation) ClearField(name string) error {
	switch name {
	case channel.FieldBaseURL:
		m.ClearBaseURL()
		return nil
	case channel.FieldDisabledAPIKeys:
		m.ClearDisabledAPIKeys()
		return nil
	case channel.FieldTags:
		m.ClearTags()
		return nil
	case channel.FieldPolicies:
		m.ClearPolicies()
		return nil
	case channel.FieldSettings:
		m.ClearSettings()
		return nil
	case channel.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	case channel.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown Channel nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChannelMutation) ResetField(name string) error {
	switch name {
	case channel.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case channel.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case channel.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case channel.FieldType:
		m.ResetType()
		return nil
	case channel.FieldBaseURL:
		m.ResetBaseURL()
		return nil
	case channel.FieldName:
		m.ResetName()
		return nil
	case channel.FieldStatus:
		m.ResetStatus()
		return nil
	case channel.FieldCredentials:
		m.ResetCredentials()
		return nil
	case channel.FieldDisabledAPIKeys:
		m.ResetDisabledAPIKeys()
		return nil
	case channel.FieldSupportedModels:
		m.ResetSupportedModels()
		return nil
	case channel.FieldAutoSyncSupportedModels:
		m.ResetAutoSyncSupportedModels()
		return nil
	case channel.FieldTags:
		m.ResetTags()
		return nil
	case channel.FieldDefaultTestModel:
		m.ResetDefaultTestModel()
		return nil
	case channel.FieldPolicies:
		m.ResetPolicies()
		return nil
	case channel.FieldSettings:
		m.ResetSettings()
		return nil
	case channel.FieldOrderingWeight:
		m.ResetOrderingWeight()
		return nil
	case channel.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case channel.FieldRemark:
		m.ResetRemark()
		return nil
	}
	return fmt.Errorf("unknown Channel field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChannelMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.requests != nil {
		edges = append(edges, channel.EdgeRequests)
	}
	if m.executions != nil {
		edges = append(edges, channel.EdgeExecutions)
	}
	if m.usage_logs != nil {
		edges = append(edges, channel.EdgeUsageLogs)
	}
	if m.channel_probes != nil {
		edges = append(edges, channel.EdgeChannelProbes)
	}
	if m.channel_model_prices != nil {
		edges = append(edges, channel.EdgeChannelModelPrices)
	}
	if m.provider_quota_status != nil {
		edges = append(edges, channel.EdgeProviderQuotaStatus)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChannelMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case channel.EdgeRequests:
		ids := make([]ent.Value, 0, len(m.requests))
		for id := range m.requests {
			ids = append(ids, id)
		}
		return ids
	case channel.EdgeExecutions:
		ids := make([]ent.Value, 0, len(m.executions))
		for id := range m.executions {
			ids = append(ids, id)
		}
		return ids
	case channel.EdgeUsageLogs:
		ids := make([]ent.Value, 0, len(m.usage_logs))
		for id := range m.usage_logs {
			ids = append(ids, id)
		}
		return ids
	case channel.EdgeChannelProbes:
		ids := make([]ent.Value, 0, len(m.channel_probes))
		for id := range m.channel_probes {
			ids = append(ids, id)
		}
		return ids
	case channel.EdgeChannelModelPrices:
		ids := make([]ent.Value, 0, len(m.channel_model_prices))
		for id := range m.channel_model_prices {
			ids = append(ids, id)
		}
		return ids
	case channel.EdgeProviderQuotaStatus:
		if id := m.provider_quota_status; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChannelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedrequests != nil {
		edges = append(edges, channel.EdgeRequests)
	}
	if m.removedexecutions != nil {
		edges = append(edges, channel.EdgeExecutions)
	}
	if m.removedusage_logs != nil {
		edges = append(edges, channel.EdgeUsageLogs)
	}
	if m.removedchannel_probes != nil {
		edges = append(edges, channel.EdgeChannelProbes)
	}
	if m.removedchannel_model_prices != nil {
		edges = append(edges, channel.EdgeChannelModelPrices)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChannelMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case channel.EdgeRequests:
		ids := make([]ent.Value, 0, len(m.removedrequests))
		for id := range m.removedrequests {
			ids = append(ids, id)
		}
		return ids
	case channel.EdgeExecutions:
		ids := make([]ent.Value, 0, len(m.removedexecutions))
		for id := range m.removedexecutions {
			ids = append(ids, id)
		}
		return ids
	case channel.EdgeUsageLogs:
		ids := make([]ent.Value, 0, len(m.removedusage_logs))
		for id := range m.removedusage_logs {
			ids = append(ids, id)
		}
		return ids
	case channel.EdgeChannelProbes:
		ids := make([]ent.Value, 0, len(m.removedchannel_probes))
		for id := range m.removedchannel_probes {
			ids = append(ids, id)
		}
		return ids
	case channel.EdgeChannelModelPrices:
		ids := make([]ent.Value, 0, len(m.removedchannel_model_prices))
		for id := range m.removedchannel_model_prices {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChannelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedrequests {
		edges = append(edges, channel.EdgeRequests)
	}
	if m.clearedexecutions {
		edges = append(edges, channel.EdgeExecutions)
	}
	if m.clearedusage_logs {
		edges = append(edges, channel.EdgeUsageLogs)
	}
	if m.clearedchannel_probes {
		edges = append(edges, channel.EdgeChannelProbes)
	}
	if m.clearedchannel_model_prices {
		edges = append(edges, channel.EdgeChannelModelPrices)
	}
	if m.clearedprovider_quota_status {
		edges = append(edges, channel.EdgeProviderQuotaStatus)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChannelMutation) EdgeCleared(name string) bool {
	switch name {
	case channel.EdgeRequests:
		return m.clearedrequests
	case channel.EdgeExecutions:
		return m.clearedexecutions
	case channel.EdgeUsageLogs:
		return m.clearedusage_logs
	case channel.EdgeChannelProbes:
		return m.clearedchannel_probes
	case channel.EdgeChannelModelPrices:
		return m.clearedchannel_model_prices
	case channel.EdgeProviderQuotaStatus:
		return m.clearedprovider_quota_status
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChannelMutation) ClearEdge(name string) error {
	switch name {
	case channel.EdgeProviderQuotaStatus:
		m.ClearProviderQuotaStatus()
		return nil
	}
	return fmt.Errorf("unknown Channel unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChannelMutation) ResetEdge(name string) error {
	switch name {
	case channel.EdgeRequests:
		m.ResetRequests()
		return nil
	case channel.EdgeExecutions:
		m.ResetExecutions()
		return nil
	case channel.EdgeUsageLogs:
		m.ResetUsageLogs()
		return nil
	case channel.EdgeChannelProbes:
		m.ResetChannelProbes()
		return nil
	case channel.EdgeChannelModelPrices:
		m.ResetChannelModelPrices()
		return nil
	case channel.EdgeProviderQuotaStatus:
		m.ResetProviderQuotaStatus()
		return nil
	}
	return fmt.Errorf("unknown Channel edge %s", name)
}

// ChannelModelPriceMutation represents an operation that mutates the ChannelModelPrice nodes in the graph.
type ChannelModelPriceMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *int
	adddeleted_at   *int
	model_id        *string
	price           *objects.ModelPrice
	reference_id    *string
	clearedFields   map[string]struct{}
	channel         *int
	clearedchannel  bool
	versions        map[int]struct{}
	removedversions map[int]struct{}
	clearedversions bool
	done            bool
	oldValue        func(context.Context) (*ChannelModelPrice, error)
	predicates      []predicate.ChannelModelPrice
}

var _ ent.Mutation = (*ChannelModelPriceMutation)(nil)

// channelmodelpriceOption allows management of the mutation configuration using functional options.
type channelmodelpriceOption func(*ChannelModelPriceMutation)

// newChannelModelPriceMutation creates new mutation for the ChannelModelPrice entity.
func newChannelModelPriceMutation(c config, op Op, opts ...channelmodelpriceOption) *ChannelModelPriceMutation {
	m := &ChannelModelPriceMutation{
		config:        c,
		op:            op,
		typ:           TypeChannelModelPrice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChannelModelPriceID sets the ID field of the mutation.
func withChannelModelPriceID(id int) channelmodelpriceOption {
	return func(m *ChannelModelPriceMutation) {
		var (
			err   error
			once  sync.Once
			value *ChannelModelPrice
		)
		m.oldValue = func(ctx context.Context) (*ChannelModelPrice, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ChannelModelPrice.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChannelModelPrice sets the old ChannelModelPrice of the mutation.
func withChannelModelPrice(node *ChannelModelPrice) channelmodelpriceOption {
	return func(m *ChannelModelPriceMutation) {
		m.oldValue = func(context.Context) (*ChannelModelPrice, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChannelModelPriceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChannelModelPriceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChannelModelPriceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChannelModelPriceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ChannelModelPrice.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ChannelModelPriceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ChannelModelPriceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ChannelModelPrice entity.
// If the ChannelModelPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelModelPriceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ChannelModelPriceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ChannelModelPriceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ChannelModelPriceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ChannelModelPrice entity.
// If the ChannelModelPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelModelPriceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ChannelModelPriceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ChannelModelPriceMutation) SetDeletedAt(i int) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ChannelModelPriceMutation) DeletedAt() (r int, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ChannelModelPrice entity.
// If the ChannelModelPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelModelPriceMutation) OldDeletedAt(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *ChannelModelPriceMutation) AddDeletedAt(i int) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *ChannelModelPriceMutation) AddedDeletedAt() (r int, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ChannelModelPriceMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetChannelID sets the "channel_id" field.
func (m *ChannelModelPriceMutation) SetChannelID(i int) {
	m.channel = &i
}

// ChannelID returns the value of the "channel_id" field in the mutation.
func (m *ChannelModelPriceMutation) ChannelID() (r int, exists bool) {
	v := m.channel
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelID returns the old "channel_id" field's value of the ChannelModelPrice entity.
// If the ChannelModelPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelModelPriceMutation) OldChannelID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelID: %w", err)
	}
	return oldValue.ChannelID, nil
}

// ResetChannelID resets all changes to the "channel_id" field.
func (m *ChannelModelPriceMutation) ResetChannelID() {
	m.channel = nil
}

// SetModelID sets the "model_id" field.
func (m *ChannelModelPriceMutation) SetModelID(s string) {
	m.model_id = &s
}

// ModelID returns the value of the "model_id" field in the mutation.
func (m *ChannelModelPriceMutation) ModelID() (r string, exists bool) {
	v := m.model_id
	if v == nil {
		return
	}
	return *v, true
}

// OldModelID returns the old "model_id" field's value of the ChannelModelPrice entity.
// If the ChannelModelPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelModelPriceMutation) OldModelID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModelID: %w", err)
	}
	return oldValue.ModelID, nil
}

// ResetModelID resets all changes to the "model_id" field.
func (m *ChannelModelPriceMutation) ResetModelID() {
	m.model_id = nil
}

// SetPrice sets the "price" field.
func (m *ChannelModelPriceMutation) SetPrice(op objects.ModelPrice) {
	m.price = &op
}

// Price returns the value of the "price" field in the mutation.
func (m *ChannelModelPriceMutation) Price() (r objects.ModelPrice, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the ChannelModelPrice entity.
// If the ChannelModelPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelModelPriceMutation) OldPrice(ctx context.Context) (v objects.ModelPrice, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// ResetPrice resets all changes to the "price" field.
func (m *ChannelModelPriceMutation) ResetPrice() {
	m.price = nil
}

// SetReferenceID sets the "reference_id" field.
func (m *ChannelModelPriceMutation) SetReferenceID(s string) {
	m.reference_id = &s
}

// ReferenceID returns the value of the "reference_id" field in the mutation.
func (m *ChannelModelPriceMutation) ReferenceID() (r string, exists bool) {
	v := m.reference_id
	if v == nil {
		return
	}
	return *v, true
}

// OldReferenceID returns the old "reference_id" field's value of the ChannelModelPrice entity.
// If the ChannelModelPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelModelPriceMutation) OldReferenceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferenceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferenceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferenceID: %w", err)
	}
	return oldValue.ReferenceID, nil
}

// ResetReferenceID resets all changes to the "reference_id" field.
func (m *ChannelModelPriceMutation) ResetReferenceID() {
	m.reference_id = nil
}

// ClearChannel clears the "channel" edge to the Channel entity.
func (m *ChannelModelPriceMutation) ClearChannel() {
	m.clearedchannel = true
	m.clearedFields[channelmodelprice.FieldChannelID] = struct{}{}
}

// ChannelCleared reports if the "channel" edge to the Channel entity was cleared.
func (m *ChannelModelPriceMutation) ChannelCleared() bool {
	return m.clearedchannel
}

// ChannelIDs returns the "channel" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChannelID instead. It exists only for internal usage by the builders.
func (m *ChannelModelPriceMutation) ChannelIDs() (ids []int) {
	if id := m.channel; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChannel resets all changes to the "channel" edge.
func (m *ChannelModelPriceMutation) ResetChannel() {
	m.channel = nil
	m.clearedchannel = false
}

// AddVersionIDs adds the "versions" edge to the ChannelModelPriceVersion entity by ids.
func (m *ChannelModelPriceMutation) AddVersionIDs(ids ...int) {
	if m.versions == nil {
		m.versions = make(map[int]struct{})
	}
	for i := range ids {
		m.versions[ids[i]] = struct{}{}
	}
}

// ClearVersions clears the "versions" edge to the ChannelModelPriceVersion entity.
func (m *ChannelModelPriceMutation) ClearVersions() {
	m.clearedversions = true
}

// VersionsCleared reports if the "versions" edge to the ChannelModelPriceVersion entity was cleared.
func (m *ChannelModelPriceMutation) VersionsCleared() bool {
	return m.clearedversions
}

// RemoveVersionIDs removes the "versions" edge to the ChannelModelPriceVersion entity by IDs.
func (m *ChannelModelPriceMutation) RemoveVersionIDs(ids ...int) {
	if m.removedversions == nil {
		m.removedversions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.versions, ids[i])
		m.removedversions[ids[i]] = struct{}{}
	}
}

// RemovedVersions returns the removed IDs of the "versions" edge to the ChannelModelPriceVersion entity.
func (m *ChannelModelPriceMutation) RemovedVersionsIDs() (ids []int) {
	for id := range m.removedversions {
		ids = append(ids, id)
	}
	return
}

// VersionsIDs returns the "versions" edge IDs in the mutation.
func (m *ChannelModelPriceMutation) VersionsIDs() (ids []int) {
	for id := range m.versions {
		ids = append(ids, id)
	}
	return
}

// ResetVersions resets all changes to the "versions" edge.
func (m *ChannelModelPriceMutation) ResetVersions() {
	m.versions = nil
	m.clearedversions = false
	m.removedversions = nil
}

// Where appends a list predicates to the ChannelModelPriceMutation builder.
func (m *ChannelModelPriceMutation) Where(ps ...predicate.ChannelModelPrice) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ChannelModelPriceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ChannelModelPriceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ChannelModelPrice, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ChannelModelPriceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ChannelModelPriceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ChannelModelPrice).
func (m *ChannelModelPriceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChannelModelPriceMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, channelmodelprice.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, channelmodelprice.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, channelmodelprice.FieldDeletedAt)
	}
	if m.channel != nil {
		fields = append(fields, channelmodelprice.FieldChannelID)
	}
	if m.model_id != nil {
		fields = append(fields, channelmodelprice.FieldModelID)
	}
	if m.price != nil {
		fields = append(fields, channelmodelprice.FieldPrice)
	}
	if m.reference_id != nil {
		fields = append(fields, channelmodelprice.FieldReferenceID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChannelModelPriceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case channelmodelprice.FieldCreatedAt:
		return m.CreatedAt()
	case channelmodelprice.FieldUpdatedAt:
		return m.UpdatedAt()
	case channelmodelprice.FieldDeletedAt:
		return m.DeletedAt()
	case channelmodelprice.FieldChannelID:
		return m.ChannelID()
	case channelmodelprice.FieldModelID:
		return m.ModelID()
	case channelmodelprice.FieldPrice:
		return m.Price()
	case channelmodelprice.FieldReferenceID:
		return m.ReferenceID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChannelModelPriceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case channelmodelprice.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case channelmodelprice.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case channelmodelprice.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case channelmodelprice.FieldChannelID:
		return m.OldChannelID(ctx)
	case channelmodelprice.FieldModelID:
		return m.OldModelID(ctx)
	case channelmodelprice.FieldPrice:
		return m.OldPrice(ctx)
	case channelmodelprice.FieldReferenceID:
		return m.OldReferenceID(ctx)
	}
	return nil, fmt.Errorf("unknown ChannelModelPrice field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChannelModelPriceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case channelmodelprice.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case channelmodelprice.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case channelmodelprice.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case channelmodelprice.FieldChannelID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelID(v)
		return nil
	case channelmodelprice.FieldModelID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModelID(v)
		return nil
	case channelmodelprice.FieldPrice:
		v, ok := value.(objects.ModelPrice)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case channelmodelprice.FieldReferenceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferenceID(v)
		return nil
	}
	return fmt.Errorf("unknown ChannelModelPrice field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChannelModelPriceMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, channelmodelprice.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChannelModelPriceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case channelmodelprice.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChannelModelPriceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case channelmodelprice.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ChannelModelPrice numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChannelModelPriceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChannelModelPriceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChannelModelPriceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ChannelModelPrice nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChannelModelPriceMutation) ResetField(name string) error {
	switch name {
	case channelmodelprice.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case channelmodelprice.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case channelmodelprice.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case channelmodelprice.FieldChannelID:
		m.ResetChannelID()
		return nil
	case channelmodelprice.FieldModelID:
		m.ResetModelID()
		return nil
	case channelmodelprice.FieldPrice:
		m.ResetPrice()
		return nil
	case channelmodelprice.FieldReferenceID:
		m.ResetReferenceID()
		return nil
	}
	return fmt.Errorf("unknown ChannelModelPrice field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChannelModelPriceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.channel != nil {
		edges = append(edges, channelmodelprice.EdgeChannel)
	}
	if m.versions != nil {
		edges = append(edges, channelmodelprice.EdgeVersions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChannelModelPriceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case channelmodelprice.EdgeChannel:
		if id := m.channel; id != nil {
			return []ent.Value{*id}
		}
	case channelmodelprice.EdgeVersions:
		ids := make([]ent.Value, 0, len(m.versions))
		for id := range m.versions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChannelModelPriceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedversions != nil {
		edges = append(edges, channelmodelprice.EdgeVersions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChannelModelPriceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case channelmodelprice.EdgeVersions:
		ids := make([]ent.Value, 0, len(m.removedversions))
		for id := range m.removedversions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChannelModelPriceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedchannel {
		edges = append(edges, channelmodelprice.EdgeChannel)
	}
	if m.clearedversions {
		edges = append(edges, channelmodelprice.EdgeVersions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChannelModelPriceMutation) EdgeCleared(name string) bool {
	switch name {
	case channelmodelprice.EdgeChannel:
		return m.clearedchannel
	case channelmodelprice.EdgeVersions:
		return m.clearedversions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChannelModelPriceMutation) ClearEdge(name string) error {
	switch name {
	case channelmodelprice.EdgeChannel:
		m.ClearChannel()
		return nil
	}
	return fmt.Errorf("unknown ChannelModelPrice unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChannelModelPriceMutation) ResetEdge(name string) error {
	switch name {
	case channelmodelprice.EdgeChannel:
		m.ResetChannel()
		return nil
	case channelmodelprice.EdgeVersions:
		m.ResetVersions()
		return nil
	}
	return fmt.Errorf("unknown ChannelModelPrice edge %s", name)
}

// ChannelModelPriceVersionMutation represents an operation that mutates the ChannelModelPriceVersion nodes in the graph.
type ChannelModelPriceVersionMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	created_at                 *time.Time
	updated_at                 *time.Time
	channel_id                 *int
	addchannel_id              *int
	model_id                   *string
	price                      *objects.ModelPrice
	status                     *channelmodelpriceversion.Status
	effective_start_at         *time.Time
	effective_end_at           *time.Time
	reference_id               *string
	clearedFields              map[string]struct{}
	channel_model_price        *int
	clearedchannel_model_price bool
	done                       bool
	oldValue                   func(context.Context) (*ChannelModelPriceVersion, error)
	predicates                 []predicate.ChannelModelPriceVersion
}

var _ ent.Mutation = (*ChannelModelPriceVersionMutation)(nil)

// channelmodelpriceversionOption allows management of the mutation configuration using functional options.
type channelmodelpriceversionOption func(*ChannelModelPriceVersionMutation)

// newChannelModelPriceVersionMutation creates new mutation for the ChannelModelPriceVersion entity.
func newChannelModelPriceVersionMutation(c config, op Op, opts ...channelmodelpriceversionOption) *ChannelModelPriceVersionMutation {
	m := &ChannelModelPriceVersionMutation{
		config:        c,
		op:            op,
		typ:           TypeChannelModelPriceVersion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChannelModelPriceVersionID sets the ID field of the mutation.
func withChannelModelPriceVersionID(id int) channelmodelpriceversionOption {
	return func(m *ChannelModelPriceVersionMutation) {
		var (
			err   error
			once  sync.Once
			value *ChannelModelPriceVersion
		)
		m.oldValue = func(ctx context.Context) (*ChannelModelPriceVersion, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ChannelModelPriceVersion.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChannelModelPriceVersion sets the old ChannelModelPriceVersion of the mutation.
func withChannelModelPriceVersion(node *ChannelModelPriceVersion) channelmodelpriceversionOption {
	return func(m *ChannelModelPriceVersionMutation) {
		m.oldValue = func(context.Context) (*ChannelModelPriceVersion, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChannelModelPriceVersionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChannelModelPriceVersionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChannelModelPriceVersionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChannelModelPriceVersionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ChannelModelPriceVersion.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ChannelModelPriceVersionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ChannelModelPriceVersionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ChannelModelPriceVersion entity.
// If the ChannelModelPriceVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelModelPriceVersionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ChannelModelPriceVersionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ChannelModelPriceVersionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ChannelModelPriceVersionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ChannelModelPriceVersion entity.
// If the ChannelModelPriceVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelModelPriceVersionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ChannelModelPriceVersionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetChannelID sets the "channel_id" field.
func (m *ChannelModelPriceVersionMutation) SetChannelID(i int) {
	m.channel_id = &i
	m.addchannel_id = nil
}

// ChannelID returns the value of the "channel_id" field in the mutation.
func (m *ChannelModelPriceVersionMutation) ChannelID() (r int, exists bool) {
	v := m.channel_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelID returns the old "channel_id" field's value of the ChannelModelPriceVersion entity.
// If the ChannelModelPriceVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelModelPriceVersionMutation) OldChannelID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelID: %w", err)
	}
	return oldValue.ChannelID, nil
}

// AddChannelID adds i to the "channel_id" field.
func (m *ChannelModelPriceVersionMutation) AddChannelID(i int) {
	if m.addchannel_id != nil {
		*m.addchannel_id += i
	} else {
		m.addchannel_id = &i
	}
}

// AddedChannelID returns the value that was added to the "channel_id" field in this mutation.
func (m *ChannelModelPriceVersionMutation) AddedChannelID() (r int, exists bool) {
	v := m.addchannel_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetChannelID resets all changes to the "channel_id" field.
func (m *ChannelModelPriceVersionMutation) ResetChannelID() {
	m.channel_id = nil
	m.addchannel_id = nil
}

// SetModelID sets the "model_id" field.
func (m *ChannelModelPriceVersionMutation) SetModelID(s string) {
	m.model_id = &s
}

// ModelID returns the value of the "model_id" field in the mutation.
func (m *ChannelModelPriceVersionMutation) ModelID() (r string, exists bool) {
	v := m.model_id
	if v == nil {
		return
	}
	return *v, true
}

// OldModelID returns the old "model_id" field's value of the ChannelModelPriceVersion entity.
// If the ChannelModelPriceVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelModelPriceVersionMutation) OldModelID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModelID: %w", err)
	}
	return oldValue.ModelID, nil
}

// ResetModelID resets all changes to the "model_id" field.
func (m *ChannelModelPriceVersionMutation) ResetModelID() {
	m.model_id = nil
}

// SetChannelModelPriceID sets the "channel_model_price_id" field.
func (m *ChannelModelPriceVersionMutation) SetChannelModelPriceID(i int) {
	m.channel_model_price = &i
}

// ChannelModelPriceID returns the value of the "channel_model_price_id" field in the mutation.
func (m *ChannelModelPriceVersionMutation) ChannelModelPriceID() (r int, exists bool) {
	v := m.channel_model_price
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelModelPriceID returns the old "channel_model_price_id" field's value of the ChannelModelPriceVersion entity.
// If the ChannelModelPriceVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelModelPriceVersionMutation) OldChannelModelPriceID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelModelPriceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelModelPriceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelModelPriceID: %w", err)
	}
	return oldValue.ChannelModelPriceID, nil
}

// ResetChannelModelPriceID resets all changes to the "channel_model_price_id" field.
func (m *ChannelModelPriceVersionMutation) ResetChannelModelPriceID() {
	m.channel_model_price = nil
}

// SetPrice sets the "price" field.
func (m *ChannelModelPriceVersionMutation) SetPrice(op objects.ModelPrice) {
	m.price = &op
}

// Price returns the value of the "price" field in the mutation.
func (m *ChannelModelPriceVersionMutation) Price() (r objects.ModelPrice, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the ChannelModelPriceVersion entity.
// If the ChannelModelPriceVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelModelPriceVersionMutation) OldPrice(ctx context.Context) (v objects.ModelPrice, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// ResetPrice resets all changes to the "price" field.
func (m *ChannelModelPriceVersionMutation) ResetPrice() {
	m.price = nil
}

// SetStatus sets the "status" field.
func (m *ChannelModelPriceVersionMutation) SetStatus(c channelmodelpriceversion.Status) {
	m.status = &c
}

// Status returns the value of the "status" field in the mutation.
func (m *ChannelModelPriceVersionMutation) Status() (r channelmodelpriceversion.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ChannelModelPriceVersion entity.
// If the ChannelModelPriceVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelModelPriceVersionMutation) OldStatus(ctx context.Context) (v channelmodelpriceversion.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ChannelModelPriceVersionMutation) ResetStatus() {
	m.status = nil
}

// SetEffectiveStartAt sets the "effective_start_at" field.
func (m *ChannelModelPriceVersionMutation) SetEffectiveStartAt(t time.Time) {
	m.effective_start_at = &t
}

// EffectiveStartAt returns the value of the "effective_start_at" field in the mutation.
func (m *ChannelModelPriceVersionMutation) EffectiveStartAt() (r time.Time, exists bool) {
	v := m.effective_start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEffectiveStartAt returns the old "effective_start_at" field's value of the ChannelModelPriceVersion entity.
// If the ChannelModelPriceVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelModelPriceVersionMutation) OldEffectiveStartAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEffectiveStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEffectiveStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffectiveStartAt: %w", err)
	}
	return oldValue.EffectiveStartAt, nil
}

// ResetEffectiveStartAt resets all changes to the "effective_start_at" field.
func (m *ChannelModelPriceVersionMutation) ResetEffectiveStartAt() {
	m.effective_start_at = nil
}

// SetEffectiveEndAt sets the "effective_end_at" field.
func (m *ChannelModelPriceVersionMutation) SetEffectiveEndAt(t time.Time) {
	m.effective_end_at = &t
}

// EffectiveEndAt returns the value of the "effective_end_at" field in the mutation.
func (m *ChannelModelPriceVersionMutation) EffectiveEndAt() (r time.Time, exists bool) {
	v := m.effective_end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEffectiveEndAt returns the old "effective_end_at" field's value of the ChannelModelPriceVersion entity.
// If the ChannelModelPriceVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelModelPriceVersionMutation) OldEffectiveEndAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEffectiveEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEffectiveEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffectiveEndAt: %w", err)
	}
	return oldValue.EffectiveEndAt, nil
}

// ClearEffectiveEndAt clears the value of the "effective_end_at" field.
func (m *ChannelModelPriceVersionMutation) ClearEffectiveEndAt() {
	m.effective_end_at = nil
	m.clearedFields[channelmodelpriceversion.FieldEffectiveEndAt] = struct{}{}
}

// EffectiveEndAtCleared returns if the "effective_end_at" field was cleared in this mutation.
func (m *ChannelModelPriceVersionMutation) EffectiveEndAtCleared() bool {
	_, ok := m.clearedFields[channelmodelpriceversion.FieldEffectiveEndAt]
	return ok
}

// ResetEffectiveEndAt resets all changes to the "effective_end_at" field.
func (m *ChannelModelPriceVersionMutation) ResetEffectiveEndAt() {
	m.effective_end_at = nil
	delete(m.clearedFields, channelmodelpriceversion.FieldEffectiveEndAt)
}

// SetReferenceID sets the "reference_id" field.
func (m *ChannelModelPriceVersionMutation) SetReferenceID(s string) {
	m.reference_id = &s
}

// ReferenceID returns the value of the "reference_id" field in the mutation.
func (m *ChannelModelPriceVersionMutation) ReferenceID() (r string, exists bool) {
	v := m.reference_id
	if v == nil {
		return
	}
	return *v, true
}

// OldReferenceID returns the old "reference_id" field's value of the ChannelModelPriceVersion entity.
// If the ChannelModelPriceVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelModelPriceVersionMutation) OldReferenceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferenceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferenceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferenceID: %w", err)
	}
	return oldValue.ReferenceID, nil
}

// ResetReferenceID resets all changes to the "reference_id" field.
func (m *ChannelModelPriceVersionMutation) ResetReferenceID() {
	m.reference_id = nil
}

// ClearChannelModelPrice clears the "channel_model_price" edge to the ChannelModelPrice entity.
func (m *ChannelModelPriceVersionMutation) ClearChannelModelPrice() {
	m.clearedchannel_model_price = true
	m.clearedFields[channelmodelpriceversion.FieldChannelModelPriceID] = struct{}{}
}

// ChannelModelPriceCleared reports if the "channel_model_price" edge to the ChannelModelPrice entity was cleared.
func (m *ChannelModelPriceVersionMutation) ChannelModelPriceCleared() bool {
	return m.clearedchannel_model_price
}

// ChannelModelPriceIDs returns the "channel_model_price" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChannelModelPriceID instead. It exists only for internal usage by the builders.
func (m *ChannelModelPriceVersionMutation) ChannelModelPriceIDs() (ids []int) {
	if id := m.channel_model_price; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChannelModelPrice resets all changes to the "channel_model_price" edge.
func (m *ChannelModelPriceVersionMutation) ResetChannelModelPrice() {
	m.channel_model_price = nil
	m.clearedchannel_model_price = false
}

// Where appends a list predicates to the ChannelModelPriceVersionMutation builder.
func (m *ChannelModelPriceVersionMutation) Where(ps ...predicate.ChannelModelPriceVersion) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ChannelModelPriceVersionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ChannelModelPriceVersionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ChannelModelPriceVersion, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ChannelModelPriceVersionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ChannelModelPriceVersionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ChannelModelPriceVersion).
func (m *ChannelModelPriceVersionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChannelModelPriceVersionMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, channelmodelpriceversion.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, channelmodelpriceversion.FieldUpdatedAt)
	}
	if m.channel_id != nil {
		fields = append(fields, channelmodelpriceversion.FieldChannelID)
	}
	if m.model_id != nil {
		fields = append(fields, channelmodelpriceversion.FieldModelID)
	}
	if m.channel_model_price != nil {
		fields = append(fields, channelmodelpriceversion.FieldChannelModelPriceID)
	}
	if m.price != nil {
		fields = append(fields, channelmodelpriceversion.FieldPrice)
	}
	if m.status != nil {
		fields = append(fields, channelmodelpriceversion.FieldStatus)
	}
	if m.effective_start_at != nil {
		fields = append(fields, channelmodelpriceversion.FieldEffectiveStartAt)
	}
	if m.effective_end_at != nil {
		fields = append(fields, channelmodelpriceversion.FieldEffectiveEndAt)
	}
	if m.reference_id != nil {
		fields = append(fields, channelmodelpriceversion.FieldReferenceID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChannelModelPriceVersionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case channelmodelpriceversion.FieldCreatedAt:
		return m.CreatedAt()
	case channelmodelpriceversion.FieldUpdatedAt:
		return m.UpdatedAt()
	case channelmodelpriceversion.FieldChannelID:
		return m.ChannelID()
	case channelmodelpriceversion.FieldModelID:
		return m.ModelID()
	case channelmodelpriceversion.FieldChannelModelPriceID:
		return m.ChannelModelPriceID()
	case channelmodelpriceversion.FieldPrice:
		return m.Price()
	case channelmodelpriceversion.FieldStatus:
		return m.Status()
	case channelmodelpriceversion.FieldEffectiveStartAt:
		return m.EffectiveStartAt()
	case channelmodelpriceversion.FieldEffectiveEndAt:
		return m.EffectiveEndAt()
	case channelmodelpriceversion.FieldReferenceID:
		return m.ReferenceID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChannelModelPriceVersionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case channelmodelpriceversion.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case channelmodelpriceversion.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case channelmodelpriceversion.FieldChannelID:
		return m.OldChannelID(ctx)
	case channelmodelpriceversion.FieldModelID:
		return m.OldModelID(ctx)
	case channelmodelpriceversion.FieldChannelModelPriceID:
		return m.OldChannelModelPriceID(ctx)
	case channelmodelpriceversion.FieldPrice:
		return m.OldPrice(ctx)
	case channelmodelpriceversion.FieldStatus:
		return m.OldStatus(ctx)
	case channelmodelpriceversion.FieldEffectiveStartAt:
		return m.OldEffectiveStartAt(ctx)
	case channelmodelpriceversion.FieldEffectiveEndAt:
		return m.OldEffectiveEndAt(ctx)
	case channelmodelpriceversion.FieldReferenceID:
		return m.OldReferenceID(ctx)
	}
	return nil, fmt.Errorf("unknown ChannelModelPriceVersion field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChannelModelPriceVersionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case channelmodelpriceversion.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case channelmodelpriceversion.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case channelmodelpriceversion.FieldChannelID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelID(v)
		return nil
	case channelmodelpriceversion.FieldModelID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModelID(v)
		return nil
	case channelmodelpriceversion.FieldChannelModelPriceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelModelPriceID(v)
		return nil
	case channelmodelpriceversion.FieldPrice:
		v, ok := value.(objects.ModelPrice)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case channelmodelpriceversion.FieldStatus:
		v, ok := value.(channelmodelpriceversion.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case channelmodelpriceversion.FieldEffectiveStartAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffectiveStartAt(v)
		return nil
	case channelmodelpriceversion.FieldEffectiveEndAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffectiveEndAt(v)
		return nil
	case channelmodelpriceversion.FieldReferenceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferenceID(v)
		return nil
	}
	return fmt.Errorf("unknown ChannelModelPriceVersion field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChannelModelPriceVersionMutation) AddedFields() []string {
	var fields []string
	if m.addchannel_id != nil {
		fields = append(fields, channelmodelpriceversion.FieldChannelID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChannelModelPriceVersionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case channelmodelpriceversion.FieldChannelID:
		return m.AddedChannelID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChannelModelPriceVersionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case channelmodelpriceversion.FieldChannelID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChannelID(v)
		return nil
	}
	return fmt.Errorf("unknown ChannelModelPriceVersion numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChannelModelPriceVersionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(channelmodelpriceversion.FieldEffectiveEndAt) {
		fields = append(fields, channelmodelpriceversion.FieldEffectiveEndAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChannelModelPriceVersionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChannelModelPriceVersionMutation) ClearField(name string) error {
	switch name {
	case channelmodelpriceversion.FieldEffectiveEndAt:
		m.ClearEffectiveEndAt()
		return nil
	}
	return fmt.Errorf("unknown ChannelModelPriceVersion nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChannelModelPriceVersionMutation) ResetField(name string) error {
	switch name {
	case channelmodelpriceversion.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case channelmodelpriceversion.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case channelmodelpriceversion.FieldChannelID:
		m.ResetChannelID()
		return nil
	case channelmodelpriceversion.FieldModelID:
		m.ResetModelID()
		return nil
	case channelmodelpriceversion.FieldChannelModelPriceID:
		m.ResetChannelModelPriceID()
		return nil
	case channelmodelpriceversion.FieldPrice:
		m.ResetPrice()
		return nil
	case channelmodelpriceversion.FieldStatus:
		m.ResetStatus()
		return nil
	case channelmodelpriceversion.FieldEffectiveStartAt:
		m.ResetEffectiveStartAt()
		return nil
	case channelmodelpriceversion.FieldEffectiveEndAt:
		m.ResetEffectiveEndAt()
		return nil
	case channelmodelpriceversion.FieldReferenceID:
		m.ResetReferenceID()
		return nil
	}
	return fmt.Errorf("unknown ChannelModelPriceVersion field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChannelModelPriceVersionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.channel_model_price != nil {
		edges = append(edges, channelmodelpriceversion.EdgeChannelModelPrice)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChannelModelPriceVersionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case channelmodelpriceversion.EdgeChannelModelPrice:
		if id := m.channel_model_price; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChannelModelPriceVersionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChannelModelPriceVersionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChannelModelPriceVersionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedchannel_model_price {
		edges = append(edges, channelmodelpriceversion.EdgeChannelModelPrice)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChannelModelPriceVersionMutation) EdgeCleared(name string) bool {
	switch name {
	case channelmodelpriceversion.EdgeChannelModelPrice:
		return m.clearedchannel_model_price
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChannelModelPriceVersionMutation) ClearEdge(name string) error {
	switch name {
	case channelmodelpriceversion.EdgeChannelModelPrice:
		m.ClearChannelModelPrice()
		return nil
	}
	return fmt.Errorf("unknown ChannelModelPriceVersion unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChannelModelPriceVersionMutation) ResetEdge(name string) error {
	switch name {
	case channelmodelpriceversion.EdgeChannelModelPrice:
		m.ResetChannelModelPrice()
		return nil
	}
	return fmt.Errorf("unknown ChannelModelPriceVersion edge %s", name)
}

// ChannelOverrideTemplateMutation represents an operation that mutates the ChannelOverrideTemplate nodes in the graph.
type ChannelOverrideTemplateMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	created_at             *time.Time
	updated_at             *time.Time
	deleted_at             *int
	adddeleted_at          *int
	name                   *string
	description            *string
	channel_type           *string
	override_parameters    *string
	override_headers       *[]objects.HeaderEntry
	appendoverride_headers []objects.HeaderEntry
	clearedFields          map[string]struct{}
	user                   *int
	cleareduser            bool
	done                   bool
	oldValue               func(context.Context) (*ChannelOverrideTemplate, error)
	predicates             []predicate.ChannelOverrideTemplate
}

var _ ent.Mutation = (*ChannelOverrideTemplateMutation)(nil)

// channeloverridetemplateOption allows management of the mutation configuration using functional options.
type channeloverridetemplateOption func(*ChannelOverrideTemplateMutation)

// newChannelOverrideTemplateMutation creates new mutation for the ChannelOverrideTemplate entity.
func newChannelOverrideTemplateMutation(c config, op Op, opts ...channeloverridetemplateOption) *ChannelOverrideTemplateMutation {
	m := &ChannelOverrideTemplateMutation{
		config:        c,
		op:            op,
		typ:           TypeChannelOverrideTemplate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChannelOverrideTemplateID sets the ID field of the mutation.
func withChannelOverrideTemplateID(id int) channeloverridetemplateOption {
	return func(m *ChannelOverrideTemplateMutation) {
		var (
			err   error
			once  sync.Once
			value *ChannelOverrideTemplate
		)
		m.oldValue = func(ctx context.Context) (*ChannelOverrideTemplate, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ChannelOverrideTemplate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChannelOverrideTemplate sets the old ChannelOverrideTemplate of the mutation.
func withChannelOverrideTemplate(node *ChannelOverrideTemplate) channeloverridetemplateOption {
	return func(m *ChannelOverrideTemplateMutation) {
		m.oldValue = func(context.Context) (*ChannelOverrideTemplate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChannelOverrideTemplateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChannelOverrideTemplateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChannelOverrideTemplateMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChannelOverrideTemplateMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ChannelOverrideTemplate.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ChannelOverrideTemplateMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ChannelOverrideTemplateMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ChannelOverrideTemplate entity.
// If the ChannelOverrideTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelOverrideTemplateMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ChannelOverrideTemplateMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ChannelOverrideTemplateMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ChannelOverrideTemplateMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ChannelOverrideTemplate entity.
// If the ChannelOverrideTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelOverrideTemplateMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ChannelOverrideTemplateMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ChannelOverrideTemplateMutation) SetDeletedAt(i int) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ChannelOverrideTemplateMutation) DeletedAt() (r int, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ChannelOverrideTemplate entity.
// If the ChannelOverrideTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelOverrideTemplateMutation) OldDeletedAt(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *ChannelOverrideTemplateMutation) AddDeletedAt(i int) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *ChannelOverrideTemplateMutation) AddedDeletedAt() (r int, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ChannelOverrideTemplateMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetUserID sets the "user_id" field.
func (m *ChannelOverrideTemplateMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ChannelOverrideTemplateMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the ChannelOverrideTemplate entity.
// If the ChannelOverrideTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelOverrideTemplateMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ChannelOverrideTemplateMutation) ResetUserID() {
	m.user = nil
}

// SetName sets the "name" field.
func (m *ChannelOverrideTemplateMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ChannelOverrideTemplateMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ChannelOverrideTemplate entity.
// If the ChannelOverrideTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelOverrideTemplateMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ChannelOverrideTemplateMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ChannelOverrideTemplateMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ChannelOverrideTemplateMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ChannelOverrideTemplate entity.
// If the ChannelOverrideTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelOverrideTemplateMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ChannelOverrideTemplateMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[channeloverridetemplate.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ChannelOverrideTemplateMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[channeloverridetemplate.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ChannelOverrideTemplateMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, channeloverridetemplate.FieldDescription)
}

// SetChannelType sets the "channel_type" field.
func (m *ChannelOverrideTemplateMutation) SetChannelType(s string) {
	m.channel_type = &s
}

// ChannelType returns the value of the "channel_type" field in the mutation.
func (m *ChannelOverrideTemplateMutation) ChannelType() (r string, exists bool) {
	v := m.channel_type
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelType returns the old "channel_type" field's value of the ChannelOverrideTemplate entity.
// If the ChannelOverrideTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelOverrideTemplateMutation) OldChannelType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelType: %w", err)
	}
	return oldValue.ChannelType, nil
}

// ResetChannelType resets all changes to the "channel_type" field.
func (m *ChannelOverrideTemplateMutation) ResetChannelType() {
	m.channel_type = nil
}

// SetOverrideParameters sets the "override_parameters" field.
func (m *ChannelOverrideTemplateMutation) SetOverrideParameters(s string) {
	m.override_parameters = &s
}

// OverrideParameters returns the value of the "override_parameters" field in the mutation.
func (m *ChannelOverrideTemplateMutation) OverrideParameters() (r string, exists bool) {
	v := m.override_parameters
	if v == nil {
		return
	}
	return *v, true
}

// OldOverrideParameters returns the old "override_parameters" field's value of the ChannelOverrideTemplate entity.
// If the ChannelOverrideTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelOverrideTemplateMutation) OldOverrideParameters(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOverrideParameters is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOverrideParameters requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOverrideParameters: %w", err)
	}
	return oldValue.OverrideParameters, nil
}

// ResetOverrideParameters resets all changes to the "override_parameters" field.
func (m *ChannelOverrideTemplateMutation) ResetOverrideParameters() {
	m.override_parameters = nil
}

// SetOverrideHeaders sets the "override_headers" field.
func (m *ChannelOverrideTemplateMutation) SetOverrideHeaders(oe []objects.HeaderEntry) {
	m.override_headers = &oe
	m.appendoverride_headers = nil
}

// OverrideHeaders returns the value of the "override_headers" field in the mutation.
func (m *ChannelOverrideTemplateMutation) OverrideHeaders() (r []objects.HeaderEntry, exists bool) {
	v := m.override_headers
	if v == nil {
		return
	}
	return *v, true
}

// OldOverrideHeaders returns the old "override_headers" field's value of the ChannelOverrideTemplate entity.
// If the ChannelOverrideTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelOverrideTemplateMutation) OldOverrideHeaders(ctx context.Context) (v []objects.HeaderEntry, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOverrideHeaders is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOverrideHeaders requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOverrideHeaders: %w", err)
	}
	return oldValue.OverrideHeaders, nil
}

// AppendOverrideHeaders adds oe to the "override_headers" field.
func (m *ChannelOverrideTemplateMutation) AppendOverrideHeaders(oe []objects.HeaderEntry) {
	m.appendoverride_headers = append(m.appendoverride_headers, oe...)
}

// AppendedOverrideHeaders returns the list of values that were appended to the "override_headers" field in this mutation.
func (m *ChannelOverrideTemplateMutation) AppendedOverrideHeaders() ([]objects.HeaderEntry, bool) {
	if len(m.appendoverride_headers) == 0 {
		return nil, false
	}
	return m.appendoverride_headers, true
}

// ResetOverrideHeaders resets all changes to the "override_headers" field.
func (m *ChannelOverrideTemplateMutation) ResetOverrideHeaders() {
	m.override_headers = nil
	m.appendoverride_headers = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *ChannelOverrideTemplateMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[channeloverridetemplate.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ChannelOverrideTemplateMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ChannelOverrideTemplateMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ChannelOverrideTemplateMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the ChannelOverrideTemplateMutation builder.
func (m *ChannelOverrideTemplateMutation) Where(ps ...predicate.ChannelOverrideTemplate) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ChannelOverrideTemplateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ChannelOverrideTemplateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ChannelOverrideTemplate, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ChannelOverrideTemplateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ChannelOverrideTemplateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ChannelOverrideTemplate).
func (m *ChannelOverrideTemplateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChannelOverrideTemplateMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, channeloverridetemplate.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, channeloverridetemplate.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, channeloverridetemplate.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, channeloverridetemplate.FieldUserID)
	}
	if m.name != nil {
		fields = append(fields, channeloverridetemplate.FieldName)
	}
	if m.description != nil {
		fields = append(fields, channeloverridetemplate.FieldDescription)
	}
	if m.channel_type != nil {
		fields = append(fields, channeloverridetemplate.FieldChannelType)
	}
	if m.override_parameters != nil {
		fields = append(fields, channeloverridetemplate.FieldOverrideParameters)
	}
	if m.override_headers != nil {
		fields = append(fields, channeloverridetemplate.FieldOverrideHeaders)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChannelOverrideTemplateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case channeloverridetemplate.FieldCreatedAt:
		return m.CreatedAt()
	case channeloverridetemplate.FieldUpdatedAt:
		return m.UpdatedAt()
	case channeloverridetemplate.FieldDeletedAt:
		return m.DeletedAt()
	case channeloverridetemplate.FieldUserID:
		return m.UserID()
	case channeloverridetemplate.FieldName:
		return m.Name()
	case channeloverridetemplate.FieldDescription:
		return m.Description()
	case channeloverridetemplate.FieldChannelType:
		return m.ChannelType()
	case channeloverridetemplate.FieldOverrideParameters:
		return m.OverrideParameters()
	case channeloverridetemplate.FieldOverrideHeaders:
		return m.OverrideHeaders()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChannelOverrideTemplateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case channeloverridetemplate.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case channeloverridetemplate.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case channeloverridetemplate.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case channeloverridetemplate.FieldUserID:
		return m.OldUserID(ctx)
	case channeloverridetemplate.FieldName:
		return m.OldName(ctx)
	case channeloverridetemplate.FieldDescription:
		return m.OldDescription(ctx)
	case channeloverridetemplate.FieldChannelType:
		return m.OldChannelType(ctx)
	case channeloverridetemplate.FieldOverrideParameters:
		return m.OldOverrideParameters(ctx)
	case channeloverridetemplate.FieldOverrideHeaders:
		return m.OldOverrideHeaders(ctx)
	}
	return nil, fmt.Errorf("unknown ChannelOverrideTemplate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChannelOverrideTemplateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case channeloverridetemplate.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case channeloverridetemplate.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case channeloverridetemplate.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case channeloverridetemplate.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case channeloverridetemplate.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case channeloverridetemplate.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case channeloverridetemplate.FieldChannelType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelType(v)
		return nil
	case channeloverridetemplate.FieldOverrideParameters:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOverrideParameters(v)
		return nil
	case channeloverridetemplate.FieldOverrideHeaders:
		v, ok := value.([]objects.HeaderEntry)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOverrideHeaders(v)
		return nil
	}
	return fmt.Errorf("unknown ChannelOverrideTemplate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChannelOverrideTemplateMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, channeloverridetemplate.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChannelOverrideTemplateMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case channeloverridetemplate.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChannelOverrideTemplateMutation) AddField(name string, value ent.Value) error {
	switch name {
	case channeloverridetemplate.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ChannelOverrideTemplate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChannelOverrideTemplateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(channeloverridetemplate.FieldDescription) {
		fields = append(fields, channeloverridetemplate.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChannelOverrideTemplateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChannelOverrideTemplateMutation) ClearField(name string) error {
	switch name {
	case channeloverridetemplate.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown ChannelOverrideTemplate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChannelOverrideTemplateMutation) ResetField(name string) error {
	switch name {
	case channeloverridetemplate.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case channeloverridetemplate.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case channeloverridetemplate.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case channeloverridetemplate.FieldUserID:
		m.ResetUserID()
		return nil
	case channeloverridetemplate.FieldName:
		m.ResetName()
		return nil
	case channeloverridetemplate.FieldDescription:
		m.ResetDescription()
		return nil
	case channeloverridetemplate.FieldChannelType:
		m.ResetChannelType()
		return nil
	case channeloverridetemplate.FieldOverrideParameters:
		m.ResetOverrideParameters()
		return nil
	case channeloverridetemplate.FieldOverrideHeaders:
		m.ResetOverrideHeaders()
		return nil
	}
	return fmt.Errorf("unknown ChannelOverrideTemplate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChannelOverrideTemplateMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, channeloverridetemplate.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChannelOverrideTemplateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case channeloverridetemplate.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChannelOverrideTemplateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChannelOverrideTemplateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChannelOverrideTemplateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, channeloverridetemplate.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChannelOverrideTemplateMutation) EdgeCleared(name string) bool {
	switch name {
	case channeloverridetemplate.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChannelOverrideTemplateMutation) ClearEdge(name string) error {
	switch name {
	case channeloverridetemplate.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown ChannelOverrideTemplate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChannelOverrideTemplateMutation) ResetEdge(name string) error {
	switch name {
	case channeloverridetemplate.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown ChannelOverrideTemplate edge %s", name)
}

// ChannelProbeMutation represents an operation that mutates the ChannelProbe nodes in the graph.
type ChannelProbeMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int
	total_request_count           *int
	addtotal_request_count        *int
	success_request_count         *int
	addsuccess_request_count      *int
	avg_tokens_per_second         *float64
	addavg_tokens_per_second      *float64
	avg_time_to_first_token_ms    *float64
	addavg_time_to_first_token_ms *float64
	timestamp                     *int64
	addtimestamp                  *int64
	clearedFields                 map[string]struct{}
	channel                       *int
	clearedchannel                bool
	done                          bool
	oldValue                      func(context.Context) (*ChannelProbe, error)
	predicates                    []predicate.ChannelProbe
}

var _ ent.Mutation = (*ChannelProbeMutation)(nil)

// channelprobeOption allows management of the mutation configuration using functional options.
type channelprobeOption func(*ChannelProbeMutation)

// newChannelProbeMutation creates new mutation for the ChannelProbe entity.
func newChannelProbeMutation(c config, op Op, opts ...channelprobeOption) *ChannelProbeMutation {
	m := &ChannelProbeMutation{
		config:        c,
		op:            op,
		typ:           TypeChannelProbe,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChannelProbeID sets the ID field of the mutation.
func withChannelProbeID(id int) channelprobeOption {
	return func(m *ChannelProbeMutation) {
		var (
			err   error
			once  sync.Once
			value *ChannelProbe
		)
		m.oldValue = func(ctx context.Context) (*ChannelProbe, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ChannelProbe.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChannelProbe sets the old ChannelProbe of the mutation.
func withChannelProbe(node *ChannelProbe) channelprobeOption {
	return func(m *ChannelProbeMutation) {
		m.oldValue = func(context.Context) (*ChannelProbe, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChannelProbeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChannelProbeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChannelProbeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChannelProbeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ChannelProbe.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetChannelID sets the "channel_id" field.
func (m *ChannelProbeMutation) SetChannelID(i int) {
	m.channel = &i
}

// ChannelID returns the value of the "channel_id" field in the mutation.
func (m *ChannelProbeMutation) ChannelID() (r int, exists bool) {
	v := m.channel
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelID returns the old "channel_id" field's value of the ChannelProbe entity.
// If the ChannelProbe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelProbeMutation) OldChannelID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelID: %w", err)
	}
	return oldValue.ChannelID, nil
}

// ResetChannelID resets all changes to the "channel_id" field.
func (m *ChannelProbeMutation) ResetChannelID() {
	m.channel = nil
}

// SetTotalRequestCount sets the "total_request_count" field.
func (m *ChannelProbeMutation) SetTotalRequestCount(i int) {
	m.total_request_count = &i
	m.addtotal_request_count = nil
}

// TotalRequestCount returns the value of the "total_request_count" field in the mutation.
func (m *ChannelProbeMutation) TotalRequestCount() (r int, exists bool) {
	v := m.total_request_count
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalRequestCount returns the old "total_request_count" field's value of the ChannelProbe entity.
// If the ChannelProbe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelProbeMutation) OldTotalRequestCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalRequestCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalRequestCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalRequestCount: %w", err)
	}
	return oldValue.TotalRequestCount, nil
}

// AddTotalRequestCount adds i to the "total_request_count" field.
func (m *ChannelProbeMutation) AddTotalRequestCount(i int) {
	if m.addtotal_request_count != nil {
		*m.addtotal_request_count += i
	} else {
		m.addtotal_request_count = &i
	}
}

// AddedTotalRequestCount returns the value that was added to the "total_request_count" field in this mutation.
func (m *ChannelProbeMutation) AddedTotalRequestCount() (r int, exists bool) {
	v := m.addtotal_request_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalRequestCount resets all changes to the "total_request_count" field.
func (m *ChannelProbeMutation) ResetTotalRequestCount() {
	m.total_request_count = nil
	m.addtotal_request_count = nil
}

// SetSuccessRequestCount sets the "success_request_count" field.
func (m *ChannelProbeMutation) SetSuccessRequestCount(i int) {
	m.success_request_count = &i
	m.addsuccess_request_count = nil
}

// SuccessRequestCount returns the value of the "success_request_count" field in the mutation.
func (m *ChannelProbeMutation) SuccessRequestCount() (r int, exists bool) {
	v := m.success_request_count
	if v == nil {
		return
	}
	return *v, true
}

// OldSuccessRequestCount returns the old "success_request_count" field's value of the ChannelProbe entity.
// If the ChannelProbe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelProbeMutation) OldSuccessRequestCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuccessRequestCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuccessRequestCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuccessRequestCount: %w", err)
	}
	return oldValue.SuccessRequestCount, nil
}

// AddSuccessRequestCount adds i to the "success_request_count" field.
func (m *ChannelProbeMutation) AddSuccessRequestCount(i int) {
	if m.addsuccess_request_count != nil {
		*m.addsuccess_request_count += i
	} else {
		m.addsuccess_request_count = &i
	}
}

// AddedSuccessRequestCount returns the value that was added to the "success_request_count" field in this mutation.
func (m *ChannelProbeMutation) AddedSuccessRequestCount() (r int, exists bool) {
	v := m.addsuccess_request_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetSuccessRequestCount resets all changes to the "success_request_count" field.
func (m *ChannelProbeMutation) ResetSuccessRequestCount() {
	m.success_request_count = nil
	m.addsuccess_request_count = nil
}

// SetAvgTokensPerSecond sets the "avg_tokens_per_second" field.
func (m *ChannelProbeMutation) SetAvgTokensPerSecond(f float64) {
	m.avg_tokens_per_second = &f
	m.addavg_tokens_per_second = nil
}

// AvgTokensPerSecond returns the value of the "avg_tokens_per_second" field in the mutation.
func (m *ChannelProbeMutation) AvgTokensPerSecond() (r float64, exists bool) {
	v := m.avg_tokens_per_second
	if v == nil {
		return
	}
	return *v, true
}

// OldAvgTokensPerSecond returns the old "avg_tokens_per_second" field's value of the ChannelProbe entity.
// If the ChannelProbe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelProbeMutation) OldAvgTokensPerSecond(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvgTokensPerSecond is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvgTokensPerSecond requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvgTokensPerSecond: %w", err)
	}
	return oldValue.AvgTokensPerSecond, nil
}

// AddAvgTokensPerSecond adds f to the "avg_tokens_per_second" field.
func (m *ChannelProbeMutation) AddAvgTokensPerSecond(f float64) {
	if m.addavg_tokens_per_second != nil {
		*m.addavg_tokens_per_second += f
	} else {
		m.addavg_tokens_per_second = &f
	}
}

// AddedAvgTokensPerSecond returns the value that was added to the "avg_tokens_per_second" field in this mutation.
func (m *ChannelProbeMutation) AddedAvgTokensPerSecond() (r float64, exists bool) {
	v := m.addavg_tokens_per_second
	if v == nil {
		return
	}
	return *v, true
}

// ClearAvgTokensPerSecond clears the value of the "avg_tokens_per_second" field.
func (m *ChannelProbeMutation) ClearAvgTokensPerSecond() {
	m.avg_tokens_per_second = nil
	m.addavg_tokens_per_second = nil
	m.clearedFields[channelprobe.FieldAvgTokensPerSecond] = struct{}{}
}

// AvgTokensPerSecondCleared returns if the "avg_tokens_per_second" field was cleared in this mutation.
func (m *ChannelProbeMutation) AvgTokensPerSecondCleared() bool {
	_, ok := m.clearedFields[channelprobe.FieldAvgTokensPerSecond]
	return ok
}

// ResetAvgTokensPerSecond resets all changes to the "avg_tokens_per_second" field.
func (m *ChannelProbeMutation) ResetAvgTokensPerSecond() {
	m.avg_tokens_per_second = nil
	m.addavg_tokens_per_second = nil
	delete(m.clearedFields, channelprobe.FieldAvgTokensPerSecond)
}

// SetAvgTimeToFirstTokenMs sets the "avg_time_to_first_token_ms" field.
func (m *ChannelProbeMutation) SetAvgTimeToFirstTokenMs(f float64) {
	m.avg_time_to_first_token_ms = &f
	m.addavg_time_to_first_token_ms = nil
}

// AvgTimeToFirstTokenMs returns the value of the "avg_time_to_first_token_ms" field in the mutation.
func (m *ChannelProbeMutation) AvgTimeToFirstTokenMs() (r float64, exists bool) {
	v := m.avg_time_to_first_token_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldAvgTimeToFirstTokenMs returns the old "avg_time_to_first_token_ms" field's value of the ChannelProbe entity.
// If the ChannelProbe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelProbeMutation) OldAvgTimeToFirstTokenMs(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvgTimeToFirstTokenMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvgTimeToFirstTokenMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvgTimeToFirstTokenMs: %w", err)
	}
	return oldValue.AvgTimeToFirstTokenMs, nil
}

// AddAvgTimeToFirstTokenMs adds f to the "avg_time_to_first_token_ms" field.
func (m *ChannelProbeMutation) AddAvgTimeToFirstTokenMs(f float64) {
	if m.addavg_time_to_first_token_ms != nil {
		*m.addavg_time_to_first_token_ms += f
	} else {
		m.addavg_time_to_first_token_ms = &f
	}
}

// AddedAvgTimeToFirstTokenMs returns the value that was added to the "avg_time_to_first_token_ms" field in this mutation.
func (m *ChannelProbeMutation) AddedAvgTimeToFirstTokenMs() (r float64, exists bool) {
	v := m.addavg_time_to_first_token_ms
	if v == nil {
		return
	}
	return *v, true
}

// ClearAvgTimeToFirstTokenMs clears the value of the "avg_time_to_first_token_ms" field.
func (m *ChannelProbeMutation) ClearAvgTimeToFirstTokenMs() {
	m.avg_time_to_first_token_ms = nil
	m.addavg_time_to_first_token_ms = nil
	m.clearedFields[channelprobe.FieldAvgTimeToFirstTokenMs] = struct{}{}
}

// AvgTimeToFirstTokenMsCleared returns if the "avg_time_to_first_token_ms" field was cleared in this mutation.
func (m *ChannelProbeMutation) AvgTimeToFirstTokenMsCleared() bool {
	_, ok := m.clearedFields[channelprobe.FieldAvgTimeToFirstTokenMs]
	return ok
}

// ResetAvgTimeToFirstTokenMs resets all changes to the "avg_time_to_first_token_ms" field.
func (m *ChannelProbeMutation) ResetAvgTimeToFirstTokenMs() {
	m.avg_time_to_first_token_ms = nil
	m.addavg_time_to_first_token_ms = nil
	delete(m.clearedFields, channelprobe.FieldAvgTimeToFirstTokenMs)
}

// SetTimestamp sets the "timestamp" field.
func (m *ChannelProbeMutation) SetTimestamp(i int64) {
	m.timestamp = &i
	m.addtimestamp = nil
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *ChannelProbeMutation) Timestamp() (r int64, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the ChannelProbe entity.
// If the ChannelProbe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelProbeMutation) OldTimestamp(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// AddTimestamp adds i to the "timestamp" field.
func (m *ChannelProbeMutation) AddTimestamp(i int64) {
	if m.addtimestamp != nil {
		*m.addtimestamp += i
	} else {
		m.addtimestamp = &i
	}
}

// AddedTimestamp returns the value that was added to the "timestamp" field in this mutation.
func (m *ChannelProbeMutation) AddedTimestamp() (r int64, exists bool) {
	v := m.addtimestamp
	if v == nil {
		return
	}
	return *v, true
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *ChannelProbeMutation) ResetTimestamp() {
	m.timestamp = nil
	m.addtimestamp = nil
}

// ClearChannel clears the "channel" edge to the Channel entity.
func (m *ChannelProbeMutation) ClearChannel() {
	m.clearedchannel = true
	m.clearedFields[channelprobe.FieldChannelID] = struct{}{}
}

// ChannelCleared reports if the "channel" edge to the Channel entity was cleared.
func (m *ChannelProbeMutation) ChannelCleared() bool {
	return m.clearedchannel
}

// ChannelIDs returns the "channel" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChannelID instead. It exists only for internal usage by the builders.
func (m *ChannelProbeMutation) ChannelIDs() (ids []int) {
	if id := m.channel; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChannel resets all changes to the "channel" edge.
func (m *ChannelProbeMutation) ResetChannel() {
	m.channel = nil
	m.clearedchannel = false
}

// Where appends a list predicates to the ChannelProbeMutation builder.
func (m *ChannelProbeMutation) Where(ps ...predicate.ChannelProbe) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ChannelProbeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ChannelProbeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ChannelProbe, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ChannelProbeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ChannelProbeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ChannelProbe).
func (m *ChannelProbeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChannelProbeMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.channel != nil {
		fields = append(fields, channelprobe.FieldChannelID)
	}
	if m.total_request_count != nil {
		fields = append(fields, channelprobe.FieldTotalRequestCount)
	}
	if m.success_request_count != nil {
		fields = append(fields, channelprobe.FieldSuccessRequestCount)
	}
	if m.avg_tokens_per_second != nil {
		fields = append(fields, channelprobe.FieldAvgTokensPerSecond)
	}
	if m.avg_time_to_first_token_ms != nil {
		fields = append(fields, channelprobe.FieldAvgTimeToFirstTokenMs)
	}
	if m.timestamp != nil {
		fields = append(fields, channelprobe.FieldTimestamp)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChannelProbeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case channelprobe.FieldChannelID:
		return m.ChannelID()
	case channelprobe.FieldTotalRequestCount:
		return m.TotalRequestCount()
	case channelprobe.FieldSuccessRequestCount:
		return m.SuccessRequestCount()
	case channelprobe.FieldAvgTokensPerSecond:
		return m.AvgTokensPerSecond()
	case channelprobe.FieldAvgTimeToFirstTokenMs:
		return m.AvgTimeToFirstTokenMs()
	case channelprobe.FieldTimestamp:
		return m.Timestamp()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChannelProbeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case channelprobe.FieldChannelID:
		return m.OldChannelID(ctx)
	case channelprobe.FieldTotalRequestCount:
		return m.OldTotalRequestCount(ctx)
	case channelprobe.FieldSuccessRequestCount:
		return m.OldSuccessRequestCount(ctx)
	case channelprobe.FieldAvgTokensPerSecond:
		return m.OldAvgTokensPerSecond(ctx)
	case channelprobe.FieldAvgTimeToFirstTokenMs:
		return m.OldAvgTimeToFirstTokenMs(ctx)
	case channelprobe.FieldTimestamp:
		return m.OldTimestamp(ctx)
	}
	return nil, fmt.Errorf("unknown ChannelProbe field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChannelProbeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case channelprobe.FieldChannelID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelID(v)
		return nil
	case channelprobe.FieldTotalRequestCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalRequestCount(v)
		return nil
	case channelprobe.FieldSuccessRequestCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuccessRequestCount(v)
		return nil
	case channelprobe.FieldAvgTokensPerSecond:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvgTokensPerSecond(v)
		return nil
	case channelprobe.FieldAvgTimeToFirstTokenMs:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvgTimeToFirstTokenMs(v)
		return nil
	case channelprobe.FieldTimestamp:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	}
	return fmt.Errorf("unknown ChannelProbe field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChannelProbeMutation) AddedFields() []string {
	var fields []string
	if m.addtotal_request_count != nil {
		fields = append(fields, channelprobe.FieldTotalRequestCount)
	}
	if m.addsuccess_request_count != nil {
		fields = append(fields, channelprobe.FieldSuccessRequestCount)
	}
	if m.addavg_tokens_per_second != nil {
		fields = append(fields, channelprobe.FieldAvgTokensPerSecond)
	}
	if m.addavg_time_to_first_token_ms != nil {
		fields = append(fields, channelprobe.FieldAvgTimeToFirstTokenMs)
	}
	if m.addtimestamp != nil {
		fields = append(fields, channelprobe.FieldTimestamp)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChannelProbeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case channelprobe.FieldTotalRequestCount:
		return m.AddedTotalRequestCount()
	case channelprobe.FieldSuccessRequestCount:
		return m.AddedSuccessRequestCount()
	case channelprobe.FieldAvgTokensPerSecond:
		return m.AddedAvgTokensPerSecond()
	case channelprobe.FieldAvgTimeToFirstTokenMs:
		return m.AddedAvgTimeToFirstTokenMs()
	case channelprobe.FieldTimestamp:
		return m.AddedTimestamp()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChannelProbeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case channelprobe.FieldTotalRequestCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalRequestCount(v)
		return nil
	case channelprobe.FieldSuccessRequestCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSuccessRequestCount(v)
		return nil
	case channelprobe.FieldAvgTokensPerSecond:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAvgTokensPerSecond(v)
		return nil
	case channelprobe.FieldAvgTimeToFirstTokenMs:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAvgTimeToFirstTokenMs(v)
		return nil
	case channelprobe.FieldTimestamp:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimestamp(v)
		return nil
	}
	return fmt.Errorf("unknown ChannelProbe numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChannelProbeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(channelprobe.FieldAvgTokensPerSecond) {
		fields = append(fields, channelprobe.FieldAvgTokensPerSecond)
	}
	if m.FieldCleared(channelprobe.FieldAvgTimeToFirstTokenMs) {
		fields = append(fields, channelprobe.FieldAvgTimeToFirstTokenMs)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChannelProbeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChannelProbeMutation) ClearField(name string) error {
	switch name {
	case channelprobe.FieldAvgTokensPerSecond:
		m.ClearAvgTokensPerSecond()
		return nil
	case channelprobe.FieldAvgTimeToFirstTokenMs:
		m.ClearAvgTimeToFirstTokenMs()
		return nil
	}
	return fmt.Errorf("unknown ChannelProbe nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChannelProbeMutation) ResetField(name string) error {
	switch name {
	case channelprobe.FieldChannelID:
		m.ResetChannelID()
		return nil
	case channelprobe.FieldTotalRequestCount:
		m.ResetTotalRequestCount()
		return nil
	case channelprobe.FieldSuccessRequestCount:
		m.ResetSuccessRequestCount()
		return nil
	case channelprobe.FieldAvgTokensPerSecond:
		m.ResetAvgTokensPerSecond()
		return nil
	case channelprobe.FieldAvgTimeToFirstTokenMs:
		m.ResetAvgTimeToFirstTokenMs()
		return nil
	case channelprobe.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	}
	return fmt.Errorf("unknown ChannelProbe field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChannelProbeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.channel != nil {
		edges = append(edges, channelprobe.EdgeChannel)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChannelProbeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case channelprobe.EdgeChannel:
		if id := m.channel; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChannelProbeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChannelProbeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChannelProbeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedchannel {
		edges = append(edges, channelprobe.EdgeChannel)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChannelProbeMutation) EdgeCleared(name string) bool {
	switch name {
	case channelprobe.EdgeChannel:
		return m.clearedchannel
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChannelProbeMutation) ClearEdge(name string) error {
	switch name {
	case channelprobe.EdgeChannel:
		m.ClearChannel()
		return nil
	}
	return fmt.Errorf("unknown ChannelProbe unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChannelProbeMutation) ResetEdge(name string) error {
	switch name {
	case channelprobe.EdgeChannel:
		m.ResetChannel()
		return nil
	}
	return fmt.Errorf("unknown ChannelProbe edge %s", name)
}

// DataStorageMutation represents an operation that mutates the DataStorage nodes in the graph.
type DataStorageMutation struct {
	config
	op                Op
	typ               string
	id                *int
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *int
	adddeleted_at     *int
	name              *string
	description       *string
	primary           *bool
	_type             *datastorage.Type
	settings          **objects.DataStorageSettings
	status            *datastorage.Status
	clearedFields     map[string]struct{}
	requests          map[int]struct{}
	removedrequests   map[int]struct{}
	clearedrequests   bool
	executions        map[int]struct{}
	removedexecutions map[int]struct{}
	clearedexecutions bool
	done              bool
	oldValue          func(context.Context) (*DataStorage, error)
	predicates        []predicate.DataStorage
}

var _ ent.Mutation = (*DataStorageMutation)(nil)

// datastorageOption allows management of the mutation configuration using functional options.
type datastorageOption func(*DataStorageMutation)

// newDataStorageMutation creates new mutation for the DataStorage entity.
func newDataStorageMutation(c config, op Op, opts ...datastorageOption) *DataStorageMutation {
	m := &DataStorageMutation{
		config:        c,
		op:            op,
		typ:           TypeDataStorage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDataStorageID sets the ID field of the mutation.
func withDataStorageID(id int) datastorageOption {
	return func(m *DataStorageMutation) {
		var (
			err   error
			once  sync.Once
			value *DataStorage
		)
		m.oldValue = func(ctx context.Context) (*DataStorage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DataStorage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDataStorage sets the old DataStorage of the mutation.
func withDataStorage(node *DataStorage) datastorageOption {
	return func(m *DataStorageMutation) {
		m.oldValue = func(context.Context) (*DataStorage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DataStorageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DataStorageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DataStorageMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DataStorageMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DataStorage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DataStorageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DataStorageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DataStorage entity.
// If the DataStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataStorageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DataStorageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DataStorageMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DataStorageMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DataStorage entity.
// If the DataStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataStorageMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DataStorageMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *DataStorageMutation) SetDeletedAt(i int) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *DataStorageMutation) DeletedAt() (r int, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the DataStorage entity.
// If the DataStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataStorageMutation) OldDeletedAt(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *DataStorageMutation) AddDeletedAt(i int) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *DataStorageMutation) AddedDeletedAt() (r int, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *DataStorageMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetName sets the "name" field.
func (m *DataStorageMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DataStorageMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the DataStorage entity.
// If the DataStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataStorageMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DataStorageMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *DataStorageMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *DataStorageMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the DataStorage entity.
// If the DataStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataStorageMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *DataStorageMutation) ResetDescription() {
	m.description = nil
}

// SetPrimary sets the "primary" field.
func (m *DataStorageMutation) SetPrimary(b bool) {
	m.primary = &b
}

// Primary returns the value of the "primary" field in the mutation.
func (m *DataStorageMutation) Primary() (r bool, exists bool) {
	v := m.primary
	if v == nil {
		return
	}
	return *v, true
}

// OldPrimary returns the old "primary" field's value of the DataStorage entity.
// If the DataStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataStorageMutation) OldPrimary(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrimary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrimary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrimary: %w", err)
	}
	return oldValue.Primary, nil
}

// ResetPrimary resets all changes to the "primary" field.
func (m *DataStorageMutation) ResetPrimary() {
	m.primary = nil
}

// SetType sets the "type" field.
func (m *DataStorageMutation) SetType(d datastorage.Type) {
	m._type = &d
}

// GetType returns the value of the "type" field in the mutation.
func (m *DataStorageMutation) GetType() (r datastorage.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the DataStorage entity.
// If the DataStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataStorageMutation) OldType(ctx context.Context) (v datastorage.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *DataStorageMutation) ResetType() {
	m._type = nil
}

// SetSettings sets the "settings" field.
func (m *DataStorageMutation) SetSettings(oss *objects.DataStorageSettings) {
	m.settings = &oss
}

// Settings returns the value of the "settings" field in the mutation.
func (m *DataStorageMutation) Settings() (r *objects.DataStorageSettings, exists bool) {
	v := m.settings
	if v == nil {
		return
	}
	return *v, true
}

// OldSettings returns the old "settings" field's value of the DataStorage entity.
// If the DataStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataStorageMutation) OldSettings(ctx context.Context) (v *objects.DataStorageSettings, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettings: %w", err)
	}
	return oldValue.Settings, nil
}

// ResetSettings resets all changes to the "settings" field.
func (m *DataStorageMutation) ResetSettings() {
	m.settings = nil
}

// SetStatus sets the "status" field.
func (m *DataStorageMutation) SetStatus(d datastorage.Status) {
	m.status = &d
}

// Status returns the value of the "status" field in the mutation.
func (m *DataStorageMutation) Status() (r datastorage.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the DataStorage entity.
// If the DataStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataStorageMutation) OldStatus(ctx context.Context) (v datastorage.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *DataStorageMutation) ResetStatus() {
	m.status = nil
}

// AddRequestIDs adds the "requests" edge to the Request entity by ids.
func (m *DataStorageMutation) AddRequestIDs(ids ...int) {
	if m.requests == nil {
		m.requests = make(map[int]struct{})
	}
	for i := range ids {
		m.requests[ids[i]] = struct{}{}
	}
}

// ClearRequests clears the "requests" edge to the Request entity.
func (m *DataStorageMutation) ClearRequests() {
	m.clearedrequests = true
}

// RequestsCleared reports if the "requests" edge to the Request entity was cleared.
func (m *DataStorageMutation) RequestsCleared() bool {
	return m.clearedrequests
}

// RemoveRequestIDs removes the "requests" edge to the Request entity by IDs.
func (m *DataStorageMutation) RemoveRequestIDs(ids ...int) {
	if m.removedrequests == nil {
		m.removedrequests = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.requests, ids[i])
		m.removedrequests[ids[i]] = struct{}{}
	}
}

// RemovedRequests returns the removed IDs of the "requests" edge to the Request entity.
func (m *DataStorageMutation) RemovedRequestsIDs() (ids []int) {
	for id := range m.removedrequests {
		ids = append(ids, id)
	}
	return
}

// RequestsIDs returns the "requests" edge IDs in the mutation.
func (m *DataStorageMutation) RequestsIDs() (ids []int) {
	for id := range m.requests {
		ids = append(ids, id)
	}
	return
}

// ResetRequests resets all changes to the "requests" edge.
func (m *DataStorageMutation) ResetRequests() {
	m.requests = nil
	m.clearedrequests = false
	m.removedrequests = nil
}

// AddExecutionIDs adds the "executions" edge to the RequestExecution entity by ids.
func (m *DataStorageMutation) AddExecutionIDs(ids ...int) {
	if m.executions == nil {
		m.executions = make(map[int]struct{})
	}
	for i := range ids {
		m.executions[ids[i]] = struct{}{}
	}
}

// ClearExecutions clears the "executions" edge to the RequestExecution entity.
func (m *DataStorageMutation) ClearExecutions() {
	m.clearedexecutions = true
}

// ExecutionsCleared reports if the "executions" edge to the RequestExecution entity was cleared.
func (m *DataStorageMutation) ExecutionsCleared() bool {
	return m.clearedexecutions
}

// RemoveExecutionIDs removes the "executions" edge to the RequestExecution entity by IDs.
func (m *DataStorageMutation) RemoveExecutionIDs(ids ...int) {
	if m.removedexecutions == nil {
		m.removedexecutions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.executions, ids[i])
		m.removedexecutions[ids[i]] = struct{}{}
	}
}

// RemovedExecutions returns the removed IDs of the "executions" edge to the RequestExecution entity.
func (m *DataStorageMutation) RemovedExecutionsIDs() (ids []int) {
	for id := range m.removedexecutions {
		ids = append(ids, id)
	}
	return
}

// ExecutionsIDs returns the "executions" edge IDs in the mutation.
func (m *DataStorageMutation) ExecutionsIDs() (ids []int) {
	for id := range m.executions {
		ids = append(ids, id)
	}
	return
}

// ResetExecutions resets all changes to the "executions" edge.
func (m *DataStorageMutation) ResetExecutions() {
	m.executions = nil
	m.clearedexecutions = false
	m.removedexecutions = nil
}

// Where appends a list predicates to the DataStorageMutation builder.
func (m *DataStorageMutation) Where(ps ...predicate.DataStorage) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DataStorageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DataStorageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DataStorage, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DataStorageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DataStorageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DataStorage).
func (m *DataStorageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DataStorageMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, datastorage.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, datastorage.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, datastorage.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, datastorage.FieldName)
	}
	if m.description != nil {
		fields = append(fields, datastorage.FieldDescription)
	}
	if m.primary != nil {
		fields = append(fields, datastorage.FieldPrimary)
	}
	if m._type != nil {
		fields = append(fields, datastorage.FieldType)
	}
	if m.settings != nil {
		fields = append(fields, datastorage.FieldSettings)
	}
	if m.status != nil {
		fields = append(fields, datastorage.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DataStorageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case datastorage.FieldCreatedAt:
		return m.CreatedAt()
	case datastorage.FieldUpdatedAt:
		return m.UpdatedAt()
	case datastorage.FieldDeletedAt:
		return m.DeletedAt()
	case datastorage.FieldName:
		return m.Name()
	case datastorage.FieldDescription:
		return m.Description()
	case datastorage.FieldPrimary:
		return m.Primary()
	case datastorage.FieldType:
		return m.GetType()
	case datastorage.FieldSettings:
		return m.Settings()
	case datastorage.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DataStorageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case datastorage.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case datastorage.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case datastorage.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case datastorage.FieldName:
		return m.OldName(ctx)
	case datastorage.FieldDescription:
		return m.OldDescription(ctx)
	case datastorage.FieldPrimary:
		return m.OldPrimary(ctx)
	case datastorage.FieldType:
		return m.OldType(ctx)
	case datastorage.FieldSettings:
		return m.OldSettings(ctx)
	case datastorage.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown DataStorage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DataStorageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case datastorage.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case datastorage.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case datastorage.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case datastorage.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case datastorage.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case datastorage.FieldPrimary:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrimary(v)
		return nil
	case datastorage.FieldType:
		v, ok := value.(datastorage.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case datastorage.FieldSettings:
		v, ok := value.(*objects.DataStorageSettings)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettings(v)
		return nil
	case datastorage.FieldStatus:
		v, ok := value.(datastorage.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown DataStorage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DataStorageMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, datastorage.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DataStorageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case datastorage.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DataStorageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case datastorage.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown DataStorage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DataStorageMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DataStorageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DataStorageMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DataStorage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DataStorageMutation) ResetField(name string) error {
	switch name {
	case datastorage.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case datastorage.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case datastorage.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case datastorage.FieldName:
		m.ResetName()
		return nil
	case datastorage.FieldDescription:
		m.ResetDescription()
		return nil
	case datastorage.FieldPrimary:
		m.ResetPrimary()
		return nil
	case datastorage.FieldType:
		m.ResetType()
		return nil
	case datastorage.FieldSettings:
		m.ResetSettings()
		return nil
	case datastorage.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown DataStorage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DataStorageMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.requests != nil {
		edges = append(edges, datastorage.EdgeRequests)
	}
	if m.executions != nil {
		edges = append(edges, datastorage.EdgeExecutions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DataStorageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case datastorage.EdgeRequests:
		ids := make([]ent.Value, 0, len(m.requests))
		for id := range m.requests {
			ids = append(ids, id)
		}
		return ids
	case datastorage.EdgeExecutions:
		ids := make([]ent.Value, 0, len(m.executions))
		for id := range m.executions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DataStorageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedrequests != nil {
		edges = append(edges, datastorage.EdgeRequests)
	}
	if m.removedexecutions != nil {
		edges = append(edges, datastorage.EdgeExecutions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DataStorageMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case datastorage.EdgeRequests:
		ids := make([]ent.Value, 0, len(m.removedrequests))
		for id := range m.removedrequests {
			ids = append(ids, id)
		}
		return ids
	case datastorage.EdgeExecutions:
		ids := make([]ent.Value, 0, len(m.removedexecutions))
		for id := range m.removedexecutions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DataStorageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedrequests {
		edges = append(edges, datastorage.EdgeRequests)
	}
	if m.clearedexecutions {
		edges = append(edges, datastorage.EdgeExecutions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DataStorageMutation) EdgeCleared(name string) bool {
	switch name {
	case datastorage.EdgeRequests:
		return m.clearedrequests
	case datastorage.EdgeExecutions:
		return m.clearedexecutions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DataStorageMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown DataStorage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DataStorageMutation) ResetEdge(name string) error {
	switch name {
	case datastorage.EdgeRequests:
		m.ResetRequests()
		return nil
	case datastorage.EdgeExecutions:
		m.ResetExecutions()
		return nil
	}
	return fmt.Errorf("unknown DataStorage edge %s", name)
}

// ModelMutation represents an operation that mutates the Model nodes in the graph.
type ModelMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *int
	adddeleted_at *int
	developer     *string
	model_id      *string
	_type         *model.Type
	name          *string
	icon          *string
	group         *string
	model_card    **objects.ModelCard
	settings      **objects.ModelSettings
	status        *model.Status
	remark        *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Model, error)
	predicates    []predicate.Model
}

var _ ent.Mutation = (*ModelMutation)(nil)

// modelOption allows management of the mutation configuration using functional options.
type modelOption func(*ModelMutation)

// newModelMutation creates new mutation for the Model entity.
func newModelMutation(c config, op Op, opts ...modelOption) *ModelMutation {
	m := &ModelMutation{
		config:        c,
		op:            op,
		typ:           TypeModel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withModelID sets the ID field of the mutation.
func withModelID(id int) modelOption {
	return func(m *ModelMutation) {
		var (
			err   error
			once  sync.Once
			value *Model
		)
		m.oldValue = func(ctx context.Context) (*Model, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Model.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withModel sets the old Model of the mutation.
func withModel(node *Model) modelOption {
	return func(m *ModelMutation) {
		m.oldValue = func(context.Context) (*Model, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ModelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ModelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ModelMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ModelMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Model.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ModelMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ModelMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ModelMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ModelMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ModelMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ModelMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ModelMutation) SetDeletedAt(i int) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ModelMutation) DeletedAt() (r int, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldDeletedAt(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *ModelMutation) AddDeletedAt(i int) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *ModelMutation) AddedDeletedAt() (r int, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ModelMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetDeveloper sets the "developer" field.
func (m *ModelMutation) SetDeveloper(s string) {
	m.developer = &s
}

// Developer returns the value of the "developer" field in the mutation.
func (m *ModelMutation) Developer() (r string, exists bool) {
	v := m.developer
	if v == nil {
		return
	}
	return *v, true
}

// OldDeveloper returns the old "developer" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldDeveloper(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeveloper is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeveloper requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeveloper: %w", err)
	}
	return oldValue.Developer, nil
}

// ResetDeveloper resets all changes to the "developer" field.
func (m *ModelMutation) ResetDeveloper() {
	m.developer = nil
}

// SetModelID sets the "model_id" field.
func (m *ModelMutation) SetModelID(s string) {
	m.model_id = &s
}

// ModelID returns the value of the "model_id" field in the mutation.
func (m *ModelMutation) ModelID() (r string, exists bool) {
	v := m.model_id
	if v == nil {
		return
	}
	return *v, true
}

// OldModelID returns the old "model_id" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldModelID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModelID: %w", err)
	}
	return oldValue.ModelID, nil
}

// ResetModelID resets all changes to the "model_id" field.
func (m *ModelMutation) ResetModelID() {
	m.model_id = nil
}

// SetType sets the "type" field.
func (m *ModelMutation) SetType(value model.Type) {
	m._type = &value
}

// GetType returns the value of the "type" field in the mutation.
func (m *ModelMutation) GetType() (r model.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldType(ctx context.Context) (v model.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ModelMutation) ResetType() {
	m._type = nil
}

// SetName sets the "name" field.
func (m *ModelMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ModelMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ModelMutation) ResetName() {
	m.name = nil
}

// SetIcon sets the "icon" field.
func (m *ModelMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *ModelMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldIcon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ResetIcon resets all changes to the "icon" field.
func (m *ModelMutation) ResetIcon() {
	m.icon = nil
}

// SetGroup sets the "group" field.
func (m *ModelMutation) SetGroup(s string) {
	m.group = &s
}

// Group returns the value of the "group" field in the mutation.
func (m *ModelMutation) Group() (r string, exists bool) {
	v := m.group
	if v == nil {
		return
	}
	return *v, true
}

// OldGroup returns the old "group" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldGroup(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroup is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroup requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroup: %w", err)
	}
	return oldValue.Group, nil
}

// ResetGroup resets all changes to the "group" field.
func (m *ModelMutation) ResetGroup() {
	m.group = nil
}

// SetModelCard sets the "model_card" field.
func (m *ModelMutation) SetModelCard(oc *objects.ModelCard) {
	m.model_card = &oc
}

// ModelCard returns the value of the "model_card" field in the mutation.
func (m *ModelMutation) ModelCard() (r *objects.ModelCard, exists bool) {
	v := m.model_card
	if v == nil {
		return
	}
	return *v, true
}

// OldModelCard returns the old "model_card" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldModelCard(ctx context.Context) (v *objects.ModelCard, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModelCard is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModelCard requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModelCard: %w", err)
	}
	return oldValue.ModelCard, nil
}

// ResetModelCard resets all changes to the "model_card" field.
func (m *ModelMutation) ResetModelCard() {
	m.model_card = nil
}

// SetSettings sets the "settings" field.
func (m *ModelMutation) SetSettings(os *objects.ModelSettings) {
	m.settings = &os
}

// Settings returns the value of the "settings" field in the mutation.
func (m *ModelMutation) Settings() (r *objects.ModelSettings, exists bool) {
	v := m.settings
	if v == nil {
		return
	}
	return *v, true
}

// OldSettings returns the old "settings" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldSettings(ctx context.Context) (v *objects.ModelSettings, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettings: %w", err)
	}
	return oldValue.Settings, nil
}

// ResetSettings resets all changes to the "settings" field.
func (m *ModelMutation) ResetSettings() {
	m.settings = nil
}

// SetStatus sets the "status" field.
func (m *ModelMutation) SetStatus(value model.Status) {
	m.status = &value
}

// Status returns the value of the "status" field in the mutation.
func (m *ModelMutation) Status() (r model.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldStatus(ctx context.Context) (v model.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ModelMutation) ResetStatus() {
	m.status = nil
}

// SetRemark sets the "remark" field.
func (m *ModelMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *ModelMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldRemark(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *ModelMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[model.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *ModelMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[model.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *ModelMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, model.FieldRemark)
}

// Where appends a list predicates to the ModelMutation builder.
func (m *ModelMutation) Where(ps ...predicate.Model) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ModelMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ModelMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Model, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ModelMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ModelMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Model).
func (m *ModelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ModelMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, model.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, model.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, model.FieldDeletedAt)
	}
	if m.developer != nil {
		fields = append(fields, model.FieldDeveloper)
	}
	if m.model_id != nil {
		fields = append(fields, model.FieldModelID)
	}
	if m._type != nil {
		fields = append(fields, model.FieldType)
	}
	if m.name != nil {
		fields = append(fields, model.FieldName)
	}
	if m.icon != nil {
		fields = append(fields, model.FieldIcon)
	}
	if m.group != nil {
		fields = append(fields, model.FieldGroup)
	}
	if m.model_card != nil {
		fields = append(fields, model.FieldModelCard)
	}
	if m.settings != nil {
		fields = append(fields, model.FieldSettings)
	}
	if m.status != nil {
		fields = append(fields, model.FieldStatus)
	}
	if m.remark != nil {
		fields = append(fields, model.FieldRemark)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ModelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case model.FieldCreatedAt:
		return m.CreatedAt()
	case model.FieldUpdatedAt:
		return m.UpdatedAt()
	case model.FieldDeletedAt:
		return m.DeletedAt()
	case model.FieldDeveloper:
		return m.Developer()
	case model.FieldModelID:
		return m.ModelID()
	case model.FieldType:
		return m.GetType()
	case model.FieldName:
		return m.Name()
	case model.FieldIcon:
		return m.Icon()
	case model.FieldGroup:
		return m.Group()
	case model.FieldModelCard:
		return m.ModelCard()
	case model.FieldSettings:
		return m.Settings()
	case model.FieldStatus:
		return m.Status()
	case model.FieldRemark:
		return m.Remark()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ModelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case model.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case model.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case model.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case model.FieldDeveloper:
		return m.OldDeveloper(ctx)
	case model.FieldModelID:
		return m.OldModelID(ctx)
	case model.FieldType:
		return m.OldType(ctx)
	case model.FieldName:
		return m.OldName(ctx)
	case model.FieldIcon:
		return m.OldIcon(ctx)
	case model.FieldGroup:
		return m.OldGroup(ctx)
	case model.FieldModelCard:
		return m.OldModelCard(ctx)
	case model.FieldSettings:
		return m.OldSettings(ctx)
	case model.FieldStatus:
		return m.OldStatus(ctx)
	case model.FieldRemark:
		return m.OldRemark(ctx)
	}
	return nil, fmt.Errorf("unknown Model field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ModelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case model.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case model.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case model.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case model.FieldDeveloper:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeveloper(v)
		return nil
	case model.FieldModelID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModelID(v)
		return nil
	case model.FieldType:
		v, ok := value.(model.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case model.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case model.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case model.FieldGroup:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroup(v)
		return nil
	case model.FieldModelCard:
		v, ok := value.(*objects.ModelCard)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModelCard(v)
		return nil
	case model.FieldSettings:
		v, ok := value.(*objects.ModelSettings)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettings(v)
		return nil
	case model.FieldStatus:
		v, ok := value.(model.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case model.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	}
	return fmt.Errorf("unknown Model field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ModelMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, model.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ModelMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case model.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ModelMutation) AddField(name string, value ent.Value) error {
	switch name {
	case model.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Model numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ModelMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(model.FieldRemark) {
		fields = append(fields, model.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ModelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ModelMutation) ClearField(name string) error {
	switch name {
	case model.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown Model nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ModelMutation) ResetField(name string) error {
	switch name {
	case model.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case model.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case model.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case model.FieldDeveloper:
		m.ResetDeveloper()
		return nil
	case model.FieldModelID:
		m.ResetModelID()
		return nil
	case model.FieldType:
		m.ResetType()
		return nil
	case model.FieldName:
		m.ResetName()
		return nil
	case model.FieldIcon:
		m.ResetIcon()
		return nil
	case model.FieldGroup:
		m.ResetGroup()
		return nil
	case model.FieldModelCard:
		m.ResetModelCard()
		return nil
	case model.FieldSettings:
		m.ResetSettings()
		return nil
	case model.FieldStatus:
		m.ResetStatus()
		return nil
	case model.FieldRemark:
		m.ResetRemark()
		return nil
	}
	return fmt.Errorf("unknown Model field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ModelMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ModelMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ModelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ModelMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ModelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ModelMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ModelMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Model unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ModelMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Model edge %s", name)
}

// ProjectMutation represents an operation that mutates the Project nodes in the graph.
type ProjectMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	created_at           *time.Time
	updated_at           *time.Time
	deleted_at           *int
	adddeleted_at        *int
	name                 *string
	description          *string
	status               *project.Status
	clearedFields        map[string]struct{}
	users                map[int]struct{}
	removedusers         map[int]struct{}
	clearedusers         bool
	roles                map[int]struct{}
	removedroles         map[int]struct{}
	clearedroles         bool
	api_keys             map[int]struct{}
	removedapi_keys      map[int]struct{}
	clearedapi_keys      bool
	requests             map[int]struct{}
	removedrequests      map[int]struct{}
	clearedrequests      bool
	usage_logs           map[int]struct{}
	removedusage_logs    map[int]struct{}
	clearedusage_logs    bool
	threads              map[int]struct{}
	removedthreads       map[int]struct{}
	clearedthreads       bool
	traces               map[int]struct{}
	removedtraces        map[int]struct{}
	clearedtraces        bool
	prompts              map[int]struct{}
	removedprompts       map[int]struct{}
	clearedprompts       bool
	project_users        map[int]struct{}
	removedproject_users map[int]struct{}
	clearedproject_users bool
	done                 bool
	oldValue             func(context.Context) (*Project, error)
	predicates           []predicate.Project
}

var _ ent.Mutation = (*ProjectMutation)(nil)

// projectOption allows management of the mutation configuration using functional options.
type projectOption func(*ProjectMutation)

// newProjectMutation creates new mutation for the Project entity.
func newProjectMutation(c config, op Op, opts ...projectOption) *ProjectMutation {
	m := &ProjectMutation{
		config:        c,
		op:            op,
		typ:           TypeProject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectID sets the ID field of the mutation.
func withProjectID(id int) projectOption {
	return func(m *ProjectMutation) {
		var (
			err   error
			once  sync.Once
			value *Project
		)
		m.oldValue = func(ctx context.Context) (*Project, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Project.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProject sets the old Project of the mutation.
func withProject(node *Project) projectOption {
	return func(m *ProjectMutation) {
		m.oldValue = func(context.Context) (*Project, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProjectMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Project.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProjectMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProjectMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProjectMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProjectMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProjectMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProjectMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ProjectMutation) SetDeletedAt(i int) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ProjectMutation) DeletedAt() (r int, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldDeletedAt(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *ProjectMutation) AddDeletedAt(i int) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *ProjectMutation) AddedDeletedAt() (r int, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ProjectMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetName sets the "name" field.
func (m *ProjectMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProjectMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProjectMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ProjectMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProjectMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ProjectMutation) ResetDescription() {
	m.description = nil
}

// SetStatus sets the "status" field.
func (m *ProjectMutation) SetStatus(pr project.Status) {
	m.status = &pr
}

// Status returns the value of the "status" field in the mutation.
func (m *ProjectMutation) Status() (r project.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldStatus(ctx context.Context) (v project.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ProjectMutation) ResetStatus() {
	m.status = nil
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *ProjectMutation) AddUserIDs(ids ...int) {
	if m.users == nil {
		m.users = make(map[int]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *ProjectMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *ProjectMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *ProjectMutation) RemoveUserIDs(ids ...int) {
	if m.removedusers == nil {
		m.removedusers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *ProjectMutation) RemovedUsersIDs() (ids []int) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *ProjectMutation) UsersIDs() (ids []int) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *ProjectMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddRoleIDs adds the "roles" edge to the Role entity by ids.
func (m *ProjectMutation) AddRoleIDs(ids ...int) {
	if m.roles == nil {
		m.roles = make(map[int]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the Role entity.
func (m *ProjectMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the Role entity was cleared.
func (m *ProjectMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the Role entity by IDs.
func (m *ProjectMutation) RemoveRoleIDs(ids ...int) {
	if m.removedroles == nil {
		m.removedroles = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the Role entity.
func (m *ProjectMutation) RemovedRolesIDs() (ids []int) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *ProjectMutation) RolesIDs() (ids []int) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *ProjectMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// AddAPIKeyIDs adds the "api_keys" edge to the APIKey entity by ids.
func (m *ProjectMutation) AddAPIKeyIDs(ids ...int) {
	if m.api_keys == nil {
		m.api_keys = make(map[int]struct{})
	}
	for i := range ids {
		m.api_keys[ids[i]] = struct{}{}
	}
}

// ClearAPIKeys clears the "api_keys" edge to the APIKey entity.
func (m *ProjectMutation) ClearAPIKeys() {
	m.clearedapi_keys = true
}

// APIKeysCleared reports if the "api_keys" edge to the APIKey entity was cleared.
func (m *ProjectMutation) APIKeysCleared() bool {
	return m.clearedapi_keys
}

// RemoveAPIKeyIDs removes the "api_keys" edge to the APIKey entity by IDs.
func (m *ProjectMutation) RemoveAPIKeyIDs(ids ...int) {
	if m.removedapi_keys == nil {
		m.removedapi_keys = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.api_keys, ids[i])
		m.removedapi_keys[ids[i]] = struct{}{}
	}
}

// RemovedAPIKeys returns the removed IDs of the "api_keys" edge to the APIKey entity.
func (m *ProjectMutation) RemovedAPIKeysIDs() (ids []int) {
	for id := range m.removedapi_keys {
		ids = append(ids, id)
	}
	return
}

// APIKeysIDs returns the "api_keys" edge IDs in the mutation.
func (m *ProjectMutation) APIKeysIDs() (ids []int) {
	for id := range m.api_keys {
		ids = append(ids, id)
	}
	return
}

// ResetAPIKeys resets all changes to the "api_keys" edge.
func (m *ProjectMutation) ResetAPIKeys() {
	m.api_keys = nil
	m.clearedapi_keys = false
	m.removedapi_keys = nil
}

// AddRequestIDs adds the "requests" edge to the Request entity by ids.
func (m *ProjectMutation) AddRequestIDs(ids ...int) {
	if m.requests == nil {
		m.requests = make(map[int]struct{})
	}
	for i := range ids {
		m.requests[ids[i]] = struct{}{}
	}
}

// ClearRequests clears the "requests" edge to the Request entity.
func (m *ProjectMutation) ClearRequests() {
	m.clearedrequests = true
}

// RequestsCleared reports if the "requests" edge to the Request entity was cleared.
func (m *ProjectMutation) RequestsCleared() bool {
	return m.clearedrequests
}

// RemoveRequestIDs removes the "requests" edge to the Request entity by IDs.
func (m *ProjectMutation) RemoveRequestIDs(ids ...int) {
	if m.removedrequests == nil {
		m.removedrequests = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.requests, ids[i])
		m.removedrequests[ids[i]] = struct{}{}
	}
}

// RemovedRequests returns the removed IDs of the "requests" edge to the Request entity.
func (m *ProjectMutation) RemovedRequestsIDs() (ids []int) {
	for id := range m.removedrequests {
		ids = append(ids, id)
	}
	return
}

// RequestsIDs returns the "requests" edge IDs in the mutation.
func (m *ProjectMutation) RequestsIDs() (ids []int) {
	for id := range m.requests {
		ids = append(ids, id)
	}
	return
}

// ResetRequests resets all changes to the "requests" edge.
func (m *ProjectMutation) ResetRequests() {
	m.requests = nil
	m.clearedrequests = false
	m.removedrequests = nil
}

// AddUsageLogIDs adds the "usage_logs" edge to the UsageLog entity by ids.
func (m *ProjectMutation) AddUsageLogIDs(ids ...int) {
	if m.usage_logs == nil {
		m.usage_logs = make(map[int]struct{})
	}
	for i := range ids {
		m.usage_logs[ids[i]] = struct{}{}
	}
}

// ClearUsageLogs clears the "usage_logs" edge to the UsageLog entity.
func (m *ProjectMutation) ClearUsageLogs() {
	m.clearedusage_logs = true
}

// UsageLogsCleared reports if the "usage_logs" edge to the UsageLog entity was cleared.
func (m *ProjectMutation) UsageLogsCleared() bool {
	return m.clearedusage_logs
}

// RemoveUsageLogIDs removes the "usage_logs" edge to the UsageLog entity by IDs.
func (m *ProjectMutation) RemoveUsageLogIDs(ids ...int) {
	if m.removedusage_logs == nil {
		m.removedusage_logs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.usage_logs, ids[i])
		m.removedusage_logs[ids[i]] = struct{}{}
	}
}

// RemovedUsageLogs returns the removed IDs of the "usage_logs" edge to the UsageLog entity.
func (m *ProjectMutation) RemovedUsageLogsIDs() (ids []int) {
	for id := range m.removedusage_logs {
		ids = append(ids, id)
	}
	return
}

// UsageLogsIDs returns the "usage_logs" edge IDs in the mutation.
func (m *ProjectMutation) UsageLogsIDs() (ids []int) {
	for id := range m.usage_logs {
		ids = append(ids, id)
	}
	return
}

// ResetUsageLogs resets all changes to the "usage_logs" edge.
func (m *ProjectMutation) ResetUsageLogs() {
	m.usage_logs = nil
	m.clearedusage_logs = false
	m.removedusage_logs = nil
}

// AddThreadIDs adds the "threads" edge to the Thread entity by ids.
func (m *ProjectMutation) AddThreadIDs(ids ...int) {
	if m.threads == nil {
		m.threads = make(map[int]struct{})
	}
	for i := range ids {
		m.threads[ids[i]] = struct{}{}
	}
}

// ClearThreads clears the "threads" edge to the Thread entity.
func (m *ProjectMutation) ClearThreads() {
	m.clearedthreads = true
}

// ThreadsCleared reports if the "threads" edge to the Thread entity was cleared.
func (m *ProjectMutation) ThreadsCleared() bool {
	return m.clearedthreads
}

// RemoveThreadIDs removes the "threads" edge to the Thread entity by IDs.
func (m *ProjectMutation) RemoveThreadIDs(ids ...int) {
	if m.removedthreads == nil {
		m.removedthreads = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.threads, ids[i])
		m.removedthreads[ids[i]] = struct{}{}
	}
}

// RemovedThreads returns the removed IDs of the "threads" edge to the Thread entity.
func (m *ProjectMutation) RemovedThreadsIDs() (ids []int) {
	for id := range m.removedthreads {
		ids = append(ids, id)
	}
	return
}

// ThreadsIDs returns the "threads" edge IDs in the mutation.
func (m *ProjectMutation) ThreadsIDs() (ids []int) {
	for id := range m.threads {
		ids = append(ids, id)
	}
	return
}

// ResetThreads resets all changes to the "threads" edge.
func (m *ProjectMutation) ResetThreads() {
	m.threads = nil
	m.clearedthreads = false
	m.removedthreads = nil
}

// AddTraceIDs adds the "traces" edge to the Trace entity by ids.
func (m *ProjectMutation) AddTraceIDs(ids ...int) {
	if m.traces == nil {
		m.traces = make(map[int]struct{})
	}
	for i := range ids {
		m.traces[ids[i]] = struct{}{}
	}
}

// ClearTraces clears the "traces" edge to the Trace entity.
func (m *ProjectMutation) ClearTraces() {
	m.clearedtraces = true
}

// TracesCleared reports if the "traces" edge to the Trace entity was cleared.
func (m *ProjectMutation) TracesCleared() bool {
	return m.clearedtraces
}

// RemoveTraceIDs removes the "traces" edge to the Trace entity by IDs.
func (m *ProjectMutation) RemoveTraceIDs(ids ...int) {
	if m.removedtraces == nil {
		m.removedtraces = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.traces, ids[i])
		m.removedtraces[ids[i]] = struct{}{}
	}
}

// RemovedTraces returns the removed IDs of the "traces" edge to the Trace entity.
func (m *ProjectMutation) RemovedTracesIDs() (ids []int) {
	for id := range m.removedtraces {
		ids = append(ids, id)
	}
	return
}

// TracesIDs returns the "traces" edge IDs in the mutation.
func (m *ProjectMutation) TracesIDs() (ids []int) {
	for id := range m.traces {
		ids = append(ids, id)
	}
	return
}

// ResetTraces resets all changes to the "traces" edge.
func (m *ProjectMutation) ResetTraces() {
	m.traces = nil
	m.clearedtraces = false
	m.removedtraces = nil
}

// AddPromptIDs adds the "prompts" edge to the Prompt entity by ids.
func (m *ProjectMutation) AddPromptIDs(ids ...int) {
	if m.prompts == nil {
		m.prompts = make(map[int]struct{})
	}
	for i := range ids {
		m.prompts[ids[i]] = struct{}{}
	}
}

// ClearPrompts clears the "prompts" edge to the Prompt entity.
func (m *ProjectMutation) ClearPrompts() {
	m.clearedprompts = true
}

// PromptsCleared reports if the "prompts" edge to the Prompt entity was cleared.
func (m *ProjectMutation) PromptsCleared() bool {
	return m.clearedprompts
}

// RemovePromptIDs removes the "prompts" edge to the Prompt entity by IDs.
func (m *ProjectMutation) RemovePromptIDs(ids ...int) {
	if m.removedprompts == nil {
		m.removedprompts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.prompts, ids[i])
		m.removedprompts[ids[i]] = struct{}{}
	}
}

// RemovedPrompts returns the removed IDs of the "prompts" edge to the Prompt entity.
func (m *ProjectMutation) RemovedPromptsIDs() (ids []int) {
	for id := range m.removedprompts {
		ids = append(ids, id)
	}
	return
}

// PromptsIDs returns the "prompts" edge IDs in the mutation.
func (m *ProjectMutation) PromptsIDs() (ids []int) {
	for id := range m.prompts {
		ids = append(ids, id)
	}
	return
}

// ResetPrompts resets all changes to the "prompts" edge.
func (m *ProjectMutation) ResetPrompts() {
	m.prompts = nil
	m.clearedprompts = false
	m.removedprompts = nil
}

// AddProjectUserIDs adds the "project_users" edge to the UserProject entity by ids.
func (m *ProjectMutation) AddProjectUserIDs(ids ...int) {
	if m.project_users == nil {
		m.project_users = make(map[int]struct{})
	}
	for i := range ids {
		m.project_users[ids[i]] = struct{}{}
	}
}

// ClearProjectUsers clears the "project_users" edge to the UserProject entity.
func (m *ProjectMutation) ClearProjectUsers() {
	m.clearedproject_users = true
}

// ProjectUsersCleared reports if the "project_users" edge to the UserProject entity was cleared.
func (m *ProjectMutation) ProjectUsersCleared() bool {
	return m.clearedproject_users
}

// RemoveProjectUserIDs removes the "project_users" edge to the UserProject entity by IDs.
func (m *ProjectMutation) RemoveProjectUserIDs(ids ...int) {
	if m.removedproject_users == nil {
		m.removedproject_users = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.project_users, ids[i])
		m.removedproject_users[ids[i]] = struct{}{}
	}
}

// RemovedProjectUsers returns the removed IDs of the "project_users" edge to the UserProject entity.
func (m *ProjectMutation) RemovedProjectUsersIDs() (ids []int) {
	for id := range m.removedproject_users {
		ids = append(ids, id)
	}
	return
}

// ProjectUsersIDs returns the "project_users" edge IDs in the mutation.
func (m *ProjectMutation) ProjectUsersIDs() (ids []int) {
	for id := range m.project_users {
		ids = append(ids, id)
	}
	return
}

// ResetProjectUsers resets all changes to the "project_users" edge.
func (m *ProjectMutation) ResetProjectUsers() {
	m.project_users = nil
	m.clearedproject_users = false
	m.removedproject_users = nil
}

// Where appends a list predicates to the ProjectMutation builder.
func (m *ProjectMutation) Where(ps ...predicate.Project) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProjectMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProjectMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Project, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProjectMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProjectMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Project).
func (m *ProjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, project.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, project.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, project.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, project.FieldName)
	}
	if m.description != nil {
		fields = append(fields, project.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, project.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case project.FieldCreatedAt:
		return m.CreatedAt()
	case project.FieldUpdatedAt:
		return m.UpdatedAt()
	case project.FieldDeletedAt:
		return m.DeletedAt()
	case project.FieldName:
		return m.Name()
	case project.FieldDescription:
		return m.Description()
	case project.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case project.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case project.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case project.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case project.FieldName:
		return m.OldName(ctx)
	case project.FieldDescription:
		return m.OldDescription(ctx)
	case project.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Project field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case project.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case project.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case project.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case project.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case project.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case project.FieldStatus:
		v, ok := value.(project.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, project.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case project.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	case project.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Project numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Project nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectMutation) ResetField(name string) error {
	switch name {
	case project.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case project.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case project.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case project.FieldName:
		m.ResetName()
		return nil
	case project.FieldDescription:
		m.ResetDescription()
		return nil
	case project.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 9)
	if m.users != nil {
		edges = append(edges, project.EdgeUsers)
	}
	if m.roles != nil {
		edges = append(edges, project.EdgeRoles)
	}
	if m.api_keys != nil {
		edges = append(edges, project.EdgeAPIKeys)
	}
	if m.requests != nil {
		edges = append(edges, project.EdgeRequests)
	}
	if m.usage_logs != nil {
		edges = append(edges, project.EdgeUsageLogs)
	}
	if m.threads != nil {
		edges = append(edges, project.EdgeThreads)
	}
	if m.traces != nil {
		edges = append(edges, project.EdgeTraces)
	}
	if m.prompts != nil {
		edges = append(edges, project.EdgePrompts)
	}
	if m.project_users != nil {
		edges = append(edges, project.EdgeProjectUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeAPIKeys:
		ids := make([]ent.Value, 0, len(m.api_keys))
		for id := range m.api_keys {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeRequests:
		ids := make([]ent.Value, 0, len(m.requests))
		for id := range m.requests {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeUsageLogs:
		ids := make([]ent.Value, 0, len(m.usage_logs))
		for id := range m.usage_logs {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeThreads:
		ids := make([]ent.Value, 0, len(m.threads))
		for id := range m.threads {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeTraces:
		ids := make([]ent.Value, 0, len(m.traces))
		for id := range m.traces {
			ids = append(ids, id)
		}
		return ids
	case project.EdgePrompts:
		ids := make([]ent.Value, 0, len(m.prompts))
		for id := range m.prompts {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeProjectUsers:
		ids := make([]ent.Value, 0, len(m.project_users))
		for id := range m.project_users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 9)
	if m.removedusers != nil {
		edges = append(edges, project.EdgeUsers)
	}
	if m.removedroles != nil {
		edges = append(edges, project.EdgeRoles)
	}
	if m.removedapi_keys != nil {
		edges = append(edges, project.EdgeAPIKeys)
	}
	if m.removedrequests != nil {
		edges = append(edges, project.EdgeRequests)
	}
	if m.removedusage_logs != nil {
		edges = append(edges, project.EdgeUsageLogs)
	}
	if m.removedthreads != nil {
		edges = append(edges, project.EdgeThreads)
	}
	if m.removedtraces != nil {
		edges = append(edges, project.EdgeTraces)
	}
	if m.removedprompts != nil {
		edges = append(edges, project.EdgePrompts)
	}
	if m.removedproject_users != nil {
		edges = append(edges, project.EdgeProjectUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeAPIKeys:
		ids := make([]ent.Value, 0, len(m.removedapi_keys))
		for id := range m.removedapi_keys {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeRequests:
		ids := make([]ent.Value, 0, len(m.removedrequests))
		for id := range m.removedrequests {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeUsageLogs:
		ids := make([]ent.Value, 0, len(m.removedusage_logs))
		for id := range m.removedusage_logs {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeThreads:
		ids := make([]ent.Value, 0, len(m.removedthreads))
		for id := range m.removedthreads {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeTraces:
		ids := make([]ent.Value, 0, len(m.removedtraces))
		for id := range m.removedtraces {
			ids = append(ids, id)
		}
		return ids
	case project.EdgePrompts:
		ids := make([]ent.Value, 0, len(m.removedprompts))
		for id := range m.removedprompts {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeProjectUsers:
		ids := make([]ent.Value, 0, len(m.removedproject_users))
		for id := range m.removedproject_users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 9)
	if m.clearedusers {
		edges = append(edges, project.EdgeUsers)
	}
	if m.clearedroles {
		edges = append(edges, project.EdgeRoles)
	}
	if m.clearedapi_keys {
		edges = append(edges, project.EdgeAPIKeys)
	}
	if m.clearedrequests {
		edges = append(edges, project.EdgeRequests)
	}
	if m.clearedusage_logs {
		edges = append(edges, project.EdgeUsageLogs)
	}
	if m.clearedthreads {
		edges = append(edges, project.EdgeThreads)
	}
	if m.clearedtraces {
		edges = append(edges, project.EdgeTraces)
	}
	if m.clearedprompts {
		edges = append(edges, project.EdgePrompts)
	}
	if m.clearedproject_users {
		edges = append(edges, project.EdgeProjectUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectMutation) EdgeCleared(name string) bool {
	switch name {
	case project.EdgeUsers:
		return m.clearedusers
	case project.EdgeRoles:
		return m.clearedroles
	case project.EdgeAPIKeys:
		return m.clearedapi_keys
	case project.EdgeRequests:
		return m.clearedrequests
	case project.EdgeUsageLogs:
		return m.clearedusage_logs
	case project.EdgeThreads:
		return m.clearedthreads
	case project.EdgeTraces:
		return m.clearedtraces
	case project.EdgePrompts:
		return m.clearedprompts
	case project.EdgeProjectUsers:
		return m.clearedproject_users
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Project unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectMutation) ResetEdge(name string) error {
	switch name {
	case project.EdgeUsers:
		m.ResetUsers()
		return nil
	case project.EdgeRoles:
		m.ResetRoles()
		return nil
	case project.EdgeAPIKeys:
		m.ResetAPIKeys()
		return nil
	case project.EdgeRequests:
		m.ResetRequests()
		return nil
	case project.EdgeUsageLogs:
		m.ResetUsageLogs()
		return nil
	case project.EdgeThreads:
		m.ResetThreads()
		return nil
	case project.EdgeTraces:
		m.ResetTraces()
		return nil
	case project.EdgePrompts:
		m.ResetPrompts()
		return nil
	case project.EdgeProjectUsers:
		m.ResetProjectUsers()
		return nil
	}
	return fmt.Errorf("unknown Project edge %s", name)
}

// PromptMutation represents an operation that mutates the Prompt nodes in the graph.
type PromptMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *int
	adddeleted_at   *int
	project_id      *int
	addproject_id   *int
	name            *string
	description     *string
	role            *string
	content         *string
	status          *prompt.Status
	settings        *objects.PromptSettings
	clearedFields   map[string]struct{}
	projects        map[int]struct{}
	removedprojects map[int]struct{}
	clearedprojects bool
	done            bool
	oldValue        func(context.Context) (*Prompt, error)
	predicates      []predicate.Prompt
}

var _ ent.Mutation = (*PromptMutation)(nil)

// promptOption allows management of the mutation configuration using functional options.
type promptOption func(*PromptMutation)

// newPromptMutation creates new mutation for the Prompt entity.
func newPromptMutation(c config, op Op, opts ...promptOption) *PromptMutation {
	m := &PromptMutation{
		config:        c,
		op:            op,
		typ:           TypePrompt,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPromptID sets the ID field of the mutation.
func withPromptID(id int) promptOption {
	return func(m *PromptMutation) {
		var (
			err   error
			once  sync.Once
			value *Prompt
		)
		m.oldValue = func(ctx context.Context) (*Prompt, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Prompt.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPrompt sets the old Prompt of the mutation.
func withPrompt(node *Prompt) promptOption {
	return func(m *PromptMutation) {
		m.oldValue = func(context.Context) (*Prompt, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PromptMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PromptMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PromptMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PromptMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Prompt.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PromptMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PromptMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PromptMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PromptMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PromptMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PromptMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PromptMutation) SetDeletedAt(i int) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PromptMutation) DeletedAt() (r int, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldDeletedAt(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *PromptMutation) AddDeletedAt(i int) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *PromptMutation) AddedDeletedAt() (r int, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PromptMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetProjectID sets the "project_id" field.
func (m *PromptMutation) SetProjectID(i int) {
	m.project_id = &i
	m.addproject_id = nil
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *PromptMutation) ProjectID() (r int, exists bool) {
	v := m.project_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldProjectID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// AddProjectID adds i to the "project_id" field.
func (m *PromptMutation) AddProjectID(i int) {
	if m.addproject_id != nil {
		*m.addproject_id += i
	} else {
		m.addproject_id = &i
	}
}

// AddedProjectID returns the value that was added to the "project_id" field in this mutation.
func (m *PromptMutation) AddedProjectID() (r int, exists bool) {
	v := m.addproject_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *PromptMutation) ResetProjectID() {
	m.project_id = nil
	m.addproject_id = nil
}

// SetName sets the "name" field.
func (m *PromptMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PromptMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PromptMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *PromptMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PromptMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *PromptMutation) ResetDescription() {
	m.description = nil
}

// SetRole sets the "role" field.
func (m *PromptMutation) SetRole(s string) {
	m.role = &s
}

// Role returns the value of the "role" field in the mutation.
func (m *PromptMutation) Role() (r string, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldRole(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *PromptMutation) ResetRole() {
	m.role = nil
}

// SetContent sets the "content" field.
func (m *PromptMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *PromptMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *PromptMutation) ResetContent() {
	m.content = nil
}

// SetStatus sets the "status" field.
func (m *PromptMutation) SetStatus(pr prompt.Status) {
	m.status = &pr
}

// Status returns the value of the "status" field in the mutation.
func (m *PromptMutation) Status() (r prompt.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldStatus(ctx context.Context) (v prompt.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *PromptMutation) ResetStatus() {
	m.status = nil
}

// SetSettings sets the "settings" field.
func (m *PromptMutation) SetSettings(os objects.PromptSettings) {
	m.settings = &os
}

// Settings returns the value of the "settings" field in the mutation.
func (m *PromptMutation) Settings() (r objects.PromptSettings, exists bool) {
	v := m.settings
	if v == nil {
		return
	}
	return *v, true
}

// OldSettings returns the old "settings" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldSettings(ctx context.Context) (v objects.PromptSettings, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettings: %w", err)
	}
	return oldValue.Settings, nil
}

// ResetSettings resets all changes to the "settings" field.
func (m *PromptMutation) ResetSettings() {
	m.settings = nil
}

// AddProjectIDs adds the "projects" edge to the Project entity by ids.
func (m *PromptMutation) AddProjectIDs(ids ...int) {
	if m.projects == nil {
		m.projects = make(map[int]struct{})
	}
	for i := range ids {
		m.projects[ids[i]] = struct{}{}
	}
}

// ClearProjects clears the "projects" edge to the Project entity.
func (m *PromptMutation) ClearProjects() {
	m.clearedprojects = true
}

// ProjectsCleared reports if the "projects" edge to the Project entity was cleared.
func (m *PromptMutation) ProjectsCleared() bool {
	return m.clearedprojects
}

// RemoveProjectIDs removes the "projects" edge to the Project entity by IDs.
func (m *PromptMutation) RemoveProjectIDs(ids ...int) {
	if m.removedprojects == nil {
		m.removedprojects = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.projects, ids[i])
		m.removedprojects[ids[i]] = struct{}{}
	}
}

// RemovedProjects returns the removed IDs of the "projects" edge to the Project entity.
func (m *PromptMutation) RemovedProjectsIDs() (ids []int) {
	for id := range m.removedprojects {
		ids = append(ids, id)
	}
	return
}

// ProjectsIDs returns the "projects" edge IDs in the mutation.
func (m *PromptMutation) ProjectsIDs() (ids []int) {
	for id := range m.projects {
		ids = append(ids, id)
	}
	return
}

// ResetProjects resets all changes to the "projects" edge.
func (m *PromptMutation) ResetProjects() {
	m.projects = nil
	m.clearedprojects = false
	m.removedprojects = nil
}

// Where appends a list predicates to the PromptMutation builder.
func (m *PromptMutation) Where(ps ...predicate.Prompt) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PromptMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PromptMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Prompt, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PromptMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PromptMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Prompt).
func (m *PromptMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PromptMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, prompt.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, prompt.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, prompt.FieldDeletedAt)
	}
	if m.project_id != nil {
		fields = append(fields, prompt.FieldProjectID)
	}
	if m.name != nil {
		fields = append(fields, prompt.FieldName)
	}
	if m.description != nil {
		fields = append(fields, prompt.FieldDescription)
	}
	if m.role != nil {
		fields = append(fields, prompt.FieldRole)
	}
	if m.content != nil {
		fields = append(fields, prompt.FieldContent)
	}
	if m.status != nil {
		fields = append(fields, prompt.FieldStatus)
	}
	if m.settings != nil {
		fields = append(fields, prompt.FieldSettings)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PromptMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case prompt.FieldCreatedAt:
		return m.CreatedAt()
	case prompt.FieldUpdatedAt:
		return m.UpdatedAt()
	case prompt.FieldDeletedAt:
		return m.DeletedAt()
	case prompt.FieldProjectID:
		return m.ProjectID()
	case prompt.FieldName:
		return m.Name()
	case prompt.FieldDescription:
		return m.Description()
	case prompt.FieldRole:
		return m.Role()
	case prompt.FieldContent:
		return m.Content()
	case prompt.FieldStatus:
		return m.Status()
	case prompt.FieldSettings:
		return m.Settings()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PromptMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case prompt.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case prompt.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case prompt.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case prompt.FieldProjectID:
		return m.OldProjectID(ctx)
	case prompt.FieldName:
		return m.OldName(ctx)
	case prompt.FieldDescription:
		return m.OldDescription(ctx)
	case prompt.FieldRole:
		return m.OldRole(ctx)
	case prompt.FieldContent:
		return m.OldContent(ctx)
	case prompt.FieldStatus:
		return m.OldStatus(ctx)
	case prompt.FieldSettings:
		return m.OldSettings(ctx)
	}
	return nil, fmt.Errorf("unknown Prompt field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromptMutation) SetField(name string, value ent.Value) error {
	switch name {
	case prompt.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case prompt.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case prompt.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case prompt.FieldProjectID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case prompt.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case prompt.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case prompt.FieldRole:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case prompt.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case prompt.FieldStatus:
		v, ok := value.(prompt.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case prompt.FieldSettings:
		v, ok := value.(objects.PromptSettings)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettings(v)
		return nil
	}
	return fmt.Errorf("unknown Prompt field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PromptMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, prompt.FieldDeletedAt)
	}
	if m.addproject_id != nil {
		fields = append(fields, prompt.FieldProjectID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PromptMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case prompt.FieldDeletedAt:
		return m.AddedDeletedAt()
	case prompt.FieldProjectID:
		return m.AddedProjectID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromptMutation) AddField(name string, value ent.Value) error {
	switch name {
	case prompt.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case prompt.FieldProjectID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProjectID(v)
		return nil
	}
	return fmt.Errorf("unknown Prompt numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PromptMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PromptMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PromptMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Prompt nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PromptMutation) ResetField(name string) error {
	switch name {
	case prompt.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case prompt.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case prompt.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case prompt.FieldProjectID:
		m.ResetProjectID()
		return nil
	case prompt.FieldName:
		m.ResetName()
		return nil
	case prompt.FieldDescription:
		m.ResetDescription()
		return nil
	case prompt.FieldRole:
		m.ResetRole()
		return nil
	case prompt.FieldContent:
		m.ResetContent()
		return nil
	case prompt.FieldStatus:
		m.ResetStatus()
		return nil
	case prompt.FieldSettings:
		m.ResetSettings()
		return nil
	}
	return fmt.Errorf("unknown Prompt field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PromptMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.projects != nil {
		edges = append(edges, prompt.EdgeProjects)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PromptMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case prompt.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.projects))
		for id := range m.projects {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PromptMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedprojects != nil {
		edges = append(edges, prompt.EdgeProjects)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PromptMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case prompt.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.removedprojects))
		for id := range m.removedprojects {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PromptMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedprojects {
		edges = append(edges, prompt.EdgeProjects)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PromptMutation) EdgeCleared(name string) bool {
	switch name {
	case prompt.EdgeProjects:
		return m.clearedprojects
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PromptMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Prompt unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PromptMutation) ResetEdge(name string) error {
	switch name {
	case prompt.EdgeProjects:
		m.ResetProjects()
		return nil
	}
	return fmt.Errorf("unknown Prompt edge %s", name)
}

// ProviderQuotaStatusMutation represents an operation that mutates the ProviderQuotaStatus nodes in the graph.
type ProviderQuotaStatusMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	updated_at     *time.Time
	deleted_at     *int
	adddeleted_at  *int
	provider_type  *providerquotastatus.ProviderType
	status         *providerquotastatus.Status
	quota_data     *map[string]interface{}
	next_reset_at  *time.Time
	ready          *bool
	next_check_at  *time.Time
	clearedFields  map[string]struct{}
	channel        *int
	clearedchannel bool
	done           bool
	oldValue       func(context.Context) (*ProviderQuotaStatus, error)
	predicates     []predicate.ProviderQuotaStatus
}

var _ ent.Mutation = (*ProviderQuotaStatusMutation)(nil)

// providerquotastatusOption allows management of the mutation configuration using functional options.
type providerquotastatusOption func(*ProviderQuotaStatusMutation)

// newProviderQuotaStatusMutation creates new mutation for the ProviderQuotaStatus entity.
func newProviderQuotaStatusMutation(c config, op Op, opts ...providerquotastatusOption) *ProviderQuotaStatusMutation {
	m := &ProviderQuotaStatusMutation{
		config:        c,
		op:            op,
		typ:           TypeProviderQuotaStatus,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProviderQuotaStatusID sets the ID field of the mutation.
func withProviderQuotaStatusID(id int) providerquotastatusOption {
	return func(m *ProviderQuotaStatusMutation) {
		var (
			err   error
			once  sync.Once
			value *ProviderQuotaStatus
		)
		m.oldValue = func(ctx context.Context) (*ProviderQuotaStatus, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProviderQuotaStatus.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProviderQuotaStatus sets the old ProviderQuotaStatus of the mutation.
func withProviderQuotaStatus(node *ProviderQuotaStatus) providerquotastatusOption {
	return func(m *ProviderQuotaStatusMutation) {
		m.oldValue = func(context.Context) (*ProviderQuotaStatus, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProviderQuotaStatusMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProviderQuotaStatusMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProviderQuotaStatusMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProviderQuotaStatusMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProviderQuotaStatus.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProviderQuotaStatusMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProviderQuotaStatusMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProviderQuotaStatus entity.
// If the ProviderQuotaStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderQuotaStatusMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProviderQuotaStatusMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProviderQuotaStatusMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProviderQuotaStatusMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProviderQuotaStatus entity.
// If the ProviderQuotaStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderQuotaStatusMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProviderQuotaStatusMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ProviderQuotaStatusMutation) SetDeletedAt(i int) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ProviderQuotaStatusMutation) DeletedAt() (r int, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ProviderQuotaStatus entity.
// If the ProviderQuotaStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderQuotaStatusMutation) OldDeletedAt(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *ProviderQuotaStatusMutation) AddDeletedAt(i int) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *ProviderQuotaStatusMutation) AddedDeletedAt() (r int, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ProviderQuotaStatusMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetChannelID sets the "channel_id" field.
func (m *ProviderQuotaStatusMutation) SetChannelID(i int) {
	m.channel = &i
}

// ChannelID returns the value of the "channel_id" field in the mutation.
func (m *ProviderQuotaStatusMutation) ChannelID() (r int, exists bool) {
	v := m.channel
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelID returns the old "channel_id" field's value of the ProviderQuotaStatus entity.
// If the ProviderQuotaStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderQuotaStatusMutation) OldChannelID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelID: %w", err)
	}
	return oldValue.ChannelID, nil
}

// ResetChannelID resets all changes to the "channel_id" field.
func (m *ProviderQuotaStatusMutation) ResetChannelID() {
	m.channel = nil
}

// SetProviderType sets the "provider_type" field.
func (m *ProviderQuotaStatusMutation) SetProviderType(pt providerquotastatus.ProviderType) {
	m.provider_type = &pt
}

// ProviderType returns the value of the "provider_type" field in the mutation.
func (m *ProviderQuotaStatusMutation) ProviderType() (r providerquotastatus.ProviderType, exists bool) {
	v := m.provider_type
	if v == nil {
		return
	}
	return *v, true
}

// OldProviderType returns the old "provider_type" field's value of the ProviderQuotaStatus entity.
// If the ProviderQuotaStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderQuotaStatusMutation) OldProviderType(ctx context.Context) (v providerquotastatus.ProviderType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProviderType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProviderType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProviderType: %w", err)
	}
	return oldValue.ProviderType, nil
}

// ResetProviderType resets all changes to the "provider_type" field.
func (m *ProviderQuotaStatusMutation) ResetProviderType() {
	m.provider_type = nil
}

// SetStatus sets the "status" field.
func (m *ProviderQuotaStatusMutation) SetStatus(pr providerquotastatus.Status) {
	m.status = &pr
}

// Status returns the value of the "status" field in the mutation.
func (m *ProviderQuotaStatusMutation) Status() (r providerquotastatus.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ProviderQuotaStatus entity.
// If the ProviderQuotaStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderQuotaStatusMutation) OldStatus(ctx context.Context) (v providerquotastatus.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ProviderQuotaStatusMutation) ResetStatus() {
	m.status = nil
}

// SetQuotaData sets the "quota_data" field.
func (m *ProviderQuotaStatusMutation) SetQuotaData(value map[string]interface{}) {
	m.quota_data = &value
}

// QuotaData returns the value of the "quota_data" field in the mutation.
func (m *ProviderQuotaStatusMutation) QuotaData() (r map[string]interface{}, exists bool) {
	v := m.quota_data
	if v == nil {
		return
	}
	return *v, true
}

// OldQuotaData returns the old "quota_data" field's value of the ProviderQuotaStatus entity.
// If the ProviderQuotaStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderQuotaStatusMutation) OldQuotaData(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuotaData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuotaData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuotaData: %w", err)
	}
	return oldValue.QuotaData, nil
}

// ResetQuotaData resets all changes to the "quota_data" field.
func (m *ProviderQuotaStatusMutation) ResetQuotaData() {
	m.quota_data = nil
}

// SetNextResetAt sets the "next_reset_at" field.
func (m *ProviderQuotaStatusMutation) SetNextResetAt(t time.Time) {
	m.next_reset_at = &t
}

// NextResetAt returns the value of the "next_reset_at" field in the mutation.
func (m *ProviderQuotaStatusMutation) NextResetAt() (r time.Time, exists bool) {
	v := m.next_reset_at
	if v == nil {
		return
	}
	return *v, true
}

// OldNextResetAt returns the old "next_reset_at" field's value of the ProviderQuotaStatus entity.
// If the ProviderQuotaStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderQuotaStatusMutation) OldNextResetAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNextResetAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNextResetAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNextResetAt: %w", err)
	}
	return oldValue.NextResetAt, nil
}

// ClearNextResetAt clears the value of the "next_reset_at" field.
func (m *ProviderQuotaStatusMutation) ClearNextResetAt() {
	m.next_reset_at = nil
	m.clearedFields[providerquotastatus.FieldNextResetAt] = struct{}{}
}

// NextResetAtCleared returns if the "next_reset_at" field was cleared in this mutation.
func (m *ProviderQuotaStatusMutation) NextResetAtCleared() bool {
	_, ok := m.clearedFields[providerquotastatus.FieldNextResetAt]
	return ok
}

// ResetNextResetAt resets all changes to the "next_reset_at" field.
func (m *ProviderQuotaStatusMutation) ResetNextResetAt() {
	m.next_reset_at = nil
	delete(m.clearedFields, providerquotastatus.FieldNextResetAt)
}

// SetReady sets the "ready" field.
func (m *ProviderQuotaStatusMutation) SetReady(b bool) {
	m.ready = &b
}

// Ready returns the value of the "ready" field in the mutation.
func (m *ProviderQuotaStatusMutation) Ready() (r bool, exists bool) {
	v := m.ready
	if v == nil {
		return
	}
	return *v, true
}

// OldReady returns the old "ready" field's value of the ProviderQuotaStatus entity.
// If the ProviderQuotaStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderQuotaStatusMutation) OldReady(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReady is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReady requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReady: %w", err)
	}
	return oldValue.Ready, nil
}

// ResetReady resets all changes to the "ready" field.
func (m *ProviderQuotaStatusMutation) ResetReady() {
	m.ready = nil
}

// SetNextCheckAt sets the "next_check_at" field.
func (m *ProviderQuotaStatusMutation) SetNextCheckAt(t time.Time) {
	m.next_check_at = &t
}

// NextCheckAt returns the value of the "next_check_at" field in the mutation.
func (m *ProviderQuotaStatusMutation) NextCheckAt() (r time.Time, exists bool) {
	v := m.next_check_at
	if v == nil {
		return
	}
	return *v, true
}

// OldNextCheckAt returns the old "next_check_at" field's value of the ProviderQuotaStatus entity.
// If the ProviderQuotaStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderQuotaStatusMutation) OldNextCheckAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNextCheckAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNextCheckAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNextCheckAt: %w", err)
	}
	return oldValue.NextCheckAt, nil
}

// ResetNextCheckAt resets all changes to the "next_check_at" field.
func (m *ProviderQuotaStatusMutation) ResetNextCheckAt() {
	m.next_check_at = nil
}

// ClearChannel clears the "channel" edge to the Channel entity.
func (m *ProviderQuotaStatusMutation) ClearChannel() {
	m.clearedchannel = true
	m.clearedFields[providerquotastatus.FieldChannelID] = struct{}{}
}

// ChannelCleared reports if the "channel" edge to the Channel entity was cleared.
func (m *ProviderQuotaStatusMutation) ChannelCleared() bool {
	return m.clearedchannel
}

// ChannelIDs returns the "channel" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChannelID instead. It exists only for internal usage by the builders.
func (m *ProviderQuotaStatusMutation) ChannelIDs() (ids []int) {
	if id := m.channel; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChannel resets all changes to the "channel" edge.
func (m *ProviderQuotaStatusMutation) ResetChannel() {
	m.channel = nil
	m.clearedchannel = false
}

// Where appends a list predicates to the ProviderQuotaStatusMutation builder.
func (m *ProviderQuotaStatusMutation) Where(ps ...predicate.ProviderQuotaStatus) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProviderQuotaStatusMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProviderQuotaStatusMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProviderQuotaStatus, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProviderQuotaStatusMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProviderQuotaStatusMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProviderQuotaStatus).
func (m *ProviderQuotaStatusMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProviderQuotaStatusMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, providerquotastatus.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, providerquotastatus.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, providerquotastatus.FieldDeletedAt)
	}
	if m.channel != nil {
		fields = append(fields, providerquotastatus.FieldChannelID)
	}
	if m.provider_type != nil {
		fields = append(fields, providerquotastatus.FieldProviderType)
	}
	if m.status != nil {
		fields = append(fields, providerquotastatus.FieldStatus)
	}
	if m.quota_data != nil {
		fields = append(fields, providerquotastatus.FieldQuotaData)
	}
	if m.next_reset_at != nil {
		fields = append(fields, providerquotastatus.FieldNextResetAt)
	}
	if m.ready != nil {
		fields = append(fields, providerquotastatus.FieldReady)
	}
	if m.next_check_at != nil {
		fields = append(fields, providerquotastatus.FieldNextCheckAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProviderQuotaStatusMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case providerquotastatus.FieldCreatedAt:
		return m.CreatedAt()
	case providerquotastatus.FieldUpdatedAt:
		return m.UpdatedAt()
	case providerquotastatus.FieldDeletedAt:
		return m.DeletedAt()
	case providerquotastatus.FieldChannelID:
		return m.ChannelID()
	case providerquotastatus.FieldProviderType:
		return m.ProviderType()
	case providerquotastatus.FieldStatus:
		return m.Status()
	case providerquotastatus.FieldQuotaData:
		return m.QuotaData()
	case providerquotastatus.FieldNextResetAt:
		return m.NextResetAt()
	case providerquotastatus.FieldReady:
		return m.Ready()
	case providerquotastatus.FieldNextCheckAt:
		return m.NextCheckAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProviderQuotaStatusMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case providerquotastatus.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case providerquotastatus.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case providerquotastatus.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case providerquotastatus.FieldChannelID:
		return m.OldChannelID(ctx)
	case providerquotastatus.FieldProviderType:
		return m.OldProviderType(ctx)
	case providerquotastatus.FieldStatus:
		return m.OldStatus(ctx)
	case providerquotastatus.FieldQuotaData:
		return m.OldQuotaData(ctx)
	case providerquotastatus.FieldNextResetAt:
		return m.OldNextResetAt(ctx)
	case providerquotastatus.FieldReady:
		return m.OldReady(ctx)
	case providerquotastatus.FieldNextCheckAt:
		return m.OldNextCheckAt(ctx)
	}
	return nil, fmt.Errorf("unknown ProviderQuotaStatus field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProviderQuotaStatusMutation) SetField(name string, value ent.Value) error {
	switch name {
	case providerquotastatus.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case providerquotastatus.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case providerquotastatus.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case providerquotastatus.FieldChannelID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelID(v)
		return nil
	case providerquotastatus.FieldProviderType:
		v, ok := value.(providerquotastatus.ProviderType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProviderType(v)
		return nil
	case providerquotastatus.FieldStatus:
		v, ok := value.(providerquotastatus.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case providerquotastatus.FieldQuotaData:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuotaData(v)
		return nil
	case providerquotastatus.FieldNextResetAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNextResetAt(v)
		return nil
	case providerquotastatus.FieldReady:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReady(v)
		return nil
	case providerquotastatus.FieldNextCheckAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNextCheckAt(v)
		return nil
	}
	return fmt.Errorf("unknown ProviderQuotaStatus field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProviderQuotaStatusMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, providerquotastatus.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProviderQuotaStatusMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case providerquotastatus.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProviderQuotaStatusMutation) AddField(name string, value ent.Value) error {
	switch name {
	case providerquotastatus.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ProviderQuotaStatus numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProviderQuotaStatusMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(providerquotastatus.FieldNextResetAt) {
		fields = append(fields, providerquotastatus.FieldNextResetAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProviderQuotaStatusMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProviderQuotaStatusMutation) ClearField(name string) error {
	switch name {
	case providerquotastatus.FieldNextResetAt:
		m.ClearNextResetAt()
		return nil
	}
	return fmt.Errorf("unknown ProviderQuotaStatus nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProviderQuotaStatusMutation) ResetField(name string) error {
	switch name {
	case providerquotastatus.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case providerquotastatus.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case providerquotastatus.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case providerquotastatus.FieldChannelID:
		m.ResetChannelID()
		return nil
	case providerquotastatus.FieldProviderType:
		m.ResetProviderType()
		return nil
	case providerquotastatus.FieldStatus:
		m.ResetStatus()
		return nil
	case providerquotastatus.FieldQuotaData:
		m.ResetQuotaData()
		return nil
	case providerquotastatus.FieldNextResetAt:
		m.ResetNextResetAt()
		return nil
	case providerquotastatus.FieldReady:
		m.ResetReady()
		return nil
	case providerquotastatus.FieldNextCheckAt:
		m.ResetNextCheckAt()
		return nil
	}
	return fmt.Errorf("unknown ProviderQuotaStatus field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProviderQuotaStatusMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.channel != nil {
		edges = append(edges, providerquotastatus.EdgeChannel)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProviderQuotaStatusMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case providerquotastatus.EdgeChannel:
		if id := m.channel; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProviderQuotaStatusMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProviderQuotaStatusMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProviderQuotaStatusMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedchannel {
		edges = append(edges, providerquotastatus.EdgeChannel)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProviderQuotaStatusMutation) EdgeCleared(name string) bool {
	switch name {
	case providerquotastatus.EdgeChannel:
		return m.clearedchannel
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProviderQuotaStatusMutation) ClearEdge(name string) error {
	switch name {
	case providerquotastatus.EdgeChannel:
		m.ClearChannel()
		return nil
	}
	return fmt.Errorf("unknown ProviderQuotaStatus unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProviderQuotaStatusMutation) ResetEdge(name string) error {
	switch name {
	case providerquotastatus.EdgeChannel:
		m.ResetChannel()
		return nil
	}
	return fmt.Errorf("unknown ProviderQuotaStatus edge %s", name)
}

// RequestMutation represents an operation that mutates the Request nodes in the graph.
type RequestMutation struct {
	config
	op                                Op
	typ                               string
	id                                *int
	created_at                        *time.Time
	updated_at                        *time.Time
	source                            *request.Source
	model_id                          *string
	format                            *string
	request_headers                   *objects.JSONRawMessage
	appendrequest_headers             objects.JSONRawMessage
	request_body                      *objects.JSONRawMessage
	appendrequest_body                objects.JSONRawMessage
	response_body                     *objects.JSONRawMessage
	appendresponse_body               objects.JSONRawMessage
	response_chunks                   *[]objects.JSONRawMessage
	appendresponse_chunks             []objects.JSONRawMessage
	external_id                       *string
	status                            *request.Status
	stream                            *bool
	client_ip                         *string
	metrics_latency_ms                *int64
	addmetrics_latency_ms             *int64
	metrics_first_token_latency_ms    *int64
	addmetrics_first_token_latency_ms *int64
	clearedFields                     map[string]struct{}
	api_key                           *int
	clearedapi_key                    bool
	project                           *int
	clearedproject                    bool
	trace                             *int
	clearedtrace                      bool
	data_storage                      *int
	cleareddata_storage               bool
	executions                        map[int]struct{}
	removedexecutions                 map[int]struct{}
	clearedexecutions                 bool
	channel                           *int
	clearedchannel                    bool
	usage_logs                        map[int]struct{}
	removedusage_logs                 map[int]struct{}
	clearedusage_logs                 bool
	done                              bool
	oldValue                          func(context.Context) (*Request, error)
	predicates                        []predicate.Request
}

var _ ent.Mutation = (*RequestMutation)(nil)

// requestOption allows management of the mutation configuration using functional options.
type requestOption func(*RequestMutation)

// newRequestMutation creates new mutation for the Request entity.
func newRequestMutation(c config, op Op, opts ...requestOption) *RequestMutation {
	m := &RequestMutation{
		config:        c,
		op:            op,
		typ:           TypeRequest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRequestID sets the ID field of the mutation.
func withRequestID(id int) requestOption {
	return func(m *RequestMutation) {
		var (
			err   error
			once  sync.Once
			value *Request
		)
		m.oldValue = func(ctx context.Context) (*Request, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Request.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRequest sets the old Request of the mutation.
func withRequest(node *Request) requestOption {
	return func(m *RequestMutation) {
		m.oldValue = func(context.Context) (*Request, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RequestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RequestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RequestMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RequestMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Request.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RequestMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RequestMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RequestMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RequestMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RequestMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RequestMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetAPIKeyID sets the "api_key_id" field.
func (m *RequestMutation) SetAPIKeyID(i int) {
	m.api_key = &i
}

// APIKeyID returns the value of the "api_key_id" field in the mutation.
func (m *RequestMutation) APIKeyID() (r int, exists bool) {
	v := m.api_key
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIKeyID returns the old "api_key_id" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldAPIKeyID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPIKeyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPIKeyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIKeyID: %w", err)
	}
	return oldValue.APIKeyID, nil
}

// ClearAPIKeyID clears the value of the "api_key_id" field.
func (m *RequestMutation) ClearAPIKeyID() {
	m.api_key = nil
	m.clearedFields[request.FieldAPIKeyID] = struct{}{}
}

// APIKeyIDCleared returns if the "api_key_id" field was cleared in this mutation.
func (m *RequestMutation) APIKeyIDCleared() bool {
	_, ok := m.clearedFields[request.FieldAPIKeyID]
	return ok
}

// ResetAPIKeyID resets all changes to the "api_key_id" field.
func (m *RequestMutation) ResetAPIKeyID() {
	m.api_key = nil
	delete(m.clearedFields, request.FieldAPIKeyID)
}

// SetProjectID sets the "project_id" field.
func (m *RequestMutation) SetProjectID(i int) {
	m.project = &i
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *RequestMutation) ProjectID() (r int, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldProjectID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *RequestMutation) ResetProjectID() {
	m.project = nil
}

// SetTraceID sets the "trace_id" field.
func (m *RequestMutation) SetTraceID(i int) {
	m.trace = &i
}

// TraceID returns the value of the "trace_id" field in the mutation.
func (m *RequestMutation) TraceID() (r int, exists bool) {
	v := m.trace
	if v == nil {
		return
	}
	return *v, true
}

// OldTraceID returns the old "trace_id" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldTraceID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTraceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTraceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTraceID: %w", err)
	}
	return oldValue.TraceID, nil
}

// ClearTraceID clears the value of the "trace_id" field.
func (m *RequestMutation) ClearTraceID() {
	m.trace = nil
	m.clearedFields[request.FieldTraceID] = struct{}{}
}

// TraceIDCleared returns if the "trace_id" field was cleared in this mutation.
func (m *RequestMutation) TraceIDCleared() bool {
	_, ok := m.clearedFields[request.FieldTraceID]
	return ok
}

// ResetTraceID resets all changes to the "trace_id" field.
func (m *RequestMutation) ResetTraceID() {
	m.trace = nil
	delete(m.clearedFields, request.FieldTraceID)
}

// SetDataStorageID sets the "data_storage_id" field.
func (m *RequestMutation) SetDataStorageID(i int) {
	m.data_storage = &i
}

// DataStorageID returns the value of the "data_storage_id" field in the mutation.
func (m *RequestMutation) DataStorageID() (r int, exists bool) {
	v := m.data_storage
	if v == nil {
		return
	}
	return *v, true
}

// OldDataStorageID returns the old "data_storage_id" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldDataStorageID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDataStorageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDataStorageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDataStorageID: %w", err)
	}
	return oldValue.DataStorageID, nil
}

// ClearDataStorageID clears the value of the "data_storage_id" field.
func (m *RequestMutation) ClearDataStorageID() {
	m.data_storage = nil
	m.clearedFields[request.FieldDataStorageID] = struct{}{}
}

// DataStorageIDCleared returns if the "data_storage_id" field was cleared in this mutation.
func (m *RequestMutation) DataStorageIDCleared() bool {
	_, ok := m.clearedFields[request.FieldDataStorageID]
	return ok
}

// ResetDataStorageID resets all changes to the "data_storage_id" field.
func (m *RequestMutation) ResetDataStorageID() {
	m.data_storage = nil
	delete(m.clearedFields, request.FieldDataStorageID)
}

// SetSource sets the "source" field.
func (m *RequestMutation) SetSource(r request.Source) {
	m.source = &r
}

// Source returns the value of the "source" field in the mutation.
func (m *RequestMutation) Source() (r request.Source, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldSource(ctx context.Context) (v request.Source, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *RequestMutation) ResetSource() {
	m.source = nil
}

// SetModelID sets the "model_id" field.
func (m *RequestMutation) SetModelID(s string) {
	m.model_id = &s
}

// ModelID returns the value of the "model_id" field in the mutation.
func (m *RequestMutation) ModelID() (r string, exists bool) {
	v := m.model_id
	if v == nil {
		return
	}
	return *v, true
}

// OldModelID returns the old "model_id" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldModelID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModelID: %w", err)
	}
	return oldValue.ModelID, nil
}

// ResetModelID resets all changes to the "model_id" field.
func (m *RequestMutation) ResetModelID() {
	m.model_id = nil
}

// SetFormat sets the "format" field.
func (m *RequestMutation) SetFormat(s string) {
	m.format = &s
}

// Format returns the value of the "format" field in the mutation.
func (m *RequestMutation) Format() (r string, exists bool) {
	v := m.format
	if v == nil {
		return
	}
	return *v, true
}

// OldFormat returns the old "format" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldFormat(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFormat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFormat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormat: %w", err)
	}
	return oldValue.Format, nil
}

// ResetFormat resets all changes to the "format" field.
func (m *RequestMutation) ResetFormat() {
	m.format = nil
}

// SetRequestHeaders sets the "request_headers" field.
func (m *RequestMutation) SetRequestHeaders(orm objects.JSONRawMessage) {
	m.request_headers = &orm
	m.appendrequest_headers = nil
}

// RequestHeaders returns the value of the "request_headers" field in the mutation.
func (m *RequestMutation) RequestHeaders() (r objects.JSONRawMessage, exists bool) {
	v := m.request_headers
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestHeaders returns the old "request_headers" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldRequestHeaders(ctx context.Context) (v objects.JSONRawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestHeaders is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestHeaders requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestHeaders: %w", err)
	}
	return oldValue.RequestHeaders, nil
}

// AppendRequestHeaders adds orm to the "request_headers" field.
func (m *RequestMutation) AppendRequestHeaders(orm objects.JSONRawMessage) {
	m.appendrequest_headers = append(m.appendrequest_headers, orm...)
}

// AppendedRequestHeaders returns the list of values that were appended to the "request_headers" field in this mutation.
func (m *RequestMutation) AppendedRequestHeaders() (objects.JSONRawMessage, bool) {
	if len(m.appendrequest_headers) == 0 {
		return nil, false
	}
	return m.appendrequest_headers, true
}

// ClearRequestHeaders clears the value of the "request_headers" field.
func (m *RequestMutation) ClearRequestHeaders() {
	m.request_headers = nil
	m.appendrequest_headers = nil
	m.clearedFields[request.FieldRequestHeaders] = struct{}{}
}

// RequestHeadersCleared returns if the "request_headers" field was cleared in this mutation.
func (m *RequestMutation) RequestHeadersCleared() bool {
	_, ok := m.clearedFields[request.FieldRequestHeaders]
	return ok
}

// ResetRequestHeaders resets all changes to the "request_headers" field.
func (m *RequestMutation) ResetRequestHeaders() {
	m.request_headers = nil
	m.appendrequest_headers = nil
	delete(m.clearedFields, request.FieldRequestHeaders)
}

// SetRequestBody sets the "request_body" field.
func (m *RequestMutation) SetRequestBody(orm objects.JSONRawMessage) {
	m.request_body = &orm
	m.appendrequest_body = nil
}

// RequestBody returns the value of the "request_body" field in the mutation.
func (m *RequestMutation) RequestBody() (r objects.JSONRawMessage, exists bool) {
	v := m.request_body
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestBody returns the old "request_body" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldRequestBody(ctx context.Context) (v objects.JSONRawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestBody: %w", err)
	}
	return oldValue.RequestBody, nil
}

// AppendRequestBody adds orm to the "request_body" field.
func (m *RequestMutation) AppendRequestBody(orm objects.JSONRawMessage) {
	m.appendrequest_body = append(m.appendrequest_body, orm...)
}

// AppendedRequestBody returns the list of values that were appended to the "request_body" field in this mutation.
func (m *RequestMutation) AppendedRequestBody() (objects.JSONRawMessage, bool) {
	if len(m.appendrequest_body) == 0 {
		return nil, false
	}
	return m.appendrequest_body, true
}

// ResetRequestBody resets all changes to the "request_body" field.
func (m *RequestMutation) ResetRequestBody() {
	m.request_body = nil
	m.appendrequest_body = nil
}

// SetResponseBody sets the "response_body" field.
func (m *RequestMutation) SetResponseBody(orm objects.JSONRawMessage) {
	m.response_body = &orm
	m.appendresponse_body = nil
}

// ResponseBody returns the value of the "response_body" field in the mutation.
func (m *RequestMutation) ResponseBody() (r objects.JSONRawMessage, exists bool) {
	v := m.response_body
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseBody returns the old "response_body" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldResponseBody(ctx context.Context) (v objects.JSONRawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseBody: %w", err)
	}
	return oldValue.ResponseBody, nil
}

// AppendResponseBody adds orm to the "response_body" field.
func (m *RequestMutation) AppendResponseBody(orm objects.JSONRawMessage) {
	m.appendresponse_body = append(m.appendresponse_body, orm...)
}

// AppendedResponseBody returns the list of values that were appended to the "response_body" field in this mutation.
func (m *RequestMutation) AppendedResponseBody() (objects.JSONRawMessage, bool) {
	if len(m.appendresponse_body) == 0 {
		return nil, false
	}
	return m.appendresponse_body, true
}

// ClearResponseBody clears the value of the "response_body" field.
func (m *RequestMutation) ClearResponseBody() {
	m.response_body = nil
	m.appendresponse_body = nil
	m.clearedFields[request.FieldResponseBody] = struct{}{}
}

// ResponseBodyCleared returns if the "response_body" field was cleared in this mutation.
func (m *RequestMutation) ResponseBodyCleared() bool {
	_, ok := m.clearedFields[request.FieldResponseBody]
	return ok
}

// ResetResponseBody resets all changes to the "response_body" field.
func (m *RequestMutation) ResetResponseBody() {
	m.response_body = nil
	m.appendresponse_body = nil
	delete(m.clearedFields, request.FieldResponseBody)
}

// SetResponseChunks sets the "response_chunks" field.
func (m *RequestMutation) SetResponseChunks(orm []objects.JSONRawMessage) {
	m.response_chunks = &orm
	m.appendresponse_chunks = nil
}

// ResponseChunks returns the value of the "response_chunks" field in the mutation.
func (m *RequestMutation) ResponseChunks() (r []objects.JSONRawMessage, exists bool) {
	v := m.response_chunks
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseChunks returns the old "response_chunks" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldResponseChunks(ctx context.Context) (v []objects.JSONRawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseChunks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseChunks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseChunks: %w", err)
	}
	return oldValue.ResponseChunks, nil
}

// AppendResponseChunks adds orm to the "response_chunks" field.
func (m *RequestMutation) AppendResponseChunks(orm []objects.JSONRawMessage) {
	m.appendresponse_chunks = append(m.appendresponse_chunks, orm...)
}

// AppendedResponseChunks returns the list of values that were appended to the "response_chunks" field in this mutation.
func (m *RequestMutation) AppendedResponseChunks() ([]objects.JSONRawMessage, bool) {
	if len(m.appendresponse_chunks) == 0 {
		return nil, false
	}
	return m.appendresponse_chunks, true
}

// ClearResponseChunks clears the value of the "response_chunks" field.
func (m *RequestMutation) ClearResponseChunks() {
	m.response_chunks = nil
	m.appendresponse_chunks = nil
	m.clearedFields[request.FieldResponseChunks] = struct{}{}
}

// ResponseChunksCleared returns if the "response_chunks" field was cleared in this mutation.
func (m *RequestMutation) ResponseChunksCleared() bool {
	_, ok := m.clearedFields[request.FieldResponseChunks]
	return ok
}

// ResetResponseChunks resets all changes to the "response_chunks" field.
func (m *RequestMutation) ResetResponseChunks() {
	m.response_chunks = nil
	m.appendresponse_chunks = nil
	delete(m.clearedFields, request.FieldResponseChunks)
}

// SetChannelID sets the "channel_id" field.
func (m *RequestMutation) SetChannelID(i int) {
	m.channel = &i
}

// ChannelID returns the value of the "channel_id" field in the mutation.
func (m *RequestMutation) ChannelID() (r int, exists bool) {
	v := m.channel
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelID returns the old "channel_id" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldChannelID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelID: %w", err)
	}
	return oldValue.ChannelID, nil
}

// ClearChannelID clears the value of the "channel_id" field.
func (m *RequestMutation) ClearChannelID() {
	m.channel = nil
	m.clearedFields[request.FieldChannelID] = struct{}{}
}

// ChannelIDCleared returns if the "channel_id" field was cleared in this mutation.
func (m *RequestMutation) ChannelIDCleared() bool {
	_, ok := m.clearedFields[request.FieldChannelID]
	return ok
}

// ResetChannelID resets all changes to the "channel_id" field.
func (m *RequestMutation) ResetChannelID() {
	m.channel = nil
	delete(m.clearedFields, request.FieldChannelID)
}

// SetExternalID sets the "external_id" field.
func (m *RequestMutation) SetExternalID(s string) {
	m.external_id = &s
}

// ExternalID returns the value of the "external_id" field in the mutation.
func (m *RequestMutation) ExternalID() (r string, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old "external_id" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldExternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// ClearExternalID clears the value of the "external_id" field.
func (m *RequestMutation) ClearExternalID() {
	m.external_id = nil
	m.clearedFields[request.FieldExternalID] = struct{}{}
}

// ExternalIDCleared returns if the "external_id" field was cleared in this mutation.
func (m *RequestMutation) ExternalIDCleared() bool {
	_, ok := m.clearedFields[request.FieldExternalID]
	return ok
}

// ResetExternalID resets all changes to the "external_id" field.
func (m *RequestMutation) ResetExternalID() {
	m.external_id = nil
	delete(m.clearedFields, request.FieldExternalID)
}

// SetStatus sets the "status" field.
func (m *RequestMutation) SetStatus(r request.Status) {
	m.status = &r
}

// Status returns the value of the "status" field in the mutation.
func (m *RequestMutation) Status() (r request.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldStatus(ctx context.Context) (v request.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *RequestMutation) ResetStatus() {
	m.status = nil
}

// SetStream sets the "stream" field.
func (m *RequestMutation) SetStream(b bool) {
	m.stream = &b
}

// Stream returns the value of the "stream" field in the mutation.
func (m *RequestMutation) Stream() (r bool, exists bool) {
	v := m.stream
	if v == nil {
		return
	}
	return *v, true
}

// OldStream returns the old "stream" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldStream(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStream is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStream requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStream: %w", err)
	}
	return oldValue.Stream, nil
}

// ResetStream resets all changes to the "stream" field.
func (m *RequestMutation) ResetStream() {
	m.stream = nil
}

// SetClientIP sets the "client_ip" field.
func (m *RequestMutation) SetClientIP(s string) {
	m.client_ip = &s
}

// ClientIP returns the value of the "client_ip" field in the mutation.
func (m *RequestMutation) ClientIP() (r string, exists bool) {
	v := m.client_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldClientIP returns the old "client_ip" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldClientIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientIP: %w", err)
	}
	return oldValue.ClientIP, nil
}

// ResetClientIP resets all changes to the "client_ip" field.
func (m *RequestMutation) ResetClientIP() {
	m.client_ip = nil
}

// SetMetricsLatencyMs sets the "metrics_latency_ms" field.
func (m *RequestMutation) SetMetricsLatencyMs(i int64) {
	m.metrics_latency_ms = &i
	m.addmetrics_latency_ms = nil
}

// MetricsLatencyMs returns the value of the "metrics_latency_ms" field in the mutation.
func (m *RequestMutation) MetricsLatencyMs() (r int64, exists bool) {
	v := m.metrics_latency_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldMetricsLatencyMs returns the old "metrics_latency_ms" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldMetricsLatencyMs(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetricsLatencyMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetricsLatencyMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetricsLatencyMs: %w", err)
	}
	return oldValue.MetricsLatencyMs, nil
}

// AddMetricsLatencyMs adds i to the "metrics_latency_ms" field.
func (m *RequestMutation) AddMetricsLatencyMs(i int64) {
	if m.addmetrics_latency_ms != nil {
		*m.addmetrics_latency_ms += i
	} else {
		m.addmetrics_latency_ms = &i
	}
}

// AddedMetricsLatencyMs returns the value that was added to the "metrics_latency_ms" field in this mutation.
func (m *RequestMutation) AddedMetricsLatencyMs() (r int64, exists bool) {
	v := m.addmetrics_latency_ms
	if v == nil {
		return
	}
	return *v, true
}

// ClearMetricsLatencyMs clears the value of the "metrics_latency_ms" field.
func (m *RequestMutation) ClearMetricsLatencyMs() {
	m.metrics_latency_ms = nil
	m.addmetrics_latency_ms = nil
	m.clearedFields[request.FieldMetricsLatencyMs] = struct{}{}
}

// MetricsLatencyMsCleared returns if the "metrics_latency_ms" field was cleared in this mutation.
func (m *RequestMutation) MetricsLatencyMsCleared() bool {
	_, ok := m.clearedFields[request.FieldMetricsLatencyMs]
	return ok
}

// ResetMetricsLatencyMs resets all changes to the "metrics_latency_ms" field.
func (m *RequestMutation) ResetMetricsLatencyMs() {
	m.metrics_latency_ms = nil
	m.addmetrics_latency_ms = nil
	delete(m.clearedFields, request.FieldMetricsLatencyMs)
}

// SetMetricsFirstTokenLatencyMs sets the "metrics_first_token_latency_ms" field.
func (m *RequestMutation) SetMetricsFirstTokenLatencyMs(i int64) {
	m.metrics_first_token_latency_ms = &i
	m.addmetrics_first_token_latency_ms = nil
}

// MetricsFirstTokenLatencyMs returns the value of the "metrics_first_token_latency_ms" field in the mutation.
func (m *RequestMutation) MetricsFirstTokenLatencyMs() (r int64, exists bool) {
	v := m.metrics_first_token_latency_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldMetricsFirstTokenLatencyMs returns the old "metrics_first_token_latency_ms" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldMetricsFirstTokenLatencyMs(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetricsFirstTokenLatencyMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetricsFirstTokenLatencyMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetricsFirstTokenLatencyMs: %w", err)
	}
	return oldValue.MetricsFirstTokenLatencyMs, nil
}

// AddMetricsFirstTokenLatencyMs adds i to the "metrics_first_token_latency_ms" field.
func (m *RequestMutation) AddMetricsFirstTokenLatencyMs(i int64) {
	if m.addmetrics_first_token_latency_ms != nil {
		*m.addmetrics_first_token_latency_ms += i
	} else {
		m.addmetrics_first_token_latency_ms = &i
	}
}

// AddedMetricsFirstTokenLatencyMs returns the value that was added to the "metrics_first_token_latency_ms" field in this mutation.
func (m *RequestMutation) AddedMetricsFirstTokenLatencyMs() (r int64, exists bool) {
	v := m.addmetrics_first_token_latency_ms
	if v == nil {
		return
	}
	return *v, true
}

// ClearMetricsFirstTokenLatencyMs clears the value of the "metrics_first_token_latency_ms" field.
func (m *RequestMutation) ClearMetricsFirstTokenLatencyMs() {
	m.metrics_first_token_latency_ms = nil
	m.addmetrics_first_token_latency_ms = nil
	m.clearedFields[request.FieldMetricsFirstTokenLatencyMs] = struct{}{}
}

// MetricsFirstTokenLatencyMsCleared returns if the "metrics_first_token_latency_ms" field was cleared in this mutation.
func (m *RequestMutation) MetricsFirstTokenLatencyMsCleared() bool {
	_, ok := m.clearedFields[request.FieldMetricsFirstTokenLatencyMs]
	return ok
}

// ResetMetricsFirstTokenLatencyMs resets all changes to the "metrics_first_token_latency_ms" field.
func (m *RequestMutation) ResetMetricsFirstTokenLatencyMs() {
	m.metrics_first_token_latency_ms = nil
	m.addmetrics_first_token_latency_ms = nil
	delete(m.clearedFields, request.FieldMetricsFirstTokenLatencyMs)
}

// ClearAPIKey clears the "api_key" edge to the APIKey entity.
func (m *RequestMutation) ClearAPIKey() {
	m.clearedapi_key = true
	m.clearedFields[request.FieldAPIKeyID] = struct{}{}
}

// APIKeyCleared reports if the "api_key" edge to the APIKey entity was cleared.
func (m *RequestMutation) APIKeyCleared() bool {
	return m.APIKeyIDCleared() || m.clearedapi_key
}

// APIKeyIDs returns the "api_key" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// APIKeyID instead. It exists only for internal usage by the builders.
func (m *RequestMutation) APIKeyIDs() (ids []int) {
	if id := m.api_key; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAPIKey resets all changes to the "api_key" edge.
func (m *RequestMutation) ResetAPIKey() {
	m.api_key = nil
	m.clearedapi_key = false
}

// ClearProject clears the "project" edge to the Project entity.
func (m *RequestMutation) ClearProject() {
	m.clearedproject = true
	m.clearedFields[request.FieldProjectID] = struct{}{}
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *RequestMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *RequestMutation) ProjectIDs() (ids []int) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *RequestMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// ClearTrace clears the "trace" edge to the Trace entity.
func (m *RequestMutation) ClearTrace() {
	m.clearedtrace = true
	m.clearedFields[request.FieldTraceID] = struct{}{}
}

// TraceCleared reports if the "trace" edge to the Trace entity was cleared.
func (m *RequestMutation) TraceCleared() bool {
	return m.TraceIDCleared() || m.clearedtrace
}

// TraceIDs returns the "trace" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TraceID instead. It exists only for internal usage by the builders.
func (m *RequestMutation) TraceIDs() (ids []int) {
	if id := m.trace; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTrace resets all changes to the "trace" edge.
func (m *RequestMutation) ResetTrace() {
	m.trace = nil
	m.clearedtrace = false
}

// ClearDataStorage clears the "data_storage" edge to the DataStorage entity.
func (m *RequestMutation) ClearDataStorage() {
	m.cleareddata_storage = true
	m.clearedFields[request.FieldDataStorageID] = struct{}{}
}

// DataStorageCleared reports if the "data_storage" edge to the DataStorage entity was cleared.
func (m *RequestMutation) DataStorageCleared() bool {
	return m.DataStorageIDCleared() || m.cleareddata_storage
}

// DataStorageIDs returns the "data_storage" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DataStorageID instead. It exists only for internal usage by the builders.
func (m *RequestMutation) DataStorageIDs() (ids []int) {
	if id := m.data_storage; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDataStorage resets all changes to the "data_storage" edge.
func (m *RequestMutation) ResetDataStorage() {
	m.data_storage = nil
	m.cleareddata_storage = false
}

// AddExecutionIDs adds the "executions" edge to the RequestExecution entity by ids.
func (m *RequestMutation) AddExecutionIDs(ids ...int) {
	if m.executions == nil {
		m.executions = make(map[int]struct{})
	}
	for i := range ids {
		m.executions[ids[i]] = struct{}{}
	}
}

// ClearExecutions clears the "executions" edge to the RequestExecution entity.
func (m *RequestMutation) ClearExecutions() {
	m.clearedexecutions = true
}

// ExecutionsCleared reports if the "executions" edge to the RequestExecution entity was cleared.
func (m *RequestMutation) ExecutionsCleared() bool {
	return m.clearedexecutions
}

// RemoveExecutionIDs removes the "executions" edge to the RequestExecution entity by IDs.
func (m *RequestMutation) RemoveExecutionIDs(ids ...int) {
	if m.removedexecutions == nil {
		m.removedexecutions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.executions, ids[i])
		m.removedexecutions[ids[i]] = struct{}{}
	}
}

// RemovedExecutions returns the removed IDs of the "executions" edge to the RequestExecution entity.
func (m *RequestMutation) RemovedExecutionsIDs() (ids []int) {
	for id := range m.removedexecutions {
		ids = append(ids, id)
	}
	return
}

// ExecutionsIDs returns the "executions" edge IDs in the mutation.
func (m *RequestMutation) ExecutionsIDs() (ids []int) {
	for id := range m.executions {
		ids = append(ids, id)
	}
	return
}

// ResetExecutions resets all changes to the "executions" edge.
func (m *RequestMutation) ResetExecutions() {
	m.executions = nil
	m.clearedexecutions = false
	m.removedexecutions = nil
}

// ClearChannel clears the "channel" edge to the Channel entity.
func (m *RequestMutation) ClearChannel() {
	m.clearedchannel = true
	m.clearedFields[request.FieldChannelID] = struct{}{}
}

// ChannelCleared reports if the "channel" edge to the Channel entity was cleared.
func (m *RequestMutation) ChannelCleared() bool {
	return m.ChannelIDCleared() || m.clearedchannel
}

// ChannelIDs returns the "channel" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChannelID instead. It exists only for internal usage by the builders.
func (m *RequestMutation) ChannelIDs() (ids []int) {
	if id := m.channel; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChannel resets all changes to the "channel" edge.
func (m *RequestMutation) ResetChannel() {
	m.channel = nil
	m.clearedchannel = false
}

// AddUsageLogIDs adds the "usage_logs" edge to the UsageLog entity by ids.
func (m *RequestMutation) AddUsageLogIDs(ids ...int) {
	if m.usage_logs == nil {
		m.usage_logs = make(map[int]struct{})
	}
	for i := range ids {
		m.usage_logs[ids[i]] = struct{}{}
	}
}

// ClearUsageLogs clears the "usage_logs" edge to the UsageLog entity.
func (m *RequestMutation) ClearUsageLogs() {
	m.clearedusage_logs = true
}

// UsageLogsCleared reports if the "usage_logs" edge to the UsageLog entity was cleared.
func (m *RequestMutation) UsageLogsCleared() bool {
	return m.clearedusage_logs
}

// RemoveUsageLogIDs removes the "usage_logs" edge to the UsageLog entity by IDs.
func (m *RequestMutation) RemoveUsageLogIDs(ids ...int) {
	if m.removedusage_logs == nil {
		m.removedusage_logs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.usage_logs, ids[i])
		m.removedusage_logs[ids[i]] = struct{}{}
	}
}

// RemovedUsageLogs returns the removed IDs of the "usage_logs" edge to the UsageLog entity.
func (m *RequestMutation) RemovedUsageLogsIDs() (ids []int) {
	for id := range m.removedusage_logs {
		ids = append(ids, id)
	}
	return
}

// UsageLogsIDs returns the "usage_logs" edge IDs in the mutation.
func (m *RequestMutation) UsageLogsIDs() (ids []int) {
	for id := range m.usage_logs {
		ids = append(ids, id)
	}
	return
}

// ResetUsageLogs resets all changes to the "usage_logs" edge.
func (m *RequestMutation) ResetUsageLogs() {
	m.usage_logs = nil
	m.clearedusage_logs = false
	m.removedusage_logs = nil
}

// Where appends a list predicates to the RequestMutation builder.
func (m *RequestMutation) Where(ps ...predicate.Request) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RequestMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RequestMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Request, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RequestMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RequestMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Request).
func (m *RequestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RequestMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.created_at != nil {
		fields = append(fields, request.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, request.FieldUpdatedAt)
	}
	if m.api_key != nil {
		fields = append(fields, request.FieldAPIKeyID)
	}
	if m.project != nil {
		fields = append(fields, request.FieldProjectID)
	}
	if m.trace != nil {
		fields = append(fields, request.FieldTraceID)
	}
	if m.data_storage != nil {
		fields = append(fields, request.FieldDataStorageID)
	}
	if m.source != nil {
		fields = append(fields, request.FieldSource)
	}
	if m.model_id != nil {
		fields = append(fields, request.FieldModelID)
	}
	if m.format != nil {
		fields = append(fields, request.FieldFormat)
	}
	if m.request_headers != nil {
		fields = append(fields, request.FieldRequestHeaders)
	}
	if m.request_body != nil {
		fields = append(fields, request.FieldRequestBody)
	}
	if m.response_body != nil {
		fields = append(fields, request.FieldResponseBody)
	}
	if m.response_chunks != nil {
		fields = append(fields, request.FieldResponseChunks)
	}
	if m.channel != nil {
		fields = append(fields, request.FieldChannelID)
	}
	if m.external_id != nil {
		fields = append(fields, request.FieldExternalID)
	}
	if m.status != nil {
		fields = append(fields, request.FieldStatus)
	}
	if m.stream != nil {
		fields = append(fields, request.FieldStream)
	}
	if m.client_ip != nil {
		fields = append(fields, request.FieldClientIP)
	}
	if m.metrics_latency_ms != nil {
		fields = append(fields, request.FieldMetricsLatencyMs)
	}
	if m.metrics_first_token_latency_ms != nil {
		fields = append(fields, request.FieldMetricsFirstTokenLatencyMs)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RequestMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case request.FieldCreatedAt:
		return m.CreatedAt()
	case request.FieldUpdatedAt:
		return m.UpdatedAt()
	case request.FieldAPIKeyID:
		return m.APIKeyID()
	case request.FieldProjectID:
		return m.ProjectID()
	case request.FieldTraceID:
		return m.TraceID()
	case request.FieldDataStorageID:
		return m.DataStorageID()
	case request.FieldSource:
		return m.Source()
	case request.FieldModelID:
		return m.ModelID()
	case request.FieldFormat:
		return m.Format()
	case request.FieldRequestHeaders:
		return m.RequestHeaders()
	case request.FieldRequestBody:
		return m.RequestBody()
	case request.FieldResponseBody:
		return m.ResponseBody()
	case request.FieldResponseChunks:
		return m.ResponseChunks()
	case request.FieldChannelID:
		return m.ChannelID()
	case request.FieldExternalID:
		return m.ExternalID()
	case request.FieldStatus:
		return m.Status()
	case request.FieldStream:
		return m.Stream()
	case request.FieldClientIP:
		return m.ClientIP()
	case request.FieldMetricsLatencyMs:
		return m.MetricsLatencyMs()
	case request.FieldMetricsFirstTokenLatencyMs:
		return m.MetricsFirstTokenLatencyMs()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RequestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case request.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case request.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case request.FieldAPIKeyID:
		return m.OldAPIKeyID(ctx)
	case request.FieldProjectID:
		return m.OldProjectID(ctx)
	case request.FieldTraceID:
		return m.OldTraceID(ctx)
	case request.FieldDataStorageID:
		return m.OldDataStorageID(ctx)
	case request.FieldSource:
		return m.OldSource(ctx)
	case request.FieldModelID:
		return m.OldModelID(ctx)
	case request.FieldFormat:
		return m.OldFormat(ctx)
	case request.FieldRequestHeaders:
		return m.OldRequestHeaders(ctx)
	case request.FieldRequestBody:
		return m.OldRequestBody(ctx)
	case request.FieldResponseBody:
		return m.OldResponseBody(ctx)
	case request.FieldResponseChunks:
		return m.OldResponseChunks(ctx)
	case request.FieldChannelID:
		return m.OldChannelID(ctx)
	case request.FieldExternalID:
		return m.OldExternalID(ctx)
	case request.FieldStatus:
		return m.OldStatus(ctx)
	case request.FieldStream:
		return m.OldStream(ctx)
	case request.FieldClientIP:
		return m.OldClientIP(ctx)
	case request.FieldMetricsLatencyMs:
		return m.OldMetricsLatencyMs(ctx)
	case request.FieldMetricsFirstTokenLatencyMs:
		return m.OldMetricsFirstTokenLatencyMs(ctx)
	}
	return nil, fmt.Errorf("unknown Request field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RequestMutation) SetField(name string, value ent.Value) error {
	switch name {
	case request.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case request.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case request.FieldAPIKeyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIKeyID(v)
		return nil
	case request.FieldProjectID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case request.FieldTraceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTraceID(v)
		return nil
	case request.FieldDataStorageID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDataStorageID(v)
		return nil
	case request.FieldSource:
		v, ok := value.(request.Source)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case request.FieldModelID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModelID(v)
		return nil
	case request.FieldFormat:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormat(v)
		return nil
	case request.FieldRequestHeaders:
		v, ok := value.(objects.JSONRawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestHeaders(v)
		return nil
	case request.FieldRequestBody:
		v, ok := value.(objects.JSONRawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestBody(v)
		return nil
	case request.FieldResponseBody:
		v, ok := value.(objects.JSONRawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseBody(v)
		return nil
	case request.FieldResponseChunks:
		v, ok := value.([]objects.JSONRawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseChunks(v)
		return nil
	case request.FieldChannelID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelID(v)
		return nil
	case request.FieldExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	case request.FieldStatus:
		v, ok := value.(request.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case request.FieldStream:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStream(v)
		return nil
	case request.FieldClientIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientIP(v)
		return nil
	case request.FieldMetricsLatencyMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetricsLatencyMs(v)
		return nil
	case request.FieldMetricsFirstTokenLatencyMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetricsFirstTokenLatencyMs(v)
		return nil
	}
	return fmt.Errorf("unknown Request field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RequestMutation) AddedFields() []string {
	var fields []string
	if m.addmetrics_latency_ms != nil {
		fields = append(fields, request.FieldMetricsLatencyMs)
	}
	if m.addmetrics_first_token_latency_ms != nil {
		fields = append(fields, request.FieldMetricsFirstTokenLatencyMs)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RequestMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case request.FieldMetricsLatencyMs:
		return m.AddedMetricsLatencyMs()
	case request.FieldMetricsFirstTokenLatencyMs:
		return m.AddedMetricsFirstTokenLatencyMs()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RequestMutation) AddField(name string, value ent.Value) error {
	switch name {
	case request.FieldMetricsLatencyMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMetricsLatencyMs(v)
		return nil
	case request.FieldMetricsFirstTokenLatencyMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMetricsFirstTokenLatencyMs(v)
		return nil
	}
	return fmt.Errorf("unknown Request numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RequestMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(request.FieldAPIKeyID) {
		fields = append(fields, request.FieldAPIKeyID)
	}
	if m.FieldCleared(request.FieldTraceID) {
		fields = append(fields, request.FieldTraceID)
	}
	if m.FieldCleared(request.FieldDataStorageID) {
		fields = append(fields, request.FieldDataStorageID)
	}
	if m.FieldCleared(request.FieldRequestHeaders) {
		fields = append(fields, request.FieldRequestHeaders)
	}
	if m.FieldCleared(request.FieldResponseBody) {
		fields = append(fields, request.FieldResponseBody)
	}
	if m.FieldCleared(request.FieldResponseChunks) {
		fields = append(fields, request.FieldResponseChunks)
	}
	if m.FieldCleared(request.FieldChannelID) {
		fields = append(fields, request.FieldChannelID)
	}
	if m.FieldCleared(request.FieldExternalID) {
		fields = append(fields, request.FieldExternalID)
	}
	if m.FieldCleared(request.FieldMetricsLatencyMs) {
		fields = append(fields, request.FieldMetricsLatencyMs)
	}
	if m.FieldCleared(request.FieldMetricsFirstTokenLatencyMs) {
		fields = append(fields, request.FieldMetricsFirstTokenLatencyMs)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RequestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RequestMutation) ClearField(name string) error {
	switch name {
	case request.FieldAPIKeyID:
		m.ClearAPIKeyID()
		return nil
	case request.FieldTraceID:
		m.ClearTraceID()
		return nil
	case request.FieldDataStorageID:
		m.ClearDataStorageID()
		return nil
	case request.FieldRequestHeaders:
		m.ClearRequestHeaders()
		return nil
	case request.FieldResponseBody:
		m.ClearResponseBody()
		return nil
	case request.FieldResponseChunks:
		m.ClearResponseChunks()
		return nil
	case request.FieldChannelID:
		m.ClearChannelID()
		return nil
	case request.FieldExternalID:
		m.ClearExternalID()
		return nil
	case request.FieldMetricsLatencyMs:
		m.ClearMetricsLatencyMs()
		return nil
	case request.FieldMetricsFirstTokenLatencyMs:
		m.ClearMetricsFirstTokenLatencyMs()
		return nil
	}
	return fmt.Errorf("unknown Request nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RequestMutation) ResetField(name string) error {
	switch name {
	case request.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case request.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case request.FieldAPIKeyID:
		m.ResetAPIKeyID()
		return nil
	case request.FieldProjectID:
		m.ResetProjectID()
		return nil
	case request.FieldTraceID:
		m.ResetTraceID()
		return nil
	case request.FieldDataStorageID:
		m.ResetDataStorageID()
		return nil
	case request.FieldSource:
		m.ResetSource()
		return nil
	case request.FieldModelID:
		m.ResetModelID()
		return nil
	case request.FieldFormat:
		m.ResetFormat()
		return nil
	case request.FieldRequestHeaders:
		m.ResetRequestHeaders()
		return nil
	case request.FieldRequestBody:
		m.ResetRequestBody()
		return nil
	case request.FieldResponseBody:
		m.ResetResponseBody()
		return nil
	case request.FieldResponseChunks:
		m.ResetResponseChunks()
		return nil
	case request.FieldChannelID:
		m.ResetChannelID()
		return nil
	case request.FieldExternalID:
		m.ResetExternalID()
		return nil
	case request.FieldStatus:
		m.ResetStatus()
		return nil
	case request.FieldStream:
		m.ResetStream()
		return nil
	case request.FieldClientIP:
		m.ResetClientIP()
		return nil
	case request.FieldMetricsLatencyMs:
		m.ResetMetricsLatencyMs()
		return nil
	case request.FieldMetricsFirstTokenLatencyMs:
		m.ResetMetricsFirstTokenLatencyMs()
		return nil
	}
	return fmt.Errorf("unknown Request field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RequestMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.api_key != nil {
		edges = append(edges, request.EdgeAPIKey)
	}
	if m.project != nil {
		edges = append(edges, request.EdgeProject)
	}
	if m.trace != nil {
		edges = append(edges, request.EdgeTrace)
	}
	if m.data_storage != nil {
		edges = append(edges, request.EdgeDataStorage)
	}
	if m.executions != nil {
		edges = append(edges, request.EdgeExecutions)
	}
	if m.channel != nil {
		edges = append(edges, request.EdgeChannel)
	}
	if m.usage_logs != nil {
		edges = append(edges, request.EdgeUsageLogs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RequestMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case request.EdgeAPIKey:
		if id := m.api_key; id != nil {
			return []ent.Value{*id}
		}
	case request.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case request.EdgeTrace:
		if id := m.trace; id != nil {
			return []ent.Value{*id}
		}
	case request.EdgeDataStorage:
		if id := m.data_storage; id != nil {
			return []ent.Value{*id}
		}
	case request.EdgeExecutions:
		ids := make([]ent.Value, 0, len(m.executions))
		for id := range m.executions {
			ids = append(ids, id)
		}
		return ids
	case request.EdgeChannel:
		if id := m.channel; id != nil {
			return []ent.Value{*id}
		}
	case request.EdgeUsageLogs:
		ids := make([]ent.Value, 0, len(m.usage_logs))
		for id := range m.usage_logs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RequestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedexecutions != nil {
		edges = append(edges, request.EdgeExecutions)
	}
	if m.removedusage_logs != nil {
		edges = append(edges, request.EdgeUsageLogs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RequestMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case request.EdgeExecutions:
		ids := make([]ent.Value, 0, len(m.removedexecutions))
		for id := range m.removedexecutions {
			ids = append(ids, id)
		}
		return ids
	case request.EdgeUsageLogs:
		ids := make([]ent.Value, 0, len(m.removedusage_logs))
		for id := range m.removedusage_logs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RequestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedapi_key {
		edges = append(edges, request.EdgeAPIKey)
	}
	if m.clearedproject {
		edges = append(edges, request.EdgeProject)
	}
	if m.clearedtrace {
		edges = append(edges, request.EdgeTrace)
	}
	if m.cleareddata_storage {
		edges = append(edges, request.EdgeDataStorage)
	}
	if m.clearedexecutions {
		edges = append(edges, request.EdgeExecutions)
	}
	if m.clearedchannel {
		edges = append(edges, request.EdgeChannel)
	}
	if m.clearedusage_logs {
		edges = append(edges, request.EdgeUsageLogs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RequestMutation) EdgeCleared(name string) bool {
	switch name {
	case request.EdgeAPIKey:
		return m.clearedapi_key
	case request.EdgeProject:
		return m.clearedproject
	case request.EdgeTrace:
		return m.clearedtrace
	case request.EdgeDataStorage:
		return m.cleareddata_storage
	case request.EdgeExecutions:
		return m.clearedexecutions
	case request.EdgeChannel:
		return m.clearedchannel
	case request.EdgeUsageLogs:
		return m.clearedusage_logs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RequestMutation) ClearEdge(name string) error {
	switch name {
	case request.EdgeAPIKey:
		m.ClearAPIKey()
		return nil
	case request.EdgeProject:
		m.ClearProject()
		return nil
	case request.EdgeTrace:
		m.ClearTrace()
		return nil
	case request.EdgeDataStorage:
		m.ClearDataStorage()
		return nil
	case request.EdgeChannel:
		m.ClearChannel()
		return nil
	}
	return fmt.Errorf("unknown Request unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RequestMutation) ResetEdge(name string) error {
	switch name {
	case request.EdgeAPIKey:
		m.ResetAPIKey()
		return nil
	case request.EdgeProject:
		m.ResetProject()
		return nil
	case request.EdgeTrace:
		m.ResetTrace()
		return nil
	case request.EdgeDataStorage:
		m.ResetDataStorage()
		return nil
	case request.EdgeExecutions:
		m.ResetExecutions()
		return nil
	case request.EdgeChannel:
		m.ResetChannel()
		return nil
	case request.EdgeUsageLogs:
		m.ResetUsageLogs()
		return nil
	}
	return fmt.Errorf("unknown Request edge %s", name)
}

// RequestExecutionMutation represents an operation that mutates the RequestExecution nodes in the graph.
type RequestExecutionMutation struct {
	config
	op                                Op
	typ                               string
	id                                *int
	created_at                        *time.Time
	updated_at                        *time.Time
	project_id                        *int
	addproject_id                     *int
	external_id                       *string
	model_id                          *string
	format                            *string
	request_body                      *objects.JSONRawMessage
	appendrequest_body                objects.JSONRawMessage
	response_body                     *objects.JSONRawMessage
	appendresponse_body               objects.JSONRawMessage
	response_chunks                   *[]objects.JSONRawMessage
	appendresponse_chunks             []objects.JSONRawMessage
	error_message                     *string
	status                            *requestexecution.Status
	stream                            *bool
	metrics_latency_ms                *int64
	addmetrics_latency_ms             *int64
	metrics_first_token_latency_ms    *int64
	addmetrics_first_token_latency_ms *int64
	request_headers                   *objects.JSONRawMessage
	appendrequest_headers             objects.JSONRawMessage
	clearedFields                     map[string]struct{}
	request                           *int
	clearedrequest                    bool
	channel                           *int
	clearedchannel                    bool
	data_storage                      *int
	cleareddata_storage               bool
	done                              bool
	oldValue                          func(context.Context) (*RequestExecution, error)
	predicates                        []predicate.RequestExecution
}

var _ ent.Mutation = (*RequestExecutionMutation)(nil)

// requestexecutionOption allows management of the mutation configuration using functional options.
type requestexecutionOption func(*RequestExecutionMutation)

// newRequestExecutionMutation creates new mutation for the RequestExecution entity.
func newRequestExecutionMutation(c config, op Op, opts ...requestexecutionOption) *RequestExecutionMutation {
	m := &RequestExecutionMutation{
		config:        c,
		op:            op,
		typ:           TypeRequestExecution,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRequestExecutionID sets the ID field of the mutation.
func withRequestExecutionID(id int) requestexecutionOption {
	return func(m *RequestExecutionMutation) {
		var (
			err   error
			once  sync.Once
			value *RequestExecution
		)
		m.oldValue = func(ctx context.Context) (*RequestExecution, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RequestExecution.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRequestExecution sets the old RequestExecution of the mutation.
func withRequestExecution(node *RequestExecution) requestexecutionOption {
	return func(m *RequestExecutionMutation) {
		m.oldValue = func(context.Context) (*RequestExecution, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RequestExecutionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RequestExecutionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RequestExecutionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RequestExecutionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RequestExecution.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RequestExecutionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RequestExecutionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RequestExecution entity.
// If the RequestExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestExecutionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RequestExecutionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RequestExecutionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RequestExecutionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RequestExecution entity.
// If the RequestExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestExecutionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RequestExecutionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetProjectID sets the "project_id" field.
func (m *RequestExecutionMutation) SetProjectID(i int) {
	m.project_id = &i
	m.addproject_id = nil
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *RequestExecutionMutation) ProjectID() (r int, exists bool) {
	v := m.project_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the RequestExecution entity.
// If the RequestExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestExecutionMutation) OldProjectID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// AddProjectID adds i to the "project_id" field.
func (m *RequestExecutionMutation) AddProjectID(i int) {
	if m.addproject_id != nil {
		*m.addproject_id += i
	} else {
		m.addproject_id = &i
	}
}

// AddedProjectID returns the value that was added to the "project_id" field in this mutation.
func (m *RequestExecutionMutation) AddedProjectID() (r int, exists bool) {
	v := m.addproject_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *RequestExecutionMutation) ResetProjectID() {
	m.project_id = nil
	m.addproject_id = nil
}

// SetRequestID sets the "request_id" field.
func (m *RequestExecutionMutation) SetRequestID(i int) {
	m.request = &i
}

// RequestID returns the value of the "request_id" field in the mutation.
func (m *RequestExecutionMutation) RequestID() (r int, exists bool) {
	v := m.request
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestID returns the old "request_id" field's value of the RequestExecution entity.
// If the RequestExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestExecutionMutation) OldRequestID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestID: %w", err)
	}
	return oldValue.RequestID, nil
}

// ResetRequestID resets all changes to the "request_id" field.
func (m *RequestExecutionMutation) ResetRequestID() {
	m.request = nil
}

// SetChannelID sets the "channel_id" field.
func (m *RequestExecutionMutation) SetChannelID(i int) {
	m.channel = &i
}

// ChannelID returns the value of the "channel_id" field in the mutation.
func (m *RequestExecutionMutation) ChannelID() (r int, exists bool) {
	v := m.channel
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelID returns the old "channel_id" field's value of the RequestExecution entity.
// If the RequestExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestExecutionMutation) OldChannelID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelID: %w", err)
	}
	return oldValue.ChannelID, nil
}

// ClearChannelID clears the value of the "channel_id" field.
func (m *RequestExecutionMutation) ClearChannelID() {
	m.channel = nil
	m.clearedFields[requestexecution.FieldChannelID] = struct{}{}
}

// ChannelIDCleared returns if the "channel_id" field was cleared in this mutation.
func (m *RequestExecutionMutation) ChannelIDCleared() bool {
	_, ok := m.clearedFields[requestexecution.FieldChannelID]
	return ok
}

// ResetChannelID resets all changes to the "channel_id" field.
func (m *RequestExecutionMutation) ResetChannelID() {
	m.channel = nil
	delete(m.clearedFields, requestexecution.FieldChannelID)
}

// SetDataStorageID sets the "data_storage_id" field.
func (m *RequestExecutionMutation) SetDataStorageID(i int) {
	m.data_storage = &i
}

// DataStorageID returns the value of the "data_storage_id" field in the mutation.
func (m *RequestExecutionMutation) DataStorageID() (r int, exists bool) {
	v := m.data_storage
	if v == nil {
		return
	}
	return *v, true
}

// OldDataStorageID returns the old "data_storage_id" field's value of the RequestExecution entity.
// If the RequestExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestExecutionMutation) OldDataStorageID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDataStorageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDataStorageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDataStorageID: %w", err)
	}
	return oldValue.DataStorageID, nil
}

// ClearDataStorageID clears the value of the "data_storage_id" field.
func (m *RequestExecutionMutation) ClearDataStorageID() {
	m.data_storage = nil
	m.clearedFields[requestexecution.FieldDataStorageID] = struct{}{}
}

// DataStorageIDCleared returns if the "data_storage_id" field was cleared in this mutation.
func (m *RequestExecutionMutation) DataStorageIDCleared() bool {
	_, ok := m.clearedFields[requestexecution.FieldDataStorageID]
	return ok
}

// ResetDataStorageID resets all changes to the "data_storage_id" field.
func (m *RequestExecutionMutation) ResetDataStorageID() {
	m.data_storage = nil
	delete(m.clearedFields, requestexecution.FieldDataStorageID)
}

// SetExternalID sets the "external_id" field.
func (m *RequestExecutionMutation) SetExternalID(s string) {
	m.external_id = &s
}

// ExternalID returns the value of the "external_id" field in the mutation.
func (m *RequestExecutionMutation) ExternalID() (r string, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old "external_id" field's value of the RequestExecution entity.
// If the RequestExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestExecutionMutation) OldExternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// ClearExternalID clears the value of the "external_id" field.
func (m *RequestExecutionMutation) ClearExternalID() {
	m.external_id = nil
	m.clearedFields[requestexecution.FieldExternalID] = struct{}{}
}

// ExternalIDCleared returns if the "external_id" field was cleared in this mutation.
func (m *RequestExecutionMutation) ExternalIDCleared() bool {
	_, ok := m.clearedFields[requestexecution.FieldExternalID]
	return ok
}

// ResetExternalID resets all changes to the "external_id" field.
func (m *RequestExecutionMutation) ResetExternalID() {
	m.external_id = nil
	delete(m.clearedFields, requestexecution.FieldExternalID)
}

// SetModelID sets the "model_id" field.
func (m *RequestExecutionMutation) SetModelID(s string) {
	m.model_id = &s
}

// ModelID returns the value of the "model_id" field in the mutation.
func (m *RequestExecutionMutation) ModelID() (r string, exists bool) {
	v := m.model_id
	if v == nil {
		return
	}
	return *v, true
}

// OldModelID returns the old "model_id" field's value of the RequestExecution entity.
// If the RequestExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestExecutionMutation) OldModelID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModelID: %w", err)
	}
	return oldValue.ModelID, nil
}

// ResetModelID resets all changes to the "model_id" field.
func (m *RequestExecutionMutation) ResetModelID() {
	m.model_id = nil
}

// SetFormat sets the "format" field.
func (m *RequestExecutionMutation) SetFormat(s string) {
	m.format = &s
}

// Format returns the value of the "format" field in the mutation.
func (m *RequestExecutionMutation) Format() (r string, exists bool) {
	v := m.format
	if v == nil {
		return
	}
	return *v, true
}

// OldFormat returns the old "format" field's value of the RequestExecution entity.
// If the RequestExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestExecutionMutation) OldFormat(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFormat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFormat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormat: %w", err)
	}
	return oldValue.Format, nil
}

// ResetFormat resets all changes to the "format" field.
func (m *RequestExecutionMutation) ResetFormat() {
	m.format = nil
}

// SetRequestBody sets the "request_body" field.
func (m *RequestExecutionMutation) SetRequestBody(orm objects.JSONRawMessage) {
	m.request_body = &orm
	m.appendrequest_body = nil
}

// RequestBody returns the value of the "request_body" field in the mutation.
func (m *RequestExecutionMutation) RequestBody() (r objects.JSONRawMessage, exists bool) {
	v := m.request_body
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestBody returns the old "request_body" field's value of the RequestExecution entity.
// If the RequestExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestExecutionMutation) OldRequestBody(ctx context.Context) (v objects.JSONRawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestBody: %w", err)
	}
	return oldValue.RequestBody, nil
}

// AppendRequestBody adds orm to the "request_body" field.
func (m *RequestExecutionMutation) AppendRequestBody(orm objects.JSONRawMessage) {
	m.appendrequest_body = append(m.appendrequest_body, orm...)
}

// AppendedRequestBody returns the list of values that were appended to the "request_body" field in this mutation.
func (m *RequestExecutionMutation) AppendedRequestBody() (objects.JSONRawMessage, bool) {
	if len(m.appendrequest_body) == 0 {
		return nil, false
	}
	return m.appendrequest_body, true
}

// ResetRequestBody resets all changes to the "request_body" field.
func (m *RequestExecutionMutation) ResetRequestBody() {
	m.request_body = nil
	m.appendrequest_body = nil
}

// SetResponseBody sets the "response_body" field.
func (m *RequestExecutionMutation) SetResponseBody(orm objects.JSONRawMessage) {
	m.response_body = &orm
	m.appendresponse_body = nil
}

// ResponseBody returns the value of the "response_body" field in the mutation.
func (m *RequestExecutionMutation) ResponseBody() (r objects.JSONRawMessage, exists bool) {
	v := m.response_body
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseBody returns the old "response_body" field's value of the RequestExecution entity.
// If the RequestExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestExecutionMutation) OldResponseBody(ctx context.Context) (v objects.JSONRawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseBody: %w", err)
	}
	return oldValue.ResponseBody, nil
}

// AppendResponseBody adds orm to the "response_body" field.
func (m *RequestExecutionMutation) AppendResponseBody(orm objects.JSONRawMessage) {
	m.appendresponse_body = append(m.appendresponse_body, orm...)
}

// AppendedResponseBody returns the list of values that were appended to the "response_body" field in this mutation.
func (m *RequestExecutionMutation) AppendedResponseBody() (objects.JSONRawMessage, bool) {
	if len(m.appendresponse_body) == 0 {
		return nil, false
	}
	return m.appendresponse_body, true
}

// ClearResponseBody clears the value of the "response_body" field.
func (m *RequestExecutionMutation) ClearResponseBody() {
	m.response_body = nil
	m.appendresponse_body = nil
	m.clearedFields[requestexecution.FieldResponseBody] = struct{}{}
}

// ResponseBodyCleared returns if the "response_body" field was cleared in this mutation.
func (m *RequestExecutionMutation) ResponseBodyCleared() bool {
	_, ok := m.clearedFields[requestexecution.FieldResponseBody]
	return ok
}

// ResetResponseBody resets all changes to the "response_body" field.
func (m *RequestExecutionMutation) ResetResponseBody() {
	m.response_body = nil
	m.appendresponse_body = nil
	delete(m.clearedFields, requestexecution.FieldResponseBody)
}

// SetResponseChunks sets the "response_chunks" field.
func (m *RequestExecutionMutation) SetResponseChunks(orm []objects.JSONRawMessage) {
	m.response_chunks = &orm
	m.appendresponse_chunks = nil
}

// ResponseChunks returns the value of the "response_chunks" field in the mutation.
func (m *RequestExecutionMutation) ResponseChunks() (r []objects.JSONRawMessage, exists bool) {
	v := m.response_chunks
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseChunks returns the old "response_chunks" field's value of the RequestExecution entity.
// If the RequestExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestExecutionMutation) OldResponseChunks(ctx context.Context) (v []objects.JSONRawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseChunks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseChunks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseChunks: %w", err)
	}
	return oldValue.ResponseChunks, nil
}

// AppendResponseChunks adds orm to the "response_chunks" field.
func (m *RequestExecutionMutation) AppendResponseChunks(orm []objects.JSONRawMessage) {
	m.appendresponse_chunks = append(m.appendresponse_chunks, orm...)
}

// AppendedResponseChunks returns the list of values that were appended to the "response_chunks" field in this mutation.
func (m *RequestExecutionMutation) AppendedResponseChunks() ([]objects.JSONRawMessage, bool) {
	if len(m.appendresponse_chunks) == 0 {
		return nil, false
	}
	return m.appendresponse_chunks, true
}

// ClearResponseChunks clears the value of the "response_chunks" field.
func (m *RequestExecutionMutation) ClearResponseChunks() {
	m.response_chunks = nil
	m.appendresponse_chunks = nil
	m.clearedFields[requestexecution.FieldResponseChunks] = struct{}{}
}

// ResponseChunksCleared returns if the "response_chunks" field was cleared in this mutation.
func (m *RequestExecutionMutation) ResponseChunksCleared() bool {
	_, ok := m.clearedFields[requestexecution.FieldResponseChunks]
	return ok
}

// ResetResponseChunks resets all changes to the "response_chunks" field.
func (m *RequestExecutionMutation) ResetResponseChunks() {
	m.response_chunks = nil
	m.appendresponse_chunks = nil
	delete(m.clearedFields, requestexecution.FieldResponseChunks)
}

// SetErrorMessage sets the "error_message" field.
func (m *RequestExecutionMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *RequestExecutionMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the RequestExecution entity.
// If the RequestExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestExecutionMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *RequestExecutionMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[requestexecution.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *RequestExecutionMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[requestexecution.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *RequestExecutionMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, requestexecution.FieldErrorMessage)
}

// SetStatus sets the "status" field.
func (m *RequestExecutionMutation) SetStatus(r requestexecution.Status) {
	m.status = &r
}

// Status returns the value of the "status" field in the mutation.
func (m *RequestExecutionMutation) Status() (r requestexecution.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the RequestExecution entity.
// If the RequestExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestExecutionMutation) OldStatus(ctx context.Context) (v requestexecution.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *RequestExecutionMutation) ResetStatus() {
	m.status = nil
}

// SetStream sets the "stream" field.
func (m *RequestExecutionMutation) SetStream(b bool) {
	m.stream = &b
}

// Stream returns the value of the "stream" field in the mutation.
func (m *RequestExecutionMutation) Stream() (r bool, exists bool) {
	v := m.stream
	if v == nil {
		return
	}
	return *v, true
}

// OldStream returns the old "stream" field's value of the RequestExecution entity.
// If the RequestExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestExecutionMutation) OldStream(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStream is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStream requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStream: %w", err)
	}
	return oldValue.Stream, nil
}

// ResetStream resets all changes to the "stream" field.
func (m *RequestExecutionMutation) ResetStream() {
	m.stream = nil
}

// SetMetricsLatencyMs sets the "metrics_latency_ms" field.
func (m *RequestExecutionMutation) SetMetricsLatencyMs(i int64) {
	m.metrics_latency_ms = &i
	m.addmetrics_latency_ms = nil
}

// MetricsLatencyMs returns the value of the "metrics_latency_ms" field in the mutation.
func (m *RequestExecutionMutation) MetricsLatencyMs() (r int64, exists bool) {
	v := m.metrics_latency_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldMetricsLatencyMs returns the old "metrics_latency_ms" field's value of the RequestExecution entity.
// If the RequestExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestExecutionMutation) OldMetricsLatencyMs(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetricsLatencyMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetricsLatencyMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetricsLatencyMs: %w", err)
	}
	return oldValue.MetricsLatencyMs, nil
}

// AddMetricsLatencyMs adds i to the "metrics_latency_ms" field.
func (m *RequestExecutionMutation) AddMetricsLatencyMs(i int64) {
	if m.addmetrics_latency_ms != nil {
		*m.addmetrics_latency_ms += i
	} else {
		m.addmetrics_latency_ms = &i
	}
}

// AddedMetricsLatencyMs returns the value that was added to the "metrics_latency_ms" field in this mutation.
func (m *RequestExecutionMutation) AddedMetricsLatencyMs() (r int64, exists bool) {
	v := m.addmetrics_latency_ms
	if v == nil {
		return
	}
	return *v, true
}

// ClearMetricsLatencyMs clears the value of the "metrics_latency_ms" field.
func (m *RequestExecutionMutation) ClearMetricsLatencyMs() {
	m.metrics_latency_ms = nil
	m.addmetrics_latency_ms = nil
	m.clearedFields[requestexecution.FieldMetricsLatencyMs] = struct{}{}
}

// MetricsLatencyMsCleared returns if the "metrics_latency_ms" field was cleared in this mutation.
func (m *RequestExecutionMutation) MetricsLatencyMsCleared() bool {
	_, ok := m.clearedFields[requestexecution.FieldMetricsLatencyMs]
	return ok
}

// ResetMetricsLatencyMs resets all changes to the "metrics_latency_ms" field.
func (m *RequestExecutionMutation) ResetMetricsLatencyMs() {
	m.metrics_latency_ms = nil
	m.addmetrics_latency_ms = nil
	delete(m.clearedFields, requestexecution.FieldMetricsLatencyMs)
}

// SetMetricsFirstTokenLatencyMs sets the "metrics_first_token_latency_ms" field.
func (m *RequestExecutionMutation) SetMetricsFirstTokenLatencyMs(i int64) {
	m.metrics_first_token_latency_ms = &i
	m.addmetrics_first_token_latency_ms = nil
}

// MetricsFirstTokenLatencyMs returns the value of the "metrics_first_token_latency_ms" field in the mutation.
func (m *RequestExecutionMutation) MetricsFirstTokenLatencyMs() (r int64, exists bool) {
	v := m.metrics_first_token_latency_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldMetricsFirstTokenLatencyMs returns the old "metrics_first_token_latency_ms" field's value of the RequestExecution entity.
// If the RequestExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestExecutionMutation) OldMetricsFirstTokenLatencyMs(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetricsFirstTokenLatencyMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetricsFirstTokenLatencyMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetricsFirstTokenLatencyMs: %w", err)
	}
	return oldValue.MetricsFirstTokenLatencyMs, nil
}

// AddMetricsFirstTokenLatencyMs adds i to the "metrics_first_token_latency_ms" field.
func (m *RequestExecutionMutation) AddMetricsFirstTokenLatencyMs(i int64) {
	if m.addmetrics_first_token_latency_ms != nil {
		*m.addmetrics_first_token_latency_ms += i
	} else {
		m.addmetrics_first_token_latency_ms = &i
	}
}

// AddedMetricsFirstTokenLatencyMs returns the value that was added to the "metrics_first_token_latency_ms" field in this mutation.
func (m *RequestExecutionMutation) AddedMetricsFirstTokenLatencyMs() (r int64, exists bool) {
	v := m.addmetrics_first_token_latency_ms
	if v == nil {
		return
	}
	return *v, true
}

// ClearMetricsFirstTokenLatencyMs clears the value of the "metrics_first_token_latency_ms" field.
func (m *RequestExecutionMutation) ClearMetricsFirstTokenLatencyMs() {
	m.metrics_first_token_latency_ms = nil
	m.addmetrics_first_token_latency_ms = nil
	m.clearedFields[requestexecution.FieldMetricsFirstTokenLatencyMs] = struct{}{}
}

// MetricsFirstTokenLatencyMsCleared returns if the "metrics_first_token_latency_ms" field was cleared in this mutation.
func (m *RequestExecutionMutation) MetricsFirstTokenLatencyMsCleared() bool {
	_, ok := m.clearedFields[requestexecution.FieldMetricsFirstTokenLatencyMs]
	return ok
}

// ResetMetricsFirstTokenLatencyMs resets all changes to the "metrics_first_token_latency_ms" field.
func (m *RequestExecutionMutation) ResetMetricsFirstTokenLatencyMs() {
	m.metrics_first_token_latency_ms = nil
	m.addmetrics_first_token_latency_ms = nil
	delete(m.clearedFields, requestexecution.FieldMetricsFirstTokenLatencyMs)
}

// SetRequestHeaders sets the "request_headers" field.
func (m *RequestExecutionMutation) SetRequestHeaders(orm objects.JSONRawMessage) {
	m.request_headers = &orm
	m.appendrequest_headers = nil
}

// RequestHeaders returns the value of the "request_headers" field in the mutation.
func (m *RequestExecutionMutation) RequestHeaders() (r objects.JSONRawMessage, exists bool) {
	v := m.request_headers
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestHeaders returns the old "request_headers" field's value of the RequestExecution entity.
// If the RequestExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestExecutionMutation) OldRequestHeaders(ctx context.Context) (v objects.JSONRawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestHeaders is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestHeaders requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestHeaders: %w", err)
	}
	return oldValue.RequestHeaders, nil
}

// AppendRequestHeaders adds orm to the "request_headers" field.
func (m *RequestExecutionMutation) AppendRequestHeaders(orm objects.JSONRawMessage) {
	m.appendrequest_headers = append(m.appendrequest_headers, orm...)
}

// AppendedRequestHeaders returns the list of values that were appended to the "request_headers" field in this mutation.
func (m *RequestExecutionMutation) AppendedRequestHeaders() (objects.JSONRawMessage, bool) {
	if len(m.appendrequest_headers) == 0 {
		return nil, false
	}
	return m.appendrequest_headers, true
}

// ClearRequestHeaders clears the value of the "request_headers" field.
func (m *RequestExecutionMutation) ClearRequestHeaders() {
	m.request_headers = nil
	m.appendrequest_headers = nil
	m.clearedFields[requestexecution.FieldRequestHeaders] = struct{}{}
}

// RequestHeadersCleared returns if the "request_headers" field was cleared in this mutation.
func (m *RequestExecutionMutation) RequestHeadersCleared() bool {
	_, ok := m.clearedFields[requestexecution.FieldRequestHeaders]
	return ok
}

// ResetRequestHeaders resets all changes to the "request_headers" field.
func (m *RequestExecutionMutation) ResetRequestHeaders() {
	m.request_headers = nil
	m.appendrequest_headers = nil
	delete(m.clearedFields, requestexecution.FieldRequestHeaders)
}

// ClearRequest clears the "request" edge to the Request entity.
func (m *RequestExecutionMutation) ClearRequest() {
	m.clearedrequest = true
	m.clearedFields[requestexecution.FieldRequestID] = struct{}{}
}

// RequestCleared reports if the "request" edge to the Request entity was cleared.
func (m *RequestExecutionMutation) RequestCleared() bool {
	return m.clearedrequest
}

// RequestIDs returns the "request" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RequestID instead. It exists only for internal usage by the builders.
func (m *RequestExecutionMutation) RequestIDs() (ids []int) {
	if id := m.request; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRequest resets all changes to the "request" edge.
func (m *RequestExecutionMutation) ResetRequest() {
	m.request = nil
	m.clearedrequest = false
}

// ClearChannel clears the "channel" edge to the Channel entity.
func (m *RequestExecutionMutation) ClearChannel() {
	m.clearedchannel = true
	m.clearedFields[requestexecution.FieldChannelID] = struct{}{}
}

// ChannelCleared reports if the "channel" edge to the Channel entity was cleared.
func (m *RequestExecutionMutation) ChannelCleared() bool {
	return m.ChannelIDCleared() || m.clearedchannel
}

// ChannelIDs returns the "channel" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChannelID instead. It exists only for internal usage by the builders.
func (m *RequestExecutionMutation) ChannelIDs() (ids []int) {
	if id := m.channel; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChannel resets all changes to the "channel" edge.
func (m *RequestExecutionMutation) ResetChannel() {
	m.channel = nil
	m.clearedchannel = false
}

// ClearDataStorage clears the "data_storage" edge to the DataStorage entity.
func (m *RequestExecutionMutation) ClearDataStorage() {
	m.cleareddata_storage = true
	m.clearedFields[requestexecution.FieldDataStorageID] = struct{}{}
}

// DataStorageCleared reports if the "data_storage" edge to the DataStorage entity was cleared.
func (m *RequestExecutionMutation) DataStorageCleared() bool {
	return m.DataStorageIDCleared() || m.cleareddata_storage
}

// DataStorageIDs returns the "data_storage" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DataStorageID instead. It exists only for internal usage by the builders.
func (m *RequestExecutionMutation) DataStorageIDs() (ids []int) {
	if id := m.data_storage; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDataStorage resets all changes to the "data_storage" edge.
func (m *RequestExecutionMutation) ResetDataStorage() {
	m.data_storage = nil
	m.cleareddata_storage = false
}

// Where appends a list predicates to the RequestExecutionMutation builder.
func (m *RequestExecutionMutation) Where(ps ...predicate.RequestExecution) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RequestExecutionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RequestExecutionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RequestExecution, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RequestExecutionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RequestExecutionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RequestExecution).
func (m *RequestExecutionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RequestExecutionMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.created_at != nil {
		fields = append(fields, requestexecution.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, requestexecution.FieldUpdatedAt)
	}
	if m.project_id != nil {
		fields = append(fields, requestexecution.FieldProjectID)
	}
	if m.request != nil {
		fields = append(fields, requestexecution.FieldRequestID)
	}
	if m.channel != nil {
		fields = append(fields, requestexecution.FieldChannelID)
	}
	if m.data_storage != nil {
		fields = append(fields, requestexecution.FieldDataStorageID)
	}
	if m.external_id != nil {
		fields = append(fields, requestexecution.FieldExternalID)
	}
	if m.model_id != nil {
		fields = append(fields, requestexecution.FieldModelID)
	}
	if m.format != nil {
		fields = append(fields, requestexecution.FieldFormat)
	}
	if m.request_body != nil {
		fields = append(fields, requestexecution.FieldRequestBody)
	}
	if m.response_body != nil {
		fields = append(fields, requestexecution.FieldResponseBody)
	}
	if m.response_chunks != nil {
		fields = append(fields, requestexecution.FieldResponseChunks)
	}
	if m.error_message != nil {
		fields = append(fields, requestexecution.FieldErrorMessage)
	}
	if m.status != nil {
		fields = append(fields, requestexecution.FieldStatus)
	}
	if m.stream != nil {
		fields = append(fields, requestexecution.FieldStream)
	}
	if m.metrics_latency_ms != nil {
		fields = append(fields, requestexecution.FieldMetricsLatencyMs)
	}
	if m.metrics_first_token_latency_ms != nil {
		fields = append(fields, requestexecution.FieldMetricsFirstTokenLatencyMs)
	}
	if m.request_headers != nil {
		fields = append(fields, requestexecution.FieldRequestHeaders)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RequestExecutionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case requestexecution.FieldCreatedAt:
		return m.CreatedAt()
	case requestexecution.FieldUpdatedAt:
		return m.UpdatedAt()
	case requestexecution.FieldProjectID:
		return m.ProjectID()
	case requestexecution.FieldRequestID:
		return m.RequestID()
	case requestexecution.FieldChannelID:
		return m.ChannelID()
	case requestexecution.FieldDataStorageID:
		return m.DataStorageID()
	case requestexecution.FieldExternalID:
		return m.ExternalID()
	case requestexecution.FieldModelID:
		return m.ModelID()
	case requestexecution.FieldFormat:
		return m.Format()
	case requestexecution.FieldRequestBody:
		return m.RequestBody()
	case requestexecution.FieldResponseBody:
		return m.ResponseBody()
	case requestexecution.FieldResponseChunks:
		return m.ResponseChunks()
	case requestexecution.FieldErrorMessage:
		return m.ErrorMessage()
	case requestexecution.FieldStatus:
		return m.Status()
	case requestexecution.FieldStream:
		return m.Stream()
	case requestexecution.FieldMetricsLatencyMs:
		return m.MetricsLatencyMs()
	case requestexecution.FieldMetricsFirstTokenLatencyMs:
		return m.MetricsFirstTokenLatencyMs()
	case requestexecution.FieldRequestHeaders:
		return m.RequestHeaders()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RequestExecutionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case requestexecution.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case requestexecution.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case requestexecution.FieldProjectID:
		return m.OldProjectID(ctx)
	case requestexecution.FieldRequestID:
		return m.OldRequestID(ctx)
	case requestexecution.FieldChannelID:
		return m.OldChannelID(ctx)
	case requestexecution.FieldDataStorageID:
		return m.OldDataStorageID(ctx)
	case requestexecution.FieldExternalID:
		return m.OldExternalID(ctx)
	case requestexecution.FieldModelID:
		return m.OldModelID(ctx)
	case requestexecution.FieldFormat:
		return m.OldFormat(ctx)
	case requestexecution.FieldRequestBody:
		return m.OldRequestBody(ctx)
	case requestexecution.FieldResponseBody:
		return m.OldResponseBody(ctx)
	case requestexecution.FieldResponseChunks:
		return m.OldResponseChunks(ctx)
	case requestexecution.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case requestexecution.FieldStatus:
		return m.OldStatus(ctx)
	case requestexecution.FieldStream:
		return m.OldStream(ctx)
	case requestexecution.FieldMetricsLatencyMs:
		return m.OldMetricsLatencyMs(ctx)
	case requestexecution.FieldMetricsFirstTokenLatencyMs:
		return m.OldMetricsFirstTokenLatencyMs(ctx)
	case requestexecution.FieldRequestHeaders:
		return m.OldRequestHeaders(ctx)
	}
	return nil, fmt.Errorf("unknown RequestExecution field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RequestExecutionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case requestexecution.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case requestexecution.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case requestexecution.FieldProjectID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case requestexecution.FieldRequestID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestID(v)
		return nil
	case requestexecution.FieldChannelID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelID(v)
		return nil
	case requestexecution.FieldDataStorageID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDataStorageID(v)
		return nil
	case requestexecution.FieldExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	case requestexecution.FieldModelID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModelID(v)
		return nil
	case requestexecution.FieldFormat:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormat(v)
		return nil
	case requestexecution.FieldRequestBody:
		v, ok := value.(objects.JSONRawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestBody(v)
		return nil
	case requestexecution.FieldResponseBody:
		v, ok := value.(objects.JSONRawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseBody(v)
		return nil
	case requestexecution.FieldResponseChunks:
		v, ok := value.([]objects.JSONRawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseChunks(v)
		return nil
	case requestexecution.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case requestexecution.FieldStatus:
		v, ok := value.(requestexecution.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case requestexecution.FieldStream:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStream(v)
		return nil
	case requestexecution.FieldMetricsLatencyMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetricsLatencyMs(v)
		return nil
	case requestexecution.FieldMetricsFirstTokenLatencyMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetricsFirstTokenLatencyMs(v)
		return nil
	case requestexecution.FieldRequestHeaders:
		v, ok := value.(objects.JSONRawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestHeaders(v)
		return nil
	}
	return fmt.Errorf("unknown RequestExecution field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RequestExecutionMutation) AddedFields() []string {
	var fields []string
	if m.addproject_id != nil {
		fields = append(fields, requestexecution.FieldProjectID)
	}
	if m.addmetrics_latency_ms != nil {
		fields = append(fields, requestexecution.FieldMetricsLatencyMs)
	}
	if m.addmetrics_first_token_latency_ms != nil {
		fields = append(fields, requestexecution.FieldMetricsFirstTokenLatencyMs)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RequestExecutionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case requestexecution.FieldProjectID:
		return m.AddedProjectID()
	case requestexecution.FieldMetricsLatencyMs:
		return m.AddedMetricsLatencyMs()
	case requestexecution.FieldMetricsFirstTokenLatencyMs:
		return m.AddedMetricsFirstTokenLatencyMs()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RequestExecutionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case requestexecution.FieldProjectID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProjectID(v)
		return nil
	case requestexecution.FieldMetricsLatencyMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMetricsLatencyMs(v)
		return nil
	case requestexecution.FieldMetricsFirstTokenLatencyMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMetricsFirstTokenLatencyMs(v)
		return nil
	}
	return fmt.Errorf("unknown RequestExecution numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RequestExecutionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(requestexecution.FieldChannelID) {
		fields = append(fields, requestexecution.FieldChannelID)
	}
	if m.FieldCleared(requestexecution.FieldDataStorageID) {
		fields = append(fields, requestexecution.FieldDataStorageID)
	}
	if m.FieldCleared(requestexecution.FieldExternalID) {
		fields = append(fields, requestexecution.FieldExternalID)
	}
	if m.FieldCleared(requestexecution.FieldResponseBody) {
		fields = append(fields, requestexecution.FieldResponseBody)
	}
	if m.FieldCleared(requestexecution.FieldResponseChunks) {
		fields = append(fields, requestexecution.FieldResponseChunks)
	}
	if m.FieldCleared(requestexecution.FieldErrorMessage) {
		fields = append(fields, requestexecution.FieldErrorMessage)
	}
	if m.FieldCleared(requestexecution.FieldMetricsLatencyMs) {
		fields = append(fields, requestexecution.FieldMetricsLatencyMs)
	}
	if m.FieldCleared(requestexecution.FieldMetricsFirstTokenLatencyMs) {
		fields = append(fields, requestexecution.FieldMetricsFirstTokenLatencyMs)
	}
	if m.FieldCleared(requestexecution.FieldRequestHeaders) {
		fields = append(fields, requestexecution.FieldRequestHeaders)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RequestExecutionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RequestExecutionMutation) ClearField(name string) error {
	switch name {
	case requestexecution.FieldChannelID:
		m.ClearChannelID()
		return nil
	case requestexecution.FieldDataStorageID:
		m.ClearDataStorageID()
		return nil
	case requestexecution.FieldExternalID:
		m.ClearExternalID()
		return nil
	case requestexecution.FieldResponseBody:
		m.ClearResponseBody()
		return nil
	case requestexecution.FieldResponseChunks:
		m.ClearResponseChunks()
		return nil
	case requestexecution.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	case requestexecution.FieldMetricsLatencyMs:
		m.ClearMetricsLatencyMs()
		return nil
	case requestexecution.FieldMetricsFirstTokenLatencyMs:
		m.ClearMetricsFirstTokenLatencyMs()
		return nil
	case requestexecution.FieldRequestHeaders:
		m.ClearRequestHeaders()
		return nil
	}
	return fmt.Errorf("unknown RequestExecution nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RequestExecutionMutation) ResetField(name string) error {
	switch name {
	case requestexecution.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case requestexecution.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case requestexecution.FieldProjectID:
		m.ResetProjectID()
		return nil
	case requestexecution.FieldRequestID:
		m.ResetRequestID()
		return nil
	case requestexecution.FieldChannelID:
		m.ResetChannelID()
		return nil
	case requestexecution.FieldDataStorageID:
		m.ResetDataStorageID()
		return nil
	case requestexecution.FieldExternalID:
		m.ResetExternalID()
		return nil
	case requestexecution.FieldModelID:
		m.ResetModelID()
		return nil
	case requestexecution.FieldFormat:
		m.ResetFormat()
		return nil
	case requestexecution.FieldRequestBody:
		m.ResetRequestBody()
		return nil
	case requestexecution.FieldResponseBody:
		m.ResetResponseBody()
		return nil
	case requestexecution.FieldResponseChunks:
		m.ResetResponseChunks()
		return nil
	case requestexecution.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case requestexecution.FieldStatus:
		m.ResetStatus()
		return nil
	case requestexecution.FieldStream:
		m.ResetStream()
		return nil
	case requestexecution.FieldMetricsLatencyMs:
		m.ResetMetricsLatencyMs()
		return nil
	case requestexecution.FieldMetricsFirstTokenLatencyMs:
		m.ResetMetricsFirstTokenLatencyMs()
		return nil
	case requestexecution.FieldRequestHeaders:
		m.ResetRequestHeaders()
		return nil
	}
	return fmt.Errorf("unknown RequestExecution field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RequestExecutionMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.request != nil {
		edges = append(edges, requestexecution.EdgeRequest)
	}
	if m.channel != nil {
		edges = append(edges, requestexecution.EdgeChannel)
	}
	if m.data_storage != nil {
		edges = append(edges, requestexecution.EdgeDataStorage)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RequestExecutionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case requestexecution.EdgeRequest:
		if id := m.request; id != nil {
			return []ent.Value{*id}
		}
	case requestexecution.EdgeChannel:
		if id := m.channel; id != nil {
			return []ent.Value{*id}
		}
	case requestexecution.EdgeDataStorage:
		if id := m.data_storage; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RequestExecutionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RequestExecutionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RequestExecutionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedrequest {
		edges = append(edges, requestexecution.EdgeRequest)
	}
	if m.clearedchannel {
		edges = append(edges, requestexecution.EdgeChannel)
	}
	if m.cleareddata_storage {
		edges = append(edges, requestexecution.EdgeDataStorage)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RequestExecutionMutation) EdgeCleared(name string) bool {
	switch name {
	case requestexecution.EdgeRequest:
		return m.clearedrequest
	case requestexecution.EdgeChannel:
		return m.clearedchannel
	case requestexecution.EdgeDataStorage:
		return m.cleareddata_storage
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RequestExecutionMutation) ClearEdge(name string) error {
	switch name {
	case requestexecution.EdgeRequest:
		m.ClearRequest()
		return nil
	case requestexecution.EdgeChannel:
		m.ClearChannel()
		return nil
	case requestexecution.EdgeDataStorage:
		m.ClearDataStorage()
		return nil
	}
	return fmt.Errorf("unknown RequestExecution unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RequestExecutionMutation) ResetEdge(name string) error {
	switch name {
	case requestexecution.EdgeRequest:
		m.ResetRequest()
		return nil
	case requestexecution.EdgeChannel:
		m.ResetChannel()
		return nil
	case requestexecution.EdgeDataStorage:
		m.ResetDataStorage()
		return nil
	}
	return fmt.Errorf("unknown RequestExecution edge %s", name)
}

// RoleMutation represents an operation that mutates the Role nodes in the graph.
type RoleMutation struct {
	config
	op                Op
	typ               string
	id                *int
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *int
	adddeleted_at     *int
	name              *string
	level             *role.Level
	scopes            *[]string
	appendscopes      []string
	clearedFields     map[string]struct{}
	users             map[int]struct{}
	removedusers      map[int]struct{}
	clearedusers      bool
	project           *int
	clearedproject    bool
	user_roles        map[int]struct{}
	removeduser_roles map[int]struct{}
	cleareduser_roles bool
	done              bool
	oldValue          func(context.Context) (*Role, error)
	predicates        []predicate.Role
}

var _ ent.Mutation = (*RoleMutation)(nil)

// roleOption allows management of the mutation configuration using functional options.
type roleOption func(*RoleMutation)

// newRoleMutation creates new mutation for the Role entity.
func newRoleMutation(c config, op Op, opts ...roleOption) *RoleMutation {
	m := &RoleMutation{
		config:        c,
		op:            op,
		typ:           TypeRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleID sets the ID field of the mutation.
func withRoleID(id int) roleOption {
	return func(m *RoleMutation) {
		var (
			err   error
			once  sync.Once
			value *Role
		)
		m.oldValue = func(ctx context.Context) (*Role, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Role.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRole sets the old Role of the mutation.
func withRole(node *Role) roleOption {
	return func(m *RoleMutation) {
		m.oldValue = func(context.Context) (*Role, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Role.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RoleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RoleMutation) SetDeletedAt(i int) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RoleMutation) DeletedAt() (r int, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldDeletedAt(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *RoleMutation) AddDeletedAt(i int) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *RoleMutation) AddedDeletedAt() (r int, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RoleMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetName sets the "name" field.
func (m *RoleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RoleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RoleMutation) ResetName() {
	m.name = nil
}

// SetLevel sets the "level" field.
func (m *RoleMutation) SetLevel(r role.Level) {
	m.level = &r
}

// Level returns the value of the "level" field in the mutation.
func (m *RoleMutation) Level() (r role.Level, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldLevel(ctx context.Context) (v role.Level, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// ResetLevel resets all changes to the "level" field.
func (m *RoleMutation) ResetLevel() {
	m.level = nil
}

// SetProjectID sets the "project_id" field.
func (m *RoleMutation) SetProjectID(i int) {
	m.project = &i
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *RoleMutation) ProjectID() (r int, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldProjectID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ClearProjectID clears the value of the "project_id" field.
func (m *RoleMutation) ClearProjectID() {
	m.project = nil
	m.clearedFields[role.FieldProjectID] = struct{}{}
}

// ProjectIDCleared returns if the "project_id" field was cleared in this mutation.
func (m *RoleMutation) ProjectIDCleared() bool {
	_, ok := m.clearedFields[role.FieldProjectID]
	return ok
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *RoleMutation) ResetProjectID() {
	m.project = nil
	delete(m.clearedFields, role.FieldProjectID)
}

// SetScopes sets the "scopes" field.
func (m *RoleMutation) SetScopes(s []string) {
	m.scopes = &s
	m.appendscopes = nil
}

// Scopes returns the value of the "scopes" field in the mutation.
func (m *RoleMutation) Scopes() (r []string, exists bool) {
	v := m.scopes
	if v == nil {
		return
	}
	return *v, true
}

// OldScopes returns the old "scopes" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldScopes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopes: %w", err)
	}
	return oldValue.Scopes, nil
}

// AppendScopes adds s to the "scopes" field.
func (m *RoleMutation) AppendScopes(s []string) {
	m.appendscopes = append(m.appendscopes, s...)
}

// AppendedScopes returns the list of values that were appended to the "scopes" field in this mutation.
func (m *RoleMutation) AppendedScopes() ([]string, bool) {
	if len(m.appendscopes) == 0 {
		return nil, false
	}
	return m.appendscopes, true
}

// ClearScopes clears the value of the "scopes" field.
func (m *RoleMutation) ClearScopes() {
	m.scopes = nil
	m.appendscopes = nil
	m.clearedFields[role.FieldScopes] = struct{}{}
}

// ScopesCleared returns if the "scopes" field was cleared in this mutation.
func (m *RoleMutation) ScopesCleared() bool {
	_, ok := m.clearedFields[role.FieldScopes]
	return ok
}

// ResetScopes resets all changes to the "scopes" field.
func (m *RoleMutation) ResetScopes() {
	m.scopes = nil
	m.appendscopes = nil
	delete(m.clearedFields, role.FieldScopes)
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *RoleMutation) AddUserIDs(ids ...int) {
	if m.users == nil {
		m.users = make(map[int]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *RoleMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *RoleMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *RoleMutation) RemoveUserIDs(ids ...int) {
	if m.removedusers == nil {
		m.removedusers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *RoleMutation) RemovedUsersIDs() (ids []int) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *RoleMutation) UsersIDs() (ids []int) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *RoleMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// ClearProject clears the "project" edge to the Project entity.
func (m *RoleMutation) ClearProject() {
	m.clearedproject = true
	m.clearedFields[role.FieldProjectID] = struct{}{}
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *RoleMutation) ProjectCleared() bool {
	return m.ProjectIDCleared() || m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *RoleMutation) ProjectIDs() (ids []int) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *RoleMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// AddUserRoleIDs adds the "user_roles" edge to the UserRole entity by ids.
func (m *RoleMutation) AddUserRoleIDs(ids ...int) {
	if m.user_roles == nil {
		m.user_roles = make(map[int]struct{})
	}
	for i := range ids {
		m.user_roles[ids[i]] = struct{}{}
	}
}

// ClearUserRoles clears the "user_roles" edge to the UserRole entity.
func (m *RoleMutation) ClearUserRoles() {
	m.cleareduser_roles = true
}

// UserRolesCleared reports if the "user_roles" edge to the UserRole entity was cleared.
func (m *RoleMutation) UserRolesCleared() bool {
	return m.cleareduser_roles
}

// RemoveUserRoleIDs removes the "user_roles" edge to the UserRole entity by IDs.
func (m *RoleMutation) RemoveUserRoleIDs(ids ...int) {
	if m.removeduser_roles == nil {
		m.removeduser_roles = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user_roles, ids[i])
		m.removeduser_roles[ids[i]] = struct{}{}
	}
}

// RemovedUserRoles returns the removed IDs of the "user_roles" edge to the UserRole entity.
func (m *RoleMutation) RemovedUserRolesIDs() (ids []int) {
	for id := range m.removeduser_roles {
		ids = append(ids, id)
	}
	return
}

// UserRolesIDs returns the "user_roles" edge IDs in the mutation.
func (m *RoleMutation) UserRolesIDs() (ids []int) {
	for id := range m.user_roles {
		ids = append(ids, id)
	}
	return
}

// ResetUserRoles resets all changes to the "user_roles" edge.
func (m *RoleMutation) ResetUserRoles() {
	m.user_roles = nil
	m.cleareduser_roles = false
	m.removeduser_roles = nil
}

// Where appends a list predicates to the RoleMutation builder.
func (m *RoleMutation) Where(ps ...predicate.Role) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Role, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Role).
func (m *RoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, role.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, role.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, role.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, role.FieldName)
	}
	if m.level != nil {
		fields = append(fields, role.FieldLevel)
	}
	if m.project != nil {
		fields = append(fields, role.FieldProjectID)
	}
	if m.scopes != nil {
		fields = append(fields, role.FieldScopes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case role.FieldCreatedAt:
		return m.CreatedAt()
	case role.FieldUpdatedAt:
		return m.UpdatedAt()
	case role.FieldDeletedAt:
		return m.DeletedAt()
	case role.FieldName:
		return m.Name()
	case role.FieldLevel:
		return m.Level()
	case role.FieldProjectID:
		return m.ProjectID()
	case role.FieldScopes:
		return m.Scopes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case role.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case role.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case role.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case role.FieldName:
		return m.OldName(ctx)
	case role.FieldLevel:
		return m.OldLevel(ctx)
	case role.FieldProjectID:
		return m.OldProjectID(ctx)
	case role.FieldScopes:
		return m.OldScopes(ctx)
	}
	return nil, fmt.Errorf("unknown Role field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case role.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case role.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case role.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case role.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case role.FieldLevel:
		v, ok := value.(role.Level)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case role.FieldProjectID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case role.FieldScopes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopes(v)
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, role.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case role.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case role.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Role numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(role.FieldProjectID) {
		fields = append(fields, role.FieldProjectID)
	}
	if m.FieldCleared(role.FieldScopes) {
		fields = append(fields, role.FieldScopes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleMutation) ClearField(name string) error {
	switch name {
	case role.FieldProjectID:
		m.ClearProjectID()
		return nil
	case role.FieldScopes:
		m.ClearScopes()
		return nil
	}
	return fmt.Errorf("unknown Role nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleMutation) ResetField(name string) error {
	switch name {
	case role.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case role.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case role.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case role.FieldName:
		m.ResetName()
		return nil
	case role.FieldLevel:
		m.ResetLevel()
		return nil
	case role.FieldProjectID:
		m.ResetProjectID()
		return nil
	case role.FieldScopes:
		m.ResetScopes()
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.users != nil {
		edges = append(edges, role.EdgeUsers)
	}
	if m.project != nil {
		edges = append(edges, role.EdgeProject)
	}
	if m.user_roles != nil {
		edges = append(edges, role.EdgeUserRoles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case role.EdgeUserRoles:
		ids := make([]ent.Value, 0, len(m.user_roles))
		for id := range m.user_roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedusers != nil {
		edges = append(edges, role.EdgeUsers)
	}
	if m.removeduser_roles != nil {
		edges = append(edges, role.EdgeUserRoles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeUserRoles:
		ids := make([]ent.Value, 0, len(m.removeduser_roles))
		for id := range m.removeduser_roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedusers {
		edges = append(edges, role.EdgeUsers)
	}
	if m.clearedproject {
		edges = append(edges, role.EdgeProject)
	}
	if m.cleareduser_roles {
		edges = append(edges, role.EdgeUserRoles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleMutation) EdgeCleared(name string) bool {
	switch name {
	case role.EdgeUsers:
		return m.clearedusers
	case role.EdgeProject:
		return m.clearedproject
	case role.EdgeUserRoles:
		return m.cleareduser_roles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleMutation) ClearEdge(name string) error {
	switch name {
	case role.EdgeProject:
		m.ClearProject()
		return nil
	}
	return fmt.Errorf("unknown Role unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleMutation) ResetEdge(name string) error {
	switch name {
	case role.EdgeUsers:
		m.ResetUsers()
		return nil
	case role.EdgeProject:
		m.ResetProject()
		return nil
	case role.EdgeUserRoles:
		m.ResetUserRoles()
		return nil
	}
	return fmt.Errorf("unknown Role edge %s", name)
}

// SystemMutation represents an operation that mutates the System nodes in the graph.
type SystemMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *int
	adddeleted_at *int
	key           *string
	value         *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*System, error)
	predicates    []predicate.System
}

var _ ent.Mutation = (*SystemMutation)(nil)

// systemOption allows management of the mutation configuration using functional options.
type systemOption func(*SystemMutation)

// newSystemMutation creates new mutation for the System entity.
func newSystemMutation(c config, op Op, opts ...systemOption) *SystemMutation {
	m := &SystemMutation{
		config:        c,
		op:            op,
		typ:           TypeSystem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSystemID sets the ID field of the mutation.
func withSystemID(id int) systemOption {
	return func(m *SystemMutation) {
		var (
			err   error
			once  sync.Once
			value *System
		)
		m.oldValue = func(ctx context.Context) (*System, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().System.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSystem sets the old System of the mutation.
func withSystem(node *System) systemOption {
	return func(m *SystemMutation) {
		m.oldValue = func(context.Context) (*System, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SystemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SystemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SystemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SystemMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().System.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SystemMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SystemMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the System entity.
// If the System object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SystemMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SystemMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SystemMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the System entity.
// If the System object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SystemMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SystemMutation) SetDeletedAt(i int) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SystemMutation) DeletedAt() (r int, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the System entity.
// If the System object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemMutation) OldDeletedAt(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *SystemMutation) AddDeletedAt(i int) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *SystemMutation) AddedDeletedAt() (r int, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SystemMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetKey sets the "key" field.
func (m *SystemMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *SystemMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the System entity.
// If the System object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *SystemMutation) ResetKey() {
	m.key = nil
}

// SetValue sets the "value" field.
func (m *SystemMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *SystemMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the System entity.
// If the System object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *SystemMutation) ResetValue() {
	m.value = nil
}

// Where appends a list predicates to the SystemMutation builder.
func (m *SystemMutation) Where(ps ...predicate.System) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SystemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SystemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.System, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SystemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SystemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (System).
func (m *SystemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SystemMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, system.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, system.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, system.FieldDeletedAt)
	}
	if m.key != nil {
		fields = append(fields, system.FieldKey)
	}
	if m.value != nil {
		fields = append(fields, system.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SystemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case system.FieldCreatedAt:
		return m.CreatedAt()
	case system.FieldUpdatedAt:
		return m.UpdatedAt()
	case system.FieldDeletedAt:
		return m.DeletedAt()
	case system.FieldKey:
		return m.Key()
	case system.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SystemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case system.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case system.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case system.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case system.FieldKey:
		return m.OldKey(ctx)
	case system.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown System field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case system.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case system.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case system.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case system.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case system.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown System field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SystemMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, system.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SystemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case system.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case system.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown System numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SystemMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SystemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SystemMutation) ClearField(name string) error {
	return fmt.Errorf("unknown System nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SystemMutation) ResetField(name string) error {
	switch name {
	case system.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case system.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case system.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case system.FieldKey:
		m.ResetKey()
		return nil
	case system.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown System field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SystemMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SystemMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SystemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SystemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SystemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SystemMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SystemMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown System unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SystemMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown System edge %s", name)
}

// ThreadMutation represents an operation that mutates the Thread nodes in the graph.
type ThreadMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	updated_at     *time.Time
	thread_id      *string
	clearedFields  map[string]struct{}
	project        *int
	clearedproject bool
	traces         map[int]struct{}
	removedtraces  map[int]struct{}
	clearedtraces  bool
	done           bool
	oldValue       func(context.Context) (*Thread, error)
	predicates     []predicate.Thread
}

var _ ent.Mutation = (*ThreadMutation)(nil)

// threadOption allows management of the mutation configuration using functional options.
type threadOption func(*ThreadMutation)

// newThreadMutation creates new mutation for the Thread entity.
func newThreadMutation(c config, op Op, opts ...threadOption) *ThreadMutation {
	m := &ThreadMutation{
		config:        c,
		op:            op,
		typ:           TypeThread,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withThreadID sets the ID field of the mutation.
func withThreadID(id int) threadOption {
	return func(m *ThreadMutation) {
		var (
			err   error
			once  sync.Once
			value *Thread
		)
		m.oldValue = func(ctx context.Context) (*Thread, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Thread.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withThread sets the old Thread of the mutation.
func withThread(node *Thread) threadOption {
	return func(m *ThreadMutation) {
		m.oldValue = func(context.Context) (*Thread, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ThreadMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ThreadMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ThreadMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ThreadMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Thread.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ThreadMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ThreadMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ThreadMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ThreadMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ThreadMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ThreadMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetProjectID sets the "project_id" field.
func (m *ThreadMutation) SetProjectID(i int) {
	m.project = &i
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *ThreadMutation) ProjectID() (r int, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldProjectID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *ThreadMutation) ResetProjectID() {
	m.project = nil
}

// SetThreadID sets the "thread_id" field.
func (m *ThreadMutation) SetThreadID(s string) {
	m.thread_id = &s
}

// ThreadID returns the value of the "thread_id" field in the mutation.
func (m *ThreadMutation) ThreadID() (r string, exists bool) {
	v := m.thread_id
	if v == nil {
		return
	}
	return *v, true
}

// OldThreadID returns the old "thread_id" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldThreadID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThreadID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThreadID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThreadID: %w", err)
	}
	return oldValue.ThreadID, nil
}

// ResetThreadID resets all changes to the "thread_id" field.
func (m *ThreadMutation) ResetThreadID() {
	m.thread_id = nil
}

// ClearProject clears the "project" edge to the Project entity.
func (m *ThreadMutation) ClearProject() {
	m.clearedproject = true
	m.clearedFields[thread.FieldProjectID] = struct{}{}
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *ThreadMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *ThreadMutation) ProjectIDs() (ids []int) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *ThreadMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// AddTraceIDs adds the "traces" edge to the Trace entity by ids.
func (m *ThreadMutation) AddTraceIDs(ids ...int) {
	if m.traces == nil {
		m.traces = make(map[int]struct{})
	}
	for i := range ids {
		m.traces[ids[i]] = struct{}{}
	}
}

// ClearTraces clears the "traces" edge to the Trace entity.
func (m *ThreadMutation) ClearTraces() {
	m.clearedtraces = true
}

// TracesCleared reports if the "traces" edge to the Trace entity was cleared.
func (m *ThreadMutation) TracesCleared() bool {
	return m.clearedtraces
}

// RemoveTraceIDs removes the "traces" edge to the Trace entity by IDs.
func (m *ThreadMutation) RemoveTraceIDs(ids ...int) {
	if m.removedtraces == nil {
		m.removedtraces = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.traces, ids[i])
		m.removedtraces[ids[i]] = struct{}{}
	}
}

// RemovedTraces returns the removed IDs of the "traces" edge to the Trace entity.
func (m *ThreadMutation) RemovedTracesIDs() (ids []int) {
	for id := range m.removedtraces {
		ids = append(ids, id)
	}
	return
}

// TracesIDs returns the "traces" edge IDs in the mutation.
func (m *ThreadMutation) TracesIDs() (ids []int) {
	for id := range m.traces {
		ids = append(ids, id)
	}
	return
}

// ResetTraces resets all changes to the "traces" edge.
func (m *ThreadMutation) ResetTraces() {
	m.traces = nil
	m.clearedtraces = false
	m.removedtraces = nil
}

// Where appends a list predicates to the ThreadMutation builder.
func (m *ThreadMutation) Where(ps ...predicate.Thread) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ThreadMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ThreadMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Thread, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ThreadMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ThreadMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Thread).
func (m *ThreadMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ThreadMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, thread.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, thread.FieldUpdatedAt)
	}
	if m.project != nil {
		fields = append(fields, thread.FieldProjectID)
	}
	if m.thread_id != nil {
		fields = append(fields, thread.FieldThreadID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ThreadMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case thread.FieldCreatedAt:
		return m.CreatedAt()
	case thread.FieldUpdatedAt:
		return m.UpdatedAt()
	case thread.FieldProjectID:
		return m.ProjectID()
	case thread.FieldThreadID:
		return m.ThreadID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ThreadMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case thread.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case thread.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case thread.FieldProjectID:
		return m.OldProjectID(ctx)
	case thread.FieldThreadID:
		return m.OldThreadID(ctx)
	}
	return nil, fmt.Errorf("unknown Thread field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ThreadMutation) SetField(name string, value ent.Value) error {
	switch name {
	case thread.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case thread.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case thread.FieldProjectID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case thread.FieldThreadID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThreadID(v)
		return nil
	}
	return fmt.Errorf("unknown Thread field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ThreadMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ThreadMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ThreadMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Thread numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ThreadMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ThreadMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ThreadMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Thread nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ThreadMutation) ResetField(name string) error {
	switch name {
	case thread.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case thread.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case thread.FieldProjectID:
		m.ResetProjectID()
		return nil
	case thread.FieldThreadID:
		m.ResetThreadID()
		return nil
	}
	return fmt.Errorf("unknown Thread field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ThreadMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.project != nil {
		edges = append(edges, thread.EdgeProject)
	}
	if m.traces != nil {
		edges = append(edges, thread.EdgeTraces)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ThreadMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case thread.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case thread.EdgeTraces:
		ids := make([]ent.Value, 0, len(m.traces))
		for id := range m.traces {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ThreadMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtraces != nil {
		edges = append(edges, thread.EdgeTraces)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ThreadMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case thread.EdgeTraces:
		ids := make([]ent.Value, 0, len(m.removedtraces))
		for id := range m.removedtraces {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ThreadMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproject {
		edges = append(edges, thread.EdgeProject)
	}
	if m.clearedtraces {
		edges = append(edges, thread.EdgeTraces)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ThreadMutation) EdgeCleared(name string) bool {
	switch name {
	case thread.EdgeProject:
		return m.clearedproject
	case thread.EdgeTraces:
		return m.clearedtraces
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ThreadMutation) ClearEdge(name string) error {
	switch name {
	case thread.EdgeProject:
		m.ClearProject()
		return nil
	}
	return fmt.Errorf("unknown Thread unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ThreadMutation) ResetEdge(name string) error {
	switch name {
	case thread.EdgeProject:
		m.ResetProject()
		return nil
	case thread.EdgeTraces:
		m.ResetTraces()
		return nil
	}
	return fmt.Errorf("unknown Thread edge %s", name)
}

// TraceMutation represents an operation that mutates the Trace nodes in the graph.
type TraceMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	updated_at      *time.Time
	trace_id        *string
	clearedFields   map[string]struct{}
	project         *int
	clearedproject  bool
	thread          *int
	clearedthread   bool
	requests        map[int]struct{}
	removedrequests map[int]struct{}
	clearedrequests bool
	done            bool
	oldValue        func(context.Context) (*Trace, error)
	predicates      []predicate.Trace
}

var _ ent.Mutation = (*TraceMutation)(nil)

// traceOption allows management of the mutation configuration using functional options.
type traceOption func(*TraceMutation)

// newTraceMutation creates new mutation for the Trace entity.
func newTraceMutation(c config, op Op, opts ...traceOption) *TraceMutation {
	m := &TraceMutation{
		config:        c,
		op:            op,
		typ:           TypeTrace,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTraceID sets the ID field of the mutation.
func withTraceID(id int) traceOption {
	return func(m *TraceMutation) {
		var (
			err   error
			once  sync.Once
			value *Trace
		)
		m.oldValue = func(ctx context.Context) (*Trace, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Trace.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTrace sets the old Trace of the mutation.
func withTrace(node *Trace) traceOption {
	return func(m *TraceMutation) {
		m.oldValue = func(context.Context) (*Trace, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TraceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TraceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TraceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TraceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Trace.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TraceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TraceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Trace entity.
// If the Trace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TraceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TraceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TraceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TraceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Trace entity.
// If the Trace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TraceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TraceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetProjectID sets the "project_id" field.
func (m *TraceMutation) SetProjectID(i int) {
	m.project = &i
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *TraceMutation) ProjectID() (r int, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the Trace entity.
// If the Trace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TraceMutation) OldProjectID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *TraceMutation) ResetProjectID() {
	m.project = nil
}

// SetTraceID sets the "trace_id" field.
func (m *TraceMutation) SetTraceID(s string) {
	m.trace_id = &s
}

// TraceID returns the value of the "trace_id" field in the mutation.
func (m *TraceMutation) TraceID() (r string, exists bool) {
	v := m.trace_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTraceID returns the old "trace_id" field's value of the Trace entity.
// If the Trace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TraceMutation) OldTraceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTraceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTraceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTraceID: %w", err)
	}
	return oldValue.TraceID, nil
}

// ResetTraceID resets all changes to the "trace_id" field.
func (m *TraceMutation) ResetTraceID() {
	m.trace_id = nil
}

// SetThreadID sets the "thread_id" field.
func (m *TraceMutation) SetThreadID(i int) {
	m.thread = &i
}

// ThreadID returns the value of the "thread_id" field in the mutation.
func (m *TraceMutation) ThreadID() (r int, exists bool) {
	v := m.thread
	if v == nil {
		return
	}
	return *v, true
}

// OldThreadID returns the old "thread_id" field's value of the Trace entity.
// If the Trace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TraceMutation) OldThreadID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThreadID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThreadID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThreadID: %w", err)
	}
	return oldValue.ThreadID, nil
}

// ClearThreadID clears the value of the "thread_id" field.
func (m *TraceMutation) ClearThreadID() {
	m.thread = nil
	m.clearedFields[trace.FieldThreadID] = struct{}{}
}

// ThreadIDCleared returns if the "thread_id" field was cleared in this mutation.
func (m *TraceMutation) ThreadIDCleared() bool {
	_, ok := m.clearedFields[trace.FieldThreadID]
	return ok
}

// ResetThreadID resets all changes to the "thread_id" field.
func (m *TraceMutation) ResetThreadID() {
	m.thread = nil
	delete(m.clearedFields, trace.FieldThreadID)
}

// ClearProject clears the "project" edge to the Project entity.
func (m *TraceMutation) ClearProject() {
	m.clearedproject = true
	m.clearedFields[trace.FieldProjectID] = struct{}{}
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *TraceMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *TraceMutation) ProjectIDs() (ids []int) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *TraceMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// ClearThread clears the "thread" edge to the Thread entity.
func (m *TraceMutation) ClearThread() {
	m.clearedthread = true
	m.clearedFields[trace.FieldThreadID] = struct{}{}
}

// ThreadCleared reports if the "thread" edge to the Thread entity was cleared.
func (m *TraceMutation) ThreadCleared() bool {
	return m.ThreadIDCleared() || m.clearedthread
}

// ThreadIDs returns the "thread" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ThreadID instead. It exists only for internal usage by the builders.
func (m *TraceMutation) ThreadIDs() (ids []int) {
	if id := m.thread; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetThread resets all changes to the "thread" edge.
func (m *TraceMutation) ResetThread() {
	m.thread = nil
	m.clearedthread = false
}

// AddRequestIDs adds the "requests" edge to the Request entity by ids.
func (m *TraceMutation) AddRequestIDs(ids ...int) {
	if m.requests == nil {
		m.requests = make(map[int]struct{})
	}
	for i := range ids {
		m.requests[ids[i]] = struct{}{}
	}
}

// ClearRequests clears the "requests" edge to the Request entity.
func (m *TraceMutation) ClearRequests() {
	m.clearedrequests = true
}

// RequestsCleared reports if the "requests" edge to the Request entity was cleared.
func (m *TraceMutation) RequestsCleared() bool {
	return m.clearedrequests
}

// RemoveRequestIDs removes the "requests" edge to the Request entity by IDs.
func (m *TraceMutation) RemoveRequestIDs(ids ...int) {
	if m.removedrequests == nil {
		m.removedrequests = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.requests, ids[i])
		m.removedrequests[ids[i]] = struct{}{}
	}
}

// RemovedRequests returns the removed IDs of the "requests" edge to the Request entity.
func (m *TraceMutation) RemovedRequestsIDs() (ids []int) {
	for id := range m.removedrequests {
		ids = append(ids, id)
	}
	return
}

// RequestsIDs returns the "requests" edge IDs in the mutation.
func (m *TraceMutation) RequestsIDs() (ids []int) {
	for id := range m.requests {
		ids = append(ids, id)
	}
	return
}

// ResetRequests resets all changes to the "requests" edge.
func (m *TraceMutation) ResetRequests() {
	m.requests = nil
	m.clearedrequests = false
	m.removedrequests = nil
}

// Where appends a list predicates to the TraceMutation builder.
func (m *TraceMutation) Where(ps ...predicate.Trace) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TraceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TraceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Trace, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TraceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TraceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Trace).
func (m *TraceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TraceMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, trace.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, trace.FieldUpdatedAt)
	}
	if m.project != nil {
		fields = append(fields, trace.FieldProjectID)
	}
	if m.trace_id != nil {
		fields = append(fields, trace.FieldTraceID)
	}
	if m.thread != nil {
		fields = append(fields, trace.FieldThreadID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TraceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case trace.FieldCreatedAt:
		return m.CreatedAt()
	case trace.FieldUpdatedAt:
		return m.UpdatedAt()
	case trace.FieldProjectID:
		return m.ProjectID()
	case trace.FieldTraceID:
		return m.TraceID()
	case trace.FieldThreadID:
		return m.ThreadID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TraceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case trace.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case trace.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case trace.FieldProjectID:
		return m.OldProjectID(ctx)
	case trace.FieldTraceID:
		return m.OldTraceID(ctx)
	case trace.FieldThreadID:
		return m.OldThreadID(ctx)
	}
	return nil, fmt.Errorf("unknown Trace field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TraceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case trace.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case trace.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case trace.FieldProjectID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case trace.FieldTraceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTraceID(v)
		return nil
	case trace.FieldThreadID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThreadID(v)
		return nil
	}
	return fmt.Errorf("unknown Trace field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TraceMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TraceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TraceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Trace numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TraceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(trace.FieldThreadID) {
		fields = append(fields, trace.FieldThreadID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TraceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TraceMutation) ClearField(name string) error {
	switch name {
	case trace.FieldThreadID:
		m.ClearThreadID()
		return nil
	}
	return fmt.Errorf("unknown Trace nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TraceMutation) ResetField(name string) error {
	switch name {
	case trace.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case trace.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case trace.FieldProjectID:
		m.ResetProjectID()
		return nil
	case trace.FieldTraceID:
		m.ResetTraceID()
		return nil
	case trace.FieldThreadID:
		m.ResetThreadID()
		return nil
	}
	return fmt.Errorf("unknown Trace field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TraceMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.project != nil {
		edges = append(edges, trace.EdgeProject)
	}
	if m.thread != nil {
		edges = append(edges, trace.EdgeThread)
	}
	if m.requests != nil {
		edges = append(edges, trace.EdgeRequests)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TraceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case trace.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case trace.EdgeThread:
		if id := m.thread; id != nil {
			return []ent.Value{*id}
		}
	case trace.EdgeRequests:
		ids := make([]ent.Value, 0, len(m.requests))
		for id := range m.requests {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TraceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedrequests != nil {
		edges = append(edges, trace.EdgeRequests)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TraceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case trace.EdgeRequests:
		ids := make([]ent.Value, 0, len(m.removedrequests))
		for id := range m.removedrequests {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TraceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedproject {
		edges = append(edges, trace.EdgeProject)
	}
	if m.clearedthread {
		edges = append(edges, trace.EdgeThread)
	}
	if m.clearedrequests {
		edges = append(edges, trace.EdgeRequests)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TraceMutation) EdgeCleared(name string) bool {
	switch name {
	case trace.EdgeProject:
		return m.clearedproject
	case trace.EdgeThread:
		return m.clearedthread
	case trace.EdgeRequests:
		return m.clearedrequests
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TraceMutation) ClearEdge(name string) error {
	switch name {
	case trace.EdgeProject:
		m.ClearProject()
		return nil
	case trace.EdgeThread:
		m.ClearThread()
		return nil
	}
	return fmt.Errorf("unknown Trace unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TraceMutation) ResetEdge(name string) error {
	switch name {
	case trace.EdgeProject:
		m.ResetProject()
		return nil
	case trace.EdgeThread:
		m.ResetThread()
		return nil
	case trace.EdgeRequests:
		m.ResetRequests()
		return nil
	}
	return fmt.Errorf("unknown Trace edge %s", name)
}

// UsageLogMutation represents an operation that mutates the UsageLog nodes in the graph.
type UsageLogMutation struct {
	config
	op                                       Op
	typ                                      string
	id                                       *int
	created_at                               *time.Time
	updated_at                               *time.Time
	api_key_id                               *int
	addapi_key_id                            *int
	model_id                                 *string
	prompt_tokens                            *int64
	addprompt_tokens                         *int64
	completion_tokens                        *int64
	addcompletion_tokens                     *int64
	total_tokens                             *int64
	addtotal_tokens                          *int64
	prompt_audio_tokens                      *int64
	addprompt_audio_tokens                   *int64
	prompt_cached_tokens                     *int64
	addprompt_cached_tokens                  *int64
	prompt_write_cached_tokens               *int64
	addprompt_write_cached_tokens            *int64
	prompt_write_cached_tokens_5m            *int64
	addprompt_write_cached_tokens_5m         *int64
	prompt_write_cached_tokens_1h            *int64
	addprompt_write_cached_tokens_1h         *int64
	completion_audio_tokens                  *int64
	addcompletion_audio_tokens               *int64
	completion_reasoning_tokens              *int64
	addcompletion_reasoning_tokens           *int64
	completion_accepted_prediction_tokens    *int64
	addcompletion_accepted_prediction_tokens *int64
	completion_rejected_prediction_tokens    *int64
	addcompletion_rejected_prediction_tokens *int64
	source                                   *usagelog.Source
	format                                   *string
	total_cost                               *float64
	addtotal_cost                            *float64
	cost_items                               *[]objects.CostItem
	appendcost_items                         []objects.CostItem
	cost_price_reference_id                  *string
	clearedFields                            map[string]struct{}
	request                                  *int
	clearedrequest                           bool
	project                                  *int
	clearedproject                           bool
	channel                                  *int
	clearedchannel                           bool
	done                                     bool
	oldValue                                 func(context.Context) (*UsageLog, error)
	predicates                               []predicate.UsageLog
}

var _ ent.Mutation = (*UsageLogMutation)(nil)

// usagelogOption allows management of the mutation configuration using functional options.
type usagelogOption func(*UsageLogMutation)

// newUsageLogMutation creates new mutation for the UsageLog entity.
func newUsageLogMutation(c config, op Op, opts ...usagelogOption) *UsageLogMutation {
	m := &UsageLogMutation{
		config:        c,
		op:            op,
		typ:           TypeUsageLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUsageLogID sets the ID field of the mutation.
func withUsageLogID(id int) usagelogOption {
	return func(m *UsageLogMutation) {
		var (
			err   error
			once  sync.Once
			value *UsageLog
		)
		m.oldValue = func(ctx context.Context) (*UsageLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UsageLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUsageLog sets the old UsageLog of the mutation.
func withUsageLog(node *UsageLog) usagelogOption {
	return func(m *UsageLogMutation) {
		m.oldValue = func(context.Context) (*UsageLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UsageLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UsageLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UsageLogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UsageLogMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UsageLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UsageLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UsageLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UsageLogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UsageLogMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UsageLogMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UsageLogMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetRequestID sets the "request_id" field.
func (m *UsageLogMutation) SetRequestID(i int) {
	m.request = &i
}

// RequestID returns the value of the "request_id" field in the mutation.
func (m *UsageLogMutation) RequestID() (r int, exists bool) {
	v := m.request
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestID returns the old "request_id" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldRequestID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestID: %w", err)
	}
	return oldValue.RequestID, nil
}

// ResetRequestID resets all changes to the "request_id" field.
func (m *UsageLogMutation) ResetRequestID() {
	m.request = nil
}

// SetAPIKeyID sets the "api_key_id" field.
func (m *UsageLogMutation) SetAPIKeyID(i int) {
	m.api_key_id = &i
	m.addapi_key_id = nil
}

// APIKeyID returns the value of the "api_key_id" field in the mutation.
func (m *UsageLogMutation) APIKeyID() (r int, exists bool) {
	v := m.api_key_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIKeyID returns the old "api_key_id" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldAPIKeyID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPIKeyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPIKeyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIKeyID: %w", err)
	}
	return oldValue.APIKeyID, nil
}

// AddAPIKeyID adds i to the "api_key_id" field.
func (m *UsageLogMutation) AddAPIKeyID(i int) {
	if m.addapi_key_id != nil {
		*m.addapi_key_id += i
	} else {
		m.addapi_key_id = &i
	}
}

// AddedAPIKeyID returns the value that was added to the "api_key_id" field in this mutation.
func (m *UsageLogMutation) AddedAPIKeyID() (r int, exists bool) {
	v := m.addapi_key_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearAPIKeyID clears the value of the "api_key_id" field.
func (m *UsageLogMutation) ClearAPIKeyID() {
	m.api_key_id = nil
	m.addapi_key_id = nil
	m.clearedFields[usagelog.FieldAPIKeyID] = struct{}{}
}

// APIKeyIDCleared returns if the "api_key_id" field was cleared in this mutation.
func (m *UsageLogMutation) APIKeyIDCleared() bool {
	_, ok := m.clearedFields[usagelog.FieldAPIKeyID]
	return ok
}

// ResetAPIKeyID resets all changes to the "api_key_id" field.
func (m *UsageLogMutation) ResetAPIKeyID() {
	m.api_key_id = nil
	m.addapi_key_id = nil
	delete(m.clearedFields, usagelog.FieldAPIKeyID)
}

// SetProjectID sets the "project_id" field.
func (m *UsageLogMutation) SetProjectID(i int) {
	m.project = &i
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *UsageLogMutation) ProjectID() (r int, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldProjectID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *UsageLogMutation) ResetProjectID() {
	m.project = nil
}

// SetChannelID sets the "channel_id" field.
func (m *UsageLogMutation) SetChannelID(i int) {
	m.channel = &i
}

// ChannelID returns the value of the "channel_id" field in the mutation.
func (m *UsageLogMutation) ChannelID() (r int, exists bool) {
	v := m.channel
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelID returns the old "channel_id" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldChannelID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelID: %w", err)
	}
	return oldValue.ChannelID, nil
}

// ClearChannelID clears the value of the "channel_id" field.
func (m *UsageLogMutation) ClearChannelID() {
	m.channel = nil
	m.clearedFields[usagelog.FieldChannelID] = struct{}{}
}

// ChannelIDCleared returns if the "channel_id" field was cleared in this mutation.
func (m *UsageLogMutation) ChannelIDCleared() bool {
	_, ok := m.clearedFields[usagelog.FieldChannelID]
	return ok
}

// ResetChannelID resets all changes to the "channel_id" field.
func (m *UsageLogMutation) ResetChannelID() {
	m.channel = nil
	delete(m.clearedFields, usagelog.FieldChannelID)
}

// SetModelID sets the "model_id" field.
func (m *UsageLogMutation) SetModelID(s string) {
	m.model_id = &s
}

// ModelID returns the value of the "model_id" field in the mutation.
func (m *UsageLogMutation) ModelID() (r string, exists bool) {
	v := m.model_id
	if v == nil {
		return
	}
	return *v, true
}

// OldModelID returns the old "model_id" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldModelID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModelID: %w", err)
	}
	return oldValue.ModelID, nil
}

// ResetModelID resets all changes to the "model_id" field.
func (m *UsageLogMutation) ResetModelID() {
	m.model_id = nil
}

// SetPromptTokens sets the "prompt_tokens" field.
func (m *UsageLogMutation) SetPromptTokens(i int64) {
	m.prompt_tokens = &i
	m.addprompt_tokens = nil
}

// PromptTokens returns the value of the "prompt_tokens" field in the mutation.
func (m *UsageLogMutation) PromptTokens() (r int64, exists bool) {
	v := m.prompt_tokens
	if v == nil {
		return
	}
	return *v, true
}

// OldPromptTokens returns the old "prompt_tokens" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldPromptTokens(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPromptTokens is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPromptTokens requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPromptTokens: %w", err)
	}
	return oldValue.PromptTokens, nil
}

// AddPromptTokens adds i to the "prompt_tokens" field.
func (m *UsageLogMutation) AddPromptTokens(i int64) {
	if m.addprompt_tokens != nil {
		*m.addprompt_tokens += i
	} else {
		m.addprompt_tokens = &i
	}
}

// AddedPromptTokens returns the value that was added to the "prompt_tokens" field in this mutation.
func (m *UsageLogMutation) AddedPromptTokens() (r int64, exists bool) {
	v := m.addprompt_tokens
	if v == nil {
		return
	}
	return *v, true
}

// ResetPromptTokens resets all changes to the "prompt_tokens" field.
func (m *UsageLogMutation) ResetPromptTokens() {
	m.prompt_tokens = nil
	m.addprompt_tokens = nil
}

// SetCompletionTokens sets the "completion_tokens" field.
func (m *UsageLogMutation) SetCompletionTokens(i int64) {
	m.completion_tokens = &i
	m.addcompletion_tokens = nil
}

// CompletionTokens returns the value of the "completion_tokens" field in the mutation.
func (m *UsageLogMutation) CompletionTokens() (r int64, exists bool) {
	v := m.completion_tokens
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletionTokens returns the old "completion_tokens" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldCompletionTokens(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletionTokens is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletionTokens requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletionTokens: %w", err)
	}
	return oldValue.CompletionTokens, nil
}

// AddCompletionTokens adds i to the "completion_tokens" field.
func (m *UsageLogMutation) AddCompletionTokens(i int64) {
	if m.addcompletion_tokens != nil {
		*m.addcompletion_tokens += i
	} else {
		m.addcompletion_tokens = &i
	}
}

// AddedCompletionTokens returns the value that was added to the "completion_tokens" field in this mutation.
func (m *UsageLogMutation) AddedCompletionTokens() (r int64, exists bool) {
	v := m.addcompletion_tokens
	if v == nil {
		return
	}
	return *v, true
}

// ResetCompletionTokens resets all changes to the "completion_tokens" field.
func (m *UsageLogMutation) ResetCompletionTokens() {
	m.completion_tokens = nil
	m.addcompletion_tokens = nil
}

// SetTotalTokens sets the "total_tokens" field.
func (m *UsageLogMutation) SetTotalTokens(i int64) {
	m.total_tokens = &i
	m.addtotal_tokens = nil
}

// TotalTokens returns the value of the "total_tokens" field in the mutation.
func (m *UsageLogMutation) TotalTokens() (r int64, exists bool) {
	v := m.total_tokens
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalTokens returns the old "total_tokens" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldTotalTokens(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalTokens is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalTokens requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalTokens: %w", err)
	}
	return oldValue.TotalTokens, nil
}

// AddTotalTokens adds i to the "total_tokens" field.
func (m *UsageLogMutation) AddTotalTokens(i int64) {
	if m.addtotal_tokens != nil {
		*m.addtotal_tokens += i
	} else {
		m.addtotal_tokens = &i
	}
}

// AddedTotalTokens returns the value that was added to the "total_tokens" field in this mutation.
func (m *UsageLogMutation) AddedTotalTokens() (r int64, exists bool) {
	v := m.addtotal_tokens
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalTokens resets all changes to the "total_tokens" field.
func (m *UsageLogMutation) ResetTotalTokens() {
	m.total_tokens = nil
	m.addtotal_tokens = nil
}

// SetPromptAudioTokens sets the "prompt_audio_tokens" field.
func (m *UsageLogMutation) SetPromptAudioTokens(i int64) {
	m.prompt_audio_tokens = &i
	m.addprompt_audio_tokens = nil
}

// PromptAudioTokens returns the value of the "prompt_audio_tokens" field in the mutation.
func (m *UsageLogMutation) PromptAudioTokens() (r int64, exists bool) {
	v := m.prompt_audio_tokens
	if v == nil {
		return
	}
	return *v, true
}

// OldPromptAudioTokens returns the old "prompt_audio_tokens" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldPromptAudioTokens(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPromptAudioTokens is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPromptAudioTokens requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPromptAudioTokens: %w", err)
	}
	return oldValue.PromptAudioTokens, nil
}

// AddPromptAudioTokens adds i to the "prompt_audio_tokens" field.
func (m *UsageLogMutation) AddPromptAudioTokens(i int64) {
	if m.addprompt_audio_tokens != nil {
		*m.addprompt_audio_tokens += i
	} else {
		m.addprompt_audio_tokens = &i
	}
}

// AddedPromptAudioTokens returns the value that was added to the "prompt_audio_tokens" field in this mutation.
func (m *UsageLogMutation) AddedPromptAudioTokens() (r int64, exists bool) {
	v := m.addprompt_audio_tokens
	if v == nil {
		return
	}
	return *v, true
}

// ClearPromptAudioTokens clears the value of the "prompt_audio_tokens" field.
func (m *UsageLogMutation) ClearPromptAudioTokens() {
	m.prompt_audio_tokens = nil
	m.addprompt_audio_tokens = nil
	m.clearedFields[usagelog.FieldPromptAudioTokens] = struct{}{}
}

// PromptAudioTokensCleared returns if the "prompt_audio_tokens" field was cleared in this mutation.
func (m *UsageLogMutation) PromptAudioTokensCleared() bool {
	_, ok := m.clearedFields[usagelog.FieldPromptAudioTokens]
	return ok
}

// ResetPromptAudioTokens resets all changes to the "prompt_audio_tokens" field.
func (m *UsageLogMutation) ResetPromptAudioTokens() {
	m.prompt_audio_tokens = nil
	m.addprompt_audio_tokens = nil
	delete(m.clearedFields, usagelog.FieldPromptAudioTokens)
}

// SetPromptCachedTokens sets the "prompt_cached_tokens" field.
func (m *UsageLogMutation) SetPromptCachedTokens(i int64) {
	m.prompt_cached_tokens = &i
	m.addprompt_cached_tokens = nil
}

// PromptCachedTokens returns the value of the "prompt_cached_tokens" field in the mutation.
func (m *UsageLogMutation) PromptCachedTokens() (r int64, exists bool) {
	v := m.prompt_cached_tokens
	if v == nil {
		return
	}
	return *v, true
}

// OldPromptCachedTokens returns the old "prompt_cached_tokens" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldPromptCachedTokens(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPromptCachedTokens is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPromptCachedTokens requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPromptCachedTokens: %w", err)
	}
	return oldValue.PromptCachedTokens, nil
}

// AddPromptCachedTokens adds i to the "prompt_cached_tokens" field.
func (m *UsageLogMutation) AddPromptCachedTokens(i int64) {
	if m.addprompt_cached_tokens != nil {
		*m.addprompt_cached_tokens += i
	} else {
		m.addprompt_cached_tokens = &i
	}
}

// AddedPromptCachedTokens returns the value that was added to the "prompt_cached_tokens" field in this mutation.
func (m *UsageLogMutation) AddedPromptCachedTokens() (r int64, exists bool) {
	v := m.addprompt_cached_tokens
	if v == nil {
		return
	}
	return *v, true
}

// ClearPromptCachedTokens clears the value of the "prompt_cached_tokens" field.
func (m *UsageLogMutation) ClearPromptCachedTokens() {
	m.prompt_cached_tokens = nil
	m.addprompt_cached_tokens = nil
	m.clearedFields[usagelog.FieldPromptCachedTokens] = struct{}{}
}

// PromptCachedTokensCleared returns if the "prompt_cached_tokens" field was cleared in this mutation.
func (m *UsageLogMutation) PromptCachedTokensCleared() bool {
	_, ok := m.clearedFields[usagelog.FieldPromptCachedTokens]
	return ok
}

// ResetPromptCachedTokens resets all changes to the "prompt_cached_tokens" field.
func (m *UsageLogMutation) ResetPromptCachedTokens() {
	m.prompt_cached_tokens = nil
	m.addprompt_cached_tokens = nil
	delete(m.clearedFields, usagelog.FieldPromptCachedTokens)
}

// SetPromptWriteCachedTokens sets the "prompt_write_cached_tokens" field.
func (m *UsageLogMutation) SetPromptWriteCachedTokens(i int64) {
	m.prompt_write_cached_tokens = &i
	m.addprompt_write_cached_tokens = nil
}

// PromptWriteCachedTokens returns the value of the "prompt_write_cached_tokens" field in the mutation.
func (m *UsageLogMutation) PromptWriteCachedTokens() (r int64, exists bool) {
	v := m.prompt_write_cached_tokens
	if v == nil {
		return
	}
	return *v, true
}

// OldPromptWriteCachedTokens returns the old "prompt_write_cached_tokens" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldPromptWriteCachedTokens(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPromptWriteCachedTokens is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPromptWriteCachedTokens requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPromptWriteCachedTokens: %w", err)
	}
	return oldValue.PromptWriteCachedTokens, nil
}

// AddPromptWriteCachedTokens adds i to the "prompt_write_cached_tokens" field.
func (m *UsageLogMutation) AddPromptWriteCachedTokens(i int64) {
	if m.addprompt_write_cached_tokens != nil {
		*m.addprompt_write_cached_tokens += i
	} else {
		m.addprompt_write_cached_tokens = &i
	}
}

// AddedPromptWriteCachedTokens returns the value that was added to the "prompt_write_cached_tokens" field in this mutation.
func (m *UsageLogMutation) AddedPromptWriteCachedTokens() (r int64, exists bool) {
	v := m.addprompt_write_cached_tokens
	if v == nil {
		return
	}
	return *v, true
}

// ClearPromptWriteCachedTokens clears the value of the "prompt_write_cached_tokens" field.
func (m *UsageLogMutation) ClearPromptWriteCachedTokens() {
	m.prompt_write_cached_tokens = nil
	m.addprompt_write_cached_tokens = nil
	m.clearedFields[usagelog.FieldPromptWriteCachedTokens] = struct{}{}
}

// PromptWriteCachedTokensCleared returns if the "prompt_write_cached_tokens" field was cleared in this mutation.
func (m *UsageLogMutation) PromptWriteCachedTokensCleared() bool {
	_, ok := m.clearedFields[usagelog.FieldPromptWriteCachedTokens]
	return ok
}

// ResetPromptWriteCachedTokens resets all changes to the "prompt_write_cached_tokens" field.
func (m *UsageLogMutation) ResetPromptWriteCachedTokens() {
	m.prompt_write_cached_tokens = nil
	m.addprompt_write_cached_tokens = nil
	delete(m.clearedFields, usagelog.FieldPromptWriteCachedTokens)
}

// SetPromptWriteCachedTokens5m sets the "prompt_write_cached_tokens_5m" field.
func (m *UsageLogMutation) SetPromptWriteCachedTokens5m(i int64) {
	m.prompt_write_cached_tokens_5m = &i
	m.addprompt_write_cached_tokens_5m = nil
}

// PromptWriteCachedTokens5m returns the value of the "prompt_write_cached_tokens_5m" field in the mutation.
func (m *UsageLogMutation) PromptWriteCachedTokens5m() (r int64, exists bool) {
	v := m.prompt_write_cached_tokens_5m
	if v == nil {
		return
	}
	return *v, true
}

// OldPromptWriteCachedTokens5m returns the old "prompt_write_cached_tokens_5m" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldPromptWriteCachedTokens5m(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPromptWriteCachedTokens5m is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPromptWriteCachedTokens5m requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPromptWriteCachedTokens5m: %w", err)
	}
	return oldValue.PromptWriteCachedTokens5m, nil
}

// AddPromptWriteCachedTokens5m adds i to the "prompt_write_cached_tokens_5m" field.
func (m *UsageLogMutation) AddPromptWriteCachedTokens5m(i int64) {
	if m.addprompt_write_cached_tokens_5m != nil {
		*m.addprompt_write_cached_tokens_5m += i
	} else {
		m.addprompt_write_cached_tokens_5m = &i
	}
}

// AddedPromptWriteCachedTokens5m returns the value that was added to the "prompt_write_cached_tokens_5m" field in this mutation.
func (m *UsageLogMutation) AddedPromptWriteCachedTokens5m() (r int64, exists bool) {
	v := m.addprompt_write_cached_tokens_5m
	if v == nil {
		return
	}
	return *v, true
}

// ClearPromptWriteCachedTokens5m clears the value of the "prompt_write_cached_tokens_5m" field.
func (m *UsageLogMutation) ClearPromptWriteCachedTokens5m() {
	m.prompt_write_cached_tokens_5m = nil
	m.addprompt_write_cached_tokens_5m = nil
	m.clearedFields[usagelog.FieldPromptWriteCachedTokens5m] = struct{}{}
}

// PromptWriteCachedTokens5mCleared returns if the "prompt_write_cached_tokens_5m" field was cleared in this mutation.
func (m *UsageLogMutation) PromptWriteCachedTokens5mCleared() bool {
	_, ok := m.clearedFields[usagelog.FieldPromptWriteCachedTokens5m]
	return ok
}

// ResetPromptWriteCachedTokens5m resets all changes to the "prompt_write_cached_tokens_5m" field.
func (m *UsageLogMutation) ResetPromptWriteCachedTokens5m() {
	m.prompt_write_cached_tokens_5m = nil
	m.addprompt_write_cached_tokens_5m = nil
	delete(m.clearedFields, usagelog.FieldPromptWriteCachedTokens5m)
}

// SetPromptWriteCachedTokens1h sets the "prompt_write_cached_tokens_1h" field.
func (m *UsageLogMutation) SetPromptWriteCachedTokens1h(i int64) {
	m.prompt_write_cached_tokens_1h = &i
	m.addprompt_write_cached_tokens_1h = nil
}

// PromptWriteCachedTokens1h returns the value of the "prompt_write_cached_tokens_1h" field in the mutation.
func (m *UsageLogMutation) PromptWriteCachedTokens1h() (r int64, exists bool) {
	v := m.prompt_write_cached_tokens_1h
	if v == nil {
		return
	}
	return *v, true
}

// OldPromptWriteCachedTokens1h returns the old "prompt_write_cached_tokens_1h" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldPromptWriteCachedTokens1h(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPromptWriteCachedTokens1h is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPromptWriteCachedTokens1h requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPromptWriteCachedTokens1h: %w", err)
	}
	return oldValue.PromptWriteCachedTokens1h, nil
}

// AddPromptWriteCachedTokens1h adds i to the "prompt_write_cached_tokens_1h" field.
func (m *UsageLogMutation) AddPromptWriteCachedTokens1h(i int64) {
	if m.addprompt_write_cached_tokens_1h != nil {
		*m.addprompt_write_cached_tokens_1h += i
	} else {
		m.addprompt_write_cached_tokens_1h = &i
	}
}

// AddedPromptWriteCachedTokens1h returns the value that was added to the "prompt_write_cached_tokens_1h" field in this mutation.
func (m *UsageLogMutation) AddedPromptWriteCachedTokens1h() (r int64, exists bool) {
	v := m.addprompt_write_cached_tokens_1h
	if v == nil {
		return
	}
	return *v, true
}

// ClearPromptWriteCachedTokens1h clears the value of the "prompt_write_cached_tokens_1h" field.
func (m *UsageLogMutation) ClearPromptWriteCachedTokens1h() {
	m.prompt_write_cached_tokens_1h = nil
	m.addprompt_write_cached_tokens_1h = nil
	m.clearedFields[usagelog.FieldPromptWriteCachedTokens1h] = struct{}{}
}

// PromptWriteCachedTokens1hCleared returns if the "prompt_write_cached_tokens_1h" field was cleared in this mutation.
func (m *UsageLogMutation) PromptWriteCachedTokens1hCleared() bool {
	_, ok := m.clearedFields[usagelog.FieldPromptWriteCachedTokens1h]
	return ok
}

// ResetPromptWriteCachedTokens1h resets all changes to the "prompt_write_cached_tokens_1h" field.
func (m *UsageLogMutation) ResetPromptWriteCachedTokens1h() {
	m.prompt_write_cached_tokens_1h = nil
	m.addprompt_write_cached_tokens_1h = nil
	delete(m.clearedFields, usagelog.FieldPromptWriteCachedTokens1h)
}

// SetCompletionAudioTokens sets the "completion_audio_tokens" field.
func (m *UsageLogMutation) SetCompletionAudioTokens(i int64) {
	m.completion_audio_tokens = &i
	m.addcompletion_audio_tokens = nil
}

// CompletionAudioTokens returns the value of the "completion_audio_tokens" field in the mutation.
func (m *UsageLogMutation) CompletionAudioTokens() (r int64, exists bool) {
	v := m.completion_audio_tokens
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletionAudioTokens returns the old "completion_audio_tokens" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldCompletionAudioTokens(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletionAudioTokens is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletionAudioTokens requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletionAudioTokens: %w", err)
	}
	return oldValue.CompletionAudioTokens, nil
}

// AddCompletionAudioTokens adds i to the "completion_audio_tokens" field.
func (m *UsageLogMutation) AddCompletionAudioTokens(i int64) {
	if m.addcompletion_audio_tokens != nil {
		*m.addcompletion_audio_tokens += i
	} else {
		m.addcompletion_audio_tokens = &i
	}
}

// AddedCompletionAudioTokens returns the value that was added to the "completion_audio_tokens" field in this mutation.
func (m *UsageLogMutation) AddedCompletionAudioTokens() (r int64, exists bool) {
	v := m.addcompletion_audio_tokens
	if v == nil {
		return
	}
	return *v, true
}

// ClearCompletionAudioTokens clears the value of the "completion_audio_tokens" field.
func (m *UsageLogMutation) ClearCompletionAudioTokens() {
	m.completion_audio_tokens = nil
	m.addcompletion_audio_tokens = nil
	m.clearedFields[usagelog.FieldCompletionAudioTokens] = struct{}{}
}

// CompletionAudioTokensCleared returns if the "completion_audio_tokens" field was cleared in this mutation.
func (m *UsageLogMutation) CompletionAudioTokensCleared() bool {
	_, ok := m.clearedFields[usagelog.FieldCompletionAudioTokens]
	return ok
}

// ResetCompletionAudioTokens resets all changes to the "completion_audio_tokens" field.
func (m *UsageLogMutation) ResetCompletionAudioTokens() {
	m.completion_audio_tokens = nil
	m.addcompletion_audio_tokens = nil
	delete(m.clearedFields, usagelog.FieldCompletionAudioTokens)
}

// SetCompletionReasoningTokens sets the "completion_reasoning_tokens" field.
func (m *UsageLogMutation) SetCompletionReasoningTokens(i int64) {
	m.completion_reasoning_tokens = &i
	m.addcompletion_reasoning_tokens = nil
}

// CompletionReasoningTokens returns the value of the "completion_reasoning_tokens" field in the mutation.
func (m *UsageLogMutation) CompletionReasoningTokens() (r int64, exists bool) {
	v := m.completion_reasoning_tokens
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletionReasoningTokens returns the old "completion_reasoning_tokens" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldCompletionReasoningTokens(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletionReasoningTokens is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletionReasoningTokens requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletionReasoningTokens: %w", err)
	}
	return oldValue.CompletionReasoningTokens, nil
}

// AddCompletionReasoningTokens adds i to the "completion_reasoning_tokens" field.
func (m *UsageLogMutation) AddCompletionReasoningTokens(i int64) {
	if m.addcompletion_reasoning_tokens != nil {
		*m.addcompletion_reasoning_tokens += i
	} else {
		m.addcompletion_reasoning_tokens = &i
	}
}

// AddedCompletionReasoningTokens returns the value that was added to the "completion_reasoning_tokens" field in this mutation.
func (m *UsageLogMutation) AddedCompletionReasoningTokens() (r int64, exists bool) {
	v := m.addcompletion_reasoning_tokens
	if v == nil {
		return
	}
	return *v, true
}

// ClearCompletionReasoningTokens clears the value of the "completion_reasoning_tokens" field.
func (m *UsageLogMutation) ClearCompletionReasoningTokens() {
	m.completion_reasoning_tokens = nil
	m.addcompletion_reasoning_tokens = nil
	m.clearedFields[usagelog.FieldCompletionReasoningTokens] = struct{}{}
}

// CompletionReasoningTokensCleared returns if the "completion_reasoning_tokens" field was cleared in this mutation.
func (m *UsageLogMutation) CompletionReasoningTokensCleared() bool {
	_, ok := m.clearedFields[usagelog.FieldCompletionReasoningTokens]
	return ok
}

// ResetCompletionReasoningTokens resets all changes to the "completion_reasoning_tokens" field.
func (m *UsageLogMutation) ResetCompletionReasoningTokens() {
	m.completion_reasoning_tokens = nil
	m.addcompletion_reasoning_tokens = nil
	delete(m.clearedFields, usagelog.FieldCompletionReasoningTokens)
}

// SetCompletionAcceptedPredictionTokens sets the "completion_accepted_prediction_tokens" field.
func (m *UsageLogMutation) SetCompletionAcceptedPredictionTokens(i int64) {
	m.completion_accepted_prediction_tokens = &i
	m.addcompletion_accepted_prediction_tokens = nil
}

// CompletionAcceptedPredictionTokens returns the value of the "completion_accepted_prediction_tokens" field in the mutation.
func (m *UsageLogMutation) CompletionAcceptedPredictionTokens() (r int64, exists bool) {
	v := m.completion_accepted_prediction_tokens
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletionAcceptedPredictionTokens returns the old "completion_accepted_prediction_tokens" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldCompletionAcceptedPredictionTokens(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletionAcceptedPredictionTokens is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletionAcceptedPredictionTokens requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletionAcceptedPredictionTokens: %w", err)
	}
	return oldValue.CompletionAcceptedPredictionTokens, nil
}

// AddCompletionAcceptedPredictionTokens adds i to the "completion_accepted_prediction_tokens" field.
func (m *UsageLogMutation) AddCompletionAcceptedPredictionTokens(i int64) {
	if m.addcompletion_accepted_prediction_tokens != nil {
		*m.addcompletion_accepted_prediction_tokens += i
	} else {
		m.addcompletion_accepted_prediction_tokens = &i
	}
}

// AddedCompletionAcceptedPredictionTokens returns the value that was added to the "completion_accepted_prediction_tokens" field in this mutation.
func (m *UsageLogMutation) AddedCompletionAcceptedPredictionTokens() (r int64, exists bool) {
	v := m.addcompletion_accepted_prediction_tokens
	if v == nil {
		return
	}
	return *v, true
}

// ClearCompletionAcceptedPredictionTokens clears the value of the "completion_accepted_prediction_tokens" field.
func (m *UsageLogMutation) ClearCompletionAcceptedPredictionTokens() {
	m.completion_accepted_prediction_tokens = nil
	m.addcompletion_accepted_prediction_tokens = nil
	m.clearedFields[usagelog.FieldCompletionAcceptedPredictionTokens] = struct{}{}
}

// CompletionAcceptedPredictionTokensCleared returns if the "completion_accepted_prediction_tokens" field was cleared in this mutation.
func (m *UsageLogMutation) CompletionAcceptedPredictionTokensCleared() bool {
	_, ok := m.clearedFields[usagelog.FieldCompletionAcceptedPredictionTokens]
	return ok
}

// ResetCompletionAcceptedPredictionTokens resets all changes to the "completion_accepted_prediction_tokens" field.
func (m *UsageLogMutation) ResetCompletionAcceptedPredictionTokens() {
	m.completion_accepted_prediction_tokens = nil
	m.addcompletion_accepted_prediction_tokens = nil
	delete(m.clearedFields, usagelog.FieldCompletionAcceptedPredictionTokens)
}

// SetCompletionRejectedPredictionTokens sets the "completion_rejected_prediction_tokens" field.
func (m *UsageLogMutation) SetCompletionRejectedPredictionTokens(i int64) {
	m.completion_rejected_prediction_tokens = &i
	m.addcompletion_rejected_prediction_tokens = nil
}

// CompletionRejectedPredictionTokens returns the value of the "completion_rejected_prediction_tokens" field in the mutation.
func (m *UsageLogMutation) CompletionRejectedPredictionTokens() (r int64, exists bool) {
	v := m.completion_rejected_prediction_tokens
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletionRejectedPredictionTokens returns the old "completion_rejected_prediction_tokens" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldCompletionRejectedPredictionTokens(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletionRejectedPredictionTokens is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletionRejectedPredictionTokens requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletionRejectedPredictionTokens: %w", err)
	}
	return oldValue.CompletionRejectedPredictionTokens, nil
}

// AddCompletionRejectedPredictionTokens adds i to the "completion_rejected_prediction_tokens" field.
func (m *UsageLogMutation) AddCompletionRejectedPredictionTokens(i int64) {
	if m.addcompletion_rejected_prediction_tokens != nil {
		*m.addcompletion_rejected_prediction_tokens += i
	} else {
		m.addcompletion_rejected_prediction_tokens = &i
	}
}

// AddedCompletionRejectedPredictionTokens returns the value that was added to the "completion_rejected_prediction_tokens" field in this mutation.
func (m *UsageLogMutation) AddedCompletionRejectedPredictionTokens() (r int64, exists bool) {
	v := m.addcompletion_rejected_prediction_tokens
	if v == nil {
		return
	}
	return *v, true
}

// ClearCompletionRejectedPredictionTokens clears the value of the "completion_rejected_prediction_tokens" field.
func (m *UsageLogMutation) ClearCompletionRejectedPredictionTokens() {
	m.completion_rejected_prediction_tokens = nil
	m.addcompletion_rejected_prediction_tokens = nil
	m.clearedFields[usagelog.FieldCompletionRejectedPredictionTokens] = struct{}{}
}

// CompletionRejectedPredictionTokensCleared returns if the "completion_rejected_prediction_tokens" field was cleared in this mutation.
func (m *UsageLogMutation) CompletionRejectedPredictionTokensCleared() bool {
	_, ok := m.clearedFields[usagelog.FieldCompletionRejectedPredictionTokens]
	return ok
}

// ResetCompletionRejectedPredictionTokens resets all changes to the "completion_rejected_prediction_tokens" field.
func (m *UsageLogMutation) ResetCompletionRejectedPredictionTokens() {
	m.completion_rejected_prediction_tokens = nil
	m.addcompletion_rejected_prediction_tokens = nil
	delete(m.clearedFields, usagelog.FieldCompletionRejectedPredictionTokens)
}

// SetSource sets the "source" field.
func (m *UsageLogMutation) SetSource(u usagelog.Source) {
	m.source = &u
}

// Source returns the value of the "source" field in the mutation.
func (m *UsageLogMutation) Source() (r usagelog.Source, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldSource(ctx context.Context) (v usagelog.Source, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *UsageLogMutation) ResetSource() {
	m.source = nil
}

// SetFormat sets the "format" field.
func (m *UsageLogMutation) SetFormat(s string) {
	m.format = &s
}

// Format returns the value of the "format" field in the mutation.
func (m *UsageLogMutation) Format() (r string, exists bool) {
	v := m.format
	if v == nil {
		return
	}
	return *v, true
}

// OldFormat returns the old "format" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldFormat(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFormat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFormat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormat: %w", err)
	}
	return oldValue.Format, nil
}

// ResetFormat resets all changes to the "format" field.
func (m *UsageLogMutation) ResetFormat() {
	m.format = nil
}

// SetTotalCost sets the "total_cost" field.
func (m *UsageLogMutation) SetTotalCost(f float64) {
	m.total_cost = &f
	m.addtotal_cost = nil
}

// TotalCost returns the value of the "total_cost" field in the mutation.
func (m *UsageLogMutation) TotalCost() (r float64, exists bool) {
	v := m.total_cost
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalCost returns the old "total_cost" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldTotalCost(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalCost: %w", err)
	}
	return oldValue.TotalCost, nil
}

// AddTotalCost adds f to the "total_cost" field.
func (m *UsageLogMutation) AddTotalCost(f float64) {
	if m.addtotal_cost != nil {
		*m.addtotal_cost += f
	} else {
		m.addtotal_cost = &f
	}
}

// AddedTotalCost returns the value that was added to the "total_cost" field in this mutation.
func (m *UsageLogMutation) AddedTotalCost() (r float64, exists bool) {
	v := m.addtotal_cost
	if v == nil {
		return
	}
	return *v, true
}

// ClearTotalCost clears the value of the "total_cost" field.
func (m *UsageLogMutation) ClearTotalCost() {
	m.total_cost = nil
	m.addtotal_cost = nil
	m.clearedFields[usagelog.FieldTotalCost] = struct{}{}
}

// TotalCostCleared returns if the "total_cost" field was cleared in this mutation.
func (m *UsageLogMutation) TotalCostCleared() bool {
	_, ok := m.clearedFields[usagelog.FieldTotalCost]
	return ok
}

// ResetTotalCost resets all changes to the "total_cost" field.
func (m *UsageLogMutation) ResetTotalCost() {
	m.total_cost = nil
	m.addtotal_cost = nil
	delete(m.clearedFields, usagelog.FieldTotalCost)
}

// SetCostItems sets the "cost_items" field.
func (m *UsageLogMutation) SetCostItems(oi []objects.CostItem) {
	m.cost_items = &oi
	m.appendcost_items = nil
}

// CostItems returns the value of the "cost_items" field in the mutation.
func (m *UsageLogMutation) CostItems() (r []objects.CostItem, exists bool) {
	v := m.cost_items
	if v == nil {
		return
	}
	return *v, true
}

// OldCostItems returns the old "cost_items" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldCostItems(ctx context.Context) (v []objects.CostItem, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCostItems is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCostItems requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCostItems: %w", err)
	}
	return oldValue.CostItems, nil
}

// AppendCostItems adds oi to the "cost_items" field.
func (m *UsageLogMutation) AppendCostItems(oi []objects.CostItem) {
	m.appendcost_items = append(m.appendcost_items, oi...)
}

// AppendedCostItems returns the list of values that were appended to the "cost_items" field in this mutation.
func (m *UsageLogMutation) AppendedCostItems() ([]objects.CostItem, bool) {
	if len(m.appendcost_items) == 0 {
		return nil, false
	}
	return m.appendcost_items, true
}

// ClearCostItems clears the value of the "cost_items" field.
func (m *UsageLogMutation) ClearCostItems() {
	m.cost_items = nil
	m.appendcost_items = nil
	m.clearedFields[usagelog.FieldCostItems] = struct{}{}
}

// CostItemsCleared returns if the "cost_items" field was cleared in this mutation.
func (m *UsageLogMutation) CostItemsCleared() bool {
	_, ok := m.clearedFields[usagelog.FieldCostItems]
	return ok
}

// ResetCostItems resets all changes to the "cost_items" field.
func (m *UsageLogMutation) ResetCostItems() {
	m.cost_items = nil
	m.appendcost_items = nil
	delete(m.clearedFields, usagelog.FieldCostItems)
}

// SetCostPriceReferenceID sets the "cost_price_reference_id" field.
func (m *UsageLogMutation) SetCostPriceReferenceID(s string) {
	m.cost_price_reference_id = &s
}

// CostPriceReferenceID returns the value of the "cost_price_reference_id" field in the mutation.
func (m *UsageLogMutation) CostPriceReferenceID() (r string, exists bool) {
	v := m.cost_price_reference_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCostPriceReferenceID returns the old "cost_price_reference_id" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldCostPriceReferenceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCostPriceReferenceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCostPriceReferenceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCostPriceReferenceID: %w", err)
	}
	return oldValue.CostPriceReferenceID, nil
}

// ClearCostPriceReferenceID clears the value of the "cost_price_reference_id" field.
func (m *UsageLogMutation) ClearCostPriceReferenceID() {
	m.cost_price_reference_id = nil
	m.clearedFields[usagelog.FieldCostPriceReferenceID] = struct{}{}
}

// CostPriceReferenceIDCleared returns if the "cost_price_reference_id" field was cleared in this mutation.
func (m *UsageLogMutation) CostPriceReferenceIDCleared() bool {
	_, ok := m.clearedFields[usagelog.FieldCostPriceReferenceID]
	return ok
}

// ResetCostPriceReferenceID resets all changes to the "cost_price_reference_id" field.
func (m *UsageLogMutation) ResetCostPriceReferenceID() {
	m.cost_price_reference_id = nil
	delete(m.clearedFields, usagelog.FieldCostPriceReferenceID)
}

// ClearRequest clears the "request" edge to the Request entity.
func (m *UsageLogMutation) ClearRequest() {
	m.clearedrequest = true
	m.clearedFields[usagelog.FieldRequestID] = struct{}{}
}

// RequestCleared reports if the "request" edge to the Request entity was cleared.
func (m *UsageLogMutation) RequestCleared() bool {
	return m.clearedrequest
}

// RequestIDs returns the "request" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RequestID instead. It exists only for internal usage by the builders.
func (m *UsageLogMutation) RequestIDs() (ids []int) {
	if id := m.request; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRequest resets all changes to the "request" edge.
func (m *UsageLogMutation) ResetRequest() {
	m.request = nil
	m.clearedrequest = false
}

// ClearProject clears the "project" edge to the Project entity.
func (m *UsageLogMutation) ClearProject() {
	m.clearedproject = true
	m.clearedFields[usagelog.FieldProjectID] = struct{}{}
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *UsageLogMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *UsageLogMutation) ProjectIDs() (ids []int) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *UsageLogMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// ClearChannel clears the "channel" edge to the Channel entity.
func (m *UsageLogMutation) ClearChannel() {
	m.clearedchannel = true
	m.clearedFields[usagelog.FieldChannelID] = struct{}{}
}

// ChannelCleared reports if the "channel" edge to the Channel entity was cleared.
func (m *UsageLogMutation) ChannelCleared() bool {
	return m.ChannelIDCleared() || m.clearedchannel
}

// ChannelIDs returns the "channel" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChannelID instead. It exists only for internal usage by the builders.
func (m *UsageLogMutation) ChannelIDs() (ids []int) {
	if id := m.channel; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChannel resets all changes to the "channel" edge.
func (m *UsageLogMutation) ResetChannel() {
	m.channel = nil
	m.clearedchannel = false
}

// Where appends a list predicates to the UsageLogMutation builder.
func (m *UsageLogMutation) Where(ps ...predicate.UsageLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UsageLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UsageLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UsageLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UsageLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UsageLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UsageLog).
func (m *UsageLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UsageLogMutation) Fields() []string {
	fields := make([]string, 0, 24)
	if m.created_at != nil {
		fields = append(fields, usagelog.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, usagelog.FieldUpdatedAt)
	}
	if m.request != nil {
		fields = append(fields, usagelog.FieldRequestID)
	}
	if m.api_key_id != nil {
		fields = append(fields, usagelog.FieldAPIKeyID)
	}
	if m.project != nil {
		fields = append(fields, usagelog.FieldProjectID)
	}
	if m.channel != nil {
		fields = append(fields, usagelog.FieldChannelID)
	}
	if m.model_id != nil {
		fields = append(fields, usagelog.FieldModelID)
	}
	if m.prompt_tokens != nil {
		fields = append(fields, usagelog.FieldPromptTokens)
	}
	if m.completion_tokens != nil {
		fields = append(fields, usagelog.FieldCompletionTokens)
	}
	if m.total_tokens != nil {
		fields = append(fields, usagelog.FieldTotalTokens)
	}
	if m.prompt_audio_tokens != nil {
		fields = append(fields, usagelog.FieldPromptAudioTokens)
	}
	if m.prompt_cached_tokens != nil {
		fields = append(fields, usagelog.FieldPromptCachedTokens)
	}
	if m.prompt_write_cached_tokens != nil {
		fields = append(fields, usagelog.FieldPromptWriteCachedTokens)
	}
	if m.prompt_write_cached_tokens_5m != nil {
		fields = append(fields, usagelog.FieldPromptWriteCachedTokens5m)
	}
	if m.prompt_write_cached_tokens_1h != nil {
		fields = append(fields, usagelog.FieldPromptWriteCachedTokens1h)
	}
	if m.completion_audio_tokens != nil {
		fields = append(fields, usagelog.FieldCompletionAudioTokens)
	}
	if m.completion_reasoning_tokens != nil {
		fields = append(fields, usagelog.FieldCompletionReasoningTokens)
	}
	if m.completion_accepted_prediction_tokens != nil {
		fields = append(fields, usagelog.FieldCompletionAcceptedPredictionTokens)
	}
	if m.completion_rejected_prediction_tokens != nil {
		fields = append(fields, usagelog.FieldCompletionRejectedPredictionTokens)
	}
	if m.source != nil {
		fields = append(fields, usagelog.FieldSource)
	}
	if m.format != nil {
		fields = append(fields, usagelog.FieldFormat)
	}
	if m.total_cost != nil {
		fields = append(fields, usagelog.FieldTotalCost)
	}
	if m.cost_items != nil {
		fields = append(fields, usagelog.FieldCostItems)
	}
	if m.cost_price_reference_id != nil {
		fields = append(fields, usagelog.FieldCostPriceReferenceID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UsageLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usagelog.FieldCreatedAt:
		return m.CreatedAt()
	case usagelog.FieldUpdatedAt:
		return m.UpdatedAt()
	case usagelog.FieldRequestID:
		return m.RequestID()
	case usagelog.FieldAPIKeyID:
		return m.APIKeyID()
	case usagelog.FieldProjectID:
		return m.ProjectID()
	case usagelog.FieldChannelID:
		return m.ChannelID()
	case usagelog.FieldModelID:
		return m.ModelID()
	case usagelog.FieldPromptTokens:
		return m.PromptTokens()
	case usagelog.FieldCompletionTokens:
		return m.CompletionTokens()
	case usagelog.FieldTotalTokens:
		return m.TotalTokens()
	case usagelog.FieldPromptAudioTokens:
		return m.PromptAudioTokens()
	case usagelog.FieldPromptCachedTokens:
		return m.PromptCachedTokens()
	case usagelog.FieldPromptWriteCachedTokens:
		return m.PromptWriteCachedTokens()
	case usagelog.FieldPromptWriteCachedTokens5m:
		return m.PromptWriteCachedTokens5m()
	case usagelog.FieldPromptWriteCachedTokens1h:
		return m.PromptWriteCachedTokens1h()
	case usagelog.FieldCompletionAudioTokens:
		return m.CompletionAudioTokens()
	case usagelog.FieldCompletionReasoningTokens:
		return m.CompletionReasoningTokens()
	case usagelog.FieldCompletionAcceptedPredictionTokens:
		return m.CompletionAcceptedPredictionTokens()
	case usagelog.FieldCompletionRejectedPredictionTokens:
		return m.CompletionRejectedPredictionTokens()
	case usagelog.FieldSource:
		return m.Source()
	case usagelog.FieldFormat:
		return m.Format()
	case usagelog.FieldTotalCost:
		return m.TotalCost()
	case usagelog.FieldCostItems:
		return m.CostItems()
	case usagelog.FieldCostPriceReferenceID:
		return m.CostPriceReferenceID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UsageLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usagelog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case usagelog.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case usagelog.FieldRequestID:
		return m.OldRequestID(ctx)
	case usagelog.FieldAPIKeyID:
		return m.OldAPIKeyID(ctx)
	case usagelog.FieldProjectID:
		return m.OldProjectID(ctx)
	case usagelog.FieldChannelID:
		return m.OldChannelID(ctx)
	case usagelog.FieldModelID:
		return m.OldModelID(ctx)
	case usagelog.FieldPromptTokens:
		return m.OldPromptTokens(ctx)
	case usagelog.FieldCompletionTokens:
		return m.OldCompletionTokens(ctx)
	case usagelog.FieldTotalTokens:
		return m.OldTotalTokens(ctx)
	case usagelog.FieldPromptAudioTokens:
		return m.OldPromptAudioTokens(ctx)
	case usagelog.FieldPromptCachedTokens:
		return m.OldPromptCachedTokens(ctx)
	case usagelog.FieldPromptWriteCachedTokens:
		return m.OldPromptWriteCachedTokens(ctx)
	case usagelog.FieldPromptWriteCachedTokens5m:
		return m.OldPromptWriteCachedTokens5m(ctx)
	case usagelog.FieldPromptWriteCachedTokens1h:
		return m.OldPromptWriteCachedTokens1h(ctx)
	case usagelog.FieldCompletionAudioTokens:
		return m.OldCompletionAudioTokens(ctx)
	case usagelog.FieldCompletionReasoningTokens:
		return m.OldCompletionReasoningTokens(ctx)
	case usagelog.FieldCompletionAcceptedPredictionTokens:
		return m.OldCompletionAcceptedPredictionTokens(ctx)
	case usagelog.FieldCompletionRejectedPredictionTokens:
		return m.OldCompletionRejectedPredictionTokens(ctx)
	case usagelog.FieldSource:
		return m.OldSource(ctx)
	case usagelog.FieldFormat:
		return m.OldFormat(ctx)
	case usagelog.FieldTotalCost:
		return m.OldTotalCost(ctx)
	case usagelog.FieldCostItems:
		return m.OldCostItems(ctx)
	case usagelog.FieldCostPriceReferenceID:
		return m.OldCostPriceReferenceID(ctx)
	}
	return nil, fmt.Errorf("unknown UsageLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UsageLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usagelog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case usagelog.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case usagelog.FieldRequestID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestID(v)
		return nil
	case usagelog.FieldAPIKeyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIKeyID(v)
		return nil
	case usagelog.FieldProjectID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case usagelog.FieldChannelID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelID(v)
		return nil
	case usagelog.FieldModelID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModelID(v)
		return nil
	case usagelog.FieldPromptTokens:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPromptTokens(v)
		return nil
	case usagelog.FieldCompletionTokens:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletionTokens(v)
		return nil
	case usagelog.FieldTotalTokens:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalTokens(v)
		return nil
	case usagelog.FieldPromptAudioTokens:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPromptAudioTokens(v)
		return nil
	case usagelog.FieldPromptCachedTokens:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPromptCachedTokens(v)
		return nil
	case usagelog.FieldPromptWriteCachedTokens:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPromptWriteCachedTokens(v)
		return nil
	case usagelog.FieldPromptWriteCachedTokens5m:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPromptWriteCachedTokens5m(v)
		return nil
	case usagelog.FieldPromptWriteCachedTokens1h:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPromptWriteCachedTokens1h(v)
		return nil
	case usagelog.FieldCompletionAudioTokens:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletionAudioTokens(v)
		return nil
	case usagelog.FieldCompletionReasoningTokens:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletionReasoningTokens(v)
		return nil
	case usagelog.FieldCompletionAcceptedPredictionTokens:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletionAcceptedPredictionTokens(v)
		return nil
	case usagelog.FieldCompletionRejectedPredictionTokens:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletionRejectedPredictionTokens(v)
		return nil
	case usagelog.FieldSource:
		v, ok := value.(usagelog.Source)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case usagelog.FieldFormat:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormat(v)
		return nil
	case usagelog.FieldTotalCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalCost(v)
		return nil
	case usagelog.FieldCostItems:
		v, ok := value.([]objects.CostItem)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCostItems(v)
		return nil
	case usagelog.FieldCostPriceReferenceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCostPriceReferenceID(v)
		return nil
	}
	return fmt.Errorf("unknown UsageLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UsageLogMutation) AddedFields() []string {
	var fields []string
	if m.addapi_key_id != nil {
		fields = append(fields, usagelog.FieldAPIKeyID)
	}
	if m.addprompt_tokens != nil {
		fields = append(fields, usagelog.FieldPromptTokens)
	}
	if m.addcompletion_tokens != nil {
		fields = append(fields, usagelog.FieldCompletionTokens)
	}
	if m.addtotal_tokens != nil {
		fields = append(fields, usagelog.FieldTotalTokens)
	}
	if m.addprompt_audio_tokens != nil {
		fields = append(fields, usagelog.FieldPromptAudioTokens)
	}
	if m.addprompt_cached_tokens != nil {
		fields = append(fields, usagelog.FieldPromptCachedTokens)
	}
	if m.addprompt_write_cached_tokens != nil {
		fields = append(fields, usagelog.FieldPromptWriteCachedTokens)
	}
	if m.addprompt_write_cached_tokens_5m != nil {
		fields = append(fields, usagelog.FieldPromptWriteCachedTokens5m)
	}
	if m.addprompt_write_cached_tokens_1h != nil {
		fields = append(fields, usagelog.FieldPromptWriteCachedTokens1h)
	}
	if m.addcompletion_audio_tokens != nil {
		fields = append(fields, usagelog.FieldCompletionAudioTokens)
	}
	if m.addcompletion_reasoning_tokens != nil {
		fields = append(fields, usagelog.FieldCompletionReasoningTokens)
	}
	if m.addcompletion_accepted_prediction_tokens != nil {
		fields = append(fields, usagelog.FieldCompletionAcceptedPredictionTokens)
	}
	if m.addcompletion_rejected_prediction_tokens != nil {
		fields = append(fields, usagelog.FieldCompletionRejectedPredictionTokens)
	}
	if m.addtotal_cost != nil {
		fields = append(fields, usagelog.FieldTotalCost)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UsageLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case usagelog.FieldAPIKeyID:
		return m.AddedAPIKeyID()
	case usagelog.FieldPromptTokens:
		return m.AddedPromptTokens()
	case usagelog.FieldCompletionTokens:
		return m.AddedCompletionTokens()
	case usagelog.FieldTotalTokens:
		return m.AddedTotalTokens()
	case usagelog.FieldPromptAudioTokens:
		return m.AddedPromptAudioTokens()
	case usagelog.FieldPromptCachedTokens:
		return m.AddedPromptCachedTokens()
	case usagelog.FieldPromptWriteCachedTokens:
		return m.AddedPromptWriteCachedTokens()
	case usagelog.FieldPromptWriteCachedTokens5m:
		return m.AddedPromptWriteCachedTokens5m()
	case usagelog.FieldPromptWriteCachedTokens1h:
		return m.AddedPromptWriteCachedTokens1h()
	case usagelog.FieldCompletionAudioTokens:
		return m.AddedCompletionAudioTokens()
	case usagelog.FieldCompletionReasoningTokens:
		return m.AddedCompletionReasoningTokens()
	case usagelog.FieldCompletionAcceptedPredictionTokens:
		return m.AddedCompletionAcceptedPredictionTokens()
	case usagelog.FieldCompletionRejectedPredictionTokens:
		return m.AddedCompletionRejectedPredictionTokens()
	case usagelog.FieldTotalCost:
		return m.AddedTotalCost()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UsageLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case usagelog.FieldAPIKeyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAPIKeyID(v)
		return nil
	case usagelog.FieldPromptTokens:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPromptTokens(v)
		return nil
	case usagelog.FieldCompletionTokens:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCompletionTokens(v)
		return nil
	case usagelog.FieldTotalTokens:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalTokens(v)
		return nil
	case usagelog.FieldPromptAudioTokens:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPromptAudioTokens(v)
		return nil
	case usagelog.FieldPromptCachedTokens:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPromptCachedTokens(v)
		return nil
	case usagelog.FieldPromptWriteCachedTokens:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPromptWriteCachedTokens(v)
		return nil
	case usagelog.FieldPromptWriteCachedTokens5m:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPromptWriteCachedTokens5m(v)
		return nil
	case usagelog.FieldPromptWriteCachedTokens1h:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPromptWriteCachedTokens1h(v)
		return nil
	case usagelog.FieldCompletionAudioTokens:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCompletionAudioTokens(v)
		return nil
	case usagelog.FieldCompletionReasoningTokens:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCompletionReasoningTokens(v)
		return nil
	case usagelog.FieldCompletionAcceptedPredictionTokens:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCompletionAcceptedPredictionTokens(v)
		return nil
	case usagelog.FieldCompletionRejectedPredictionTokens:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCompletionRejectedPredictionTokens(v)
		return nil
	case usagelog.FieldTotalCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalCost(v)
		return nil
	}
	return fmt.Errorf("unknown UsageLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UsageLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(usagelog.FieldAPIKeyID) {
		fields = append(fields, usagelog.FieldAPIKeyID)
	}
	if m.FieldCleared(usagelog.FieldChannelID) {
		fields = append(fields, usagelog.FieldChannelID)
	}
	if m.FieldCleared(usagelog.FieldPromptAudioTokens) {
		fields = append(fields, usagelog.FieldPromptAudioTokens)
	}
	if m.FieldCleared(usagelog.FieldPromptCachedTokens) {
		fields = append(fields, usagelog.FieldPromptCachedTokens)
	}
	if m.FieldCleared(usagelog.FieldPromptWriteCachedTokens) {
		fields = append(fields, usagelog.FieldPromptWriteCachedTokens)
	}
	if m.FieldCleared(usagelog.FieldPromptWriteCachedTokens5m) {
		fields = append(fields, usagelog.FieldPromptWriteCachedTokens5m)
	}
	if m.FieldCleared(usagelog.FieldPromptWriteCachedTokens1h) {
		fields = append(fields, usagelog.FieldPromptWriteCachedTokens1h)
	}
	if m.FieldCleared(usagelog.FieldCompletionAudioTokens) {
		fields = append(fields, usagelog.FieldCompletionAudioTokens)
	}
	if m.FieldCleared(usagelog.FieldCompletionReasoningTokens) {
		fields = append(fields, usagelog.FieldCompletionReasoningTokens)
	}
	if m.FieldCleared(usagelog.FieldCompletionAcceptedPredictionTokens) {
		fields = append(fields, usagelog.FieldCompletionAcceptedPredictionTokens)
	}
	if m.FieldCleared(usagelog.FieldCompletionRejectedPredictionTokens) {
		fields = append(fields, usagelog.FieldCompletionRejectedPredictionTokens)
	}
	if m.FieldCleared(usagelog.FieldTotalCost) {
		fields = append(fields, usagelog.FieldTotalCost)
	}
	if m.FieldCleared(usagelog.FieldCostItems) {
		fields = append(fields, usagelog.FieldCostItems)
	}
	if m.FieldCleared(usagelog.FieldCostPriceReferenceID) {
		fields = append(fields, usagelog.FieldCostPriceReferenceID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UsageLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UsageLogMutation) ClearField(name string) error {
	switch name {
	case usagelog.FieldAPIKeyID:
		m.ClearAPIKeyID()
		return nil
	case usagelog.FieldChannelID:
		m.ClearChannelID()
		return nil
	case usagelog.FieldPromptAudioTokens:
		m.ClearPromptAudioTokens()
		return nil
	case usagelog.FieldPromptCachedTokens:
		m.ClearPromptCachedTokens()
		return nil
	case usagelog.FieldPromptWriteCachedTokens:
		m.ClearPromptWriteCachedTokens()
		return nil
	case usagelog.FieldPromptWriteCachedTokens5m:
		m.ClearPromptWriteCachedTokens5m()
		return nil
	case usagelog.FieldPromptWriteCachedTokens1h:
		m.ClearPromptWriteCachedTokens1h()
		return nil
	case usagelog.FieldCompletionAudioTokens:
		m.ClearCompletionAudioTokens()
		return nil
	case usagelog.FieldCompletionReasoningTokens:
		m.ClearCompletionReasoningTokens()
		return nil
	case usagelog.FieldCompletionAcceptedPredictionTokens:
		m.ClearCompletionAcceptedPredictionTokens()
		return nil
	case usagelog.FieldCompletionRejectedPredictionTokens:
		m.ClearCompletionRejectedPredictionTokens()
		return nil
	case usagelog.FieldTotalCost:
		m.ClearTotalCost()
		return nil
	case usagelog.FieldCostItems:
		m.ClearCostItems()
		return nil
	case usagelog.FieldCostPriceReferenceID:
		m.ClearCostPriceReferenceID()
		return nil
	}
	return fmt.Errorf("unknown UsageLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UsageLogMutation) ResetField(name string) error {
	switch name {
	case usagelog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case usagelog.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case usagelog.FieldRequestID:
		m.ResetRequestID()
		return nil
	case usagelog.FieldAPIKeyID:
		m.ResetAPIKeyID()
		return nil
	case usagelog.FieldProjectID:
		m.ResetProjectID()
		return nil
	case usagelog.FieldChannelID:
		m.ResetChannelID()
		return nil
	case usagelog.FieldModelID:
		m.ResetModelID()
		return nil
	case usagelog.FieldPromptTokens:
		m.ResetPromptTokens()
		return nil
	case usagelog.FieldCompletionTokens:
		m.ResetCompletionTokens()
		return nil
	case usagelog.FieldTotalTokens:
		m.ResetTotalTokens()
		return nil
	case usagelog.FieldPromptAudioTokens:
		m.ResetPromptAudioTokens()
		return nil
	case usagelog.FieldPromptCachedTokens:
		m.ResetPromptCachedTokens()
		return nil
	case usagelog.FieldPromptWriteCachedTokens:
		m.ResetPromptWriteCachedTokens()
		return nil
	case usagelog.FieldPromptWriteCachedTokens5m:
		m.ResetPromptWriteCachedTokens5m()
		return nil
	case usagelog.FieldPromptWriteCachedTokens1h:
		m.ResetPromptWriteCachedTokens1h()
		return nil
	case usagelog.FieldCompletionAudioTokens:
		m.ResetCompletionAudioTokens()
		return nil
	case usagelog.FieldCompletionReasoningTokens:
		m.ResetCompletionReasoningTokens()
		return nil
	case usagelog.FieldCompletionAcceptedPredictionTokens:
		m.ResetCompletionAcceptedPredictionTokens()
		return nil
	case usagelog.FieldCompletionRejectedPredictionTokens:
		m.ResetCompletionRejectedPredictionTokens()
		return nil
	case usagelog.FieldSource:
		m.ResetSource()
		return nil
	case usagelog.FieldFormat:
		m.ResetFormat()
		return nil
	case usagelog.FieldTotalCost:
		m.ResetTotalCost()
		return nil
	case usagelog.FieldCostItems:
		m.ResetCostItems()
		return nil
	case usagelog.FieldCostPriceReferenceID:
		m.ResetCostPriceReferenceID()
		return nil
	}
	return fmt.Errorf("unknown UsageLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UsageLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.request != nil {
		edges = append(edges, usagelog.EdgeRequest)
	}
	if m.project != nil {
		edges = append(edges, usagelog.EdgeProject)
	}
	if m.channel != nil {
		edges = append(edges, usagelog.EdgeChannel)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UsageLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usagelog.EdgeRequest:
		if id := m.request; id != nil {
			return []ent.Value{*id}
		}
	case usagelog.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case usagelog.EdgeChannel:
		if id := m.channel; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UsageLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UsageLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UsageLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedrequest {
		edges = append(edges, usagelog.EdgeRequest)
	}
	if m.clearedproject {
		edges = append(edges, usagelog.EdgeProject)
	}
	if m.clearedchannel {
		edges = append(edges, usagelog.EdgeChannel)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UsageLogMutation) EdgeCleared(name string) bool {
	switch name {
	case usagelog.EdgeRequest:
		return m.clearedrequest
	case usagelog.EdgeProject:
		return m.clearedproject
	case usagelog.EdgeChannel:
		return m.clearedchannel
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UsageLogMutation) ClearEdge(name string) error {
	switch name {
	case usagelog.EdgeRequest:
		m.ClearRequest()
		return nil
	case usagelog.EdgeProject:
		m.ClearProject()
		return nil
	case usagelog.EdgeChannel:
		m.ClearChannel()
		return nil
	}
	return fmt.Errorf("unknown UsageLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UsageLogMutation) ResetEdge(name string) error {
	switch name {
	case usagelog.EdgeRequest:
		m.ResetRequest()
		return nil
	case usagelog.EdgeProject:
		m.ResetProject()
		return nil
	case usagelog.EdgeChannel:
		m.ResetChannel()
		return nil
	}
	return fmt.Errorf("unknown UsageLog edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                                Op
	typ                               string
	id                                *int
	created_at                        *time.Time
	updated_at                        *time.Time
	deleted_at                        *int
	adddeleted_at                     *int
	email                             *string
	status                            *user.Status
	prefer_language                   *string
	password                          *string
	first_name                        *string
	last_name                         *string
	avatar                            *string
	is_owner                          *bool
	scopes                            *[]string
	appendscopes                      []string
	clearedFields                     map[string]struct{}
	projects                          map[int]struct{}
	removedprojects                   map[int]struct{}
	clearedprojects                   bool
	api_keys                          map[int]struct{}
	removedapi_keys                   map[int]struct{}
	clearedapi_keys                   bool
	roles                             map[int]struct{}
	removedroles                      map[int]struct{}
	clearedroles                      bool
	channel_override_templates        map[int]struct{}
	removedchannel_override_templates map[int]struct{}
	clearedchannel_override_templates bool
	project_users                     map[int]struct{}
	removedproject_users              map[int]struct{}
	clearedproject_users              bool
	user_roles                        map[int]struct{}
	removeduser_roles                 map[int]struct{}
	cleareduser_roles                 bool
	done                              bool
	oldValue                          func(context.Context) (*User, error)
	predicates                        []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserMutation) SetDeletedAt(i int) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserMutation) DeletedAt() (r int, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedAt(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *UserMutation) AddDeletedAt(i int) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *UserMutation) AddedDeletedAt() (r int, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetStatus sets the "status" field.
func (m *UserMutation) SetStatus(u user.Status) {
	m.status = &u
}

// Status returns the value of the "status" field in the mutation.
func (m *UserMutation) Status() (r user.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStatus(ctx context.Context) (v user.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *UserMutation) ResetStatus() {
	m.status = nil
}

// SetPreferLanguage sets the "prefer_language" field.
func (m *UserMutation) SetPreferLanguage(s string) {
	m.prefer_language = &s
}

// PreferLanguage returns the value of the "prefer_language" field in the mutation.
func (m *UserMutation) PreferLanguage() (r string, exists bool) {
	v := m.prefer_language
	if v == nil {
		return
	}
	return *v, true
}

// OldPreferLanguage returns the old "prefer_language" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPreferLanguage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPreferLanguage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPreferLanguage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPreferLanguage: %w", err)
	}
	return oldValue.PreferLanguage, nil
}

// ResetPreferLanguage resets all changes to the "prefer_language" field.
func (m *UserMutation) ResetPreferLanguage() {
	m.prefer_language = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetFirstName sets the "first_name" field.
func (m *UserMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *UserMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *UserMutation) ResetFirstName() {
	m.first_name = nil
}

// SetLastName sets the "last_name" field.
func (m *UserMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *UserMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *UserMutation) ResetLastName() {
	m.last_name = nil
}

// SetAvatar sets the "avatar" field.
func (m *UserMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *UserMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ClearAvatar clears the value of the "avatar" field.
func (m *UserMutation) ClearAvatar() {
	m.avatar = nil
	m.clearedFields[user.FieldAvatar] = struct{}{}
}

// AvatarCleared returns if the "avatar" field was cleared in this mutation.
func (m *UserMutation) AvatarCleared() bool {
	_, ok := m.clearedFields[user.FieldAvatar]
	return ok
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *UserMutation) ResetAvatar() {
	m.avatar = nil
	delete(m.clearedFields, user.FieldAvatar)
}

// SetIsOwner sets the "is_owner" field.
func (m *UserMutation) SetIsOwner(b bool) {
	m.is_owner = &b
}

// IsOwner returns the value of the "is_owner" field in the mutation.
func (m *UserMutation) IsOwner() (r bool, exists bool) {
	v := m.is_owner
	if v == nil {
		return
	}
	return *v, true
}

// OldIsOwner returns the old "is_owner" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsOwner(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsOwner is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsOwner requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsOwner: %w", err)
	}
	return oldValue.IsOwner, nil
}

// ResetIsOwner resets all changes to the "is_owner" field.
func (m *UserMutation) ResetIsOwner() {
	m.is_owner = nil
}

// SetScopes sets the "scopes" field.
func (m *UserMutation) SetScopes(s []string) {
	m.scopes = &s
	m.appendscopes = nil
}

// Scopes returns the value of the "scopes" field in the mutation.
func (m *UserMutation) Scopes() (r []string, exists bool) {
	v := m.scopes
	if v == nil {
		return
	}
	return *v, true
}

// OldScopes returns the old "scopes" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldScopes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopes: %w", err)
	}
	return oldValue.Scopes, nil
}

// AppendScopes adds s to the "scopes" field.
func (m *UserMutation) AppendScopes(s []string) {
	m.appendscopes = append(m.appendscopes, s...)
}

// AppendedScopes returns the list of values that were appended to the "scopes" field in this mutation.
func (m *UserMutation) AppendedScopes() ([]string, bool) {
	if len(m.appendscopes) == 0 {
		return nil, false
	}
	return m.appendscopes, true
}

// ClearScopes clears the value of the "scopes" field.
func (m *UserMutation) ClearScopes() {
	m.scopes = nil
	m.appendscopes = nil
	m.clearedFields[user.FieldScopes] = struct{}{}
}

// ScopesCleared returns if the "scopes" field was cleared in this mutation.
func (m *UserMutation) ScopesCleared() bool {
	_, ok := m.clearedFields[user.FieldScopes]
	return ok
}

// ResetScopes resets all changes to the "scopes" field.
func (m *UserMutation) ResetScopes() {
	m.scopes = nil
	m.appendscopes = nil
	delete(m.clearedFields, user.FieldScopes)
}

// AddProjectIDs adds the "projects" edge to the Project entity by ids.
func (m *UserMutation) AddProjectIDs(ids ...int) {
	if m.projects == nil {
		m.projects = make(map[int]struct{})
	}
	for i := range ids {
		m.projects[ids[i]] = struct{}{}
	}
}

// ClearProjects clears the "projects" edge to the Project entity.
func (m *UserMutation) ClearProjects() {
	m.clearedprojects = true
}

// ProjectsCleared reports if the "projects" edge to the Project entity was cleared.
func (m *UserMutation) ProjectsCleared() bool {
	return m.clearedprojects
}

// RemoveProjectIDs removes the "projects" edge to the Project entity by IDs.
func (m *UserMutation) RemoveProjectIDs(ids ...int) {
	if m.removedprojects == nil {
		m.removedprojects = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.projects, ids[i])
		m.removedprojects[ids[i]] = struct{}{}
	}
}

// RemovedProjects returns the removed IDs of the "projects" edge to the Project entity.
func (m *UserMutation) RemovedProjectsIDs() (ids []int) {
	for id := range m.removedprojects {
		ids = append(ids, id)
	}
	return
}

// ProjectsIDs returns the "projects" edge IDs in the mutation.
func (m *UserMutation) ProjectsIDs() (ids []int) {
	for id := range m.projects {
		ids = append(ids, id)
	}
	return
}

// ResetProjects resets all changes to the "projects" edge.
func (m *UserMutation) ResetProjects() {
	m.projects = nil
	m.clearedprojects = false
	m.removedprojects = nil
}

// AddAPIKeyIDs adds the "api_keys" edge to the APIKey entity by ids.
func (m *UserMutation) AddAPIKeyIDs(ids ...int) {
	if m.api_keys == nil {
		m.api_keys = make(map[int]struct{})
	}
	for i := range ids {
		m.api_keys[ids[i]] = struct{}{}
	}
}

// ClearAPIKeys clears the "api_keys" edge to the APIKey entity.
func (m *UserMutation) ClearAPIKeys() {
	m.clearedapi_keys = true
}

// APIKeysCleared reports if the "api_keys" edge to the APIKey entity was cleared.
func (m *UserMutation) APIKeysCleared() bool {
	return m.clearedapi_keys
}

// RemoveAPIKeyIDs removes the "api_keys" edge to the APIKey entity by IDs.
func (m *UserMutation) RemoveAPIKeyIDs(ids ...int) {
	if m.removedapi_keys == nil {
		m.removedapi_keys = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.api_keys, ids[i])
		m.removedapi_keys[ids[i]] = struct{}{}
	}
}

// RemovedAPIKeys returns the removed IDs of the "api_keys" edge to the APIKey entity.
func (m *UserMutation) RemovedAPIKeysIDs() (ids []int) {
	for id := range m.removedapi_keys {
		ids = append(ids, id)
	}
	return
}

// APIKeysIDs returns the "api_keys" edge IDs in the mutation.
func (m *UserMutation) APIKeysIDs() (ids []int) {
	for id := range m.api_keys {
		ids = append(ids, id)
	}
	return
}

// ResetAPIKeys resets all changes to the "api_keys" edge.
func (m *UserMutation) ResetAPIKeys() {
	m.api_keys = nil
	m.clearedapi_keys = false
	m.removedapi_keys = nil
}

// AddRoleIDs adds the "roles" edge to the Role entity by ids.
func (m *UserMutation) AddRoleIDs(ids ...int) {
	if m.roles == nil {
		m.roles = make(map[int]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the Role entity.
func (m *UserMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the Role entity was cleared.
func (m *UserMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the Role entity by IDs.
func (m *UserMutation) RemoveRoleIDs(ids ...int) {
	if m.removedroles == nil {
		m.removedroles = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the Role entity.
func (m *UserMutation) RemovedRolesIDs() (ids []int) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *UserMutation) RolesIDs() (ids []int) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *UserMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// AddChannelOverrideTemplateIDs adds the "channel_override_templates" edge to the ChannelOverrideTemplate entity by ids.
func (m *UserMutation) AddChannelOverrideTemplateIDs(ids ...int) {
	if m.channel_override_templates == nil {
		m.channel_override_templates = make(map[int]struct{})
	}
	for i := range ids {
		m.channel_override_templates[ids[i]] = struct{}{}
	}
}

// ClearChannelOverrideTemplates clears the "channel_override_templates" edge to the ChannelOverrideTemplate entity.
func (m *UserMutation) ClearChannelOverrideTemplates() {
	m.clearedchannel_override_templates = true
}

// ChannelOverrideTemplatesCleared reports if the "channel_override_templates" edge to the ChannelOverrideTemplate entity was cleared.
func (m *UserMutation) ChannelOverrideTemplatesCleared() bool {
	return m.clearedchannel_override_templates
}

// RemoveChannelOverrideTemplateIDs removes the "channel_override_templates" edge to the ChannelOverrideTemplate entity by IDs.
func (m *UserMutation) RemoveChannelOverrideTemplateIDs(ids ...int) {
	if m.removedchannel_override_templates == nil {
		m.removedchannel_override_templates = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.channel_override_templates, ids[i])
		m.removedchannel_override_templates[ids[i]] = struct{}{}
	}
}

// RemovedChannelOverrideTemplates returns the removed IDs of the "channel_override_templates" edge to the ChannelOverrideTemplate entity.
func (m *UserMutation) RemovedChannelOverrideTemplatesIDs() (ids []int) {
	for id := range m.removedchannel_override_templates {
		ids = append(ids, id)
	}
	return
}

// ChannelOverrideTemplatesIDs returns the "channel_override_templates" edge IDs in the mutation.
func (m *UserMutation) ChannelOverrideTemplatesIDs() (ids []int) {
	for id := range m.channel_override_templates {
		ids = append(ids, id)
	}
	return
}

// ResetChannelOverrideTemplates resets all changes to the "channel_override_templates" edge.
func (m *UserMutation) ResetChannelOverrideTemplates() {
	m.channel_override_templates = nil
	m.clearedchannel_override_templates = false
	m.removedchannel_override_templates = nil
}

// AddProjectUserIDs adds the "project_users" edge to the UserProject entity by ids.
func (m *UserMutation) AddProjectUserIDs(ids ...int) {
	if m.project_users == nil {
		m.project_users = make(map[int]struct{})
	}
	for i := range ids {
		m.project_users[ids[i]] = struct{}{}
	}
}

// ClearProjectUsers clears the "project_users" edge to the UserProject entity.
func (m *UserMutation) ClearProjectUsers() {
	m.clearedproject_users = true
}

// ProjectUsersCleared reports if the "project_users" edge to the UserProject entity was cleared.
func (m *UserMutation) ProjectUsersCleared() bool {
	return m.clearedproject_users
}

// RemoveProjectUserIDs removes the "project_users" edge to the UserProject entity by IDs.
func (m *UserMutation) RemoveProjectUserIDs(ids ...int) {
	if m.removedproject_users == nil {
		m.removedproject_users = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.project_users, ids[i])
		m.removedproject_users[ids[i]] = struct{}{}
	}
}

// RemovedProjectUsers returns the removed IDs of the "project_users" edge to the UserProject entity.
func (m *UserMutation) RemovedProjectUsersIDs() (ids []int) {
	for id := range m.removedproject_users {
		ids = append(ids, id)
	}
	return
}

// ProjectUsersIDs returns the "project_users" edge IDs in the mutation.
func (m *UserMutation) ProjectUsersIDs() (ids []int) {
	for id := range m.project_users {
		ids = append(ids, id)
	}
	return
}

// ResetProjectUsers resets all changes to the "project_users" edge.
func (m *UserMutation) ResetProjectUsers() {
	m.project_users = nil
	m.clearedproject_users = false
	m.removedproject_users = nil
}

// AddUserRoleIDs adds the "user_roles" edge to the UserRole entity by ids.
func (m *UserMutation) AddUserRoleIDs(ids ...int) {
	if m.user_roles == nil {
		m.user_roles = make(map[int]struct{})
	}
	for i := range ids {
		m.user_roles[ids[i]] = struct{}{}
	}
}

// ClearUserRoles clears the "user_roles" edge to the UserRole entity.
func (m *UserMutation) ClearUserRoles() {
	m.cleareduser_roles = true
}

// UserRolesCleared reports if the "user_roles" edge to the UserRole entity was cleared.
func (m *UserMutation) UserRolesCleared() bool {
	return m.cleareduser_roles
}

// RemoveUserRoleIDs removes the "user_roles" edge to the UserRole entity by IDs.
func (m *UserMutation) RemoveUserRoleIDs(ids ...int) {
	if m.removeduser_roles == nil {
		m.removeduser_roles = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user_roles, ids[i])
		m.removeduser_roles[ids[i]] = struct{}{}
	}
}

// RemovedUserRoles returns the removed IDs of the "user_roles" edge to the UserRole entity.
func (m *UserMutation) RemovedUserRolesIDs() (ids []int) {
	for id := range m.removeduser_roles {
		ids = append(ids, id)
	}
	return
}

// UserRolesIDs returns the "user_roles" edge IDs in the mutation.
func (m *UserMutation) UserRolesIDs() (ids []int) {
	for id := range m.user_roles {
		ids = append(ids, id)
	}
	return
}

// ResetUserRoles resets all changes to the "user_roles" edge.
func (m *UserMutation) ResetUserRoles() {
	m.user_roles = nil
	m.cleareduser_roles = false
	m.removeduser_roles = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.status != nil {
		fields = append(fields, user.FieldStatus)
	}
	if m.prefer_language != nil {
		fields = append(fields, user.FieldPreferLanguage)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.first_name != nil {
		fields = append(fields, user.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, user.FieldLastName)
	}
	if m.avatar != nil {
		fields = append(fields, user.FieldAvatar)
	}
	if m.is_owner != nil {
		fields = append(fields, user.FieldIsOwner)
	}
	if m.scopes != nil {
		fields = append(fields, user.FieldScopes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldDeletedAt:
		return m.DeletedAt()
	case user.FieldEmail:
		return m.Email()
	case user.FieldStatus:
		return m.Status()
	case user.FieldPreferLanguage:
		return m.PreferLanguage()
	case user.FieldPassword:
		return m.Password()
	case user.FieldFirstName:
		return m.FirstName()
	case user.FieldLastName:
		return m.LastName()
	case user.FieldAvatar:
		return m.Avatar()
	case user.FieldIsOwner:
		return m.IsOwner()
	case user.FieldScopes:
		return m.Scopes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldStatus:
		return m.OldStatus(ctx)
	case user.FieldPreferLanguage:
		return m.OldPreferLanguage(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldFirstName:
		return m.OldFirstName(ctx)
	case user.FieldLastName:
		return m.OldLastName(ctx)
	case user.FieldAvatar:
		return m.OldAvatar(ctx)
	case user.FieldIsOwner:
		return m.OldIsOwner(ctx)
	case user.FieldScopes:
		return m.OldScopes(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(user.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case user.FieldPreferLanguage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPreferLanguage(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case user.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case user.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case user.FieldIsOwner:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsOwner(v)
		return nil
	case user.FieldScopes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopes(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldAvatar) {
		fields = append(fields, user.FieldAvatar)
	}
	if m.FieldCleared(user.FieldScopes) {
		fields = append(fields, user.FieldScopes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldAvatar:
		m.ClearAvatar()
		return nil
	case user.FieldScopes:
		m.ClearScopes()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldStatus:
		m.ResetStatus()
		return nil
	case user.FieldPreferLanguage:
		m.ResetPreferLanguage()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldFirstName:
		m.ResetFirstName()
		return nil
	case user.FieldLastName:
		m.ResetLastName()
		return nil
	case user.FieldAvatar:
		m.ResetAvatar()
		return nil
	case user.FieldIsOwner:
		m.ResetIsOwner()
		return nil
	case user.FieldScopes:
		m.ResetScopes()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.projects != nil {
		edges = append(edges, user.EdgeProjects)
	}
	if m.api_keys != nil {
		edges = append(edges, user.EdgeAPIKeys)
	}
	if m.roles != nil {
		edges = append(edges, user.EdgeRoles)
	}
	if m.channel_override_templates != nil {
		edges = append(edges, user.EdgeChannelOverrideTemplates)
	}
	if m.project_users != nil {
		edges = append(edges, user.EdgeProjectUsers)
	}
	if m.user_roles != nil {
		edges = append(edges, user.EdgeUserRoles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.projects))
		for id := range m.projects {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAPIKeys:
		ids := make([]ent.Value, 0, len(m.api_keys))
		for id := range m.api_keys {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeChannelOverrideTemplates:
		ids := make([]ent.Value, 0, len(m.channel_override_templates))
		for id := range m.channel_override_templates {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeProjectUsers:
		ids := make([]ent.Value, 0, len(m.project_users))
		for id := range m.project_users {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserRoles:
		ids := make([]ent.Value, 0, len(m.user_roles))
		for id := range m.user_roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedprojects != nil {
		edges = append(edges, user.EdgeProjects)
	}
	if m.removedapi_keys != nil {
		edges = append(edges, user.EdgeAPIKeys)
	}
	if m.removedroles != nil {
		edges = append(edges, user.EdgeRoles)
	}
	if m.removedchannel_override_templates != nil {
		edges = append(edges, user.EdgeChannelOverrideTemplates)
	}
	if m.removedproject_users != nil {
		edges = append(edges, user.EdgeProjectUsers)
	}
	if m.removeduser_roles != nil {
		edges = append(edges, user.EdgeUserRoles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.removedprojects))
		for id := range m.removedprojects {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAPIKeys:
		ids := make([]ent.Value, 0, len(m.removedapi_keys))
		for id := range m.removedapi_keys {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeChannelOverrideTemplates:
		ids := make([]ent.Value, 0, len(m.removedchannel_override_templates))
		for id := range m.removedchannel_override_templates {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeProjectUsers:
		ids := make([]ent.Value, 0, len(m.removedproject_users))
		for id := range m.removedproject_users {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserRoles:
		ids := make([]ent.Value, 0, len(m.removeduser_roles))
		for id := range m.removeduser_roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedprojects {
		edges = append(edges, user.EdgeProjects)
	}
	if m.clearedapi_keys {
		edges = append(edges, user.EdgeAPIKeys)
	}
	if m.clearedroles {
		edges = append(edges, user.EdgeRoles)
	}
	if m.clearedchannel_override_templates {
		edges = append(edges, user.EdgeChannelOverrideTemplates)
	}
	if m.clearedproject_users {
		edges = append(edges, user.EdgeProjectUsers)
	}
	if m.cleareduser_roles {
		edges = append(edges, user.EdgeUserRoles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeProjects:
		return m.clearedprojects
	case user.EdgeAPIKeys:
		return m.clearedapi_keys
	case user.EdgeRoles:
		return m.clearedroles
	case user.EdgeChannelOverrideTemplates:
		return m.clearedchannel_override_templates
	case user.EdgeProjectUsers:
		return m.clearedproject_users
	case user.EdgeUserRoles:
		return m.cleareduser_roles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeProjects:
		m.ResetProjects()
		return nil
	case user.EdgeAPIKeys:
		m.ResetAPIKeys()
		return nil
	case user.EdgeRoles:
		m.ResetRoles()
		return nil
	case user.EdgeChannelOverrideTemplates:
		m.ResetChannelOverrideTemplates()
		return nil
	case user.EdgeProjectUsers:
		m.ResetProjectUsers()
		return nil
	case user.EdgeUserRoles:
		m.ResetUserRoles()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserProjectMutation represents an operation that mutates the UserProject nodes in the graph.
type UserProjectMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	updated_at     *time.Time
	is_owner       *bool
	scopes         *[]string
	appendscopes   []string
	clearedFields  map[string]struct{}
	user           *int
	cleareduser    bool
	project        *int
	clearedproject bool
	done           bool
	oldValue       func(context.Context) (*UserProject, error)
	predicates     []predicate.UserProject
}

var _ ent.Mutation = (*UserProjectMutation)(nil)

// userprojectOption allows management of the mutation configuration using functional options.
type userprojectOption func(*UserProjectMutation)

// newUserProjectMutation creates new mutation for the UserProject entity.
func newUserProjectMutation(c config, op Op, opts ...userprojectOption) *UserProjectMutation {
	m := &UserProjectMutation{
		config:        c,
		op:            op,
		typ:           TypeUserProject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserProjectID sets the ID field of the mutation.
func withUserProjectID(id int) userprojectOption {
	return func(m *UserProjectMutation) {
		var (
			err   error
			once  sync.Once
			value *UserProject
		)
		m.oldValue = func(ctx context.Context) (*UserProject, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserProject.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserProject sets the old UserProject of the mutation.
func withUserProject(node *UserProject) userprojectOption {
	return func(m *UserProjectMutation) {
		m.oldValue = func(context.Context) (*UserProject, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserProjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserProjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserProjectMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserProjectMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserProject.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserProjectMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserProjectMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserProject entity.
// If the UserProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProjectMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserProjectMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserProjectMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserProjectMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserProject entity.
// If the UserProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProjectMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserProjectMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user_id" field.
func (m *UserProjectMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserProjectMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserProject entity.
// If the UserProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProjectMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserProjectMutation) ResetUserID() {
	m.user = nil
}

// SetProjectID sets the "project_id" field.
func (m *UserProjectMutation) SetProjectID(i int) {
	m.project = &i
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *UserProjectMutation) ProjectID() (r int, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the UserProject entity.
// If the UserProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProjectMutation) OldProjectID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *UserProjectMutation) ResetProjectID() {
	m.project = nil
}

// SetIsOwner sets the "is_owner" field.
func (m *UserProjectMutation) SetIsOwner(b bool) {
	m.is_owner = &b
}

// IsOwner returns the value of the "is_owner" field in the mutation.
func (m *UserProjectMutation) IsOwner() (r bool, exists bool) {
	v := m.is_owner
	if v == nil {
		return
	}
	return *v, true
}

// OldIsOwner returns the old "is_owner" field's value of the UserProject entity.
// If the UserProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProjectMutation) OldIsOwner(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsOwner is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsOwner requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsOwner: %w", err)
	}
	return oldValue.IsOwner, nil
}

// ResetIsOwner resets all changes to the "is_owner" field.
func (m *UserProjectMutation) ResetIsOwner() {
	m.is_owner = nil
}

// SetScopes sets the "scopes" field.
func (m *UserProjectMutation) SetScopes(s []string) {
	m.scopes = &s
	m.appendscopes = nil
}

// Scopes returns the value of the "scopes" field in the mutation.
func (m *UserProjectMutation) Scopes() (r []string, exists bool) {
	v := m.scopes
	if v == nil {
		return
	}
	return *v, true
}

// OldScopes returns the old "scopes" field's value of the UserProject entity.
// If the UserProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProjectMutation) OldScopes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopes: %w", err)
	}
	return oldValue.Scopes, nil
}

// AppendScopes adds s to the "scopes" field.
func (m *UserProjectMutation) AppendScopes(s []string) {
	m.appendscopes = append(m.appendscopes, s...)
}

// AppendedScopes returns the list of values that were appended to the "scopes" field in this mutation.
func (m *UserProjectMutation) AppendedScopes() ([]string, bool) {
	if len(m.appendscopes) == 0 {
		return nil, false
	}
	return m.appendscopes, true
}

// ClearScopes clears the value of the "scopes" field.
func (m *UserProjectMutation) ClearScopes() {
	m.scopes = nil
	m.appendscopes = nil
	m.clearedFields[userproject.FieldScopes] = struct{}{}
}

// ScopesCleared returns if the "scopes" field was cleared in this mutation.
func (m *UserProjectMutation) ScopesCleared() bool {
	_, ok := m.clearedFields[userproject.FieldScopes]
	return ok
}

// ResetScopes resets all changes to the "scopes" field.
func (m *UserProjectMutation) ResetScopes() {
	m.scopes = nil
	m.appendscopes = nil
	delete(m.clearedFields, userproject.FieldScopes)
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserProjectMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[userproject.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserProjectMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserProjectMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserProjectMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearProject clears the "project" edge to the Project entity.
func (m *UserProjectMutation) ClearProject() {
	m.clearedproject = true
	m.clearedFields[userproject.FieldProjectID] = struct{}{}
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *UserProjectMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *UserProjectMutation) ProjectIDs() (ids []int) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *UserProjectMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// Where appends a list predicates to the UserProjectMutation builder.
func (m *UserProjectMutation) Where(ps ...predicate.UserProject) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserProjectMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserProjectMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserProject, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserProjectMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserProjectMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserProject).
func (m *UserProjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserProjectMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, userproject.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userproject.FieldUpdatedAt)
	}
	if m.user != nil {
		fields = append(fields, userproject.FieldUserID)
	}
	if m.project != nil {
		fields = append(fields, userproject.FieldProjectID)
	}
	if m.is_owner != nil {
		fields = append(fields, userproject.FieldIsOwner)
	}
	if m.scopes != nil {
		fields = append(fields, userproject.FieldScopes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserProjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userproject.FieldCreatedAt:
		return m.CreatedAt()
	case userproject.FieldUpdatedAt:
		return m.UpdatedAt()
	case userproject.FieldUserID:
		return m.UserID()
	case userproject.FieldProjectID:
		return m.ProjectID()
	case userproject.FieldIsOwner:
		return m.IsOwner()
	case userproject.FieldScopes:
		return m.Scopes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserProjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userproject.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userproject.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userproject.FieldUserID:
		return m.OldUserID(ctx)
	case userproject.FieldProjectID:
		return m.OldProjectID(ctx)
	case userproject.FieldIsOwner:
		return m.OldIsOwner(ctx)
	case userproject.FieldScopes:
		return m.OldScopes(ctx)
	}
	return nil, fmt.Errorf("unknown UserProject field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserProjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userproject.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userproject.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userproject.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userproject.FieldProjectID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case userproject.FieldIsOwner:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsOwner(v)
		return nil
	case userproject.FieldScopes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopes(v)
		return nil
	}
	return fmt.Errorf("unknown UserProject field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserProjectMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserProjectMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserProjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserProject numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserProjectMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userproject.FieldScopes) {
		fields = append(fields, userproject.FieldScopes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserProjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserProjectMutation) ClearField(name string) error {
	switch name {
	case userproject.FieldScopes:
		m.ClearScopes()
		return nil
	}
	return fmt.Errorf("unknown UserProject nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserProjectMutation) ResetField(name string) error {
	switch name {
	case userproject.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userproject.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userproject.FieldUserID:
		m.ResetUserID()
		return nil
	case userproject.FieldProjectID:
		m.ResetProjectID()
		return nil
	case userproject.FieldIsOwner:
		m.ResetIsOwner()
		return nil
	case userproject.FieldScopes:
		m.ResetScopes()
		return nil
	}
	return fmt.Errorf("unknown UserProject field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserProjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, userproject.EdgeUser)
	}
	if m.project != nil {
		edges = append(edges, userproject.EdgeProject)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserProjectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userproject.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case userproject.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserProjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserProjectMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserProjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, userproject.EdgeUser)
	}
	if m.clearedproject {
		edges = append(edges, userproject.EdgeProject)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserProjectMutation) EdgeCleared(name string) bool {
	switch name {
	case userproject.EdgeUser:
		return m.cleareduser
	case userproject.EdgeProject:
		return m.clearedproject
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserProjectMutation) ClearEdge(name string) error {
	switch name {
	case userproject.EdgeUser:
		m.ClearUser()
		return nil
	case userproject.EdgeProject:
		m.ClearProject()
		return nil
	}
	return fmt.Errorf("unknown UserProject unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserProjectMutation) ResetEdge(name string) error {
	switch name {
	case userproject.EdgeUser:
		m.ResetUser()
		return nil
	case userproject.EdgeProject:
		m.ResetProject()
		return nil
	}
	return fmt.Errorf("unknown UserProject edge %s", name)
}

// UserRoleMutation represents an operation that mutates the UserRole nodes in the graph.
type UserRoleMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	role          *int
	clearedrole   bool
	done          bool
	oldValue      func(context.Context) (*UserRole, error)
	predicates    []predicate.UserRole
}

var _ ent.Mutation = (*UserRoleMutation)(nil)

// userroleOption allows management of the mutation configuration using functional options.
type userroleOption func(*UserRoleMutation)

// newUserRoleMutation creates new mutation for the UserRole entity.
func newUserRoleMutation(c config, op Op, opts ...userroleOption) *UserRoleMutation {
	m := &UserRoleMutation{
		config:        c,
		op:            op,
		typ:           TypeUserRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserRoleID sets the ID field of the mutation.
func withUserRoleID(id int) userroleOption {
	return func(m *UserRoleMutation) {
		var (
			err   error
			once  sync.Once
			value *UserRole
		)
		m.oldValue = func(ctx context.Context) (*UserRole, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserRole.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserRole sets the old UserRole of the mutation.
func withUserRole(node *UserRole) userroleOption {
	return func(m *UserRoleMutation) {
		m.oldValue = func(context.Context) (*UserRole, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserRoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserRoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserRoleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserRoleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserRole.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *UserRoleMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserRoleMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserRoleMutation) ResetUserID() {
	m.user = nil
}

// SetRoleID sets the "role_id" field.
func (m *UserRoleMutation) SetRoleID(i int) {
	m.role = &i
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *UserRoleMutation) RoleID() (r int, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldRoleID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *UserRoleMutation) ResetRoleID() {
	m.role = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserRoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserRoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *UserRoleMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[userrole.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *UserRoleMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[userrole.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserRoleMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, userrole.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserRoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserRoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserRoleMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[userrole.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserRoleMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[userrole.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserRoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, userrole.FieldUpdatedAt)
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserRoleMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[userrole.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserRoleMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserRoleMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserRoleMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearRole clears the "role" edge to the Role entity.
func (m *UserRoleMutation) ClearRole() {
	m.clearedrole = true
	m.clearedFields[userrole.FieldRoleID] = struct{}{}
}

// RoleCleared reports if the "role" edge to the Role entity was cleared.
func (m *UserRoleMutation) RoleCleared() bool {
	return m.clearedrole
}

// RoleIDs returns the "role" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoleID instead. It exists only for internal usage by the builders.
func (m *UserRoleMutation) RoleIDs() (ids []int) {
	if id := m.role; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRole resets all changes to the "role" edge.
func (m *UserRoleMutation) ResetRole() {
	m.role = nil
	m.clearedrole = false
}

// Where appends a list predicates to the UserRoleMutation builder.
func (m *UserRoleMutation) Where(ps ...predicate.UserRole) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserRoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserRoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserRole, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserRoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserRoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserRole).
func (m *UserRoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserRoleMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.user != nil {
		fields = append(fields, userrole.FieldUserID)
	}
	if m.role != nil {
		fields = append(fields, userrole.FieldRoleID)
	}
	if m.created_at != nil {
		fields = append(fields, userrole.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userrole.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserRoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userrole.FieldUserID:
		return m.UserID()
	case userrole.FieldRoleID:
		return m.RoleID()
	case userrole.FieldCreatedAt:
		return m.CreatedAt()
	case userrole.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserRoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userrole.FieldUserID:
		return m.OldUserID(ctx)
	case userrole.FieldRoleID:
		return m.OldRoleID(ctx)
	case userrole.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userrole.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UserRole field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserRoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userrole.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userrole.FieldRoleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	case userrole.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userrole.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserRole field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserRoleMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserRoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserRoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserRole numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserRoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userrole.FieldCreatedAt) {
		fields = append(fields, userrole.FieldCreatedAt)
	}
	if m.FieldCleared(userrole.FieldUpdatedAt) {
		fields = append(fields, userrole.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserRoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserRoleMutation) ClearField(name string) error {
	switch name {
	case userrole.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case userrole.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown UserRole nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserRoleMutation) ResetField(name string) error {
	switch name {
	case userrole.FieldUserID:
		m.ResetUserID()
		return nil
	case userrole.FieldRoleID:
		m.ResetRoleID()
		return nil
	case userrole.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userrole.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown UserRole field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserRoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, userrole.EdgeUser)
	}
	if m.role != nil {
		edges = append(edges, userrole.EdgeRole)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserRoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userrole.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case userrole.EdgeRole:
		if id := m.role; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserRoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserRoleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserRoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, userrole.EdgeUser)
	}
	if m.clearedrole {
		edges = append(edges, userrole.EdgeRole)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserRoleMutation) EdgeCleared(name string) bool {
	switch name {
	case userrole.EdgeUser:
		return m.cleareduser
	case userrole.EdgeRole:
		return m.clearedrole
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserRoleMutation) ClearEdge(name string) error {
	switch name {
	case userrole.EdgeUser:
		m.ClearUser()
		return nil
	case userrole.EdgeRole:
		m.ClearRole()
		return nil
	}
	return fmt.Errorf("unknown UserRole unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserRoleMutation) ResetEdge(name string) error {
	switch name {
	case userrole.EdgeUser:
		m.ResetUser()
		return nil
	case userrole.EdgeRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown UserRole edge %s", name)
}
