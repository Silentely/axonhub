package middleware

import (
	"bytes"
	"errors"
	"fmt"
	"net/http"
	"runtime"

	"github.com/gin-gonic/gin"

	"github.com/looplj/axonhub/internal/log"
)

// Recovery returns a middleware that recovers from any panics and logs detailed error information.
// It replaces gin's default Recovery middleware with enhanced logging capabilities.
func Recovery() gin.HandlerFunc {
	return RecoveryWithWriter()
}

// RecoveryWithWriter returns a middleware that recovers from any panics and logs detailed error information.
// It replaces gin's default Recovery middleware with enhanced logging capabilities.
func RecoveryWithWriter() gin.HandlerFunc {
	return func(c *gin.Context) {
		defer func() {
			if err := recover(); err != nil {
				// Get stack trace
				stack := stack(3)

				// Log detailed error information
				log.Error(
					c.Request.Context(),
					fmt.Sprintf("[PANIC] %s", err),
					log.String("path", c.Request.URL.Path),
					log.String("method", c.Request.Method),
					log.String("client_ip", c.ClientIP()),
					log.String("user_agent", c.Request.UserAgent()),
					log.String("stack", string(stack)),
				)

				// Return 500 error
				AbortWithError(c, http.StatusInternalServerError, errors.New("Internal server error"))
			}
		}()

		c.Next()
	}
}

// stack returns a formatted stack trace of the goroutine that calls it.
// It skips the first skip frames.
func stack(skip int) []byte {
	buf := new(bytes.Buffer)

	var lastFile string

	for i := skip; ; i++ {
		pc, file, line, ok := runtime.Caller(i)
		if !ok {
			break
		}

		// Ignore autogenerated runtime code
		if file == "" || file == "<autogenerated>" {
			continue
		}

		// Only print the file name when it changes
		if file != lastFile {
			fmt.Fprintf(buf, "\n%s:", file)
			lastFile = file
		}

		// Print function name and line
		fn := runtime.FuncForPC(pc)
		if fn != nil {
			fmt.Fprintf(buf, "\n\t%s:%d", fn.Name(), line)
		}
	}

	return buf.Bytes()
}
