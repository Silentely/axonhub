scalar JSONRawMessage
scalar JSONRawMessageInput
scalar Decimal
scalar DecimalInput

type ModelMapping {
  from: String!
  to: String!
}

type HeaderEntry {
  key: String!
  value: String!
}

input HeaderEntryInput {
  key: String!
  value: String!
}

type TransformOptions {
  forceArrayInstructions: Boolean!
  forceArrayInputs: Boolean!
  replaceDeveloperRoleWithSystem: Boolean!
}

input TransformOptionsInput {
  forceArrayInstructions: Boolean
  forceArrayInputs: Boolean
  replaceDeveloperRoleWithSystem: Boolean
}

enum ProxyType {
  DISABLED
  ENVIRONMENT
  URL
}

type ProxyConfig {
  type: ProxyType!
  url: String
  username: String
  password: String
}

input ProxyConfigInput {
  type: ProxyType!
  url: String
  username: String
  password: String
}

type ChannelSettings {
  extraModelPrefix: String
  modelMappings: [ModelMapping!]
  autoTrimedModelPrefixes: [String!]
  hideOriginalModels: Boolean
  hideMappedModels: Boolean
  overrideParameters: String
  overrideHeaders: [HeaderEntry!]
  proxy: ProxyConfig
  transformOptions: TransformOptions
}

enum CapabilityPolicy {
  unlimited
  require
  forbid
}

type ChannelPolicies {
  stream: CapabilityPolicy
}

input ChannelPoliciesInput {
  stream: CapabilityPolicy
}

input ModelMappingInput {
  from: String!
  to: String!
}

input ChannelSettingsInput {
  extraModelPrefix: String
  modelMappings: [ModelMappingInput!]
  autoTrimedModelPrefixes: [String!]
  hideOriginalModels: Boolean
  hideMappedModels: Boolean
  overrideParameters: String
  overrideHeaders: [HeaderEntryInput!]
  proxy: ProxyConfigInput
  transformOptions: TransformOptionsInput
}

type ChannelCredentials {
  apiKey: String
  aws: AWSCredential
  gcp: GCPCredential
  oauth: OAuthCredentials
}

type OAuthCredentials {
  accessToken: String
  refreshToken: String
  clientID: String
  expiresAt: Time
  tokenType: String
  scopes: [String!]
}

type GCPCredential {
  region: String!
  projectID: String!
  jsonData: String!
}

type AWSCredential {
  accessKeyID: String!
  secretAccessKey: String!
  region: String!
}

input ChannelCredentialsInput {
  apiKey: String
  aws: AWSCredentialInput
  gcp: GCPCredentialInput
  oauth: OAuthCredentialsInput
}

input OAuthCredentialsInput {
  accessToken: String
  refreshToken: String
  clientID: String
  expiresAt: Time
  tokenType: String
  scopes: [String!]
}

input AWSCredentialInput {
  accessKeyID: String!
  secretAccessKey: String!
  region: String!
}

input GCPCredentialInput {
  region: String!
  projectID: String!
  jsonData: String!
}

input SignInInput {
  email: String!
  password: String!
}

type SignInPayload {
  user: User!
  token: String!
}

input TestChannelInput {
  channelID: ID!
  modelID: String
  proxy: ProxyConfigInput
}

type TestChannelPayload {
  latency: Float!
  success: Boolean!
  message: String
  error: String
}

input BulkImportChannelItem {
  type: String!
  name: String!
  baseURL: String
  apiKey: String
  supportedModels: [String!]!
  defaultTestModel: String!
}

input BulkImportChannelsInput {
  channels: [BulkImportChannelItem!]!
}

type BulkImportChannelsResult {
  success: Boolean!
  created: Int!
  failed: Int!
  errors: [String!]
  channels: [Channel!]!
}

input BulkCreateChannelsInput {
  type: ChannelType!
  name: String!
  tags: [String!]
  baseURL: String
  apiKeys: [String!]!
  supportedModels: [String!]!
  autoSyncSupportedModels: Boolean
  defaultTestModel: String!
  settings: ChannelSettingsInput
  policies: ChannelPoliciesInput
  orderingWeight: Int
  remark: String
}

input ChannelOrderingItem {
  id: ID!
  orderingWeight: Int!
}

input BulkUpdateChannelOrderingInput {
  channels: [ChannelOrderingItem!]!
}

type BulkUpdateChannelOrderingResult {
  success: Boolean!
  updated: Int!
  channels: [Channel!]!
}

input UpdateAPIKeyProfilesInput {
  activeProfile: String!
  profiles: [APIKeyProfileInput!]
}

input APIKeyProfileInput {
  name: String!
  modelMappings: [ModelMappingInput!]
  channelIDs: [Int!]
  channelTags: [String!]
  modelIDs: [String!]
  quota: APIKeyQuotaInput
  loadBalanceStrategy: String
}

input UpdateAPIKeyScopesInput {
  scopes: [String!]!
}

type APIKeyProfiles {
  activeProfile: String!
  profiles: [APIKeyProfile!]
}

type APIKeyProfile {
  name: String!
  modelMappings: [ModelMapping!]
  channelIDs: [Int!]
  channelTags: [String!]
  modelIDs: [String!]
  quota: APIKeyQuota
  loadBalanceStrategy: String
}

input APIKeyQuotaInput {
  requests: Int
  totalTokens: Int
  cost: DecimalInput
  period: APIKeyQuotaPeriodInput!
}

input APIKeyQuotaPeriodInput {
  type: APIKeyQuotaPeriodType!
  pastDuration: APIKeyQuotaPastDurationInput
  calendarDuration: APIKeyQuotaCalendarDurationInput
}

enum APIKeyQuotaPeriodType {
  all_time
  past_duration
  calendar_duration
}

input APIKeyQuotaPastDurationInput {
  value: Int!
  unit: APIKeyQuotaPastDurationUnit!
}

enum APIKeyQuotaPastDurationUnit {
  hour
  day
}

input APIKeyQuotaCalendarDurationInput {
  unit: APIKeyQuotaCalendarDurationUnit!
}

enum APIKeyQuotaCalendarDurationUnit {
  day
  month
}

type APIKeyQuota {
  requests: Int
  totalTokens: Int
  cost: Decimal
  period: APIKeyQuotaPeriod!
}

type APIKeyQuotaPeriod {
  type: APIKeyQuotaPeriodType!
  pastDuration: APIKeyQuotaPastDuration
  calendarDuration: APIKeyQuotaCalendarDuration
}

type APIKeyQuotaPastDuration {
  value: Int!
  unit: APIKeyQuotaPastDurationUnit!
}

type APIKeyQuotaCalendarDuration {
  unit: APIKeyQuotaCalendarDurationUnit!
}

input FetchModelsInput {
  channelType: String!
  baseURL: String!
  apiKey: String
  channelID: ID
}

type FetchModelsPayload {
  models: [ModelIdentify!]!
  error: String
}

type ModelIdentify {
  id: String!
}

type ModelIdentityWithStatus {
  id: String!
  status: ChannelStatus!
}

input QueryModelsInput {
  statusIn: [ChannelStatus!]
  includeMapping: Boolean
  includePrefix: Boolean
}

type ChannelTypeCount {
  type: String!
  count: Int!
}

input AddUserToProjectInput {
  projectId: ID!
  userId: ID!
  isOwner: Boolean
  scopes: [String!]
  roleIDs: [ID!]
}

input UpdateProjectUserInput {
  projectId: ID!
  userId: ID!
  isOwner: Boolean
  scopes: [String!]
  addRoleIDs: [ID!]
  removeRoleIDs: [ID!]
}

input RemoveUserFromProjectInput {
  projectId: ID!
  userId: ID!
}

input DataStorageSettingsInput {
  dsn: String
  directory: String
  s3: S3Input
  gcs: GCSInput
  webdav: WebDAVInput
}

input WebDAVInput {
  url: String!
  username: String
  password: String
  insecure_skip_tls: Boolean
  path: String
}

input S3Input {
  bucketName: String!
  endpoint: String
  region: String
  accessKey: String
  secretKey: String
}

input GCSInput {
  bucketName: String!
  credential: String
}

type DataStorageSettings {
  dsn: String
  directory: String
  s3: S3
  gcs: GCS
  webdav: WebDAV
}

type WebDAV {
  url: String!
  username: String
  password: String
  insecure_skip_tls: Boolean
  path: String
}

type S3 {
  bucketName: String!
  endpoint: String!
  region: String!
}

type GCS {
  bucketName: String!
}

type UsageMetadata {
  totalInputTokens: Int! 
  totalOutputTokens: Int! 
  totalTokens: Int! 
  totalCachedTokens: Int! 
  totalCachedWriteTokens: Int! 
  totalCost: Decimal! 
}

extend type Trace {
  rootSegment: Segment
  rawRootSegment: JSONRawMessage
  firstUserQuery: String @goField(forceResolver: true)
  firstText: String @goField(forceResolver: true)
  usageMetadata: UsageMetadata @goField(forceResolver: true)
}

extend type Thread {
  firstUserQuery: String @goField(forceResolver: true)
  usageMetadata: UsageMetadata @goField(forceResolver: true)
}

extend type Channel {
  """
  All model entries this channel can handle, including direct models, prefixed models, auto-trimmed models, and mapped models
  """
  allModelEntries: [ChannelModelEntry!]! @goField(forceResolver: true)

  """
  Channel credentials, will be null if user can not access the the credentials
  """
  credentials: ChannelCredentials @goField(forceResolver: true)
}

type Segment {
  id: ID!
  parentId: ID
  model: String!
  children: [Segment!]
  requestSpans: [Span!]
  responseSpans: [Span!]
  metadata: RequestMetadata
  startTime: Time!
  endTime: Time!
  duration: Int!
}

type RequestMetadata {
  itemCount: Int
  inputTokens: Int
  outputTokens: Int
  totalTokens: Int
  cachedTokens: Int
}

type Span {
  id: String!
  type: String!
  startTime: Time!
  endTime: Time!
  value: SpanValue
}

type SpanValue {
  userQuery: SpanUserQuery
  userImageUrl: SpanUserImageURL
  text: SpanText
  thinking: SpanThinking
  imageUrl: SpanImageURL
  toolUse: SpanToolUse
  toolResult: SpanToolResult
  systemInstruction: SpanSystemInstruction
}

type SpanUserQuery {
  text: String
}

type SpanUserImageURL {
  url: String
}

type SpanThinking {
  thinking: String
}

type SpanText {
  text: String
}

type SpanImageURL {
  url: String
}

type SpanToolUse {
  id: String
  name: String!
  arguments: String
}

type SpanToolResult {
  toolCallID: String
  isError: Boolean
  text: String
}

type SpanSystemInstruction {
  instruction: String
}

# Channel Override Template Types
enum OverrideApplyMode {
  MERGE
}

input ApplyChannelOverrideTemplateInput {
  templateID: ID!
  channelIDs: [ID!]!
  mode: OverrideApplyMode
}

type ApplyChannelOverrideTemplatePayload {
  success: Boolean!
  updated: Int!
  channels: [Channel!]!
}

type Mutation {
  createChannel(input: CreateChannelInput!): Channel!
  bulkCreateChannels(input: BulkCreateChannelsInput!): [Channel!]!
  updateChannel(id: ID!, input: UpdateChannelInput!): Channel!
  updateChannelStatus(id: ID!, status: ChannelStatus!): Channel!
  deleteChannel(id: ID!): Boolean!
  bulkArchiveChannels(ids: [ID!]!): Boolean!
  bulkDisableChannels(ids: [ID!]!): Boolean!
  bulkEnableChannels(ids: [ID!]!): Boolean!
  bulkDeleteChannels(ids: [ID!]!): Boolean!
  testChannel(input: TestChannelInput!): TestChannelPayload!
  bulkImportChannels(input: BulkImportChannelsInput!): BulkImportChannelsResult!
  bulkUpdateChannelOrdering(
    input: BulkUpdateChannelOrderingInput!
  ): BulkUpdateChannelOrderingResult!

  createAPIKey(input: CreateAPIKeyInput!): APIKey!
  updateAPIKey(id: ID!, input: UpdateAPIKeyInput!): APIKey!
  updateAPIKeyStatus(id: ID!, status: APIKeyStatus!): APIKey!
  updateAPIKeyProfiles(id: ID!, input: UpdateAPIKeyProfilesInput!): APIKey!
  bulkDisableAPIKeys(ids: [ID!]!): Boolean!
  bulkEnableAPIKeys(ids: [ID!]!): Boolean!
  bulkArchiveAPIKeys(ids: [ID!]!): Boolean!

  createUser(input: CreateUserInput!): User!
  updateUser(id: ID!, input: UpdateUserInput!): User!
  updateUserStatus(id: ID!, status: UserStatus!): User!

  createRole(input: CreateRoleInput!): Role!
  updateRole(id: ID!, input: UpdateRoleInput!): Role!
  deleteRole(id: ID!): Boolean!
  bulkDeleteRoles(ids: [ID!]!): Boolean!

  createProject(input: CreateProjectInput!): Project!
  updateProject(id: ID!, input: UpdateProjectInput!): Project!
  updateProjectStatus(id: ID!, status: ProjectStatus!): Project!

  addUserToProject(input: AddUserToProjectInput!): UserProject!
  removeUserFromProject(input: RemoveUserFromProjectInput!): Boolean!
  updateProjectUser(input: UpdateProjectUserInput!): UserProject!

  createDataStorage(input: CreateDataStorageInput!): DataStorage!
  updateDataStorage(id: ID!, input: UpdateDataStorageInput!): DataStorage!

  # Channel Override Template Mutations
  createChannelOverrideTemplate(
    input: CreateChannelOverrideTemplateInput!
  ): ChannelOverrideTemplate!
  updateChannelOverrideTemplate(
    id: ID!
    input: UpdateChannelOverrideTemplateInput!
  ): ChannelOverrideTemplate!
  deleteChannelOverrideTemplate(id: ID!): Boolean!
  applyChannelOverrideTemplate(
    input: ApplyChannelOverrideTemplateInput!
  ): ApplyChannelOverrideTemplatePayload!
}

input QueryChannelInput {
  """
  Returns the elements in the list that come after the specified cursor.
  """
  after: Cursor

  """
  Returns the first _n_ elements from the list.
  """
  first: Int

  """
  Returns the elements in the list that come before the specified cursor.
  """
  before: Cursor

  """
  Returns the last _n_ elements from the list.
  """
  last: Int

  """
  Ordering options for Channels returned from the connection.
  """
  orderBy: ChannelOrder

  """
  Filtering options for Channels returned from the connection.
  """
  where: ChannelWhereInput

  """
  Filtering options for Channels returned from the connection.
  """
  hasTag: String

  """
  Filter channels that support the specified model.
  """
  model: String
}

input CountChannelsByTypeInput {
  """
  Filtering options for Channels returned from the connection.
  """
  statusIn: [ChannelStatus!]
}

extend type Query {
  allChannelTags: [String!]!
  countChannelsByType(input: CountChannelsByTypeInput!): [ChannelTypeCount!]!
  """
  Query channels with extra options
  hasTag: String
  """
  queryChannels(input: QueryChannelInput!): ChannelConnection!
}
