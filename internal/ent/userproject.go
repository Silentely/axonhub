// Code generated by ent, DO NOT EDIT.

package ent

import (
	"encoding/json"
	"fmt"
	"strings"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/looplj/axonhub/internal/ent/project"
	"github.com/looplj/axonhub/internal/ent/user"
	"github.com/looplj/axonhub/internal/ent/userproject"
)

// UserProject is the model entity for the UserProject schema.
type UserProject struct {
	config `json:"-"`
	// ID of the ent.
	ID int `json:"id,omitempty"`
	// CreatedAt holds the value of the "created_at" field.
	CreatedAt time.Time `json:"created_at,omitempty"`
	// UpdatedAt holds the value of the "updated_at" field.
	UpdatedAt time.Time `json:"updated_at,omitempty"`
	// DeletedAt holds the value of the "deleted_at" field.
	DeletedAt int `json:"deleted_at,omitempty"`
	// UserID holds the value of the "user_id" field.
	UserID int `json:"user_id,omitempty"`
	// ProjectID holds the value of the "project_id" field.
	ProjectID int `json:"project_id,omitempty"`
	// Indicates whether the user is the owner of the project. This field is mutable to allow transferring ownership between users. Only users with sufficient permissions (e.g., current owner) can modify this field.
	IsOwner bool `json:"is_owner,omitempty"`
	// User-specific scopes: write_channels, read_channels, add_users, read_users, etc.
	Scopes []string `json:"scopes,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the UserProjectQuery when eager-loading is set.
	Edges        UserProjectEdges `json:"edges"`
	selectValues sql.SelectValues
}

// UserProjectEdges holds the relations/edges for other nodes in the graph.
type UserProjectEdges struct {
	// User holds the value of the user edge.
	User *User `json:"user,omitempty"`
	// Project holds the value of the project edge.
	Project *Project `json:"project,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [2]bool
	// totalCount holds the count of the edges above.
	totalCount [2]map[string]int
}

// UserOrErr returns the User value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e UserProjectEdges) UserOrErr() (*User, error) {
	if e.User != nil {
		return e.User, nil
	} else if e.loadedTypes[0] {
		return nil, &NotFoundError{label: user.Label}
	}
	return nil, &NotLoadedError{edge: "user"}
}

// ProjectOrErr returns the Project value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e UserProjectEdges) ProjectOrErr() (*Project, error) {
	if e.Project != nil {
		return e.Project, nil
	} else if e.loadedTypes[1] {
		return nil, &NotFoundError{label: project.Label}
	}
	return nil, &NotLoadedError{edge: "project"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*UserProject) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case userproject.FieldScopes:
			values[i] = new([]byte)
		case userproject.FieldIsOwner:
			values[i] = new(sql.NullBool)
		case userproject.FieldID, userproject.FieldDeletedAt, userproject.FieldUserID, userproject.FieldProjectID:
			values[i] = new(sql.NullInt64)
		case userproject.FieldCreatedAt, userproject.FieldUpdatedAt:
			values[i] = new(sql.NullTime)
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the UserProject fields.
func (_m *UserProject) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case userproject.FieldID:
			value, ok := values[i].(*sql.NullInt64)
			if !ok {
				return fmt.Errorf("unexpected type %T for field id", value)
			}
			_m.ID = int(value.Int64)
		case userproject.FieldCreatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field created_at", values[i])
			} else if value.Valid {
				_m.CreatedAt = value.Time
			}
		case userproject.FieldUpdatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field updated_at", values[i])
			} else if value.Valid {
				_m.UpdatedAt = value.Time
			}
		case userproject.FieldDeletedAt:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field deleted_at", values[i])
			} else if value.Valid {
				_m.DeletedAt = int(value.Int64)
			}
		case userproject.FieldUserID:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field user_id", values[i])
			} else if value.Valid {
				_m.UserID = int(value.Int64)
			}
		case userproject.FieldProjectID:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field project_id", values[i])
			} else if value.Valid {
				_m.ProjectID = int(value.Int64)
			}
		case userproject.FieldIsOwner:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field is_owner", values[i])
			} else if value.Valid {
				_m.IsOwner = value.Bool
			}
		case userproject.FieldScopes:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field scopes", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &_m.Scopes); err != nil {
					return fmt.Errorf("unmarshal field scopes: %w", err)
				}
			}
		default:
			_m.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the UserProject.
// This includes values selected through modifiers, order, etc.
func (_m *UserProject) Value(name string) (ent.Value, error) {
	return _m.selectValues.Get(name)
}

// QueryUser queries the "user" edge of the UserProject entity.
func (_m *UserProject) QueryUser() *UserQuery {
	return NewUserProjectClient(_m.config).QueryUser(_m)
}

// QueryProject queries the "project" edge of the UserProject entity.
func (_m *UserProject) QueryProject() *ProjectQuery {
	return NewUserProjectClient(_m.config).QueryProject(_m)
}

// Update returns a builder for updating this UserProject.
// Note that you need to call UserProject.Unwrap() before calling this method if this UserProject
// was returned from a transaction, and the transaction was committed or rolled back.
func (_m *UserProject) Update() *UserProjectUpdateOne {
	return NewUserProjectClient(_m.config).UpdateOne(_m)
}

// Unwrap unwraps the UserProject entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (_m *UserProject) Unwrap() *UserProject {
	_tx, ok := _m.config.driver.(*txDriver)
	if !ok {
		panic("ent: UserProject is not a transactional entity")
	}
	_m.config.driver = _tx.drv
	return _m
}

// String implements the fmt.Stringer.
func (_m *UserProject) String() string {
	var builder strings.Builder
	builder.WriteString("UserProject(")
	builder.WriteString(fmt.Sprintf("id=%v, ", _m.ID))
	builder.WriteString("created_at=")
	builder.WriteString(_m.CreatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("updated_at=")
	builder.WriteString(_m.UpdatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("deleted_at=")
	builder.WriteString(fmt.Sprintf("%v", _m.DeletedAt))
	builder.WriteString(", ")
	builder.WriteString("user_id=")
	builder.WriteString(fmt.Sprintf("%v", _m.UserID))
	builder.WriteString(", ")
	builder.WriteString("project_id=")
	builder.WriteString(fmt.Sprintf("%v", _m.ProjectID))
	builder.WriteString(", ")
	builder.WriteString("is_owner=")
	builder.WriteString(fmt.Sprintf("%v", _m.IsOwner))
	builder.WriteString(", ")
	builder.WriteString("scopes=")
	builder.WriteString(fmt.Sprintf("%v", _m.Scopes))
	builder.WriteByte(')')
	return builder.String()
}

// UserProjects is a parsable slice of UserProject.
type UserProjects []*UserProject
