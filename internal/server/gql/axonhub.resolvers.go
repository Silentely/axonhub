package gql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78-dev

import (
	"context"
	"fmt"

	"github.com/looplj/axonhub/internal/contexts"
	"github.com/looplj/axonhub/internal/ent"
	"github.com/looplj/axonhub/internal/ent/apikey"
	"github.com/looplj/axonhub/internal/ent/channel"
	"github.com/looplj/axonhub/internal/ent/project"
	"github.com/looplj/axonhub/internal/ent/request"
	"github.com/looplj/axonhub/internal/ent/user"
	"github.com/looplj/axonhub/internal/ent/userproject"
	"github.com/looplj/axonhub/internal/objects"
	"github.com/looplj/axonhub/internal/server/biz"
	"github.com/looplj/axonhub/internal/server/chat"
)

// CreateChannel is the resolver for the createChannel field.
func (r *mutationResolver) CreateChannel(ctx context.Context, input ent.CreateChannelInput) (*ent.Channel, error) {
	channel, err := r.client.Channel.Create().
		SetType(input.Type).
		SetNillableBaseURL(input.BaseURL).
		SetName(input.Name).
		SetCredentials(input.Credentials).
		SetSupportedModels(input.SupportedModels).
		SetDefaultTestModel(input.DefaultTestModel).
		SetSettings(input.Settings).
		Save(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to create channel: %w", err)
	}

	return channel, nil
}

// UpdateChannel is the resolver for the updateChannel field.
func (r *mutationResolver) UpdateChannel(ctx context.Context, id objects.GUID, input ent.UpdateChannelInput) (*ent.Channel, error) {
	mut := r.client.Channel.UpdateOneID(id.ID).
		SetNillableBaseURL(input.BaseURL).
		SetNillableName(input.Name).
		SetNillableDefaultTestModel(input.DefaultTestModel)

	if input.SupportedModels != nil {
		mut.SetSupportedModels(input.SupportedModels)
	}

	if input.Settings != nil {
		mut.SetSettings(input.Settings)
	}

	if input.Credentials != nil {
		mut.SetCredentials(input.Credentials)
	}

	channel, err := mut.Save(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to update channel: %w", err)
	}

	return channel, nil
}

// UpdateChannelStatus is the resolver for the updateChannelStatus field.
func (r *mutationResolver) UpdateChannelStatus(ctx context.Context, id objects.GUID, status channel.Status) (*ent.Channel, error) {
	channel, err := r.client.Channel.UpdateOneID(id.ID).
		SetStatus(status).
		Save(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to update channel status: %w", err)
	}

	return channel, nil
}

// TestChannel is the resolver for the testChannel field.
func (r *mutationResolver) TestChannel(ctx context.Context, input TestChannelInput) (*TestChannelPayload, error) {
	// Set test source context for test channel requests
	ctx = contexts.WithSource(ctx, request.SourceTest)

	processor := chat.NewTestChannelProcessor(r.channelService, r.requestService, r.systemService, r.httpClient, input.ChannelID)

	result, err := processor.TestChannel(ctx, input.ChannelID, input.ModelID)
	if err != nil {
		return nil, fmt.Errorf("failed to test channel: %w", err)
	}

	return &TestChannelPayload{
		Latency: result.Latency,
		Success: result.Success,
		Error:   result.Error,
	}, nil
}

// BulkImportChannels is the resolver for the bulkImportChannels field.
func (r *mutationResolver) BulkImportChannels(ctx context.Context, input BulkImportChannelsInput) (*BulkImportChannelsResult, error) {
	var (
		createdChannels []*ent.Channel
		errors          []string
	)

	created := 0
	failed := 0

	for i, item := range input.Channels {
		// Validate channel type
		channelType := channel.Type(item.Type)
		if err := channel.TypeValidator(channelType); err != nil {
			errors = append(errors, fmt.Sprintf("Row %d: Invalid channel type '%s'", i+1, item.Type))
			failed++

			continue
		}

		// Validate required fields
		if item.BaseURL == nil || *item.BaseURL == "" {
			errors = append(errors, fmt.Sprintf("Row %d (%s): Base URL is required", i+1, item.Name))
			failed++

			continue
		}

		if item.APIKey == nil || *item.APIKey == "" {
			errors = append(errors, fmt.Sprintf("Row %d (%s): API Key is required", i+1, item.Name))
			failed++

			continue
		}

		// Prepare credentials (API key is now required)
		credentials := &objects.ChannelCredentials{
			APIKey: *item.APIKey,
		}

		// Create the channel (baseURL is now required)
		channelBuilder := r.client.Channel.Create().
			SetType(channelType).
			SetName(item.Name).
			SetBaseURL(*item.BaseURL).
			SetCredentials(credentials).
			SetSupportedModels(item.SupportedModels).
			SetDefaultTestModel(item.DefaultTestModel)

		channel, err := channelBuilder.Save(ctx)
		if err != nil {
			errors = append(errors, fmt.Sprintf("Row %d (%s): %s", i+1, item.Name, err.Error()))
			failed++

			continue
		}

		createdChannels = append(createdChannels, channel)
		created++
	}

	success := failed == 0

	return &BulkImportChannelsResult{
		Success:  success,
		Created:  created,
		Failed:   failed,
		Errors:   errors,
		Channels: createdChannels,
	}, nil
}

// BulkUpdateChannelOrdering is the resolver for the bulkUpdateChannelOrdering field.
func (r *mutationResolver) BulkUpdateChannelOrdering(ctx context.Context, input BulkUpdateChannelOrderingInput) (*BulkUpdateChannelOrderingResult, error) {
	// Prepare updates for the service layer
	updates := make([]struct {
		ID             int
		OrderingWeight int
	}, len(input.Channels))

	for i, item := range input.Channels {
		updates[i] = struct {
			ID             int
			OrderingWeight int
		}{
			ID:             item.ID.ID,
			OrderingWeight: item.OrderingWeight,
		}
	}

	// Call the business logic layer
	updatedChannels, err := r.channelService.BulkUpdateChannelOrdering(ctx, updates)
	if err != nil {
		return nil, fmt.Errorf("failed to bulk update channel ordering: %w", err)
	}

	return &BulkUpdateChannelOrderingResult{
		Success:  true,
		Updated:  len(updatedChannels),
		Channels: updatedChannels,
	}, nil
}

// CreateAPIKey is the resolver for the createAPIKey field.
func (r *mutationResolver) CreateAPIKey(ctx context.Context, input ent.CreateAPIKeyInput) (*ent.APIKey, error) {
	return r.apiKeyService.CreateAPIKey(ctx, input)
}

// UpdateAPIKey is the resolver for the updateAPIKey field.
func (r *mutationResolver) UpdateAPIKey(ctx context.Context, id objects.GUID, input ent.UpdateAPIKeyInput) (*ent.APIKey, error) {
	return r.apiKeyService.UpdateAPIKey(ctx, id.ID, input)
}

// UpdateAPIKeyStatus is the resolver for the updateAPIKeyStatus field.
func (r *mutationResolver) UpdateAPIKeyStatus(ctx context.Context, id objects.GUID, status apikey.Status) (*ent.APIKey, error) {
	return r.apiKeyService.UpdateAPIKeyStatus(ctx, id.ID, status)
}

// UpdateAPIKeyProfiles is the resolver for the updateAPIKeyProfiles field.
func (r *mutationResolver) UpdateAPIKeyProfiles(ctx context.Context, id objects.GUID, input objects.APIKeyProfiles) (*ent.APIKey, error) {
	return r.apiKeyService.UpdateAPIKeyProfiles(ctx, id.ID, input)
}

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input ent.CreateUserInput) (*ent.User, error) {
	return r.userService.CreateUser(ctx, input)
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, id objects.GUID, input ent.UpdateUserInput) (*ent.User, error) {
	return r.userService.UpdateUser(ctx, id.ID, input)
}

// UpdateUserStatus is the resolver for the updateUserStatus field.
func (r *mutationResolver) UpdateUserStatus(ctx context.Context, id objects.GUID, status user.Status) (*ent.User, error) {
	return r.userService.UpdateUserStatus(ctx, id.ID, status)
}

// CreateRole is the resolver for the createRole field.
func (r *mutationResolver) CreateRole(ctx context.Context, input ent.CreateRoleInput) (*ent.Role, error) {
	return r.roleService.CreateRole(ctx, input)
}

// UpdateRole is the resolver for the updateRole field.
func (r *mutationResolver) UpdateRole(ctx context.Context, id objects.GUID, input ent.UpdateRoleInput) (*ent.Role, error) {
	return r.roleService.UpdateRole(ctx, id.ID, input)
}

// DeleteRole is the resolver for the deleteRole field.
func (r *mutationResolver) DeleteRole(ctx context.Context, id objects.GUID) (bool, error) {
	err := r.roleService.DeleteRole(ctx, id.ID)
	if err != nil {
		return false, err
	}

	return true, nil
}

// BulkDeleteRoles is the resolver for the bulkDeleteRoles field.
func (r *mutationResolver) BulkDeleteRoles(ctx context.Context, ids []*objects.GUID) (bool, error) {
	roleIDs := objects.IntGuids(ids)

	err := r.roleService.BulkDeleteRoles(ctx, roleIDs)
	if err != nil {
		return false, err
	}

	return true, nil
}

// CreateProject is the resolver for the createProject field.
func (r *mutationResolver) CreateProject(ctx context.Context, input ent.CreateProjectInput) (*ent.Project, error) {
	return r.projectService.CreateProject(ctx, input)
}

// UpdateProject is the resolver for the updateProject field.
func (r *mutationResolver) UpdateProject(ctx context.Context, id objects.GUID, input ent.UpdateProjectInput) (*ent.Project, error) {
	return r.projectService.UpdateProject(ctx, id.ID, input)
}

// UpdateProjectStatus is the resolver for the updateProjectStatus field.
func (r *mutationResolver) UpdateProjectStatus(ctx context.Context, id objects.GUID, status project.Status) (*ent.Project, error) {
	return r.projectService.UpdateProjectStatus(ctx, id.ID, status)
}

// AddUserToProject is the resolver for the addUserToProject field.
func (r *mutationResolver) AddUserToProject(ctx context.Context, input AddUserToProjectInput) (*ent.UserProject, error) {
	// Create the project user relationship
	mut := r.client.UserProject.Create().
		SetUserID(input.UserID.ID).
		SetProjectID(input.ProjectID.ID)

	if input.IsOwner != nil {
		mut.SetIsOwner(*input.IsOwner)
	}

	if input.Scopes != nil {
		mut.SetScopes(input.Scopes)
	}

	userProject, err := mut.Save(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to add user to project: %w", err)
	}

	// Add roles if provided
	if len(input.RoleIDs) > 0 {
		roleIDs := objects.IntGuids(input.RoleIDs)

		user, err := r.client.User.Get(ctx, input.UserID.ID)
		if err != nil {
			return nil, fmt.Errorf("failed to get user: %w", err)
		}

		err = user.Update().AddRoleIDs(roleIDs...).Exec(ctx)
		if err != nil {
			return nil, fmt.Errorf("failed to add roles to user: %w", err)
		}
	}

	return userProject, nil
}

// RemoveUserFromProject is the resolver for the removeUserFromProject field.
func (r *mutationResolver) RemoveUserFromProject(ctx context.Context, input RemoveUserFromProjectInput) (bool, error) {
	// Find the UserProject relationship
	userProject, err := r.client.UserProject.Query().
		Where(
			userproject.UserID(input.UserID.ID),
			userproject.ProjectID(input.ProjectID.ID),
		).
		Only(ctx)
	if err != nil {
		return false, fmt.Errorf("failed to find user project relationship: %w", err)
	}

	// Delete the relationship (soft delete if enabled)
	err = r.client.UserProject.DeleteOne(userProject).Exec(ctx)
	if err != nil {
		return false, fmt.Errorf("failed to remove user from project: %w", err)
	}

	return true, nil
}

// UpdateProjectUser is the resolver for the updateProjectUser field.
func (r *mutationResolver) UpdateProjectUser(ctx context.Context, input UpdateProjectUserInput) (*ent.UserProject, error) {
	// Find the UserProject relationship
	userProject, err := r.client.UserProject.Query().
		Where(
			userproject.UserID(input.UserID.ID),
			userproject.ProjectID(input.ProjectID.ID),
		).
		Only(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to find user project relationship: %w", err)
	}

	// Update the UserProject (note: isOwner is immutable, so we can only update scopes)
	mut := userProject.Update()

	if input.Scopes != nil {
		mut.SetScopes(input.Scopes)
	}

	userProject, err = mut.Save(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to update project user: %w", err)
	}

	// Update roles if provided
	user, err := r.client.User.Get(ctx, input.UserID.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to get user: %w", err)
	}

	userMut := user.Update()

	if len(input.AddRoleIDs) > 0 {
		userMut.AddRoleIDs(objects.IntGuids(input.AddRoleIDs)...)
	}

	if len(input.RemoveRoleIDs) > 0 {
		userMut.RemoveRoleIDs(objects.IntGuids(input.RemoveRoleIDs)...)
	}

	err = userMut.Exec(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to update user roles: %w", err)
	}

	return userProject, nil
}

// FetchModels is the resolver for the fetchModels field.
func (r *queryResolver) FetchModels(ctx context.Context, input FetchModelsInput) (*FetchModelsPayload, error) {
	// Convert input to biz layer input
	bizInput := biz.FetchModelsInput{
		ChannelType: input.ChannelType,
		BaseURL:     input.BaseURL,
		APIKey:      input.APIKey,
	}

	if input.ChannelID != nil {
		bizInput.ChannelID = &input.ChannelID.ID
	}

	// Call the model fetcher service
	result, err := r.modelFetcher.FetchModels(ctx, bizInput)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch models: %w", err)
	}

	// Convert result to GraphQL payload
	models := make([]*objects.ModelIdentify, len(result.Models))
	for i := range result.Models {
		models[i] = &result.Models[i]
	}

	return &FetchModelsPayload{
		Models: models,
		Error:  result.Error,
	}, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

type mutationResolver struct{ *Resolver }
